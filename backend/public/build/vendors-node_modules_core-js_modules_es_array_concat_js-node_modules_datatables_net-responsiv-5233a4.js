"use strict";
(self["webpackChunk"] = self["webpackChunk"] || []).push([["vendors-node_modules_core-js_modules_es_array_concat_js-node_modules_datatables_net-responsiv-5233a4"],{

/***/ "./node_modules/core-js/internals/array-method-has-species-support.js":
/*!****************************************************************************!*\
  !*** ./node_modules/core-js/internals/array-method-has-species-support.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var V8_VERSION = __webpack_require__(/*! ../internals/environment-v8-version */ "./node_modules/core-js/internals/environment-v8-version.js");

var SPECIES = wellKnownSymbol('species');

module.exports = function (METHOD_NAME) {
  // We can't use this feature detection in V8 since it causes
  // deoptimization and serious performance degradation
  // https://github.com/zloirock/core-js/issues/677
  return V8_VERSION >= 51 || !fails(function () {
    var array = [];
    var constructor = array.constructor = {};
    constructor[SPECIES] = function () {
      return { foo: 1 };
    };
    return array[METHOD_NAME](Boolean).foo !== 1;
  });
};


/***/ }),

/***/ "./node_modules/core-js/internals/create-property.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/create-property.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");

module.exports = function (object, key, value) {
  if (DESCRIPTORS) definePropertyModule.f(object, key, createPropertyDescriptor(0, value));
  else object[key] = value;
};


/***/ }),

/***/ "./node_modules/core-js/internals/does-not-exceed-safe-integer.js":
/*!************************************************************************!*\
  !*** ./node_modules/core-js/internals/does-not-exceed-safe-integer.js ***!
  \************************************************************************/
/***/ ((module) => {


var $TypeError = TypeError;
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF; // 2 ** 53 - 1 == 9007199254740991

module.exports = function (it) {
  if (it > MAX_SAFE_INTEGER) throw $TypeError('Maximum allowed index exceeded');
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.concat.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.concat.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var isArray = __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js/internals/is-array.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js/internals/length-of-array-like.js");
var doesNotExceedSafeInteger = __webpack_require__(/*! ../internals/does-not-exceed-safe-integer */ "./node_modules/core-js/internals/does-not-exceed-safe-integer.js");
var createProperty = __webpack_require__(/*! ../internals/create-property */ "./node_modules/core-js/internals/create-property.js");
var arraySpeciesCreate = __webpack_require__(/*! ../internals/array-species-create */ "./node_modules/core-js/internals/array-species-create.js");
var arrayMethodHasSpeciesSupport = __webpack_require__(/*! ../internals/array-method-has-species-support */ "./node_modules/core-js/internals/array-method-has-species-support.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var V8_VERSION = __webpack_require__(/*! ../internals/environment-v8-version */ "./node_modules/core-js/internals/environment-v8-version.js");

var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');

// We can't use this feature detection in V8 since it causes
// deoptimization and serious performance degradation
// https://github.com/zloirock/core-js/issues/679
var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function () {
  var array = [];
  array[IS_CONCAT_SPREADABLE] = false;
  return array.concat()[0] !== array;
});

var isConcatSpreadable = function (O) {
  if (!isObject(O)) return false;
  var spreadable = O[IS_CONCAT_SPREADABLE];
  return spreadable !== undefined ? !!spreadable : isArray(O);
};

var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !arrayMethodHasSpeciesSupport('concat');

// `Array.prototype.concat` method
// https://tc39.es/ecma262/#sec-array.prototype.concat
// with adding support of @@isConcatSpreadable and @@species
$({ target: 'Array', proto: true, arity: 1, forced: FORCED }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  concat: function concat(arg) {
    var O = toObject(this);
    var A = arraySpeciesCreate(O, 0);
    var n = 0;
    var i, k, length, len, E;
    for (i = -1, length = arguments.length; i < length; i++) {
      E = i === -1 ? O : arguments[i];
      if (isConcatSpreadable(E)) {
        len = lengthOfArrayLike(E);
        doesNotExceedSafeInteger(n + len);
        for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
      } else {
        doesNotExceedSafeInteger(n + 1);
        createProperty(A, n++, E);
      }
    }
    A.length = n;
    return A;
  }
});


/***/ }),

/***/ "./node_modules/datatables.net-bs5/js/dataTables.bootstrap5.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/datatables.net-bs5/js/dataTables.bootstrap5.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var datatables_net__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! datatables.net */ "./node_modules/datatables.net/js/dataTables.mjs");
/*! DataTables Bootstrap 5 integration
 * Â© SpryMedia Ltd - datatables.net/license
 */




// Allow reassignment of the $ variable
let $ = jquery__WEBPACK_IMPORTED_MODULE_0__;


/**
 * DataTables integration for Bootstrap 5.
 *
 * This file sets the defaults and adds options to DataTables to style its
 * controls using Bootstrap. See https://datatables.net/manual/styling/bootstrap
 * for further information.
 */

/* Set the defaults for DataTables initialisation */
$.extend( true, datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].defaults, {
	renderer: 'bootstrap'
} );


/* Default class modification */
$.extend( true, datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].ext.classes, {
	container: "dt-container dt-bootstrap5",
	search: {
		input: "form-control form-control-sm"
	},
	length: {
		select: "form-select form-select-sm"
	},
	processing: {
		container: "dt-processing card"
	},
	layout: {
		row: 'row mt-2 justify-content-between',
		cell: 'd-md-flex justify-content-between align-items-center',
		tableCell: 'col-12',
		start: 'dt-layout-start col-md-auto me-auto',
		end: 'dt-layout-end col-md-auto ms-auto',
		full: 'dt-layout-full col-md'
	}
} );


/* Bootstrap paging button renderer */
datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].ext.renderer.pagingButton.bootstrap = function (settings, buttonType, content, active, disabled) {
	var btnClasses = ['dt-paging-button', 'page-item'];

	if (active) {
		btnClasses.push('active');
	}

	if (disabled) {
		btnClasses.push('disabled')
	}

	var li = $('<li>').addClass(btnClasses.join(' '));
	var a = $('<button>', {
		'class': 'page-link',
		role: 'link',
		type: 'button'
	})
		.html(content)
		.appendTo(li);

	return {
		display: li,
		clicker: a
	};
};

datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].ext.renderer.pagingContainer.bootstrap = function (settings, buttonEls) {
	return $('<ul/>').addClass('pagination').append(buttonEls);
};


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"]);


/***/ }),

/***/ "./node_modules/datatables.net-responsive-bs5/js/responsive.bootstrap5.mjs":
/*!*********************************************************************************!*\
  !*** ./node_modules/datatables.net-responsive-bs5/js/responsive.bootstrap5.mjs ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var datatables_net_bs5__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! datatables.net-bs5 */ "./node_modules/datatables.net-bs5/js/dataTables.bootstrap5.mjs");
/* harmony import */ var datatables_net_responsive__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! datatables.net-responsive */ "./node_modules/datatables.net-responsive/js/dataTables.responsive.mjs");
/*! Bootstrap 5 integration for DataTables' Responsive
 * Â© SpryMedia Ltd - datatables.net/license
 */





// Allow reassignment of the $ variable
let $ = jquery__WEBPACK_IMPORTED_MODULE_0__;


var _display = datatables_net_bs5__WEBPACK_IMPORTED_MODULE_1__["default"].Responsive.display;
var _original = _display.modal;
var _modal = $(
	'<div class="modal fade dtr-bs-modal" role="dialog">' +
		'<div class="modal-dialog" role="document">' +
		'<div class="modal-content">' +
		'<div class="modal-header">' +
		'<button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>' +
		'</div>' +
		'<div class="modal-body"/>' +
		'</div>' +
		'</div>' +
		'</div>'
);
var modal;

// Note this could be undefined at the time of initialisation - the
// DataTable.Responsive.bootstrap function can be used to set a different
// bootstrap object
var _bs = window.bootstrap;

datatables_net_bs5__WEBPACK_IMPORTED_MODULE_1__["default"].Responsive.bootstrap = function (bs) {
	_bs = bs;
};

// Get the Bootstrap library from locally set (legacy) or from DT.
function getBs() {
	let dtBs = datatables_net_bs5__WEBPACK_IMPORTED_MODULE_1__["default"].use('bootstrap');

	if (dtBs) {
		return dtBs;
	}

	if (_bs) {
		return _bs;
	}

	throw new Error('No Bootstrap library. Set it with `DataTable.use(bootstrap);`');
}

_display.modal = function (options) {
	if (!modal && _bs.Modal) {
		let localBs = getBs();
		modal = new localBs.Modal(_modal[0]);
	}

	return function (row, update, render, closeCallback) {
		if (! modal) {
			return _original(row, update, render, closeCallback);
		}
		else {
			var rendered = render();

			if (rendered === false) {
				return false;
			}

			if (!update) {
				if (options && options.header) {
					var header = _modal.find('div.modal-header');
					var button = header.find('button').detach();

					header
						.empty()
						.append('<h4 class="modal-title">' + options.header(row) + '</h4>')
						.append(button);
				}

				_modal.find('div.modal-body').empty().append(rendered);

				_modal
					.data('dtr-row-idx', row.index())
					.one('hidden.bs.modal', closeCallback)
					.appendTo('body');

				modal.show();
			}
			else {
				if ($.contains(document, _modal[0]) && row.index() === _modal.data('dtr-row-idx')) {
					_modal.find('div.modal-body').empty().append(rendered);
				}
				else {
					// Modal not shown for this row - do nothing
					return null;
				}
			}

			return true;
		}
	};
};


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (datatables_net_bs5__WEBPACK_IMPORTED_MODULE_1__["default"]);


/***/ }),

/***/ "./node_modules/datatables.net-responsive/js/dataTables.responsive.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/datatables.net-responsive/js/dataTables.responsive.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var datatables_net__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! datatables.net */ "./node_modules/datatables.net/js/dataTables.mjs");
/*! Responsive 3.0.4
 * Â© SpryMedia Ltd - datatables.net/license
 */




// Allow reassignment of the $ variable
let $ = jquery__WEBPACK_IMPORTED_MODULE_0__;


/**
 * @summary     Responsive
 * @description Responsive tables plug-in for DataTables
 * @version     3.0.4
 * @author      SpryMedia Ltd
 * @copyright   SpryMedia Ltd.
 *
 * This source file is free software, available under the following license:
 *   MIT license - http://datatables.net/license/mit
 *
 * This source file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.
 *
 * For details please refer to: http://www.datatables.net
 */

/**
 * Responsive is a plug-in for the DataTables library that makes use of
 * DataTables' ability to change the visibility of columns, changing the
 * visibility of columns so the displayed columns fit into the table container.
 * The end result is that complex tables will be dynamically adjusted to fit
 * into the viewport, be it on a desktop, tablet or mobile browser.
 *
 * Responsive for DataTables has two modes of operation, which can used
 * individually or combined:
 *
 * * Class name based control - columns assigned class names that match the
 *   breakpoint logic can be shown / hidden as required for each breakpoint.
 * * Automatic control - columns are automatically hidden when there is no
 *   room left to display them. Columns removed from the right.
 *
 * In additional to column visibility control, Responsive also has built into
 * options to use DataTables' child row display to show / hide the information
 * from the table that has been hidden. There are also two modes of operation
 * for this child row display:
 *
 * * Inline - when the control element that the user can use to show / hide
 *   child rows is displayed inside the first column of the table.
 * * Column - where a whole column is dedicated to be the show / hide control.
 *
 * Initialisation of Responsive is performed by:
 *
 * * Adding the class `responsive` or `dt-responsive` to the table. In this case
 *   Responsive will automatically be initialised with the default configuration
 *   options when the DataTable is created.
 * * Using the `responsive` option in the DataTables configuration options. This
 *   can also be used to specify the configuration options, or simply set to
 *   `true` to use the defaults.
 *
 *  @class
 *  @param {object} settings DataTables settings object for the host table
 *  @param {object} [opts] Configuration options
 *  @requires jQuery 1.7+
 *  @requires DataTables 2.0.0+
 *
 *  @example
 *      $('#example').DataTable( {
 *        responsive: true
 *      } );
 *    } );
 */
var Responsive = function (settings, opts) {
	// Sanity check that we are using DataTables 2.0.0 or newer
	if (!datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].versionCheck || !datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].versionCheck('2')) {
		throw 'DataTables Responsive requires DataTables 2 or newer';
	}

	this.s = {
		childNodeStore: {},
		columns: [],
		current: [],
		dt: new datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].Api(settings)
	};

	// Check if responsive has already been initialised on this table
	if (this.s.dt.settings()[0].responsive) {
		return;
	}

	// details is an object, but for simplicity the user can give it as a string
	// or a boolean
	if (opts && typeof opts.details === 'string') {
		opts.details = { type: opts.details };
	}
	else if (opts && opts.details === false) {
		opts.details = { type: false };
	}
	else if (opts && opts.details === true) {
		opts.details = { type: 'inline' };
	}

	this.c = $.extend(
		true,
		{},
		Responsive.defaults,
		datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].defaults.responsive,
		opts
	);
	settings.responsive = this;
	this._constructor();
};

$.extend(Responsive.prototype, {
	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Constructor
	 */

	/**
	 * Initialise the Responsive instance
	 *
	 * @private
	 */
	_constructor: function () {
		var that = this;
		var dt = this.s.dt;
		var oldWindowWidth = $(window).innerWidth();

		dt.settings()[0]._responsive = this;

		// Use DataTables' throttle function to avoid processor thrashing
		$(window).on(
			'orientationchange.dtr',
			datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].util.throttle(function () {
				// iOS has a bug whereby resize can fire when only scrolling
				// See: http://stackoverflow.com/questions/8898412
				var width = $(window).innerWidth();

				if (width !== oldWindowWidth) {
					that._resize();
					oldWindowWidth = width;
				}
			})
		);

		// Handle new rows being dynamically added - needed as responsive
		// updates all rows (shown or not) a responsive change, rather than
		// per draw.
		dt.on('row-created.dtr', function (e, tr, data, idx) {
			if ($.inArray(false, that.s.current) !== -1) {
				$('>td, >th', tr).each(function (i) {
					var idx = dt.column.index('toData', i);

					if (that.s.current[idx] === false) {
						$(this)
							.css('display', 'none')
							.addClass('dtr-hidden');
					}
				});
			}
		});

		// Destroy event handler
		dt.on('destroy.dtr', function () {
			dt.off('.dtr');
			$(dt.table().body()).off('.dtr');
			$(window).off('resize.dtr orientationchange.dtr');
			dt.cells('.dtr-control').nodes().to$().removeClass('dtr-control');
			$(dt.table().node()).removeClass('dtr-inline collapsed');

			// Restore the columns that we've hidden
			$.each(that.s.current, function (i, val) {
				if (val === false) {
					that._setColumnVis(i, true);
				}
			});
		});

		// Reorder the breakpoints array here in case they have been added out
		// of order
		this.c.breakpoints.sort(function (a, b) {
			return a.width < b.width ? 1 : a.width > b.width ? -1 : 0;
		});

		this._classLogic();

		// Details handler
		var details = this.c.details;

		if (details.type !== false) {
			that._detailsInit();

			// DataTables will trigger this event on every column it shows and
			// hides individually
			dt.on('column-visibility.dtr', function () {
				// Use a small debounce to allow multiple columns to be set together
				if (that._timer) {
					clearTimeout(that._timer);
				}

				that._timer = setTimeout(function () {
					that._timer = null;

					that._classLogic();
					that._resizeAuto();
					that._resize(true);

					that._redrawChildren();
				}, 100);
			});

			// Redraw the details box on each draw which will happen if the data
			// has changed. This is used until DataTables implements a native
			// `updated` event for rows
			dt.on('draw.dtr', function () {
				that._redrawChildren();
			});

			$(dt.table().node()).addClass('dtr-' + details.type);
		}

		// DT2 let's us tell it if we are hiding columns
		dt.on('column-calc.dt', function (e, d) {
			var curr = that.s.current;

			for (var i = 0; i < curr.length; i++) {
				var idx = d.visible.indexOf(i);

				if (curr[i] === false && idx >= 0) {
					d.visible.splice(idx, 1);
				}
			}
		});

		// On Ajax reload we want to reopen any child rows which are displayed
		// by responsive
		dt.on('preXhr.dtr', function () {
			var rowIds = [];
			dt.rows().every(function () {
				if (this.child.isShown()) {
					rowIds.push(this.id(true));
				}
			});

			dt.one('draw.dtr', function () {
				that._resizeAuto();
				that._resize();

				dt.rows(rowIds).every(function () {
					that._detailsDisplay(this, false);
				});
			});
		});

		// First pass when the table is ready
		dt
			.on('draw.dtr', function () {
				that._controlClass();
			})
			.ready(function () {
				that._resizeAuto();
				that._resize();

				// Attach listeners after first pass
				dt.on('column-reorder.dtr', function (e, settings, details) {
					that._classLogic();
					that._resizeAuto();
					that._resize(true);
				});

				// Change in column sizes means we need to calc
				dt.on('column-sizing.dtr', function () {
					that._resizeAuto();
					that._resize();
				});
			});
	},

	/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	 * Private methods
	 */

	/**
	 * Insert a `col` tag into the correct location in a `colgroup`.
	 *
	 * @param {jQuery} colGroup The `colgroup` tag
	 * @param {jQuery} colEl The `col` tag
	 */
	_colGroupAttach: function (colGroup, colEls, idx) {
		var found = null;

		// No need to do anything if already attached
		if (colEls[idx].get(0).parentNode === colGroup[0]) {
			return;
		}

		// Find the first `col` after our own which is already attached
		for (var i = idx+1; i < colEls.length; i++) {
			if (colGroup[0] === colEls[i].get(0).parentNode) {
				found = i;
				break;
			}
		}

		if (found !== null) {
			// Insert before
			colEls[idx].insertBefore(colEls[found][0]);
		}
		else {
			// If wasn't found, insert at the end
			colGroup.append(colEls[idx]);
		}
	},

	/**
	 * Get and store nodes from a cell - use for node moving renderers
	 *
	 * @param {*} dt DT instance
	 * @param {*} row Row index
	 * @param {*} col Column index
	 */
	_childNodes: function (dt, row, col) {
		var name = row + '-' + col;

		if (this.s.childNodeStore[name]) {
			return this.s.childNodeStore[name];
		}

		// https://jsperf.com/childnodes-array-slice-vs-loop
		var nodes = [];
		var children = dt.cell(row, col).node().childNodes;
		for (var i = 0, ien = children.length; i < ien; i++) {
			nodes.push(children[i]);
		}

		this.s.childNodeStore[name] = nodes;

		return nodes;
	},

	/**
	 * Restore nodes from the cache to a table cell
	 *
	 * @param {*} dt DT instance
	 * @param {*} row Row index
	 * @param {*} col Column index
	 */
	_childNodesRestore: function (dt, row, col) {
		var name = row + '-' + col;

		if (!this.s.childNodeStore[name]) {
			return;
		}

		var node = dt.cell(row, col).node();
		var store = this.s.childNodeStore[name];
		if (store.length > 0) {
			var parent = store[0].parentNode;
			var parentChildren = parent.childNodes;
			var a = [];

			for (var i = 0, ien = parentChildren.length; i < ien; i++) {
				a.push(parentChildren[i]);
			}

			for (var j = 0, jen = a.length; j < jen; j++) {
				node.appendChild(a[j]);
			}
		}

		this.s.childNodeStore[name] = undefined;
	},

	/**
	 * Calculate the visibility for the columns in a table for a given
	 * breakpoint. The result is pre-determined based on the class logic if
	 * class names are used to control all columns, but the width of the table
	 * is also used if there are columns which are to be automatically shown
	 * and hidden.
	 *
	 * @param  {string} breakpoint Breakpoint name to use for the calculation
	 * @return {array} Array of boolean values initiating the visibility of each
	 *   column.
	 *  @private
	 */
	_columnsVisiblity: function (breakpoint) {
		var dt = this.s.dt;
		var columns = this.s.columns;
		var i, ien;

		// Create an array that defines the column ordering based first on the
		// column's priority, and secondly the column index. This allows the
		// columns to be removed from the right if the priority matches
		var order = columns
			.map(function (col, idx) {
				return {
					columnIdx: idx,
					priority: col.priority
				};
			})
			.sort(function (a, b) {
				if (a.priority !== b.priority) {
					return a.priority - b.priority;
				}
				return a.columnIdx - b.columnIdx;
			});

		// Class logic - determine which columns are in this breakpoint based
		// on the classes. If no class control (i.e. `auto`) then `-` is used
		// to indicate this to the rest of the function
		var display = $.map(columns, function (col, i) {
			if (dt.column(i).visible() === false) {
				return 'not-visible';
			}
			return col.auto && col.minWidth === null
				? false
				: col.auto === true
				? '-'
				: $.inArray(breakpoint, col.includeIn) !== -1;
		});

		// Auto column control - first pass: how much width is taken by the
		// ones that must be included from the non-auto columns
		var requiredWidth = 0;
		for (i = 0, ien = display.length; i < ien; i++) {
			if (display[i] === true) {
				requiredWidth += columns[i].minWidth;
			}
		}

		// Second pass, use up any remaining width for other columns. For
		// scrolling tables we need to subtract the width of the scrollbar. It
		// may not be requires which makes this sub-optimal, but it would
		// require another full redraw to make complete use of those extra few
		// pixels
		var scrolling = dt.settings()[0].oScroll;
		var bar = scrolling.sY || scrolling.sX ? scrolling.iBarWidth : 0;
		var widthAvailable = dt.table().container().offsetWidth - bar;
		var usedWidth = widthAvailable - requiredWidth;

		// Control column needs to always be included. This makes it sub-
		// optimal in terms of using the available with, but to stop layout
		// thrashing or overflow. Also we need to account for the control column
		// width first so we know how much width is available for the other
		// columns, since the control column might not be the first one shown
		for (i = 0, ien = display.length; i < ien; i++) {
			if (columns[i].control) {
				usedWidth -= columns[i].minWidth;
			}
		}

		// Allow columns to be shown (counting by priority and then right to
		// left) until we run out of room
		var empty = false;
		for (i = 0, ien = order.length; i < ien; i++) {
			var colIdx = order[i].columnIdx;

			if (
				display[colIdx] === '-' &&
				!columns[colIdx].control &&
				columns[colIdx].minWidth
			) {
				// Once we've found a column that won't fit we don't let any
				// others display either, or columns might disappear in the
				// middle of the table
				if (empty || usedWidth - columns[colIdx].minWidth < 0) {
					empty = true;
					display[colIdx] = false;
				}
				else {
					display[colIdx] = true;
				}

				usedWidth -= columns[colIdx].minWidth;
			}
		}

		// Determine if the 'control' column should be shown (if there is one).
		// This is the case when there is a hidden column (that is not the
		// control column). The two loops look inefficient here, but they are
		// trivial and will fly through. We need to know the outcome from the
		// first , before the action in the second can be taken
		var showControl = false;

		for (i = 0, ien = columns.length; i < ien; i++) {
			if (
				!columns[i].control &&
				!columns[i].never &&
				display[i] === false
			) {
				showControl = true;
				break;
			}
		}

		for (i = 0, ien = columns.length; i < ien; i++) {
			if (columns[i].control) {
				display[i] = showControl;
			}

			// Replace not visible string with false from the control column detection above
			if (display[i] === 'not-visible') {
				display[i] = false;
			}
		}

		// Finally we need to make sure that there is at least one column that
		// is visible
		if ($.inArray(true, display) === -1) {
			display[0] = true;
		}

		return display;
	},

	/**
	 * Create the internal `columns` array with information about the columns
	 * for the table. This includes determining which breakpoints the column
	 * will appear in, based upon class names in the column, which makes up the
	 * vast majority of this method.
	 *
	 * @private
	 */
	_classLogic: function () {
		var that = this;
		var breakpoints = this.c.breakpoints;
		var dt = this.s.dt;
		var columns = dt
			.columns()
			.eq(0)
			.map(function (i) {
				var column = this.column(i);
				var className = column.header().className;
				var priority = column.init().responsivePriority;
				var dataPriority = column
					.header()
					.getAttribute('data-priority');

				if (priority === undefined) {
					priority =
						dataPriority === undefined || dataPriority === null
							? 10000
							: dataPriority * 1;
				}

				return {
					className: className,
					includeIn: [],
					auto: false,
					control: false,
					never: className.match(/\b(dtr\-)?never\b/) ? true : false,
					priority: priority
				};
			});

		// Simply add a breakpoint to `includeIn` array, ensuring that there are
		// no duplicates
		var add = function (colIdx, name) {
			var includeIn = columns[colIdx].includeIn;

			if ($.inArray(name, includeIn) === -1) {
				includeIn.push(name);
			}
		};

		var column = function (colIdx, name, operator, matched) {
			var size, i, ien;

			if (!operator) {
				columns[colIdx].includeIn.push(name);
			}
			else if (operator === 'max-') {
				// Add this breakpoint and all smaller
				size = that._find(name).width;

				for (i = 0, ien = breakpoints.length; i < ien; i++) {
					if (breakpoints[i].width <= size) {
						add(colIdx, breakpoints[i].name);
					}
				}
			}
			else if (operator === 'min-') {
				// Add this breakpoint and all larger
				size = that._find(name).width;

				for (i = 0, ien = breakpoints.length; i < ien; i++) {
					if (breakpoints[i].width >= size) {
						add(colIdx, breakpoints[i].name);
					}
				}
			}
			else if (operator === 'not-') {
				// Add all but this breakpoint
				for (i = 0, ien = breakpoints.length; i < ien; i++) {
					if (breakpoints[i].name.indexOf(matched) === -1) {
						add(colIdx, breakpoints[i].name);
					}
				}
			}
		};

		// Loop over each column and determine if it has a responsive control
		// class
		columns.each(function (col, i) {
			var classNames = col.className.split(' ');
			var hasClass = false;

			// Split the class name up so multiple rules can be applied if needed
			for (var k = 0, ken = classNames.length; k < ken; k++) {
				var className = classNames[k].trim();

				if (className === 'all' || className === 'dtr-all') {
					// Include in all
					hasClass = true;
					col.includeIn = $.map(breakpoints, function (a) {
						return a.name;
					});
					return;
				}
				else if (
					className === 'none' ||
					className === 'dtr-none' ||
					col.never
				) {
					// Include in none (default) and no auto
					hasClass = true;
					return;
				}
				else if (
					className === 'control' ||
					className === 'dtr-control'
				) {
					// Special column that is only visible, when one of the other
					// columns is hidden. This is used for the details control
					hasClass = true;
					col.control = true;
					return;
				}

				$.each(breakpoints, function (j, breakpoint) {
					// Does this column have a class that matches this breakpoint?
					var brokenPoint = breakpoint.name.split('-');
					var re = new RegExp(
						'(min\\-|max\\-|not\\-)?(' +
							brokenPoint[0] +
							')(\\-[_a-zA-Z0-9])?'
					);
					var match = className.match(re);

					if (match) {
						hasClass = true;

						if (
							match[2] === brokenPoint[0] &&
							match[3] === '-' + brokenPoint[1]
						) {
							// Class name matches breakpoint name fully
							column(
								i,
								breakpoint.name,
								match[1],
								match[2] + match[3]
							);
						}
						else if (match[2] === brokenPoint[0] && !match[3]) {
							// Class name matched primary breakpoint name with no qualifier
							column(i, breakpoint.name, match[1], match[2]);
						}
					}
				});
			}

			// If there was no control class, then automatic sizing is used
			if (!hasClass) {
				col.auto = true;
			}
		});

		this.s.columns = columns;
	},

	/**
	 * Update the cells to show the correct control class / button
	 * @private
	 */
	_controlClass: function () {
		if (this.c.details.type === 'inline') {
			var dt = this.s.dt;
			var columnsVis = this.s.current;
			var firstVisible = $.inArray(true, columnsVis);

			// Remove from any cells which shouldn't have it
			dt.cells(
				null,
				function (idx) {
					return idx !== firstVisible;
				},
				{ page: 'current' }
			)
				.nodes()
				.to$()
				.filter('.dtr-control')
				.removeClass('dtr-control');

			if (firstVisible >= 0) {
				dt.cells(null, firstVisible, { page: 'current' })
					.nodes()
					.to$()
					.addClass('dtr-control');
			}
		}

		this._tabIndexes();
	},

	/**
	 * Show the details for the child row
	 *
	 * @param  {DataTables.Api} row    API instance for the row
	 * @param  {boolean}        update Update flag
	 * @private
	 */
	_detailsDisplay: function (row, update) {
		var that = this;
		var dt = this.s.dt;
		var details = this.c.details;
		var event = function (res) {
			$(row.node()).toggleClass('dtr-expanded', res !== false);
			$(dt.table().node()).triggerHandler('responsive-display.dt', [
				dt,
				row,
				res,
				update
			]);
		};

		if (details && details.type !== false) {
			var renderer =
				typeof details.renderer === 'string'
					? Responsive.renderer[details.renderer]()
					: details.renderer;

			var res = details.display(
				row,
				update,
				function () {
					return renderer.call(
						that,
						dt,
						row[0][0],
						that._detailsObj(row[0])
					);
				},
				function () {
					event(false);
				}
			);

			if (typeof res === 'boolean') {
				event(res);
			}
		}
	},

	/**
	 * Initialisation for the details handler
	 *
	 * @private
	 */
	_detailsInit: function () {
		var that = this;
		var dt = this.s.dt;
		var details = this.c.details;

		// The inline type always uses the first child as the target
		if (details.type === 'inline') {
			details.target = 'td.dtr-control, th.dtr-control';
		}

		$(dt.table().body()).on('keyup.dtr', 'td, th', function (e) {
			if (e.keyCode === 13 && $(this).data('dtr-keyboard')) {
				$(this).click();
			}
		});

		// type.target can be a string jQuery selector or a column index
		var target = details.target;
		var selector = typeof target === 'string' ? target : 'td, th';

		if (target !== undefined || target !== null) {
			// Click handler to show / hide the details rows when they are available
			$(dt.table().body()).on(
				'click.dtr mousedown.dtr mouseup.dtr',
				selector,
				function (e) {
					// If the table is not collapsed (i.e. there is no hidden columns)
					// then take no action
					if (!$(dt.table().node()).hasClass('collapsed')) {
						return;
					}

					// Check that the row is actually a DataTable's controlled node
					if (
						$.inArray(
							$(this).closest('tr').get(0),
							dt.rows().nodes().toArray()
						) === -1
					) {
						return;
					}

					// For column index, we determine if we should act or not in the
					// handler - otherwise it is already okay
					if (typeof target === 'number') {
						var targetIdx =
							target < 0
								? dt.columns().eq(0).length + target
								: target;

						if (dt.cell(this).index().column !== targetIdx) {
							return;
						}
					}

					// $().closest() includes itself in its check
					var row = dt.row($(this).closest('tr'));

					// Check event type to do an action
					if (e.type === 'click') {
						// The renderer is given as a function so the caller can execute it
						// only when they need (i.e. if hiding there is no point is running
						// the renderer)
						that._detailsDisplay(row, false);
					}
					else if (e.type === 'mousedown') {
						// For mouse users, prevent the focus ring from showing
						$(this).css('outline', 'none');
					}
					else if (e.type === 'mouseup') {
						// And then re-allow at the end of the click
						$(this).trigger('blur').css('outline', '');
					}
				}
			);
		}
	},

	/**
	 * Get the details to pass to a renderer for a row
	 * @param  {int} rowIdx Row index
	 * @private
	 */
	_detailsObj: function (rowIdx) {
		var that = this;
		var dt = this.s.dt;

		return $.map(this.s.columns, function (col, i) {
			// Never and control columns should not be passed to the renderer
			if (col.never || col.control) {
				return;
			}

			var dtCol = dt.settings()[0].aoColumns[i];

			return {
				className: dtCol.sClass,
				columnIndex: i,
				data: dt.cell(rowIdx, i).render(that.c.orthogonal),
				hidden: dt.column(i).visible() && !that.s.current[i],
				rowIndex: rowIdx,
				title: dt.column(i).title()
			};
		});
	},

	/**
	 * Find a breakpoint object from a name
	 *
	 * @param  {string} name Breakpoint name to find
	 * @return {object}      Breakpoint description object
	 * @private
	 */
	_find: function (name) {
		var breakpoints = this.c.breakpoints;

		for (var i = 0, ien = breakpoints.length; i < ien; i++) {
			if (breakpoints[i].name === name) {
				return breakpoints[i];
			}
		}
	},

	/**
	 * Re-create the contents of the child rows as the display has changed in
	 * some way.
	 *
	 * @private
	 */
	_redrawChildren: function () {
		var that = this;
		var dt = this.s.dt;

		dt.rows({ page: 'current' }).iterator('row', function (settings, idx) {
			that._detailsDisplay(dt.row(idx), true);
		});
	},

	/**
	 * Alter the table display for a resized viewport. This involves first
	 * determining what breakpoint the window currently is in, getting the
	 * column visibilities to apply and then setting them.
	 *
	 * @param  {boolean} forceRedraw Force a redraw
	 * @private
	 */
	_resize: function (forceRedraw) {
		var that = this;
		var dt = this.s.dt;
		var width = $(window).innerWidth();
		var breakpoints = this.c.breakpoints;
		var breakpoint = breakpoints[0].name;
		var columns = this.s.columns;
		var i, ien;
		var oldVis = this.s.current.slice();

		// Determine what breakpoint we are currently at
		for (i = breakpoints.length - 1; i >= 0; i--) {
			if (width <= breakpoints[i].width) {
				breakpoint = breakpoints[i].name;
				break;
			}
		}

		// Show the columns for that break point
		var columnsVis = this._columnsVisiblity(breakpoint);
		this.s.current = columnsVis;

		// Set the class before the column visibility is changed so event
		// listeners know what the state is. Need to determine if there are
		// any columns that are not visible but can be shown
		var collapsedClass = false;

		for (i = 0, ien = columns.length; i < ien; i++) {
			if (
				columnsVis[i] === false &&
				!columns[i].never &&
				!columns[i].control &&
				!dt.column(i).visible() === false
			) {
				collapsedClass = true;
				break;
			}
		}

		$(dt.table().node()).toggleClass('collapsed', collapsedClass);

		var changed = false;
		var visible = 0;
		var dtSettings = dt.settings()[0];
		var colGroup = $(dt.table().node()).children('colgroup');
		var colEls = dtSettings.aoColumns.map(function (col) {
			return col.colEl;
		});

		dt.columns()
			.eq(0)
			.each(function (colIdx, i) {
				// Do nothing on DataTables' hidden column - DT removes it from the table
				// so we need to slide back
				if (! dt.column(colIdx).visible()) {
					return;
				}

				if (columnsVis[i] === true) {
					visible++;
				}

				if (forceRedraw || columnsVis[i] !== oldVis[i]) {
					changed = true;
					that._setColumnVis(colIdx, columnsVis[i]);
				}

				// DataTables 2 uses `col` to define the width for a column
				// and this needs to run each time, as DataTables will change
				// the column width. We may need to reattach if we've removed
				// an element previously.
				if (! columnsVis[i]) {
					colEls[i].detach();
				}
				else {
					that._colGroupAttach(colGroup, colEls, i);
				}
			});

		if (changed) {
			dt.columns.adjust();

			this._redrawChildren();

			// Inform listeners of the change
			$(dt.table().node()).trigger('responsive-resize.dt', [
				dt,
				this._responsiveOnlyHidden()
			]);

			// If no records, update the "No records" display element
			if (dt.page.info().recordsDisplay === 0) {
				$('td', dt.table().body()).eq(0).attr('colspan', visible);
			}
		}

		that._controlClass();
	},

	/**
	 * Determine the width of each column in the table so the auto column hiding
	 * has that information to work with. This method is never going to be 100%
	 * perfect since column widths can change slightly per page, but without
	 * seriously compromising performance this is quite effective.
	 *
	 * @private
	 */
	_resizeAuto: function () {
		var dt = this.s.dt;
		var columns = this.s.columns;
		var that = this;
		var visibleColumns = dt
			.columns()
			.indexes()
			.filter(function (idx) {
				return dt.column(idx).visible();
			});

		// Are we allowed to do auto sizing?
		if (!this.c.auto) {
			return;
		}

		// Are there any columns that actually need auto-sizing, or do they all
		// have classes defined
		if (
			$.inArray(
				true,
				$.map(columns, function (c) {
					return c.auto;
				})
			) === -1
		) {
			return;
		}

		// Clone the table with the current data in it
		var clonedTable = dt.table().node().cloneNode(false);
		var clonedHeader = $(dt.table().header().cloneNode(false)).appendTo(
			clonedTable
		);
		var clonedFooter = $(dt.table().footer().cloneNode(false)).appendTo(
			clonedTable
		);
		var clonedBody = $(dt.table().body())
			.clone(false, false)
			.empty()
			.appendTo(clonedTable); // use jQuery because of IE8

		clonedTable.style.width = 'auto';

		// Header
		dt.table()
			.header.structure(visibleColumns)
			.forEach((row) => {
				var cells = row
					.filter(function (el) {
						return el ? true : false;
					})
					.map(function (el) {
						return $(el.cell)
							.clone(false)
							.css('display', 'table-cell')
							.css('width', 'auto')
							.css('min-width', 0);
					});

				$('<tr/>').append(cells).appendTo(clonedHeader);
			});

		// Always need an empty row that we can read widths from
		var emptyRow = $('<tr/>').appendTo(clonedBody);

		for (var i = 0; i < visibleColumns.count(); i++) {
			emptyRow.append('<td/>');
		}

		// Body rows
		if (this.c.details.renderer._responsiveMovesNodes) {
			// Slow but it allows for moving elements around the document
			dt.rows({ page: 'current' }).every(function (rowIdx) {
				var node = this.node();

				if (! node) {
					return;
				}

				// We clone the table's rows and cells to create the sizing table
				var tr = node.cloneNode(false);

				dt.cells(rowIdx, visibleColumns).every(function (rowIdx2, colIdx) {
					// If nodes have been moved out (listHiddenNodes), we need to
					// clone from the store
					var store = that.s.childNodeStore[rowIdx + '-' + colIdx];

					if (store) {
						$(this.node().cloneNode(false))
							.append($(store).clone())
							.appendTo(tr);
					}
					else {
						$(this.node()).clone(false).appendTo(tr);
					}
				});

				clonedBody.append(tr);
			});
		}
		else {
			// This is much faster, but it doesn't account for moving nodes around
			$(clonedBody)
				.append( $(dt.rows( { page: 'current' } ).nodes()).clone( false ) )
				.find( 'th, td' ).css( 'display', '' );
		}

		// Any cells which were hidden by Responsive in the host table, need to
		// be visible here for the calculations
		clonedBody.find('th, td').css('display', '');

		// Footer
		dt.table()
			.footer.structure(visibleColumns)
			.forEach((row) => {
				var cells = row
					.filter(function (el) {
						return el ? true : false;
					})
					.map(function (el) {
						return $(el.cell)
							.clone(false)
							.css('display', 'table-cell')
							.css('width', 'auto')
							.css('min-width', 0);
					});

				$('<tr/>').append(cells).appendTo(clonedFooter);
			});

		// In the inline case extra padding is applied to the first column to
		// give space for the show / hide icon. We need to use this in the
		// calculation
		if (this.c.details.type === 'inline') {
			$(clonedTable).addClass('dtr-inline collapsed');
		}

		// It is unsafe to insert elements with the same name into the DOM
		// multiple times. For example, cloning and inserting a checked radio
		// clears the chcecked state of the original radio.
		$(clonedTable).find('[name]').removeAttr('name');

		// A position absolute table would take the table out of the flow of
		// our container element, bypassing the height and width (Scroller)
		$(clonedTable).css('position', 'relative');

		var inserted = $('<div/>')
			.css({
				width: 1,
				height: 1,
				overflow: 'hidden',
				clear: 'both'
			})
			.append(clonedTable);

		inserted.insertBefore(dt.table().node());

		// The cloned table now contains the smallest that each column can be
		emptyRow.children().each(function (i) {
			var idx = dt.column.index('fromVisible', i);
			columns[idx].minWidth = this.offsetWidth || 0;
		});

		inserted.remove();
	},

	/**
	 * Get the state of the current hidden columns - controlled by Responsive only
	 */
	_responsiveOnlyHidden: function () {
		var dt = this.s.dt;

		return $.map(this.s.current, function (v, i) {
			// If the column is hidden by DataTables then it can't be hidden by
			// Responsive!
			if (dt.column(i).visible() === false) {
				return true;
			}
			return v;
		});
	},

	/**
	 * Set a column's visibility.
	 *
	 * We don't use DataTables' column visibility controls in order to ensure
	 * that column visibility can Responsive can no-exist. Since only IE8+ is
	 * supported (and all evergreen browsers of course) the control of the
	 * display attribute works well.
	 *
	 * @param {integer} col      Column index
	 * @param {boolean} showHide Show or hide (true or false)
	 * @private
	 */
	_setColumnVis: function (col, showHide) {
		var that = this;
		var dt = this.s.dt;
		var display = showHide ? '' : 'none'; // empty string will remove the attr

		this._setHeaderVis(col, showHide, dt.table().header.structure());
		this._setHeaderVis(col, showHide, dt.table().footer.structure());

		dt.column(col)
			.nodes()
			.to$()
			.css('display', display)
			.toggleClass('dtr-hidden', !showHide);

		// If the are child nodes stored, we might need to reinsert them
		if (!$.isEmptyObject(this.s.childNodeStore)) {
			dt.cells(null, col)
				.indexes()
				.each(function (idx) {
					that._childNodesRestore(dt, idx.row, idx.column);
				});
		}
	},

	/**
	 * Set the a column's visibility, taking into account multiple rows
	 * in a header / footer and colspan attributes
	 * @param {*} col
	 * @param {*} showHide
	 * @param {*} structure
	 */
	_setHeaderVis: function (col, showHide, structure) {
		var that = this;
		var display = showHide ? '' : 'none';

		// We use the `null`s in the structure array to indicate that a cell
		// should expand over that one if there is a colspan, but it might
		// also have been filled by a rowspan, so we need to expand the
		// rowspan cells down through the structure
		structure.forEach(function (row, rowIdx) {
			for (var col = 0; col < row.length; col++) {
				if (row[col] && row[col].rowspan > 1) {
					var span = row[col].rowspan;

					for (var i=1 ; i<span ; i++) {
						structure[rowIdx + i][col] = {};
					}
				}
			}
		});

		structure.forEach(function (row) {
			if (row[col] && row[col].cell) {
				$(row[col].cell)
					.css('display', display)
					.toggleClass('dtr-hidden', !showHide);
			}
			else {
				// In a colspan - need to rewind calc the new span since
				// display:none elements do not count as being spanned over
				var search = col;

				while (search >= 0) {
					if (row[search] && row[search].cell) {
						row[search].cell.colSpan = that._colspan(row, search);
						break;
					}

					search--;
				}
			}
		});
	},

	/**
	 * How many columns should this cell span
	 *
	 * @param {*} row Header structure row
	 * @param {*} idx The column index of the cell to span
	 */
	_colspan: function (row, idx) {
		var colspan = 1;

		for (var col = idx + 1; col < row.length; col++) {
			if (row[col] === null && this.s.current[col]) {
				// colspan and not hidden by Responsive
				colspan++;
			}
			else if (row[col]) {
				// Got the next cell, jump out
				break;
			}
		}

		return colspan;
	},

	/**
	 * Update the cell tab indexes for keyboard accessibility. This is called on
	 * every table draw - that is potentially inefficient, but also the least
	 * complex option given that column visibility can change on the fly. Its a
	 * shame user-focus was removed from CSS 3 UI, as it would have solved this
	 * issue with a single CSS statement.
	 *
	 * @private
	 */
	_tabIndexes: function () {
		var dt = this.s.dt;
		var cells = dt.cells({ page: 'current' }).nodes().to$();
		var ctx = dt.settings()[0];
		var target = this.c.details.target;

		cells.filter('[data-dtr-keyboard]').removeData('[data-dtr-keyboard]');

		if (typeof target === 'number') {
			dt.cells(null, target, { page: 'current' })
				.nodes()
				.to$()
				.attr('tabIndex', ctx.iTabIndex)
				.data('dtr-keyboard', 1);
		}
		else {
			// This is a bit of a hack - we need to limit the selected nodes to just
			// those of this table
			if (target === 'td:first-child, th:first-child') {
				target = '>td:first-child, >th:first-child';
			}

			var rows = dt.rows({ page: 'current' }).nodes();
			var nodes = target === 'tr'
				? $(rows)
				: $(target, rows);

			nodes
				.attr('tabIndex', ctx.iTabIndex)
				.data('dtr-keyboard', 1);
		}
	}
});

/**
 * List of default breakpoints. Each item in the array is an object with two
 * properties:
 *
 * * `name` - the breakpoint name.
 * * `width` - the breakpoint width
 *
 * @name Responsive.breakpoints
 * @static
 */
Responsive.breakpoints = [
	{ name: 'desktop', width: Infinity },
	{ name: 'tablet-l', width: 1024 },
	{ name: 'tablet-p', width: 768 },
	{ name: 'mobile-l', width: 480 },
	{ name: 'mobile-p', width: 320 }
];

/**
 * Display methods - functions which define how the hidden data should be shown
 * in the table.
 *
 * @namespace
 * @name Responsive.defaults
 * @static
 */
Responsive.display = {
	childRow: function (row, update, render) {
		var rowNode = $(row.node());

		if (update) {
			if (rowNode.hasClass('dtr-expanded')) {
				row.child(render(), 'child').show();

				return true;
			}
		}
		else {
			if (!rowNode.hasClass('dtr-expanded')) {
				var rendered = render();

				if (rendered === false) {
					return false;
				}

				row.child(rendered, 'child').show();
				return true;
			}
			else {
				row.child(false);

				return false;
			}
		}
	},

	childRowImmediate: function (row, update, render) {
		var rowNode = $(row.node());

		if (
			(!update && rowNode.hasClass('dtr-expanded')) ||
			!row.responsive.hasHidden()
		) {
			// User interaction and the row is show, or nothing to show
			row.child(false);

			return false;
		}
		else {
			// Display
			var rendered = render();

			if (rendered === false) {
				return false;
			}

			row.child(rendered, 'child').show();

			return true;
		}
	},

	// This is a wrapper so the modal options for Bootstrap and jQuery UI can
	// have options passed into them. This specific one doesn't need to be a
	// function but it is for consistency in the `modal` name
	modal: function (options) {
		return function (row, update, render, closeCallback) {
			var modal;
			var rendered = render();

			if (rendered === false) {
				return false;
			}

			if (!update) {
				// Show a modal
				var close = function () {
					modal.remove(); // will tidy events for us
					$(document).off('keypress.dtr');
					$(row.node()).removeClass('dtr-expanded');

					closeCallback();
				};

				modal = $('<div class="dtr-modal"/>')
					.append(
						$('<div class="dtr-modal-display"/>')
							.append(
								$('<div class="dtr-modal-content"/>')
									.data('dtr-row-idx', row.index())
									.append(rendered)
							)
							.append(
								$(
									'<div class="dtr-modal-close">&times;</div>'
								).click(function () {
									close();
								})
							)
					)
					.append(
						$('<div class="dtr-modal-background"/>').click(
							function () {
								close();
							}
						)
					)
					.appendTo('body');

				$(row.node()).addClass('dtr-expanded');

				$(document).on('keyup.dtr', function (e) {
					if (e.keyCode === 27) {
						e.stopPropagation();

						close();
					}
				});
			}
			else {
				modal = $('div.dtr-modal-content');

				if (modal.length && row.index() === modal.data('dtr-row-idx')) {
					modal.empty().append(rendered);
				}
				else {
					// Modal not shown, nothing to update
					return null;
				}
			}

			if (options && options.header) {
				$('div.dtr-modal-content').prepend(
					'<h2>' + options.header(row) + '</h2>'
				);
			}

			return true;
		};
	}
};

/**
 * Display methods - functions which define how the hidden data should be shown
 * in the table.
 *
 * @namespace
 * @name Responsive.defaults
 * @static
 */
Responsive.renderer = {
	listHiddenNodes: function () {
		var fn = function (api, rowIdx, columns) {
			var that = this;
			var ul = $(
				'<ul data-dtr-index="' + rowIdx + '" class="dtr-details"/>'
			);
			var found = false;

			$.each(columns, function (i, col) {
				if (col.hidden) {
					var klass = col.className
						? 'class="' + col.className + '"'
						: '';

					$(
						'<li ' +
							klass +
							' data-dtr-index="' +
							col.columnIndex +
							'" data-dt-row="' +
							col.rowIndex +
							'" data-dt-column="' +
							col.columnIndex +
							'">' +
							'<span class="dtr-title">' +
							col.title +
							'</span> ' +
							'</li>'
					)
						.append(
							$('<span class="dtr-data"/>').append(
								that._childNodes(
									api,
									col.rowIndex,
									col.columnIndex
								)
							)
						) // api.cell( col.rowIndex, col.columnIndex ).node().childNodes ) )
						.appendTo(ul);

					found = true;
				}
			});

			return found ? ul : false;
		};

		fn._responsiveMovesNodes = true;

		return fn;
	},

	listHidden: function () {
		return function (api, rowIdx, columns) {
			var data = $.map(columns, function (col) {
				var klass = col.className
					? 'class="' + col.className + '"'
					: '';

				return col.hidden
					? '<li ' +
							klass +
							' data-dtr-index="' +
							col.columnIndex +
							'" data-dt-row="' +
							col.rowIndex +
							'" data-dt-column="' +
							col.columnIndex +
							'">' +
							'<span class="dtr-title">' +
							col.title +
							'</span> ' +
							'<span class="dtr-data">' +
							col.data +
							'</span>' +
							'</li>'
					: '';
			}).join('');

			return data
				? $(
						'<ul data-dtr-index="' +
							rowIdx +
							'" class="dtr-details"/>'
				).append(data)
				: false;
		};
	},

	tableAll: function (options) {
		options = $.extend(
			{
				tableClass: ''
			},
			options
		);

		return function (api, rowIdx, columns) {
			var data = $.map(columns, function (col) {
				var klass = col.className
					? 'class="' + col.className + '"'
					: '';

				return (
					'<tr ' +
					klass +
					' data-dt-row="' +
					col.rowIndex +
					'" data-dt-column="' +
					col.columnIndex +
					'">' +
					'<td>' +
					( '' !== col.title
						? col.title + ':'
						: ''
					) +
					'</td> ' +
					'<td>' +
					col.data +
					'</td>' +
					'</tr>'
				);
			}).join('');

			return $(
				'<table class="' +
					options.tableClass +
					' dtr-details" width="100%"/>'
			).append(data);
		};
	}
};

/**
 * Responsive default settings for initialisation
 *
 * @namespace
 * @name Responsive.defaults
 * @static
 */
Responsive.defaults = {
	/**
	 * List of breakpoints for the instance. Note that this means that each
	 * instance can have its own breakpoints. Additionally, the breakpoints
	 * cannot be changed once an instance has been creased.
	 *
	 * @type {Array}
	 * @default Takes the value of `Responsive.breakpoints`
	 */
	breakpoints: Responsive.breakpoints,

	/**
	 * Enable / disable auto hiding calculations. It can help to increase
	 * performance slightly if you disable this option, but all columns would
	 * need to have breakpoint classes assigned to them
	 *
	 * @type {Boolean}
	 * @default  `true`
	 */
	auto: true,

	/**
	 * Details control. If given as a string value, the `type` property of the
	 * default object is set to that value, and the defaults used for the rest
	 * of the object - this is for ease of implementation.
	 *
	 * The object consists of the following properties:
	 *
	 * * `display` - A function that is used to show and hide the hidden details
	 * * `renderer` - function that is called for display of the child row data.
	 *   The default function will show the data from the hidden columns
	 * * `target` - Used as the selector for what objects to attach the child
	 *   open / close to
	 * * `type` - `false` to disable the details display, `inline` or `column`
	 *   for the two control types
	 *
	 * @type {Object|string}
	 */
	details: {
		display: Responsive.display.childRow,

		renderer: Responsive.renderer.listHidden(),

		target: 0,

		type: 'inline'
	},

	/**
	 * Orthogonal data request option. This is used to define the data type
	 * requested when Responsive gets the data to show in the child row.
	 *
	 * @type {String}
	 */
	orthogonal: 'display'
};

/*
 * API
 */
var Api = $.fn.dataTable.Api;

// Doesn't do anything - work around for a bug in DT... Not documented
Api.register('responsive()', function () {
	return this;
});

Api.register('responsive.index()', function (li) {
	li = $(li);

	return {
		column: li.data('dtr-index'),
		row: li.parent().data('dtr-index')
	};
});

Api.register('responsive.rebuild()', function () {
	return this.iterator('table', function (ctx) {
		if (ctx._responsive) {
			ctx._responsive._classLogic();
		}
	});
});

Api.register('responsive.recalc()', function () {
	return this.iterator('table', function (ctx) {
		if (ctx._responsive) {
			ctx._responsive._resizeAuto();
			ctx._responsive._resize();
		}
	});
});

Api.register('responsive.hasHidden()', function () {
	var ctx = this.context[0];

	return ctx._responsive
		? $.inArray(false, ctx._responsive._responsiveOnlyHidden()) !== -1
		: false;
});

Api.registerPlural(
	'columns().responsiveHidden()',
	'column().responsiveHidden()',
	function () {
		return this.iterator(
			'column',
			function (settings, column) {
				return settings._responsive
					? settings._responsive._responsiveOnlyHidden()[column]
					: false;
			},
			1
		);
	}
);

/**
 * Version information
 *
 * @name Responsive.version
 * @static
 */
Responsive.version = '3.0.4';

$.fn.dataTable.Responsive = Responsive;
$.fn.DataTable.Responsive = Responsive;

// Attach a listener to the document which listens for DataTables initialisation
// events so we can automatically initialise
$(document).on('preInit.dt.dtr', function (e, settings, json) {
	if (e.namespace !== 'dt') {
		return;
	}

	if (
		$(settings.nTable).hasClass('responsive') ||
		$(settings.nTable).hasClass('dt-responsive') ||
		settings.oInit.responsive ||
		datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"].defaults.responsive
	) {
		var init = settings.oInit.responsive;

		if (init !== false) {
			new Responsive(settings, $.isPlainObject(init) ? init : {});
		}
	}
});


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (datatables_net__WEBPACK_IMPORTED_MODULE_1__["default"]);


/***/ }),

/***/ "./node_modules/datatables.net/js/dataTables.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/datatables.net/js/dataTables.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/*! DataTables 2.3.1
 * Â© SpryMedia Ltd - datatables.net/license
 */



// DataTables code uses $ internally, but we want to be able to
// reassign $ with the `use` method, so it is a regular var.
var $ = jquery__WEBPACK_IMPORTED_MODULE_0__;


var DataTable = function ( selector, options )
{
	// Check if called with a window or jQuery object for DOM less applications
	// This is for backwards compatibility
	if (DataTable.factory(selector, options)) {
		return DataTable;
	}

	// When creating with `new`, create a new DataTable, returning the API instance
	if (this instanceof DataTable) {
		return $(selector).DataTable(options);
	}
	else {
		// Argument switching
		options = selector;
	}

	var _that = this;
	var emptyInit = options === undefined;
	var len = this.length;

	if ( emptyInit ) {
		options = {};
	}

	// Method to get DT API instance from jQuery object
	this.api = function ()
	{
		return new _Api( this );
	};

	this.each(function() {
		// For each initialisation we want to give it a clean initialisation
		// object that can be bashed around
		var o = {};
		var oInit = len > 1 ? // optimisation for single table case
			_fnExtend( o, options, true ) :
			options;

		
		var i=0, iLen;
		var sId = this.getAttribute( 'id' );
		var defaults = DataTable.defaults;
		var $this = $(this);
		
		// Sanity check
		if ( this.nodeName.toLowerCase() != 'table' )
		{
			_fnLog( null, 0, 'Non-table node initialisation ('+this.nodeName+')', 2 );
			return;
		}
		
		// Special case for options
		if (oInit.on && oInit.on.options) {
			_fnListener($this, 'options', oInit.on.options);	
		}
		
		$this.trigger( 'options.dt', oInit );
		
		/* Backwards compatibility for the defaults */
		_fnCompatOpts( defaults );
		_fnCompatCols( defaults.column );
		
		/* Convert the camel-case defaults to Hungarian */
		_fnCamelToHungarian( defaults, defaults, true );
		_fnCamelToHungarian( defaults.column, defaults.column, true );
		
		/* Setting up the initialisation object */
		_fnCamelToHungarian( defaults, $.extend( oInit, $this.data() ), true );
		
		
		
		/* Check to see if we are re-initialising a table */
		var allSettings = DataTable.settings;
		for ( i=0, iLen=allSettings.length ; i<iLen ; i++ )
		{
			var s = allSettings[i];
		
			/* Base check on table node */
			if (
				s.nTable == this ||
				(s.nTHead && s.nTHead.parentNode == this) ||
				(s.nTFoot && s.nTFoot.parentNode == this)
			) {
				var bRetrieve = oInit.bRetrieve !== undefined ? oInit.bRetrieve : defaults.bRetrieve;
				var bDestroy = oInit.bDestroy !== undefined ? oInit.bDestroy : defaults.bDestroy;
		
				if ( emptyInit || bRetrieve )
				{
					return s.oInstance;
				}
				else if ( bDestroy )
				{
					new DataTable.Api(s).destroy();
					break;
				}
				else
				{
					_fnLog( s, 0, 'Cannot reinitialise DataTable', 3 );
					return;
				}
			}
		
			/* If the element we are initialising has the same ID as a table which was previously
			 * initialised, but the table nodes don't match (from before) then we destroy the old
			 * instance by simply deleting it. This is under the assumption that the table has been
			 * destroyed by other methods. Anyone using non-id selectors will need to do this manually
			 */
			if ( s.sTableId == this.id )
			{
				allSettings.splice( i, 1 );
				break;
			}
		}
		
		/* Ensure the table has an ID - required for accessibility */
		if ( sId === null || sId === "" )
		{
			sId = "DataTables_Table_"+(DataTable.ext._unique++);
			this.id = sId;
		}
		
		/* Create the settings object for this table and set some of the default parameters */
		var oSettings = $.extend( true, {}, DataTable.models.oSettings, {
			"sDestroyWidth": $this[0].style.width,
			"sInstance":     sId,
			"sTableId":      sId,
			colgroup: $('<colgroup>').prependTo(this),
			fastData: function (row, column, type) {
				return _fnGetCellData(oSettings, row, column, type);
			}
		} );
		oSettings.nTable = this;
		oSettings.oInit  = oInit;
		
		allSettings.push( oSettings );
		
		// Make a single API instance available for internal handling
		oSettings.api = new _Api( oSettings );
		
		// Need to add the instance after the instance after the settings object has been added
		// to the settings array, so we can self reference the table instance if more than one
		oSettings.oInstance = (_that.length===1) ? _that : $this.dataTable();
		
		// Backwards compatibility, before we apply all the defaults
		_fnCompatOpts( oInit );
		
		// If the length menu is given, but the init display length is not, use the length menu
		if ( oInit.aLengthMenu && ! oInit.iDisplayLength )
		{
			oInit.iDisplayLength = Array.isArray(oInit.aLengthMenu[0])
				? oInit.aLengthMenu[0][0]
				: $.isPlainObject( oInit.aLengthMenu[0] )
					? oInit.aLengthMenu[0].value
					: oInit.aLengthMenu[0];
		}
		
		// Apply the defaults and init options to make a single init object will all
		// options defined from defaults and instance options.
		oInit = _fnExtend( $.extend( true, {}, defaults ), oInit );
		
		
		// Map the initialisation options onto the settings object
		_fnMap( oSettings.oFeatures, oInit, [
			"bPaginate",
			"bLengthChange",
			"bFilter",
			"bSort",
			"bSortMulti",
			"bInfo",
			"bProcessing",
			"bAutoWidth",
			"bSortClasses",
			"bServerSide",
			"bDeferRender"
		] );
		_fnMap( oSettings, oInit, [
			"ajax",
			"fnFormatNumber",
			"sServerMethod",
			"aaSorting",
			"aaSortingFixed",
			"aLengthMenu",
			"sPaginationType",
			"iStateDuration",
			"bSortCellsTop",
			"iTabIndex",
			"sDom",
			"fnStateLoadCallback",
			"fnStateSaveCallback",
			"renderer",
			"searchDelay",
			"rowId",
			"caption",
			"layout",
			"orderDescReverse",
			"orderIndicators",
			"orderHandler",
			"titleRow",
			"typeDetect",
			[ "iCookieDuration", "iStateDuration" ], // backwards compat
			[ "oSearch", "oPreviousSearch" ],
			[ "aoSearchCols", "aoPreSearchCols" ],
			[ "iDisplayLength", "_iDisplayLength" ]
		] );
		_fnMap( oSettings.oScroll, oInit, [
			[ "sScrollX", "sX" ],
			[ "sScrollXInner", "sXInner" ],
			[ "sScrollY", "sY" ],
			[ "bScrollCollapse", "bCollapse" ]
		] );
		_fnMap( oSettings.oLanguage, oInit, "fnInfoCallback" );
		
		/* Callback functions which are array driven */
		_fnCallbackReg( oSettings, 'aoDrawCallback',       oInit.fnDrawCallback );
		_fnCallbackReg( oSettings, 'aoStateSaveParams',    oInit.fnStateSaveParams );
		_fnCallbackReg( oSettings, 'aoStateLoadParams',    oInit.fnStateLoadParams );
		_fnCallbackReg( oSettings, 'aoStateLoaded',        oInit.fnStateLoaded );
		_fnCallbackReg( oSettings, 'aoRowCallback',        oInit.fnRowCallback );
		_fnCallbackReg( oSettings, 'aoRowCreatedCallback', oInit.fnCreatedRow );
		_fnCallbackReg( oSettings, 'aoHeaderCallback',     oInit.fnHeaderCallback );
		_fnCallbackReg( oSettings, 'aoFooterCallback',     oInit.fnFooterCallback );
		_fnCallbackReg( oSettings, 'aoInitComplete',       oInit.fnInitComplete );
		_fnCallbackReg( oSettings, 'aoPreDrawCallback',    oInit.fnPreDrawCallback );
		
		oSettings.rowIdFn = _fnGetObjectDataFn( oInit.rowId );
		
		// Add event listeners
		if (oInit.on) {
			Object.keys(oInit.on).forEach(function (key) {
				_fnListener($this, key, oInit.on[key]);
			});
		}
		
		/* Browser support detection */
		_fnBrowserDetect( oSettings );
		
		var oClasses = oSettings.oClasses;
		
		$.extend( oClasses, DataTable.ext.classes, oInit.oClasses );
		$this.addClass( oClasses.table );
		
		if (! oSettings.oFeatures.bPaginate) {
			oInit.iDisplayStart = 0;
		}
		
		if ( oSettings.iInitDisplayStart === undefined )
		{
			/* Display start point, taking into account the save saving */
			oSettings.iInitDisplayStart = oInit.iDisplayStart;
			oSettings._iDisplayStart = oInit.iDisplayStart;
		}
		
		var defer = oInit.iDeferLoading;
		if ( defer !== null )
		{
			oSettings.deferLoading = true;
		
			var tmp = Array.isArray(defer);
			oSettings._iRecordsDisplay = tmp ? defer[0] : defer;
			oSettings._iRecordsTotal = tmp ? defer[1] : defer;
		}
		
		/*
		 * Columns
		 * See if we should load columns automatically or use defined ones
		 */
		var columnsInit = [];
		var thead = this.getElementsByTagName('thead');
		var initHeaderLayout = _fnDetectHeader( oSettings, thead[0] );
		
		// If we don't have a columns array, then generate one with nulls
		if ( oInit.aoColumns ) {
			columnsInit = oInit.aoColumns;
		}
		else if ( initHeaderLayout.length ) {
			for ( i=0, iLen=initHeaderLayout[0].length ; i<iLen ; i++ ) {
				columnsInit.push( null );
			}
		}
		
		// Add the columns
		for ( i=0, iLen=columnsInit.length ; i<iLen ; i++ ) {
			_fnAddColumn( oSettings );
		}
		
		// Apply the column definitions
		_fnApplyColumnDefs( oSettings, oInit.aoColumnDefs, columnsInit, initHeaderLayout, function (iCol, oDef) {
			_fnColumnOptions( oSettings, iCol, oDef );
		} );
		
		/* HTML5 attribute detection - build an mData object automatically if the
		 * attributes are found
		 */
		var rowOne = $this.children('tbody').find('tr:first-child').eq(0);
		
		if ( rowOne.length ) {
			var a = function ( cell, name ) {
				return cell.getAttribute( 'data-'+name ) !== null ? name : null;
			};
		
			$( rowOne[0] ).children('th, td').each( function (i, cell) {
				var col = oSettings.aoColumns[i];
		
				if (! col) {
					_fnLog( oSettings, 0, 'Incorrect column count', 18 );
				}
		
				if ( col.mData === i ) {
					var sort = a( cell, 'sort' ) || a( cell, 'order' );
					var filter = a( cell, 'filter' ) || a( cell, 'search' );
		
					if ( sort !== null || filter !== null ) {
						col.mData = {
							_:      i+'.display',
							sort:   sort !== null   ? i+'.@data-'+sort   : undefined,
							type:   sort !== null   ? i+'.@data-'+sort   : undefined,
							filter: filter !== null ? i+'.@data-'+filter : undefined
						};
						col._isArrayHost = true;
		
						_fnColumnOptions( oSettings, i );
					}
				}
			} );
		}
		
		// Must be done after everything which can be overridden by the state saving!
		_fnCallbackReg( oSettings, 'aoDrawCallback', _fnSaveState );
		
		var features = oSettings.oFeatures;
		if ( oInit.bStateSave )
		{
			features.bStateSave = true;
		}
		
		// If aaSorting is not defined, then we use the first indicator in asSorting
		// in case that has been altered, so the default sort reflects that option
		if ( oInit.aaSorting === undefined ) {
			var sorting = oSettings.aaSorting;
			for ( i=0, iLen=sorting.length ; i<iLen ; i++ ) {
				sorting[i][1] = oSettings.aoColumns[ i ].asSorting[0];
			}
		}
		
		// Do a first pass on the sorting classes (allows any size changes to be taken into
		// account, and also will apply sorting disabled classes if disabled
		_fnSortingClasses( oSettings );
		
		_fnCallbackReg( oSettings, 'aoDrawCallback', function () {
			if ( oSettings.bSorted || _fnDataSource( oSettings ) === 'ssp' || features.bDeferRender ) {
				_fnSortingClasses( oSettings );
			}
		} );
		
		
		/*
		 * Table HTML init
		 * Cache the header, body and footer as required, creating them if needed
		 */
		var caption = $this.children('caption');
		
		if ( oSettings.caption ) {
			if ( caption.length === 0 ) {
				caption = $('<caption/>').appendTo( $this );
			}
		
			caption.html( oSettings.caption );
		}
		
		// Store the caption side, so we can remove the element from the document
		// when creating the element
		if (caption.length) {
			caption[0]._captionSide = caption.css('caption-side');
			oSettings.captionNode = caption[0];
		}
		
		if ( thead.length === 0 ) {
			thead = $('<thead/>').appendTo($this);
		}
		oSettings.nTHead = thead[0];
		
		var tbody = $this.children('tbody');
		if ( tbody.length === 0 ) {
			tbody = $('<tbody/>').insertAfter(thead);
		}
		oSettings.nTBody = tbody[0];
		
		var tfoot = $this.children('tfoot');
		if ( tfoot.length === 0 ) {
			// If we are a scrolling table, and no footer has been given, then we need to create
			// a tfoot element for the caption element to be appended to
			tfoot = $('<tfoot/>').appendTo($this);
		}
		oSettings.nTFoot = tfoot[0];
		
		// Copy the data index array
		oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
		
		// Initialisation complete - table can be drawn
		oSettings.bInitialised = true;
		
		// Language definitions
		var oLanguage = oSettings.oLanguage;
		$.extend( true, oLanguage, oInit.oLanguage );
		
		if ( oLanguage.sUrl ) {
			// Get the language definitions from a file
			$.ajax( {
				dataType: 'json',
				url: oLanguage.sUrl,
				success: function ( json ) {
					_fnCamelToHungarian( defaults.oLanguage, json );
					$.extend( true, oLanguage, json, oSettings.oInit.oLanguage );
		
					_fnCallbackFire( oSettings, null, 'i18n', [oSettings], true);
					_fnInitialise( oSettings );
				},
				error: function () {
					// Error occurred loading language file
					_fnLog( oSettings, 0, 'i18n file loading error', 21 );
		
					// Continue on as best we can
					_fnInitialise( oSettings );
				}
			} );
		}
		else {
			_fnCallbackFire( oSettings, null, 'i18n', [oSettings], true);
			_fnInitialise( oSettings );
		}
	} );
	_that = null;
	return this;
};



/**
 * DataTables extensions
 * 
 * This namespace acts as a collection area for plug-ins that can be used to
 * extend DataTables capabilities. Indeed many of the build in methods
 * use this method to provide their own capabilities (sorting methods for
 * example).
 *
 * Note that this namespace is aliased to `jQuery.fn.dataTableExt` for legacy
 * reasons
 *
 *  @namespace
 */
DataTable.ext = _ext = {
	/**
	 * DataTables build type (expanded by the download builder)
	 *
	 *  @type string
	 */
	builder: "-source-",

	/**
	 * Buttons. For use with the Buttons extension for DataTables. This is
	 * defined here so other extensions can define buttons regardless of load
	 * order. It is _not_ used by DataTables core.
	 *
	 *  @type object
	 *  @default {}
	 */
	buttons: {},


	/**
	 * ColumnControl buttons and content
	 *
	 *  @type object
	 */
	ccContent: {},


	/**
	 * Element class names
	 *
	 *  @type object
	 *  @default {}
	 */
	classes: {},


	/**
	 * Error reporting.
	 * 
	 * How should DataTables report an error. Can take the value 'alert',
	 * 'throw', 'none' or a function.
	 *
	 *  @type string|function
	 *  @default alert
	 */
	errMode: "alert",


	/**
	 * Legacy so v1 plug-ins don't throw js errors on load
	 */
	feature: [],

	/**
	 * Feature plug-ins.
	 * 
	 * This is an object of callbacks which provide the features for DataTables
	 * to be initialised via the `layout` option.
	 */
	features: {},


	/**
	 * Row searching.
	 * 
	 * This method of searching is complimentary to the default type based
	 * searching, and a lot more comprehensive as it allows you complete control
	 * over the searching logic. Each element in this array is a function
	 * (parameters described below) that is called for every row in the table,
	 * and your logic decides if it should be included in the searching data set
	 * or not.
	 *
	 * Searching functions have the following input parameters:
	 *
	 * 1. `{object}` DataTables settings object: see
	 *    {@link DataTable.models.oSettings}
	 * 2. `{array|object}` Data for the row to be processed (same as the
	 *    original format that was passed in as the data source, or an array
	 *    from a DOM data source
	 * 3. `{int}` Row index ({@link DataTable.models.oSettings.aoData}), which
	 *    can be useful to retrieve the `TR` element if you need DOM interaction.
	 *
	 * And the following return is expected:
	 *
	 * * {boolean} Include the row in the searched result set (true) or not
	 *   (false)
	 *
	 * Note that as with the main search ability in DataTables, technically this
	 * is "filtering", since it is subtractive. However, for consistency in
	 * naming we call it searching here.
	 *
	 *  @type array
	 *  @default []
	 *
	 *  @example
	 *    // The following example shows custom search being applied to the
	 *    // fourth column (i.e. the data[3] index) based on two input values
	 *    // from the end-user, matching the data in a certain range.
	 *    $.fn.dataTable.ext.search.push(
	 *      function( settings, data, dataIndex ) {
	 *        var min = document.getElementById('min').value * 1;
	 *        var max = document.getElementById('max').value * 1;
	 *        var version = data[3] == "-" ? 0 : data[3]*1;
	 *
	 *        if ( min == "" && max == "" ) {
	 *          return true;
	 *        }
	 *        else if ( min == "" && version < max ) {
	 *          return true;
	 *        }
	 *        else if ( min < version && "" == max ) {
	 *          return true;
	 *        }
	 *        else if ( min < version && version < max ) {
	 *          return true;
	 *        }
	 *        return false;
	 *      }
	 *    );
	 */
	search: [],


	/**
	 * Selector extensions
	 *
	 * The `selector` option can be used to extend the options available for the
	 * selector modifier options (`selector-modifier` object data type) that
	 * each of the three built in selector types offer (row, column and cell +
	 * their plural counterparts). For example the Select extension uses this
	 * mechanism to provide an option to select only rows, columns and cells
	 * that have been marked as selected by the end user (`{selected: true}`),
	 * which can be used in conjunction with the existing built in selector
	 * options.
	 *
	 * Each property is an array to which functions can be pushed. The functions
	 * take three attributes:
	 *
	 * * Settings object for the host table
	 * * Options object (`selector-modifier` object type)
	 * * Array of selected item indexes
	 *
	 * The return is an array of the resulting item indexes after the custom
	 * selector has been applied.
	 *
	 *  @type object
	 */
	selector: {
		cell: [],
		column: [],
		row: []
	},


	/**
	 * Legacy configuration options. Enable and disable legacy options that
	 * are available in DataTables.
	 *
	 *  @type object
	 */
	legacy: {
		/**
		 * Enable / disable DataTables 1.9 compatible server-side processing
		 * requests
		 *
		 *  @type boolean
		 *  @default null
		 */
		ajax: null
	},


	/**
	 * Pagination plug-in methods.
	 * 
	 * Each entry in this object is a function and defines which buttons should
	 * be shown by the pagination rendering method that is used for the table:
	 * {@link DataTable.ext.renderer.pageButton}. The renderer addresses how the
	 * buttons are displayed in the document, while the functions here tell it
	 * what buttons to display. This is done by returning an array of button
	 * descriptions (what each button will do).
	 *
	 * Pagination types (the four built in options and any additional plug-in
	 * options defined here) can be used through the `paginationType`
	 * initialisation parameter.
	 *
	 * The functions defined take two parameters:
	 *
	 * 1. `{int} page` The current page index
	 * 2. `{int} pages` The number of pages in the table
	 *
	 * Each function is expected to return an array where each element of the
	 * array can be one of:
	 *
	 * * `first` - Jump to first page when activated
	 * * `last` - Jump to last page when activated
	 * * `previous` - Show previous page when activated
	 * * `next` - Show next page when activated
	 * * `{int}` - Show page of the index given
	 * * `{array}` - A nested array containing the above elements to add a
	 *   containing 'DIV' element (might be useful for styling).
	 *
	 * Note that DataTables v1.9- used this object slightly differently whereby
	 * an object with two functions would be defined for each plug-in. That
	 * ability is still supported by DataTables 1.10+ to provide backwards
	 * compatibility, but this option of use is now decremented and no longer
	 * documented in DataTables 1.10+.
	 *
	 *  @type object
	 *  @default {}
	 *
	 *  @example
	 *    // Show previous, next and current page buttons only
	 *    $.fn.dataTableExt.oPagination.current = function ( page, pages ) {
	 *      return [ 'previous', page, 'next' ];
	 *    };
	 */
	pager: {},


	renderer: {
		pageButton: {},
		header: {}
	},


	/**
	 * Ordering plug-ins - custom data source
	 * 
	 * The extension options for ordering of data available here is complimentary
	 * to the default type based ordering that DataTables typically uses. It
	 * allows much greater control over the the data that is being used to
	 * order a column, but is necessarily therefore more complex.
	 * 
	 * This type of ordering is useful if you want to do ordering based on data
	 * live from the DOM (for example the contents of an 'input' element) rather
	 * than just the static string that DataTables knows of.
	 * 
	 * The way these plug-ins work is that you create an array of the values you
	 * wish to be ordering for the column in question and then return that
	 * array. The data in the array much be in the index order of the rows in
	 * the table (not the currently ordering order!). Which order data gathering
	 * function is run here depends on the `dt-init columns.orderDataType`
	 * parameter that is used for the column (if any).
	 *
	 * The functions defined take two parameters:
	 *
	 * 1. `{object}` DataTables settings object: see
	 *    {@link DataTable.models.oSettings}
	 * 2. `{int}` Target column index
	 *
	 * Each function is expected to return an array:
	 *
	 * * `{array}` Data for the column to be ordering upon
	 *
	 *  @type array
	 *
	 *  @example
	 *    // Ordering using `input` node values
	 *    $.fn.dataTable.ext.order['dom-text'] = function  ( settings, col )
	 *    {
	 *      return this.api().column( col, {order:'index'} ).nodes().map( function ( td, i ) {
	 *        return $('input', td).val();
	 *      } );
	 *    }
	 */
	order: {},


	/**
	 * Type based plug-ins.
	 *
	 * Each column in DataTables has a type assigned to it, either by automatic
	 * detection or by direct assignment using the `type` option for the column.
	 * The type of a column will effect how it is ordering and search (plug-ins
	 * can also make use of the column type if required).
	 *
	 * @namespace
	 */
	type: {
		/**
		 * Automatic column class assignment
		 */
		className: {},

		/**
		 * Type detection functions.
		 *
		 * The functions defined in this object are used to automatically detect
		 * a column's type, making initialisation of DataTables super easy, even
		 * when complex data is in the table.
		 *
		 * The functions defined take two parameters:
		 *
	     *  1. `{*}` Data from the column cell to be analysed
	     *  2. `{settings}` DataTables settings object. This can be used to
	     *     perform context specific type detection - for example detection
	     *     based on language settings such as using a comma for a decimal
	     *     place. Generally speaking the options from the settings will not
	     *     be required
		 *
		 * Each function is expected to return:
		 *
		 * * `{string|null}` Data type detected, or null if unknown (and thus
		 *   pass it on to the other type detection functions.
		 *
		 *  @type array
		 *
		 *  @example
		 *    // Currency type detection plug-in:
		 *    $.fn.dataTable.ext.type.detect.push(
		 *      function ( data, settings ) {
		 *        // Check the numeric part
		 *        if ( ! data.substring(1).match(/[0-9]/) ) {
		 *          return null;
		 *        }
		 *
		 *        // Check prefixed by currency
		 *        if ( data.charAt(0) == '$' || data.charAt(0) == '&pound;' ) {
		 *          return 'currency';
		 *        }
		 *        return null;
		 *      }
		 *    );
		 */
		detect: [],

		/**
		 * Automatic renderer assignment
		 */
		render: {},


		/**
		 * Type based search formatting.
		 *
		 * The type based searching functions can be used to pre-format the
		 * data to be search on. For example, it can be used to strip HTML
		 * tags or to de-format telephone numbers for numeric only searching.
		 *
		 * Note that is a search is not defined for a column of a given type,
		 * no search formatting will be performed.
		 * 
		 * Pre-processing of searching data plug-ins - When you assign the sType
		 * for a column (or have it automatically detected for you by DataTables
		 * or a type detection plug-in), you will typically be using this for
		 * custom sorting, but it can also be used to provide custom searching
		 * by allowing you to pre-processing the data and returning the data in
		 * the format that should be searched upon. This is done by adding
		 * functions this object with a parameter name which matches the sType
		 * for that target column. This is the corollary of <i>afnSortData</i>
		 * for searching data.
		 *
		 * The functions defined take a single parameter:
		 *
	     *  1. `{*}` Data from the column cell to be prepared for searching
		 *
		 * Each function is expected to return:
		 *
		 * * `{string|null}` Formatted string that will be used for the searching.
		 *
		 *  @type object
		 *  @default {}
		 *
		 *  @example
		 *    $.fn.dataTable.ext.type.search['title-numeric'] = function ( d ) {
		 *      return d.replace(/\n/g," ").replace( /<.*?>/g, "" );
		 *    }
		 */
		search: {},


		/**
		 * Type based ordering.
		 *
		 * The column type tells DataTables what ordering to apply to the table
		 * when a column is sorted upon. The order for each type that is defined,
		 * is defined by the functions available in this object.
		 *
		 * Each ordering option can be described by three properties added to
		 * this object:
		 *
		 * * `{type}-pre` - Pre-formatting function
		 * * `{type}-asc` - Ascending order function
		 * * `{type}-desc` - Descending order function
		 *
		 * All three can be used together, only `{type}-pre` or only
		 * `{type}-asc` and `{type}-desc` together. It is generally recommended
		 * that only `{type}-pre` is used, as this provides the optimal
		 * implementation in terms of speed, although the others are provided
		 * for compatibility with existing Javascript sort functions.
		 *
		 * `{type}-pre`: Functions defined take a single parameter:
		 *
	     *  1. `{*}` Data from the column cell to be prepared for ordering
		 *
		 * And return:
		 *
		 * * `{*}` Data to be sorted upon
		 *
		 * `{type}-asc` and `{type}-desc`: Functions are typical Javascript sort
		 * functions, taking two parameters:
		 *
	     *  1. `{*}` Data to compare to the second parameter
	     *  2. `{*}` Data to compare to the first parameter
		 *
		 * And returning:
		 *
		 * * `{*}` Ordering match: <0 if first parameter should be sorted lower
		 *   than the second parameter, ===0 if the two parameters are equal and
		 *   >0 if the first parameter should be sorted height than the second
		 *   parameter.
		 * 
		 *  @type object
		 *  @default {}
		 *
		 *  @example
		 *    // Numeric ordering of formatted numbers with a pre-formatter
		 *    $.extend( $.fn.dataTable.ext.type.order, {
		 *      "string-pre": function(x) {
		 *        a = (a === "-" || a === "") ? 0 : a.replace( /[^\d\-\.]/g, "" );
		 *        return parseFloat( a );
		 *      }
		 *    } );
		 *
		 *  @example
		 *    // Case-sensitive string ordering, with no pre-formatting method
		 *    $.extend( $.fn.dataTable.ext.order, {
		 *      "string-case-asc": function(x,y) {
		 *        return ((x < y) ? -1 : ((x > y) ? 1 : 0));
		 *      },
		 *      "string-case-desc": function(x,y) {
		 *        return ((x < y) ? 1 : ((x > y) ? -1 : 0));
		 *      }
		 *    } );
		 */
		order: {}
	},

	/**
	 * Unique DataTables instance counter
	 *
	 * @type int
	 * @private
	 */
	_unique: 0,


	//
	// Depreciated
	// The following properties are retained for backwards compatibility only.
	// The should not be used in new projects and will be removed in a future
	// version
	//

	/**
	 * Version check function.
	 *  @type function
	 *  @depreciated Since 1.10
	 */
	fnVersionCheck: DataTable.fnVersionCheck,


	/**
	 * Index for what 'this' index API functions should use
	 *  @type int
	 *  @deprecated Since v1.10
	 */
	iApiIndex: 0,


	/**
	 * Software version
	 *  @type string
	 *  @deprecated Since v1.10
	 */
	sVersion: DataTable.version
};


//
// Backwards compatibility. Alias to pre 1.10 Hungarian notation counter parts
//
$.extend( _ext, {
	afnFiltering: _ext.search,
	aTypes:       _ext.type.detect,
	ofnSearch:    _ext.type.search,
	oSort:        _ext.type.order,
	afnSortData:  _ext.order,
	aoFeatures:   _ext.feature,
	oStdClasses:  _ext.classes,
	oPagination:  _ext.pager
} );


$.extend( DataTable.ext.classes, {
	container: 'dt-container',
	empty: {
		row: 'dt-empty'
	},
	info: {
		container: 'dt-info'
	},
	layout: {
		row: 'dt-layout-row',
		cell: 'dt-layout-cell',
		tableRow: 'dt-layout-table',
		tableCell: '',
		start: 'dt-layout-start',
		end: 'dt-layout-end',
		full: 'dt-layout-full'
	},
	length: {
		container: 'dt-length',
		select: 'dt-input'
	},
	order: {
		canAsc: 'dt-orderable-asc',
		canDesc: 'dt-orderable-desc',
		isAsc: 'dt-ordering-asc',
		isDesc: 'dt-ordering-desc',
		none: 'dt-orderable-none',
		position: 'sorting_'
	},
	processing: {
		container: 'dt-processing'
	},
	scrolling: {
		body: 'dt-scroll-body',
		container: 'dt-scroll',
		footer: {
			self: 'dt-scroll-foot',
			inner: 'dt-scroll-footInner'
		},
		header: {
			self: 'dt-scroll-head',
			inner: 'dt-scroll-headInner'
		}
	},
	search: {
		container: 'dt-search',
		input: 'dt-input'
	},
	table: 'dataTable',	
	tbody: {
		cell: '',
		row: ''
	},
	thead: {
		cell: '',
		row: ''
	},
	tfoot: {
		cell: '',
		row: ''
	},
	paging: {
		active: 'current',
		button: 'dt-paging-button',
		container: 'dt-paging',
		disabled: 'disabled',
		nav: ''
	}
} );


/*
 * It is useful to have variables which are scoped locally so only the
 * DataTables functions can access them and they don't leak into global space.
 * At the same time these functions are often useful over multiple files in the
 * core and API, so we list, or at least document, all variables which are used
 * by DataTables as private variables here. This also ensures that there is no
 * clashing of variable names and that they can easily referenced for reuse.
 */


// Defined else where
//  _selector_run
//  _selector_opts
//  _selector_row_indexes

var _ext; // DataTable.ext
var _Api; // DataTable.Api
var _api_register; // DataTable.Api.register
var _api_registerPlural; // DataTable.Api.registerPlural

var _re_dic = {};
var _re_new_lines = /[\r\n\u2028]/g;
var _re_html = /<([^>]*>)/g;
var _max_str_len = Math.pow(2, 28);

// This is not strict ISO8601 - Date.parse() is quite lax, although
// implementations differ between browsers.
var _re_date = /^\d{2,4}[./-]\d{1,2}[./-]\d{1,2}([T ]{1}\d{1,2}[:.]\d{2}([.:]\d{2})?)?$/;

// Escape regular expression special characters
var _re_escape_regex = new RegExp( '(\\' + [ '/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\', '$', '^', '-' ].join('|\\') + ')', 'g' );

// https://en.wikipedia.org/wiki/Foreign_exchange_market
// - \u20BD - Russian ruble.
// - \u20a9 - South Korean Won
// - \u20BA - Turkish Lira
// - \u20B9 - Indian Rupee
// - R - Brazil (R$) and South Africa
// - fr - Swiss Franc
// - kr - Swedish krona, Norwegian krone and Danish krone
// - \u2009 is thin space and \u202F is narrow no-break space, both used in many
// - É - Bitcoin
// - Î - Ethereum
//   standards as thousands separators.
var _re_formatted_numeric = /['\u00A0,$Â£â¬Â¥%\u2009\u202F\u20BD\u20a9\u20BArfkÉÎ]/gi;


var _empty = function ( d ) {
	return !d || d === true || d === '-' ? true : false;
};


var _intVal = function ( s ) {
	var integer = parseInt( s, 10 );
	return !isNaN(integer) && isFinite(s) ? integer : null;
};

// Convert from a formatted number with characters other than `.` as the
// decimal place, to a Javascript number
var _numToDecimal = function ( num, decimalPoint ) {
	// Cache created regular expressions for speed as this function is called often
	if ( ! _re_dic[ decimalPoint ] ) {
		_re_dic[ decimalPoint ] = new RegExp( _fnEscapeRegex( decimalPoint ), 'g' );
	}
	return typeof num === 'string' && decimalPoint !== '.' ?
		num.replace( /\./g, '' ).replace( _re_dic[ decimalPoint ], '.' ) :
		num;
};


var _isNumber = function ( d, decimalPoint, formatted, allowEmpty ) {
	var type = typeof d;
	var strType = type === 'string';

	if ( type === 'number' || type === 'bigint') {
		return true;
	}

	// If empty return immediately so there must be a number if it is a
	// formatted string (this stops the string "k", or "kr", etc being detected
	// as a formatted number for currency
	if ( allowEmpty && _empty( d ) ) {
		return true;
	}

	if ( decimalPoint && strType ) {
		d = _numToDecimal( d, decimalPoint );
	}

	if ( formatted && strType ) {
		d = d.replace( _re_formatted_numeric, '' );
	}

	return !isNaN( parseFloat(d) ) && isFinite( d );
};


// A string without HTML in it can be considered to be HTML still
var _isHtml = function ( d ) {
	return _empty( d ) || typeof d === 'string';
};

// Is a string a number surrounded by HTML?
var _htmlNumeric = function ( d, decimalPoint, formatted, allowEmpty ) {
	if ( allowEmpty && _empty( d ) ) {
		return true;
	}

	// input and select strings mean that this isn't just a number
	if (typeof d === 'string' && d.match(/<(input|select)/i)) {
		return null;
	}

	var html = _isHtml( d );
	return ! html ?
		null :
		_isNumber( _stripHtml( d ), decimalPoint, formatted, allowEmpty ) ?
			true :
			null;
};


var _pluck = function ( a, prop, prop2 ) {
	var out = [];
	var i=0, ien=a.length;

	// Could have the test in the loop for slightly smaller code, but speed
	// is essential here
	if ( prop2 !== undefined ) {
		for ( ; i<ien ; i++ ) {
			if ( a[i] && a[i][ prop ] ) {
				out.push( a[i][ prop ][ prop2 ] );
			}
		}
	}
	else {
		for ( ; i<ien ; i++ ) {
			if ( a[i] ) {
				out.push( a[i][ prop ] );
			}
		}
	}

	return out;
};


// Basically the same as _pluck, but rather than looping over `a` we use `order`
// as the indexes to pick from `a`
var _pluck_order = function ( a, order, prop, prop2 )
{
	var out = [];
	var i=0, ien=order.length;

	// Could have the test in the loop for slightly smaller code, but speed
	// is essential here
	if ( prop2 !== undefined ) {
		for ( ; i<ien ; i++ ) {
			if ( a[ order[i] ] && a[ order[i] ][ prop ] ) {
				out.push( a[ order[i] ][ prop ][ prop2 ] );
			}
		}
	}
	else {
		for ( ; i<ien ; i++ ) {
			if ( a[ order[i] ] ) {
				out.push( a[ order[i] ][ prop ] );
			}
		}
	}

	return out;
};


var _range = function ( len, start )
{
	var out = [];
	var end;

	if ( start === undefined ) {
		start = 0;
		end = len;
	}
	else {
		end = start;
		start = len;
	}

	for ( var i=start ; i<end ; i++ ) {
		out.push( i );
	}

	return out;
};


var _removeEmpty = function ( a )
{
	var out = [];

	for ( var i=0, ien=a.length ; i<ien ; i++ ) {
		if ( a[i] ) { // careful - will remove all falsy values!
			out.push( a[i] );
		}
	}

	return out;
};

// Replaceable function in api.util
var _stripHtml = function (input) {
	if (! input || typeof input !== 'string') {
		return input;
	}

	// Irrelevant check to workaround CodeQL's false positive on the regex
	if (input.length > _max_str_len) {
		throw new Error('Exceeded max str len');
	}

	var previous;

	input = input.replace(_re_html, ''); // Complete tags

	// Safety for incomplete script tag - use do / while to ensure that
	// we get all instances
	do {
		previous = input;
		input = input.replace(/<script/i, '');
	} while (input !== previous);

	return previous;
};

// Replaceable function in api.util
var _escapeHtml = function ( d ) {
	if (Array.isArray(d)) {
		d = d.join(',');
	}

	return typeof d === 'string' ?
		d
			.replace(/&/g, '&amp;')
			.replace(/</g, '&lt;')
			.replace(/>/g, '&gt;')
			.replace(/"/g, '&quot;') :
		d;
};

// Remove diacritics from a string by decomposing it and then removing
// non-ascii characters
var _normalize = function (str, both) {
	if (typeof str !== 'string') {
		return str;
	}

	// It is faster to just run `normalize` than it is to check if
	// we need to with a regex! (Check as it isn't available in old
	// Safari)
	var res = str.normalize
		? str.normalize("NFD")
		: str;

	// Equally, here we check if a regex is needed or not
	return res.length !== str.length
		? (both === true ? str + ' ' : '' ) + res.replace(/[\u0300-\u036f]/g, "")
		: res;
}

/**
 * Determine if all values in the array are unique. This means we can short
 * cut the _unique method at the cost of a single loop. A sorted array is used
 * to easily check the values.
 *
 * @param  {array} src Source array
 * @return {boolean} true if all unique, false otherwise
 * @ignore
 */
var _areAllUnique = function ( src ) {
	if ( src.length < 2 ) {
		return true;
	}

	var sorted = src.slice().sort();
	var last = sorted[0];

	for ( var i=1, ien=sorted.length ; i<ien ; i++ ) {
		if ( sorted[i] === last ) {
			return false;
		}

		last = sorted[i];
	}

	return true;
};


/**
 * Find the unique elements in a source array.
 *
 * @param  {array} src Source array
 * @return {array} Array of unique items
 * @ignore
 */
var _unique = function ( src )
{
	if (Array.from && Set) {
		return Array.from(new Set(src));
	}

	if ( _areAllUnique( src ) ) {
		return src.slice();
	}

	// A faster unique method is to use object keys to identify used values,
	// but this doesn't work with arrays or objects, which we must also
	// consider. See jsperf.app/compare-array-unique-versions/4 for more
	// information.
	var
		out = [],
		val,
		i, ien=src.length,
		j, k=0;

	again: for ( i=0 ; i<ien ; i++ ) {
		val = src[i];

		for ( j=0 ; j<k ; j++ ) {
			if ( out[j] === val ) {
				continue again;
			}
		}

		out.push( val );
		k++;
	}

	return out;
};

// Surprisingly this is faster than [].concat.apply
// https://jsperf.com/flatten-an-array-loop-vs-reduce/2
var _flatten = function (out, val) {
	if (Array.isArray(val)) {
		for (var i=0 ; i<val.length ; i++) {
			_flatten(out, val[i]);
		}
	}
	else {
		out.push(val);
	}

	return out;
}

// Similar to jQuery's addClass, but use classList.add
function _addClass(el, name) {
	if (name) {
		name.split(' ').forEach(function (n) {
			if (n) {
				// `add` does deduplication, so no need to check `contains`
				el.classList.add(n);
			}
		});
	}
}

/**
 * DataTables utility methods
 * 
 * This namespace provides helper methods that DataTables uses internally to
 * create a DataTable, but which are not exclusively used only for DataTables.
 * These methods can be used by extension authors to save the duplication of
 * code.
 *
 *  @namespace
 */
DataTable.util = {
	/**
	 * Return a string with diacritic characters decomposed
	 * @param {*} mixed Function or string to normalize
	 * @param {*} both Return original string and the normalized string
	 * @returns String or undefined
	 */
	diacritics: function (mixed, both) {
		var type = typeof mixed;

		if (type !== 'function') {
			return _normalize(mixed, both);
		}
		_normalize = mixed;
	},

	/**
	 * Debounce a function
	 *
	 * @param {function} fn Function to be called
	 * @param {integer} freq Call frequency in mS
	 * @return {function} Wrapped function
	 */
	debounce: function ( fn, timeout ) {
		var timer;

		return function () {
			var that = this;
			var args = arguments;

			clearTimeout(timer);

			timer = setTimeout( function () {
				fn.apply(that, args);
			}, timeout || 250 );
		};
	},

	/**
	 * Throttle the calls to a function. Arguments and context are maintained
	 * for the throttled function.
	 *
	 * @param {function} fn Function to be called
	 * @param {integer} freq Call frequency in mS
	 * @return {function} Wrapped function
	 */
	throttle: function ( fn, freq ) {
		var
			frequency = freq !== undefined ? freq : 200,
			last,
			timer;

		return function () {
			var
				that = this,
				now  = +new Date(),
				args = arguments;

			if ( last && now < last + frequency ) {
				clearTimeout( timer );

				timer = setTimeout( function () {
					last = undefined;
					fn.apply( that, args );
				}, frequency );
			}
			else {
				last = now;
				fn.apply( that, args );
			}
		};
	},

	/**
	 * Escape a string such that it can be used in a regular expression
	 *
	 *  @param {string} val string to escape
	 *  @returns {string} escaped string
	 */
	escapeRegex: function ( val ) {
		return val.replace( _re_escape_regex, '\\$1' );
	},

	/**
	 * Create a function that will write to a nested object or array
	 * @param {*} source JSON notation string
	 * @returns Write function
	 */
	set: function ( source ) {
		if ( $.isPlainObject( source ) ) {
			/* Unlike get, only the underscore (global) option is used for for
			 * setting data since we don't know the type here. This is why an object
			 * option is not documented for `mData` (which is read/write), but it is
			 * for `mRender` which is read only.
			 */
			return DataTable.util.set( source._ );
		}
		else if ( source === null ) {
			// Nothing to do when the data source is null
			return function () {};
		}
		else if ( typeof source === 'function' ) {
			return function (data, val, meta) {
				source( data, 'set', val, meta );
			};
		}
		else if (
			typeof source === 'string' && (source.indexOf('.') !== -1 ||
			source.indexOf('[') !== -1 || source.indexOf('(') !== -1)
		) {
			// Like the get, we need to get data from a nested object
			var setData = function (data, val, src) {
				var a = _fnSplitObjNotation( src ), b;
				var aLast = a[a.length-1];
				var arrayNotation, funcNotation, o, innerSrc;
	
				for ( var i=0, iLen=a.length-1 ; i<iLen ; i++ ) {
					// Protect against prototype pollution
					if (a[i] === '__proto__' || a[i] === 'constructor') {
						throw new Error('Cannot set prototype values');
					}
	
					// Check if we are dealing with an array notation request
					arrayNotation = a[i].match(__reArray);
					funcNotation = a[i].match(__reFn);
	
					if ( arrayNotation ) {
						a[i] = a[i].replace(__reArray, '');
						data[ a[i] ] = [];
	
						// Get the remainder of the nested object to set so we can recurse
						b = a.slice();
						b.splice( 0, i+1 );
						innerSrc = b.join('.');
	
						// Traverse each entry in the array setting the properties requested
						if ( Array.isArray( val ) ) {
							for ( var j=0, jLen=val.length ; j<jLen ; j++ ) {
								o = {};
								setData( o, val[j], innerSrc );
								data[ a[i] ].push( o );
							}
						}
						else {
							// We've been asked to save data to an array, but it
							// isn't array data to be saved. Best that can be done
							// is to just save the value.
							data[ a[i] ] = val;
						}
	
						// The inner call to setData has already traversed through the remainder
						// of the source and has set the data, thus we can exit here
						return;
					}
					else if ( funcNotation ) {
						// Function call
						a[i] = a[i].replace(__reFn, '');
						data = data[ a[i] ]( val );
					}
	
					// If the nested object doesn't currently exist - since we are
					// trying to set the value - create it
					if ( data[ a[i] ] === null || data[ a[i] ] === undefined ) {
						data[ a[i] ] = {};
					}
					data = data[ a[i] ];
				}
	
				// Last item in the input - i.e, the actual set
				if ( aLast.match(__reFn ) ) {
					// Function call
					data = data[ aLast.replace(__reFn, '') ]( val );
				}
				else {
					// If array notation is used, we just want to strip it and use the property name
					// and assign the value. If it isn't used, then we get the result we want anyway
					data[ aLast.replace(__reArray, '') ] = val;
				}
			};
	
			return function (data, val) { // meta is also passed in, but not used
				return setData( data, val, source );
			};
		}
		else {
			// Array or flat object mapping
			return function (data, val) { // meta is also passed in, but not used
				data[source] = val;
			};
		}
	},

	/**
	 * Create a function that will read nested objects from arrays, based on JSON notation
	 * @param {*} source JSON notation string
	 * @returns Value read
	 */
	get: function ( source ) {
		if ( $.isPlainObject( source ) ) {
			// Build an object of get functions, and wrap them in a single call
			var o = {};
			$.each( source, function (key, val) {
				if ( val ) {
					o[key] = DataTable.util.get( val );
				}
			} );
	
			return function (data, type, row, meta) {
				var t = o[type] || o._;
				return t !== undefined ?
					t(data, type, row, meta) :
					data;
			};
		}
		else if ( source === null ) {
			// Give an empty string for rendering / sorting etc
			return function (data) { // type, row and meta also passed, but not used
				return data;
			};
		}
		else if ( typeof source === 'function' ) {
			return function (data, type, row, meta) {
				return source( data, type, row, meta );
			};
		}
		else if (
			typeof source === 'string' && (source.indexOf('.') !== -1 ||
			source.indexOf('[') !== -1 || source.indexOf('(') !== -1)
		) {
			/* If there is a . in the source string then the data source is in a
			 * nested object so we loop over the data for each level to get the next
			 * level down. On each loop we test for undefined, and if found immediately
			 * return. This allows entire objects to be missing and sDefaultContent to
			 * be used if defined, rather than throwing an error
			 */
			var fetchData = function (data, type, src) {
				var arrayNotation, funcNotation, out, innerSrc;
	
				if ( src !== "" ) {
					var a = _fnSplitObjNotation( src );
	
					for ( var i=0, iLen=a.length ; i<iLen ; i++ ) {
						// Check if we are dealing with special notation
						arrayNotation = a[i].match(__reArray);
						funcNotation = a[i].match(__reFn);
	
						if ( arrayNotation ) {
							// Array notation
							a[i] = a[i].replace(__reArray, '');
	
							// Condition allows simply [] to be passed in
							if ( a[i] !== "" ) {
								data = data[ a[i] ];
							}
							out = [];
	
							// Get the remainder of the nested object to get
							a.splice( 0, i+1 );
							innerSrc = a.join('.');
	
							// Traverse each entry in the array getting the properties requested
							if ( Array.isArray( data ) ) {
								for ( var j=0, jLen=data.length ; j<jLen ; j++ ) {
									out.push( fetchData( data[j], type, innerSrc ) );
								}
							}
	
							// If a string is given in between the array notation indicators, that
							// is used to join the strings together, otherwise an array is returned
							var join = arrayNotation[0].substring(1, arrayNotation[0].length-1);
							data = (join==="") ? out : out.join(join);
	
							// The inner call to fetchData has already traversed through the remainder
							// of the source requested, so we exit from the loop
							break;
						}
						else if ( funcNotation ) {
							// Function call
							a[i] = a[i].replace(__reFn, '');
							data = data[ a[i] ]();
							continue;
						}
	
						if (data === null || data[ a[i] ] === null) {
							return null;
						}
						else if ( data === undefined || data[ a[i] ] === undefined ) {
							return undefined;
						}

						data = data[ a[i] ];
					}
				}
	
				return data;
			};
	
			return function (data, type) { // row and meta also passed, but not used
				return fetchData( data, type, source );
			};
		}
		else {
			// Array or flat object mapping
			return function (data) { // row and meta also passed, but not used
				return data[source];
			};
		}
	},

	stripHtml: function (mixed) {
		var type = typeof mixed;

		if (type === 'function') {
			_stripHtml = mixed;
			return;
		}
		else if (type === 'string') {
			return _stripHtml(mixed);
		}
		return mixed;
	},

	escapeHtml: function (mixed) {
		var type = typeof mixed;

		if (type === 'function') {
			_escapeHtml = mixed;
			return;
		}
		else if (type === 'string' || Array.isArray(mixed)) {
			return _escapeHtml(mixed);
		}
		return mixed;
	},

	unique: _unique
};



/**
 * Create a mapping object that allows camel case parameters to be looked up
 * for their Hungarian counterparts. The mapping is stored in a private
 * parameter called `_hungarianMap` which can be accessed on the source object.
 *  @param {object} o
 *  @memberof DataTable#oApi
 */
function _fnHungarianMap ( o )
{
	var
		hungarian = 'a aa ai ao as b fn i m o s ',
		match,
		newKey,
		map = {};

	$.each( o, function (key) {
		match = key.match(/^([^A-Z]+?)([A-Z])/);

		if ( match && hungarian.indexOf(match[1]+' ') !== -1 )
		{
			newKey = key.replace( match[0], match[2].toLowerCase() );
			map[ newKey ] = key;

			if ( match[1] === 'o' )
			{
				_fnHungarianMap( o[key] );
			}
		}
	} );

	o._hungarianMap = map;
}


/**
 * Convert from camel case parameters to Hungarian, based on a Hungarian map
 * created by _fnHungarianMap.
 *  @param {object} src The model object which holds all parameters that can be
 *    mapped.
 *  @param {object} user The object to convert from camel case to Hungarian.
 *  @param {boolean} force When set to `true`, properties which already have a
 *    Hungarian value in the `user` object will be overwritten. Otherwise they
 *    won't be.
 *  @memberof DataTable#oApi
 */
function _fnCamelToHungarian ( src, user, force )
{
	if ( ! src._hungarianMap ) {
		_fnHungarianMap( src );
	}

	var hungarianKey;

	$.each( user, function (key) {
		hungarianKey = src._hungarianMap[ key ];

		if ( hungarianKey !== undefined && (force || user[hungarianKey] === undefined) )
		{
			// For objects, we need to buzz down into the object to copy parameters
			if ( hungarianKey.charAt(0) === 'o' )
			{
				// Copy the camelCase options over to the hungarian
				if ( ! user[ hungarianKey ] ) {
					user[ hungarianKey ] = {};
				}
				$.extend( true, user[hungarianKey], user[key] );

				_fnCamelToHungarian( src[hungarianKey], user[hungarianKey], force );
			}
			else {
				user[hungarianKey] = user[ key ];
			}
		}
	} );
}

/**
 * Map one parameter onto another
 *  @param {object} o Object to map
 *  @param {*} knew The new parameter name
 *  @param {*} old The old parameter name
 */
var _fnCompatMap = function ( o, knew, old ) {
	if ( o[ knew ] !== undefined ) {
		o[ old ] = o[ knew ];
	}
};


/**
 * Provide backwards compatibility for the main DT options. Note that the new
 * options are mapped onto the old parameters, so this is an external interface
 * change only.
 *  @param {object} init Object to map
 */
function _fnCompatOpts ( init )
{
	_fnCompatMap( init, 'ordering',      'bSort' );
	_fnCompatMap( init, 'orderMulti',    'bSortMulti' );
	_fnCompatMap( init, 'orderClasses',  'bSortClasses' );
	_fnCompatMap( init, 'orderCellsTop', 'bSortCellsTop' );
	_fnCompatMap( init, 'order',         'aaSorting' );
	_fnCompatMap( init, 'orderFixed',    'aaSortingFixed' );
	_fnCompatMap( init, 'paging',        'bPaginate' );
	_fnCompatMap( init, 'pagingType',    'sPaginationType' );
	_fnCompatMap( init, 'pageLength',    'iDisplayLength' );
	_fnCompatMap( init, 'searching',     'bFilter' );

	// Boolean initialisation of x-scrolling
	if ( typeof init.sScrollX === 'boolean' ) {
		init.sScrollX = init.sScrollX ? '100%' : '';
	}
	if ( typeof init.scrollX === 'boolean' ) {
		init.scrollX = init.scrollX ? '100%' : '';
	}

	// Objects for ordering
	if ( typeof init.bSort === 'object' ) {
		init.orderIndicators = init.bSort.indicators !== undefined ? init.bSort.indicators : true;
		init.orderHandler = init.bSort.handler !== undefined ? init.bSort.handler : true;
		init.bSort = true;
	}
	else if (init.bSort === false) {
		init.orderIndicators = false;
		init.orderHandler = false;
	}
	else if (init.bSort === true) {
		init.orderIndicators = true;
		init.orderHandler = true;
	}

	// Which cells are the title cells?
	if (typeof init.bSortCellsTop === 'boolean') {
		init.titleRow = init.bSortCellsTop;
	}

	// Column search objects are in an array, so it needs to be converted
	// element by element
	var searchCols = init.aoSearchCols;

	if ( searchCols ) {
		for ( var i=0, ien=searchCols.length ; i<ien ; i++ ) {
			if ( searchCols[i] ) {
				_fnCamelToHungarian( DataTable.models.oSearch, searchCols[i] );
			}
		}
	}

	// Enable search delay if server-side processing is enabled
	if (init.serverSide && ! init.searchDelay) {
		init.searchDelay = 400;
	}
}


/**
 * Provide backwards compatibility for column options. Note that the new options
 * are mapped onto the old parameters, so this is an external interface change
 * only.
 *  @param {object} init Object to map
 */
function _fnCompatCols ( init )
{
	_fnCompatMap( init, 'orderable',     'bSortable' );
	_fnCompatMap( init, 'orderData',     'aDataSort' );
	_fnCompatMap( init, 'orderSequence', 'asSorting' );
	_fnCompatMap( init, 'orderDataType', 'sortDataType' );

	// orderData can be given as an integer
	var dataSort = init.aDataSort;
	if ( typeof dataSort === 'number' && ! Array.isArray( dataSort ) ) {
		init.aDataSort = [ dataSort ];
	}
}


/**
 * Browser feature detection for capabilities, quirks
 *  @param {object} settings dataTables settings object
 *  @memberof DataTable#oApi
 */
function _fnBrowserDetect( settings )
{
	// We don't need to do this every time DataTables is constructed, the values
	// calculated are specific to the browser and OS configuration which we
	// don't expect to change between initialisations
	if ( ! DataTable.__browser ) {
		var browser = {};
		DataTable.__browser = browser;

		// Scrolling feature / quirks detection
		var n = $('<div/>')
			.css( {
				position: 'fixed',
				top: 0,
				left: -1 * window.pageXOffset, // allow for scrolling
				height: 1,
				width: 1,
				overflow: 'hidden'
			} )
			.append(
				$('<div/>')
					.css( {
						position: 'absolute',
						top: 1,
						left: 1,
						width: 100,
						overflow: 'scroll'
					} )
					.append(
						$('<div/>')
							.css( {
								width: '100%',
								height: 10
							} )
					)
			)
			.appendTo( 'body' );

		var outer = n.children();
		var inner = outer.children();

		// Get scrollbar width
		browser.barWidth = outer[0].offsetWidth - outer[0].clientWidth;

		// In rtl text layout, some browsers (most, but not all) will place the
		// scrollbar on the left, rather than the right.
		browser.bScrollbarLeft = Math.round( inner.offset().left ) !== 1;

		n.remove();
	}

	$.extend( settings.oBrowser, DataTable.__browser );
	settings.oScroll.iBarWidth = DataTable.__browser.barWidth;
}

/**
 * Add a column to the list used for the table with default values
 *  @param {object} oSettings dataTables settings object
 *  @memberof DataTable#oApi
 */
function _fnAddColumn( oSettings )
{
	// Add column to aoColumns array
	var oDefaults = DataTable.defaults.column;
	var iCol = oSettings.aoColumns.length;
	var oCol = $.extend( {}, DataTable.models.oColumn, oDefaults, {
		"aDataSort": oDefaults.aDataSort ? oDefaults.aDataSort : [iCol],
		"mData": oDefaults.mData ? oDefaults.mData : iCol,
		idx: iCol,
		searchFixed: {},
		colEl: $('<col>').attr('data-dt-column', iCol)
	} );
	oSettings.aoColumns.push( oCol );

	// Add search object for column specific search. Note that the `searchCols[ iCol ]`
	// passed into extend can be undefined. This allows the user to give a default
	// with only some of the parameters defined, and also not give a default
	var searchCols = oSettings.aoPreSearchCols;
	searchCols[ iCol ] = $.extend( {}, DataTable.models.oSearch, searchCols[ iCol ] );
}


/**
 * Apply options for a column
 *  @param {object} oSettings dataTables settings object
 *  @param {int} iCol column index to consider
 *  @param {object} oOptions object with sType, bVisible and bSearchable etc
 *  @memberof DataTable#oApi
 */
function _fnColumnOptions( oSettings, iCol, oOptions )
{
	var oCol = oSettings.aoColumns[ iCol ];

	/* User specified column options */
	if ( oOptions !== undefined && oOptions !== null )
	{
		// Backwards compatibility
		_fnCompatCols( oOptions );

		// Map camel case parameters to their Hungarian counterparts
		_fnCamelToHungarian( DataTable.defaults.column, oOptions, true );

		/* Backwards compatibility for mDataProp */
		if ( oOptions.mDataProp !== undefined && !oOptions.mData )
		{
			oOptions.mData = oOptions.mDataProp;
		}

		if ( oOptions.sType )
		{
			oCol._sManualType = oOptions.sType;
		}
	
		// `class` is a reserved word in Javascript, so we need to provide
		// the ability to use a valid name for the camel case input
		if ( oOptions.className && ! oOptions.sClass )
		{
			oOptions.sClass = oOptions.className;
		}

		var origClass = oCol.sClass;

		$.extend( oCol, oOptions );
		_fnMap( oCol, oOptions, "sWidth", "sWidthOrig" );

		// Merge class from previously defined classes with this one, rather than just
		// overwriting it in the extend above
		if (origClass !== oCol.sClass) {
			oCol.sClass = origClass + ' ' + oCol.sClass;
		}

		/* iDataSort to be applied (backwards compatibility), but aDataSort will take
		 * priority if defined
		 */
		if ( oOptions.iDataSort !== undefined )
		{
			oCol.aDataSort = [ oOptions.iDataSort ];
		}
		_fnMap( oCol, oOptions, "aDataSort" );
	}

	/* Cache the data get and set functions for speed */
	var mDataSrc = oCol.mData;
	var mData = _fnGetObjectDataFn( mDataSrc );

	// The `render` option can be given as an array to access the helper rendering methods.
	// The first element is the rendering method to use, the rest are the parameters to pass
	if ( oCol.mRender && Array.isArray( oCol.mRender ) ) {
		var copy = oCol.mRender.slice();
		var name = copy.shift();

		oCol.mRender = DataTable.render[name].apply(window, copy);
	}

	oCol._render = oCol.mRender ? _fnGetObjectDataFn( oCol.mRender ) : null;

	var attrTest = function( src ) {
		return typeof src === 'string' && src.indexOf('@') !== -1;
	};
	oCol._bAttrSrc = $.isPlainObject( mDataSrc ) && (
		attrTest(mDataSrc.sort) || attrTest(mDataSrc.type) || attrTest(mDataSrc.filter)
	);
	oCol._setter = null;

	oCol.fnGetData = function (rowData, type, meta) {
		var innerData = mData( rowData, type, undefined, meta );

		return oCol._render && type ?
			oCol._render( innerData, type, rowData, meta ) :
			innerData;
	};
	oCol.fnSetData = function ( rowData, val, meta ) {
		return _fnSetObjectDataFn( mDataSrc )( rowData, val, meta );
	};

	// Indicate if DataTables should read DOM data as an object or array
	// Used in _fnGetRowElements
	if ( typeof mDataSrc !== 'number' && ! oCol._isArrayHost ) {
		oSettings._rowReadObject = true;
	}

	/* Feature sorting overrides column specific when off */
	if ( !oSettings.oFeatures.bSort )
	{
		oCol.bSortable = false;
	}
}


/**
 * Adjust the table column widths for new data. Note: you would probably want to
 * do a redraw after calling this function!
 *  @param {object} settings dataTables settings object
 *  @memberof DataTable#oApi
 */
function _fnAdjustColumnSizing ( settings )
{
	_fnCalculateColumnWidths( settings );
	_fnColumnSizes( settings );

	var scroll = settings.oScroll;
	if ( scroll.sY !== '' || scroll.sX !== '') {
		_fnScrollDraw( settings );
	}

	_fnCallbackFire( settings, null, 'column-sizing', [settings] );
}

/**
 * Apply column sizes
 *
 * @param {*} settings DataTables settings object
 */
function _fnColumnSizes ( settings )
{
	var cols = settings.aoColumns;

	for (var i=0 ; i<cols.length ; i++) {
		var width = _fnColumnsSumWidth(settings, [i], false, false);

		cols[i].colEl.css('width', width);

		if (settings.oScroll.sX) {
			cols[i].colEl.css('min-width', width);
		}
	}
}


/**
 * Convert the index of a visible column to the index in the data array (take account
 * of hidden columns)
 *  @param {object} oSettings dataTables settings object
 *  @param {int} iMatch Visible column index to lookup
 *  @returns {int} i the data index
 *  @memberof DataTable#oApi
 */
function _fnVisibleToColumnIndex( oSettings, iMatch )
{
	var aiVis = _fnGetColumns( oSettings, 'bVisible' );

	return typeof aiVis[iMatch] === 'number' ?
		aiVis[iMatch] :
		null;
}


/**
 * Convert the index of an index in the data array and convert it to the visible
 *   column index (take account of hidden columns)
 *  @param {int} iMatch Column index to lookup
 *  @param {object} oSettings dataTables settings object
 *  @returns {int} i the data index
 *  @memberof DataTable#oApi
 */
function _fnColumnIndexToVisible( oSettings, iMatch )
{
	var aiVis = _fnGetColumns( oSettings, 'bVisible' );
	var iPos = aiVis.indexOf(iMatch);

	return iPos !== -1 ? iPos : null;
}


/**
 * Get the number of visible columns
 *  @param {object} oSettings dataTables settings object
 *  @returns {int} i the number of visible columns
 *  @memberof DataTable#oApi
 */
function _fnVisbleColumns( settings )
{
	var layout = settings.aoHeader;
	var columns = settings.aoColumns;
	var vis = 0;

	if ( layout.length ) {
		for ( var i=0, ien=layout[0].length ; i<ien ; i++ ) {
			if ( columns[i].bVisible && $(layout[0][i].cell).css('display') !== 'none' ) {
				vis++;
			}
		}
	}

	return vis;
}


/**
 * Get an array of column indexes that match a given property
 *  @param {object} oSettings dataTables settings object
 *  @param {string} sParam Parameter in aoColumns to look for - typically
 *    bVisible or bSearchable
 *  @returns {array} Array of indexes with matched properties
 *  @memberof DataTable#oApi
 */
function _fnGetColumns( oSettings, sParam )
{
	var a = [];

	oSettings.aoColumns.map( function(val, i) {
		if ( val[sParam] ) {
			a.push( i );
		}
	} );

	return a;
}

/**
 * Allow the result from a type detection function to be `true` while
 * translating that into a string. Old type detection functions will
 * return the type name if it passes. An obect store would be better,
 * but not backwards compatible.
 *
 * @param {*} typeDetect Object or function for type detection
 * @param {*} res Result from the type detection function
 * @returns Type name or false
 */
function _typeResult (typeDetect, res) {
	return res === true
		? typeDetect._name
		: res;
}

/**
 * Calculate the 'type' of a column
 *  @param {object} settings dataTables settings object
 *  @memberof DataTable#oApi
 */
function _fnColumnTypes ( settings )
{
	var columns = settings.aoColumns;
	var data = settings.aoData;
	var types = DataTable.ext.type.detect;
	var i, ien, j, jen, k, ken;
	var col, detectedType, cache;

	// For each column, spin over the data type detection functions, seeing if one matches
	for ( i=0, ien=columns.length ; i<ien ; i++ ) {
		col = columns[i];
		cache = [];

		if ( ! col.sType && col._sManualType ) {
			col.sType = col._sManualType;
		}
		else if ( ! col.sType ) {
			// With SSP type detection can be unreliable and error prone, so we provide a way
			// to turn it off.
			if (! settings.typeDetect) {
				return;
			}

			for ( j=0, jen=types.length ; j<jen ; j++ ) {
				var typeDetect = types[j];

				// There can be either one, or three type detection functions
				var oneOf = typeDetect.oneOf;
				var allOf = typeDetect.allOf || typeDetect;
				var init = typeDetect.init;
				var one = false;

				detectedType = null;

				// Fast detect based on column assignment
				if (init) {
					detectedType = _typeResult(typeDetect, init(settings, col, i));

					if (detectedType) {
						col.sType = detectedType;
						break;
					}
				}

				for ( k=0, ken=data.length ; k<ken ; k++ ) {
					if (! data[k]) {
						continue;
					}

					// Use a cache array so we only need to get the type data
					// from the formatter once (when using multiple detectors)
					if ( cache[k] === undefined ) {
						cache[k] = _fnGetCellData( settings, k, i, 'type' );
					}

					// Only one data point in the column needs to match this function
					if (oneOf && ! one) {
						one = _typeResult(typeDetect, oneOf( cache[k], settings ));
					}

					// All data points need to match this function
					detectedType = _typeResult(typeDetect, allOf( cache[k], settings ));

					// If null, then this type can't apply to this column, so
					// rather than testing all cells, break out. There is an
					// exception for the last type which is `html`. We need to
					// scan all rows since it is possible to mix string and HTML
					// types
					if ( ! detectedType && j !== types.length-3 ) {
						break;
					}

					// Only a single match is needed for html type since it is
					// bottom of the pile and very similar to string - but it
					// must not be empty
					if ( detectedType === 'html' && ! _empty(cache[k]) ) {
						break;
					}
				}

				// Type is valid for all data points in the column - use this
				// type
				if ( (oneOf && one && detectedType) || (!oneOf && detectedType) ) {
					col.sType = detectedType;
					break;
				}
			}

			// Fall back - if no type was detected, always use string
			if ( ! col.sType ) {
				col.sType = 'string';
			}
		}

		// Set class names for header / footer for auto type classes
		var autoClass = _ext.type.className[col.sType];

		if (autoClass) {
			_columnAutoClass(settings.aoHeader, i, autoClass);
			_columnAutoClass(settings.aoFooter, i, autoClass);
		}

		var renderer = _ext.type.render[col.sType];

		// This can only happen once! There is no way to remove
		// a renderer. After the first time the renderer has
		// already been set so createTr will run the renderer itself.
		if (renderer && ! col._render) {
			col._render = DataTable.util.get(renderer);

			_columnAutoRender(settings, i);
		}
	}
}

/**
 * Apply an auto detected renderer to data which doesn't yet have
 * a renderer
 */
function _columnAutoRender(settings, colIdx) {
	var data = settings.aoData;

	for (var i=0 ; i<data.length ; i++) {
		if (data[i].nTr) {
			// We have to update the display here since there is no
			// invalidation check for the data
			var display = _fnGetCellData( settings, i, colIdx, 'display' );

			data[i].displayData[colIdx] = display;
			_fnWriteCell(data[i].anCells[colIdx], display);

			// No need to update sort / filter data since it has
			// been invalidated and will be re-read with the
			// renderer now applied
		}
	}
}

/**
 * Apply a class name to a column's header cells
 */
function _columnAutoClass(container, colIdx, className) {
	container.forEach(function (row) {
		if (row[colIdx] && row[colIdx].unique) {
			_addClass(row[colIdx].cell, className);
		}
	});
}

/**
 * Take the column definitions and static columns arrays and calculate how
 * they relate to column indexes. The callback function will then apply the
 * definition found for a column to a suitable configuration object.
 *  @param {object} oSettings dataTables settings object
 *  @param {array} aoColDefs The aoColumnDefs array that is to be applied
 *  @param {array} aoCols The aoColumns array that defines columns individually
 *  @param {array} headerLayout Layout for header as it was loaded
 *  @param {function} fn Callback function - takes two parameters, the calculated
 *    column index and the definition for that column.
 *  @memberof DataTable#oApi
 */
function _fnApplyColumnDefs( oSettings, aoColDefs, aoCols, headerLayout, fn )
{
	var i, iLen, j, jLen, k, kLen, def;
	var columns = oSettings.aoColumns;

	if ( aoCols ) {
		for ( i=0, iLen=aoCols.length ; i<iLen ; i++ ) {
			if (aoCols[i] && aoCols[i].name) {
				columns[i].sName = aoCols[i].name;
			}
		}
	}

	// Column definitions with aTargets
	if ( aoColDefs )
	{
		/* Loop over the definitions array - loop in reverse so first instance has priority */
		for ( i=aoColDefs.length-1 ; i>=0 ; i-- )
		{
			def = aoColDefs[i];

			/* Each definition can target multiple columns, as it is an array */
			var aTargets = def.target !== undefined
				? def.target
				: def.targets !== undefined
					? def.targets
					: def.aTargets;

			if ( ! Array.isArray( aTargets ) )
			{
				aTargets = [ aTargets ];
			}

			for ( j=0, jLen=aTargets.length ; j<jLen ; j++ )
			{
				var target = aTargets[j];

				if ( typeof target === 'number' && target >= 0 )
				{
					/* Add columns that we don't yet know about */
					while( columns.length <= target )
					{
						_fnAddColumn( oSettings );
					}

					/* Integer, basic index */
					fn( target, def );
				}
				else if ( typeof target === 'number' && target < 0 )
				{
					/* Negative integer, right to left column counting */
					fn( columns.length+target, def );
				}
				else if ( typeof target === 'string' )
				{
					for ( k=0, kLen=columns.length ; k<kLen ; k++ ) {
						if (target === '_all') {
							// Apply to all columns
							fn( k, def );
						}
						else if (target.indexOf(':name') !== -1) {
							// Column selector
							if (columns[k].sName === target.replace(':name', '')) {
								fn( k, def );
							}
						}
						else {
							// Cell selector
							headerLayout.forEach(function (row) {
								if (row[k]) {
									var cell = $(row[k].cell);

									// Legacy support. Note that it means that we don't support
									// an element name selector only, since they are treated as
									// class names for 1.x compat.
									if (target.match(/^[a-z][\w-]*$/i)) {
										target = '.' + target;
									}

									if (cell.is( target )) {
										fn( k, def );
									}
								}
							});
						}
					}
				}
			}
		}
	}

	// Statically defined columns array
	if ( aoCols ) {
		for ( i=0, iLen=aoCols.length ; i<iLen ; i++ ) {
			fn( i, aoCols[i] );
		}
	}
}


/**
 * Get the width for a given set of columns
 *
 * @param {*} settings DataTables settings object
 * @param {*} targets Columns - comma separated string or array of numbers
 * @param {*} original Use the original width (true) or calculated (false)
 * @param {*} incVisible Include visible columns (true) or not (false)
 * @returns Combined CSS value
 */
function _fnColumnsSumWidth( settings, targets, original, incVisible ) {
	if ( ! Array.isArray( targets ) ) {
		targets = _fnColumnsFromHeader( targets );
	}

	var sum = 0;
	var unit;
	var columns = settings.aoColumns;
	
	for ( var i=0, ien=targets.length ; i<ien ; i++ ) {
		var column = columns[ targets[i] ];
		var definedWidth = original ?
			column.sWidthOrig :
			column.sWidth;

		if ( ! incVisible && column.bVisible === false ) {
			continue;
		}

		if ( definedWidth === null || definedWidth === undefined ) {
			return null; // can't determine a defined width - browser defined
		}
		else if ( typeof definedWidth === 'number' ) {
			unit = 'px';
			sum += definedWidth;
		}
		else {
			var matched = definedWidth.match(/([\d\.]+)([^\d]*)/);

			if ( matched ) {
				sum += matched[1] * 1;
				unit = matched.length === 3 ?
					matched[2] :
					'px';
			}
		}
	}

	return sum + unit;
}

function _fnColumnsFromHeader( cell )
{
	var attr = $(cell).closest('[data-dt-column]').attr('data-dt-column');

	if ( ! attr ) {
		return [];
	}

	return attr.split(',').map( function (val) {
		return val * 1;
	} );
}
/**
 * Add a data array to the table, creating DOM node etc. This is the parallel to
 * _fnGatherData, but for adding rows from a Javascript source, rather than a
 * DOM source.
 *  @param {object} settings dataTables settings object
 *  @param {array} data data array to be added
 *  @param {node} [tr] TR element to add to the table - optional. If not given,
 *    DataTables will create a row automatically
 *  @param {array} [tds] Array of TD|TH elements for the row - must be given
 *    if nTr is.
 *  @returns {int} >=0 if successful (index of new aoData entry), -1 if failed
 *  @memberof DataTable#oApi
 */
function _fnAddData ( settings, dataIn, tr, tds )
{
	/* Create the object for storing information about this new row */
	var rowIdx = settings.aoData.length;
	var rowModel = $.extend( true, {}, DataTable.models.oRow, {
		src: tr ? 'dom' : 'data',
		idx: rowIdx
	} );

	rowModel._aData = dataIn;
	settings.aoData.push( rowModel );

	var columns = settings.aoColumns;

	for ( var i=0, iLen=columns.length ; i<iLen ; i++ )
	{
		// Invalidate the column types as the new data needs to be revalidated
		columns[i].sType = null;
	}

	/* Add to the display array */
	settings.aiDisplayMaster.push( rowIdx );

	var id = settings.rowIdFn( dataIn );
	if ( id !== undefined ) {
		settings.aIds[ id ] = rowModel;
	}

	/* Create the DOM information, or register it if already present */
	if ( tr || ! settings.oFeatures.bDeferRender )
	{
		_fnCreateTr( settings, rowIdx, tr, tds );
	}

	return rowIdx;
}


/**
 * Add one or more TR elements to the table. Generally we'd expect to
 * use this for reading data from a DOM sourced table, but it could be
 * used for an TR element. Note that if a TR is given, it is used (i.e.
 * it is not cloned).
 *  @param {object} settings dataTables settings object
 *  @param {array|node|jQuery} trs The TR element(s) to add to the table
 *  @returns {array} Array of indexes for the added rows
 *  @memberof DataTable#oApi
 */
function _fnAddTr( settings, trs )
{
	var row;

	// Allow an individual node to be passed in
	if ( ! (trs instanceof $) ) {
		trs = $(trs);
	}

	return trs.map( function (i, el) {
		row = _fnGetRowElements( settings, el );
		return _fnAddData( settings, row.data, el, row.cells );
	} );
}


/**
 * Get the data for a given cell from the internal cache, taking into account data mapping
 *  @param {object} settings dataTables settings object
 *  @param {int} rowIdx aoData row id
 *  @param {int} colIdx Column index
 *  @param {string} type data get type ('display', 'type' 'filter|search' 'sort|order')
 *  @returns {*} Cell data
 *  @memberof DataTable#oApi
 */
function _fnGetCellData( settings, rowIdx, colIdx, type )
{
	if (type === 'search') {
		type = 'filter';
	}
	else if (type === 'order') {
		type = 'sort';
	}

	var row = settings.aoData[rowIdx];

	if (! row) {
		return undefined;
	}

	var draw           = settings.iDraw;
	var col            = settings.aoColumns[colIdx];
	var rowData        = row._aData;
	var defaultContent = col.sDefaultContent;
	var cellData       = col.fnGetData( rowData, type, {
		settings: settings,
		row:      rowIdx,
		col:      colIdx
	} );

	// Allow for a node being returned for non-display types
	if (type !== 'display' && cellData && typeof cellData === 'object' && cellData.nodeName) {
		cellData = cellData.innerHTML;
	}

	if ( cellData === undefined ) {
		if ( settings.iDrawError != draw && defaultContent === null ) {
			_fnLog( settings, 0, "Requested unknown parameter "+
				(typeof col.mData=='function' ? '{function}' : "'"+col.mData+"'")+
				" for row "+rowIdx+", column "+colIdx, 4 );
			settings.iDrawError = draw;
		}
		return defaultContent;
	}

	// When the data source is null and a specific data type is requested (i.e.
	// not the original data), we can use default column data
	if ( (cellData === rowData || cellData === null) && defaultContent !== null && type !== undefined ) {
		cellData = defaultContent;
	}
	else if ( typeof cellData === 'function' ) {
		// If the data source is a function, then we run it and use the return,
		// executing in the scope of the data object (for instances)
		return cellData.call( rowData );
	}

	if ( cellData === null && type === 'display' ) {
		return '';
	}

	if ( type === 'filter' ) {
		var fomatters = DataTable.ext.type.search;

		if ( fomatters[ col.sType ] ) {
			cellData = fomatters[ col.sType ]( cellData );
		}
	}

	return cellData;
}


/**
 * Set the value for a specific cell, into the internal data cache
 *  @param {object} settings dataTables settings object
 *  @param {int} rowIdx aoData row id
 *  @param {int} colIdx Column index
 *  @param {*} val Value to set
 *  @memberof DataTable#oApi
 */
function _fnSetCellData( settings, rowIdx, colIdx, val )
{
	var col     = settings.aoColumns[colIdx];
	var rowData = settings.aoData[rowIdx]._aData;

	col.fnSetData( rowData, val, {
		settings: settings,
		row:      rowIdx,
		col:      colIdx
	}  );
}

/**
 * Write a value to a cell
 * @param {*} td Cell
 * @param {*} val Value
 */
function _fnWriteCell(td, val)
{
	if (val && typeof val === 'object' && val.nodeName) {
		$(td)
			.empty()
			.append(val);
	}
	else {
		td.innerHTML = val;
	}
}


// Private variable that is used to match action syntax in the data property object
var __reArray = /\[.*?\]$/;
var __reFn = /\(\)$/;

/**
 * Split string on periods, taking into account escaped periods
 * @param  {string} str String to split
 * @return {array} Split string
 */
function _fnSplitObjNotation( str )
{
	var parts = str.match(/(\\.|[^.])+/g) || [''];

	return parts.map( function ( s ) {
		return s.replace(/\\\./g, '.');
	} );
}


/**
 * Return a function that can be used to get data from a source object, taking
 * into account the ability to use nested objects as a source
 *  @param {string|int|function} mSource The data source for the object
 *  @returns {function} Data get function
 *  @memberof DataTable#oApi
 */
var _fnGetObjectDataFn = DataTable.util.get;


/**
 * Return a function that can be used to set data from a source object, taking
 * into account the ability to use nested objects as a source
 *  @param {string|int|function} mSource The data source for the object
 *  @returns {function} Data set function
 *  @memberof DataTable#oApi
 */
var _fnSetObjectDataFn = DataTable.util.set;


/**
 * Return an array with the full table data
 *  @param {object} oSettings dataTables settings object
 *  @returns array {array} aData Master data array
 *  @memberof DataTable#oApi
 */
function _fnGetDataMaster ( settings )
{
	return _pluck( settings.aoData, '_aData' );
}


/**
 * Nuke the table
 *  @param {object} oSettings dataTables settings object
 *  @memberof DataTable#oApi
 */
function _fnClearTable( settings )
{
	settings.aoData.length = 0;
	settings.aiDisplayMaster.length = 0;
	settings.aiDisplay.length = 0;
	settings.aIds = {};
}


/**
 * Mark cached data as invalid such that a re-read of the data will occur when
 * the cached data is next requested. Also update from the data source object.
 *
 * @param {object} settings DataTables settings object
 * @param {int}    rowIdx   Row index to invalidate
 * @param {string} [src]    Source to invalidate from: undefined, 'auto', 'dom'
 *     or 'data'
 * @param {int}    [colIdx] Column index to invalidate. If undefined the whole
 *     row will be invalidated
 * @memberof DataTable#oApi
 *
 * @todo For the modularisation of v1.11 this will need to become a callback, so
 *   the sort and filter methods can subscribe to it. That will required
 *   initialisation options for sorting, which is why it is not already baked in
 */
function _fnInvalidate( settings, rowIdx, src, colIdx )
{
	var row = settings.aoData[ rowIdx ];
	var i, ien;

	// Remove the cached data for the row
	row._aSortData = null;
	row._aFilterData = null;
	row.displayData = null;

	// Are we reading last data from DOM or the data object?
	if ( src === 'dom' || ((! src || src === 'auto') && row.src === 'dom') ) {
		// Read the data from the DOM
		row._aData = _fnGetRowElements(
				settings, row, colIdx, colIdx === undefined ? undefined : row._aData
			)
			.data;
	}
	else {
		// Reading from data object, update the DOM
		var cells = row.anCells;
		var display = _fnGetRowDisplay(settings, rowIdx);

		if ( cells ) {
			if ( colIdx !== undefined ) {
				_fnWriteCell(cells[colIdx], display[colIdx]);
			}
			else {
				for ( i=0, ien=cells.length ; i<ien ; i++ ) {
					_fnWriteCell(cells[i], display[i]);
				}
			}
		}
	}

	// Column specific invalidation
	var cols = settings.aoColumns;
	if ( colIdx !== undefined ) {
		// Type - the data might have changed
		cols[ colIdx ].sType = null;

		// Max length string. Its a fairly cheep recalculation, so not worth
		// something more complicated
		cols[ colIdx ].maxLenString = null;
	}
	else {
		for ( i=0, ien=cols.length ; i<ien ; i++ ) {
			cols[i].sType = null;
			cols[i].maxLenString = null;
		}

		// Update DataTables special `DT_*` attributes for the row
		_fnRowAttributes( settings, row );
	}
}


/**
 * Build a data source object from an HTML row, reading the contents of the
 * cells that are in the row.
 *
 * @param {object} settings DataTables settings object
 * @param {node|object} TR element from which to read data or existing row
 *   object from which to re-read the data from the cells
 * @param {int} [colIdx] Optional column index
 * @param {array|object} [d] Data source object. If `colIdx` is given then this
 *   parameter should also be given and will be used to write the data into.
 *   Only the column in question will be written
 * @returns {object} Object with two parameters: `data` the data read, in
 *   document order, and `cells` and array of nodes (they can be useful to the
 *   caller, so rather than needing a second traversal to get them, just return
 *   them from here).
 * @memberof DataTable#oApi
 */
function _fnGetRowElements( settings, row, colIdx, d )
{
	var
		tds = [],
		td = row.firstChild,
		name, col, i=0, contents,
		columns = settings.aoColumns,
		objectRead = settings._rowReadObject;

	// Allow the data object to be passed in, or construct
	d = d !== undefined ?
		d :
		objectRead ?
			{} :
			[];

	var attr = function ( str, td  ) {
		if ( typeof str === 'string' ) {
			var idx = str.indexOf('@');

			if ( idx !== -1 ) {
				var attr = str.substring( idx+1 );
				var setter = _fnSetObjectDataFn( str );
				setter( d, td.getAttribute( attr ) );
			}
		}
	};

	// Read data from a cell and store into the data object
	var cellProcess = function ( cell ) {
		if ( colIdx === undefined || colIdx === i ) {
			col = columns[i];
			contents = (cell.innerHTML).trim();

			if ( col && col._bAttrSrc ) {
				var setter = _fnSetObjectDataFn( col.mData._ );
				setter( d, contents );

				attr( col.mData.sort, cell );
				attr( col.mData.type, cell );
				attr( col.mData.filter, cell );
			}
			else {
				// Depending on the `data` option for the columns the data can
				// be read to either an object or an array.
				if ( objectRead ) {
					if ( ! col._setter ) {
						// Cache the setter function
						col._setter = _fnSetObjectDataFn( col.mData );
					}
					col._setter( d, contents );
				}
				else {
					d[i] = contents;
				}
			}
		}

		i++;
	};

	if ( td ) {
		// `tr` element was passed in
		while ( td ) {
			name = td.nodeName.toUpperCase();

			if ( name == "TD" || name == "TH" ) {
				cellProcess( td );
				tds.push( td );
			}

			td = td.nextSibling;
		}
	}
	else {
		// Existing row object passed in
		tds = row.anCells;

		for ( var j=0, jen=tds.length ; j<jen ; j++ ) {
			cellProcess( tds[j] );
		}
	}

	// Read the ID from the DOM if present
	var rowNode = row.firstChild ? row : row.nTr;

	if ( rowNode ) {
		var id = rowNode.getAttribute( 'id' );

		if ( id ) {
			_fnSetObjectDataFn( settings.rowId )( d, id );
		}
	}

	return {
		data: d,
		cells: tds
	};
}

/**
 * Render and cache a row's display data for the columns, if required
 * @returns 
 */
function _fnGetRowDisplay (settings, rowIdx) {
	var rowModal = settings.aoData[rowIdx];
	var columns = settings.aoColumns;

	if (! rowModal.displayData) {
		// Need to render and cache
		rowModal.displayData = [];
	
		for ( var colIdx=0, len=columns.length ; colIdx<len ; colIdx++ ) {
			rowModal.displayData.push(
				_fnGetCellData( settings, rowIdx, colIdx, 'display' )
			);
		}
	}

	return rowModal.displayData;
}

/**
 * Create a new TR element (and it's TD children) for a row
 *  @param {object} oSettings dataTables settings object
 *  @param {int} iRow Row to consider
 *  @param {node} [nTrIn] TR element to add to the table - optional. If not given,
 *    DataTables will create a row automatically
 *  @param {array} [anTds] Array of TD|TH elements for the row - must be given
 *    if nTr is.
 *  @memberof DataTable#oApi
 */
function _fnCreateTr ( oSettings, iRow, nTrIn, anTds )
{
	var
		row = oSettings.aoData[iRow],
		rowData = row._aData,
		cells = [],
		nTr, nTd, oCol,
		i, iLen, create,
		trClass = oSettings.oClasses.tbody.row;

	if ( row.nTr === null )
	{
		nTr = nTrIn || document.createElement('tr');

		row.nTr = nTr;
		row.anCells = cells;

		_addClass(nTr, trClass);

		/* Use a private property on the node to allow reserve mapping from the node
		 * to the aoData array for fast look up
		 */
		nTr._DT_RowIndex = iRow;

		/* Special parameters can be given by the data source to be used on the row */
		_fnRowAttributes( oSettings, row );

		/* Process each column */
		for ( i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
		{
			oCol = oSettings.aoColumns[i];
			create = nTrIn && anTds[i] ? false : true;

			nTd = create ? document.createElement( oCol.sCellType ) : anTds[i];

			if (! nTd) {
				_fnLog( oSettings, 0, 'Incorrect column count', 18 );
			}

			nTd._DT_CellIndex = {
				row: iRow,
				column: i
			};
			
			cells.push( nTd );
			
			var display = _fnGetRowDisplay(oSettings, iRow);

			// Need to create the HTML if new, or if a rendering function is defined
			if (
				create ||
				(
					(oCol.mRender || oCol.mData !== i) &&
					(!$.isPlainObject(oCol.mData) || oCol.mData._ !== i+'.display')
				)
			) {
				_fnWriteCell(nTd, display[i]);
			}

			// column class
			_addClass(nTd, oCol.sClass);

			// Visibility - add or remove as required
			if ( oCol.bVisible && create )
			{
				nTr.appendChild( nTd );
			}
			else if ( ! oCol.bVisible && ! create )
			{
				nTd.parentNode.removeChild( nTd );
			}

			if ( oCol.fnCreatedCell )
			{
				oCol.fnCreatedCell.call( oSettings.oInstance,
					nTd, _fnGetCellData( oSettings, iRow, i ), rowData, iRow, i
				);
			}
		}

		_fnCallbackFire( oSettings, 'aoRowCreatedCallback', 'row-created', [nTr, rowData, iRow, cells] );
	}
	else {
		_addClass(row.nTr, trClass);
	}
}


/**
 * Add attributes to a row based on the special `DT_*` parameters in a data
 * source object.
 *  @param {object} settings DataTables settings object
 *  @param {object} DataTables row object for the row to be modified
 *  @memberof DataTable#oApi
 */
function _fnRowAttributes( settings, row )
{
	var tr = row.nTr;
	var data = row._aData;

	if ( tr ) {
		var id = settings.rowIdFn( data );

		if ( id ) {
			tr.id = id;
		}

		if ( data.DT_RowClass ) {
			// Remove any classes added by DT_RowClass before
			var a = data.DT_RowClass.split(' ');
			row.__rowc = row.__rowc ?
				_unique( row.__rowc.concat( a ) ) :
				a;

			$(tr)
				.removeClass( row.__rowc.join(' ') )
				.addClass( data.DT_RowClass );
		}

		if ( data.DT_RowAttr ) {
			$(tr).attr( data.DT_RowAttr );
		}

		if ( data.DT_RowData ) {
			$(tr).data( data.DT_RowData );
		}
	}
}


/**
 * Create the HTML header for the table
 *  @param {object} oSettings dataTables settings object
 *  @memberof DataTable#oApi
 */
function _fnBuildHead( settings, side )
{
	var classes = settings.oClasses;
	var columns = settings.aoColumns;
	var i, ien, row;
	var target = side === 'header'
		? settings.nTHead
		: settings.nTFoot;
	var titleProp = side === 'header' ? 'sTitle' : side;

	// Footer might be defined
	if (! target) {
		return;
	}

	// If no cells yet and we have content for them, then create
	if (side === 'header' || _pluck(settings.aoColumns, titleProp).join('')) {
		row = $('tr', target);

		// Add a row if needed
		if (! row.length) {
			row = $('<tr/>').appendTo(target)
		}

		// Add the number of cells needed to make up to the number of columns
		if (row.length === 1) {
			var cellCount = 0;
			
			$('td, th', row).each(function () {
				cellCount += this.colSpan;
			});

			for ( i=cellCount, ien=columns.length ; i<ien ; i++ ) {
				$('<th/>')
					.html( columns[i][titleProp] || '' )
					.appendTo( row );
			}
		}
	}

	var detected = _fnDetectHeader( settings, target, true );

	if (side === 'header') {
		settings.aoHeader = detected;
		$('tr', target).addClass(classes.thead.row);
	}
	else {
		settings.aoFooter = detected;
		$('tr', target).addClass(classes.tfoot.row);
	}

	// Every cell needs to be passed through the renderer
	$(target).children('tr').children('th, td')
		.each( function () {
			_fnRenderer( settings, side )(
				settings, $(this), classes
			);
		} );
}

/**
 * Build a layout structure for a header or footer
 *
 * @param {*} settings DataTables settings
 * @param {*} source Source layout array
 * @param {*} incColumns What columns should be included
 * @returns Layout array in column index order
 */
function _fnHeaderLayout( settings, source, incColumns )
{
	var row, column, cell;
	var local = [];
	var structure = [];
	var columns = settings.aoColumns;
	var columnCount = columns.length;
	var rowspan, colspan;

	if ( ! source ) {
		return;
	}

	// Default is to work on only visible columns
	if ( ! incColumns ) {
		incColumns = _range(columnCount)
			.filter(function (idx) {
				return columns[idx].bVisible;
			});
	}

	// Make a copy of the master layout array, but with only the columns we want
	for ( row=0 ; row<source.length ; row++ ) {
		// Remove any columns we haven't selected
		local[row] = source[row].slice().filter(function (cell, i) {
			return incColumns.includes(i);
		});

		// Prep the structure array - it needs an element for each row
		structure.push( [] );
	}

	for ( row=0 ; row<local.length ; row++ ) {
		for ( column=0 ; column<local[row].length ; column++ ) {
			rowspan = 1;
			colspan = 1;

			// Check to see if there is already a cell (row/colspan) covering our target
			// insert point. If there is, then there is nothing to do.
			if ( structure[row][column] === undefined ) {
				cell = local[row][column].cell;

				// Expand for rowspan
				while (
					local[row+rowspan] !== undefined &&
					local[row][column].cell == local[row+rowspan][column].cell
				) {
					structure[row+rowspan][column] = null;
					rowspan++;
				}

				// And for colspan
				while (
					local[row][column+colspan] !== undefined &&
					local[row][column].cell == local[row][column+colspan].cell
				) {
					// Which also needs to go over rows
					for ( var k=0 ; k<rowspan ; k++ ) {
						structure[row+k][column+colspan] = null;
					}

					colspan++;
				}

				var titleSpan = $('span.dt-column-title', cell);

				structure[row][column] = {
					cell: cell,
					colspan: colspan,
					rowspan: rowspan,
					title: titleSpan.length
						? titleSpan.html()
						: $(cell).html()
				};
			}
		}
	}

	return structure;
}


/**
 * Draw the header (or footer) element based on the column visibility states.
 *
 *  @param object oSettings dataTables settings object
 *  @param array aoSource Layout array from _fnDetectHeader
 *  @memberof DataTable#oApi
 */
function _fnDrawHead( settings, source )
{
	var layout = _fnHeaderLayout(settings, source);
	var tr, n;

	for ( var row=0 ; row<source.length ; row++ ) {
		tr = source[row].row;

		// All cells are going to be replaced, so empty out the row
		// Can't use $().empty() as that kills event handlers
		if (tr) {
			while( (n = tr.firstChild) ) {
				tr.removeChild( n );
			}
		}

		for ( var column=0 ; column<layout[row].length ; column++ ) {
			var point = layout[row][column];

			if (point) {
				$(point.cell)
					.appendTo(tr)
					.attr('rowspan', point.rowspan)
					.attr('colspan', point.colspan);
			}
		}
	}
}


/**
 * Insert the required TR nodes into the table for display
 *  @param {object} oSettings dataTables settings object
 *  @param ajaxComplete true after ajax call to complete rendering
 *  @memberof DataTable#oApi
 */
function _fnDraw( oSettings, ajaxComplete )
{
	// Allow for state saving and a custom start position
	_fnStart( oSettings );

	/* Provide a pre-callback function which can be used to cancel the draw is false is returned */
	var aPreDraw = _fnCallbackFire( oSettings, 'aoPreDrawCallback', 'preDraw', [oSettings] );
	if ( aPreDraw.indexOf(false) !== -1 )
	{
		_fnProcessingDisplay( oSettings, false );
		return;
	}

	var anRows = [];
	var iRowCount = 0;
	var bServerSide = _fnDataSource( oSettings ) == 'ssp';
	var aiDisplay = oSettings.aiDisplay;
	var iDisplayStart = oSettings._iDisplayStart;
	var iDisplayEnd = oSettings.fnDisplayEnd();
	var columns = oSettings.aoColumns;
	var body = $(oSettings.nTBody);

	oSettings.bDrawing = true;

	/* Server-side processing draw intercept */
	if ( oSettings.deferLoading )
	{
		oSettings.deferLoading = false;
		oSettings.iDraw++;
		_fnProcessingDisplay( oSettings, false );
	}
	else if ( !bServerSide )
	{
		oSettings.iDraw++;
	}
	else if ( !oSettings.bDestroying && !ajaxComplete)
	{
		// Show loading message for server-side processing
		if (oSettings.iDraw === 0) {
			body.empty().append(_emptyRow(oSettings));
		}

		_fnAjaxUpdate( oSettings );
		return;
	}

	if ( aiDisplay.length !== 0 )
	{
		var iStart = bServerSide ? 0 : iDisplayStart;
		var iEnd = bServerSide ? oSettings.aoData.length : iDisplayEnd;

		for ( var j=iStart ; j<iEnd ; j++ )
		{
			var iDataIndex = aiDisplay[j];
			var aoData = oSettings.aoData[ iDataIndex ];
			if ( aoData.nTr === null )
			{
				_fnCreateTr( oSettings, iDataIndex );
			}

			var nRow = aoData.nTr;

			// Add various classes as needed
			for (var i=0 ; i<columns.length ; i++) {
				var col = columns[i];
				var td = aoData.anCells[i];

				_addClass(td, _ext.type.className[col.sType]); // auto class
				_addClass(td, oSettings.oClasses.tbody.cell); // all cells
			}

			// Row callback functions - might want to manipulate the row
			// iRowCount and j are not currently documented. Are they at all
			// useful?
			_fnCallbackFire( oSettings, 'aoRowCallback', null,
				[nRow, aoData._aData, iRowCount, j, iDataIndex] );

			anRows.push( nRow );
			iRowCount++;
		}
	}
	else
	{
		anRows[ 0 ] = _emptyRow(oSettings);
	}

	/* Header and footer callbacks */
	_fnCallbackFire( oSettings, 'aoHeaderCallback', 'header', [ $(oSettings.nTHead).children('tr')[0],
		_fnGetDataMaster( oSettings ), iDisplayStart, iDisplayEnd, aiDisplay ] );

	_fnCallbackFire( oSettings, 'aoFooterCallback', 'footer', [ $(oSettings.nTFoot).children('tr')[0],
		_fnGetDataMaster( oSettings ), iDisplayStart, iDisplayEnd, aiDisplay ] );

	// replaceChildren is faster, but only became widespread in 2020,
	// so a fall back in jQuery is provided for older browsers.
	if (body[0].replaceChildren) {
		body[0].replaceChildren.apply(body[0], anRows);
	}
	else {
		body.children().detach();
		body.append( $(anRows) );
	}

	// Empty table needs a specific class
	$(oSettings.nTableWrapper).toggleClass('dt-empty-footer', $('tr', oSettings.nTFoot).length === 0);

	/* Call all required callback functions for the end of a draw */
	_fnCallbackFire( oSettings, 'aoDrawCallback', 'draw', [oSettings], true );

	/* Draw is complete, sorting and filtering must be as well */
	oSettings.bSorted = false;
	oSettings.bFiltered = false;
	oSettings.bDrawing = false;
}


/**
 * Redraw the table - taking account of the various features which are enabled
 *  @param {object} oSettings dataTables settings object
 *  @param {boolean} [holdPosition] Keep the current paging position. By default
 *    the paging is reset to the first page
 *  @memberof DataTable#oApi
 */
function _fnReDraw( settings, holdPosition, recompute )
{
	var
		features = settings.oFeatures,
		sort     = features.bSort,
		filter   = features.bFilter;

	if (recompute === undefined || recompute === true) {
		// Resolve any column types that are unknown due to addition or invalidation
		_fnColumnTypes( settings );

		if ( sort ) {
			_fnSort( settings );
		}

		if ( filter ) {
			_fnFilterComplete( settings, settings.oPreviousSearch );
		}
		else {
			// No filtering, so we want to just use the display master
			settings.aiDisplay = settings.aiDisplayMaster.slice();
		}
	}

	if ( holdPosition !== true ) {
		settings._iDisplayStart = 0;
	}

	// Let any modules know about the draw hold position state (used by
	// scrolling internally)
	settings._drawHold = holdPosition;

	_fnDraw( settings );

	settings.api.one('draw', function () {
		settings._drawHold = false;
	});
}


/*
 * Table is empty - create a row with an empty message in it
 */
function _emptyRow ( settings ) {
	var oLang = settings.oLanguage;
	var zero = oLang.sZeroRecords;
	var dataSrc = _fnDataSource( settings );

	// Make use of the fact that settings.json is only set once the initial data has
	// been loaded. Show loading when that isn't the case
	if ((dataSrc === 'ssp' || dataSrc === 'ajax') && ! settings.json) {
		zero = oLang.sLoadingRecords;
	}
	else if ( oLang.sEmptyTable && settings.fnRecordsTotal() === 0 )
	{
		zero = oLang.sEmptyTable;
	}

	return $( '<tr/>' )
		.append( $('<td />', {
			'colSpan': _fnVisbleColumns( settings ),
			'class':   settings.oClasses.empty.row
		} ).html( zero ) )[0];
}


/**
 * Expand the layout items into an object for the rendering function
 */
function _layoutItems (row, align, items) {
	if ( Array.isArray(items)) {
		for (var i=0 ; i<items.length ; i++) {
			_layoutItems(row, align, items[i]);
		}

		return;
	}

	var rowCell = row[align];

	// If it is an object, then there can be multiple features contained in it
	if ( $.isPlainObject( items ) ) {
		// A feature plugin cannot be named "features" due to this check
		if (items.features) {
			if (items.rowId) {
				row.id = items.rowId;
			}
			if (items.rowClass) {
				row.className = items.rowClass;
			}

			rowCell.id = items.id;
			rowCell.className = items.className;

			_layoutItems(row, align, items.features);
		}
		else {
			Object.keys(items).map(function (key) {
				rowCell.contents.push( {
					feature: key,
					opts: items[key]
				});
			});
		}
	}
	else {
		rowCell.contents.push(items);
	}
}

/**
 * Find, or create a layout row
 */
function _layoutGetRow(rows, rowNum, align) {
	var row;

	// Find existing rows
	for (var i=0; i<rows.length; i++) {
		row = rows[i];

		if (row.rowNum === rowNum) {
			// full is on its own, but start and end share a row
			if (
				(align === 'full' && row.full) ||
				((align === 'start' || align === 'end') && (row.start || row.end))
			) {
				if (! row[align]) {
					row[align] = {
						contents: []
					};
				}

				return row;
			}
		}
	}

	// If we get this far, then there was no match, create a new row
	row = {
		rowNum: rowNum	
	};

	row[align] = {
		contents: []
	};

	rows.push(row);

	return row;
}

/**
 * Convert a `layout` object given by a user to the object structure needed
 * for the renderer. This is done twice, once for above and once for below
 * the table. Ordering must also be considered.
 *
 * @param {*} settings DataTables settings object
 * @param {*} layout Layout object to convert
 * @param {string} side `top` or `bottom`
 * @returns Converted array structure - one item for each row.
 */
function _layoutArray ( settings, layout, side ) {
	var rows = [];
	
	// Split out into an array
	$.each( layout, function ( pos, items ) {
		if (items === null) {
			return;
		}

		var parts = pos.match(/^([a-z]+)([0-9]*)([A-Za-z]*)$/);
		var rowNum = parts[2]
			? parts[2] * 1
			: 0;
		var align = parts[3]
			? parts[3].toLowerCase()
			: 'full';

		// Filter out the side we aren't interested in
		if (parts[1] !== side) {
			return;
		}

		// Get or create the row we should attach to
		var row = _layoutGetRow(rows, rowNum, align);

		_layoutItems(row, align, items);
	});

	// Order by item identifier
	rows.sort( function ( a, b ) {
		var order1 = a.rowNum;
		var order2 = b.rowNum;

		// If both in the same row, then the row with `full` comes first
		if (order1 === order2) {
			var ret = a.full && ! b.full ? -1 : 1;

			return side === 'bottom'
				? ret * -1
				: ret;
		}

		return order2 - order1;
	} );

	// Invert for below the table
	if ( side === 'bottom' ) {
		rows.reverse();
	}

	for (var row = 0; row<rows.length; row++) {
		delete rows[row].rowNum;

		_layoutResolve(settings, rows[row]);
	}

	return rows;
}


/**
 * Convert the contents of a row's layout object to nodes that can be inserted
 * into the document by a renderer. Execute functions, look up plug-ins, etc.
 *
 * @param {*} settings DataTables settings object
 * @param {*} row Layout object for this row
 */
function _layoutResolve( settings, row ) {
	var getFeature = function (feature, opts) {
		if ( ! _ext.features[ feature ] ) {
			_fnLog( settings, 0, 'Unknown feature: '+ feature );
		}

		return _ext.features[ feature ].apply( this, [settings, opts] );
	};

	var resolve = function ( item ) {
		if (! row[ item ]) {
			return;
		}

		var line = row[ item ].contents;

		for ( var i=0, ien=line.length ; i<ien ; i++ ) {
			if ( ! line[i] ) {
				continue;
			}
			else if ( typeof line[i] === 'string' ) {
				line[i] = getFeature( line[i], null );
			}
			else if ( $.isPlainObject(line[i]) ) {
				// If it's an object, it just has feature and opts properties from
				// the transform in _layoutArray
				line[i] = getFeature(line[i].feature, line[i].opts);
			}
			else if ( typeof line[i].node === 'function' ) {
				line[i] = line[i].node( settings );
			}
			else if ( typeof line[i] === 'function' ) {
				var inst = line[i]( settings );

				line[i] = typeof inst.node === 'function' ?
					inst.node() :
					inst;
			}
		}
	};

	resolve('start');
	resolve('end');
	resolve('full');
}


/**
 * Add the options to the page HTML for the table
 *  @param {object} settings DataTables settings object
 *  @memberof DataTable#oApi
 */
function _fnAddOptionsHtml ( settings )
{
	var classes = settings.oClasses;
	var table = $(settings.nTable);

	// Wrapper div around everything DataTables controls
	var insert = $('<div/>')
		.attr({
			id:      settings.sTableId+'_wrapper',
			'class': classes.container
		})
		.insertBefore(table);

	settings.nTableWrapper = insert[0];

	if (settings.sDom) {
		// Legacy
		_fnLayoutDom(settings, settings.sDom, insert);
	}
	else {
		var top = _layoutArray( settings, settings.layout, 'top' );
		var bottom = _layoutArray( settings, settings.layout, 'bottom' );
		var renderer = _fnRenderer( settings, 'layout' );
	
		// Everything above - the renderer will actually insert the contents into the document
		top.forEach(function (item) {
			renderer( settings, insert, item );
		});

		// The table - always the center of attention
		renderer( settings, insert, {
			full: {
				table: true,
				contents: [ _fnFeatureHtmlTable(settings) ]
			}
		} );

		// Everything below
		bottom.forEach(function (item) {
			renderer( settings, insert, item );
		});
	}

	// Processing floats on top, so it isn't an inserted feature
	_processingHtml( settings );
}

/**
 * Draw the table with the legacy DOM property
 * @param {*} settings DT settings object
 * @param {*} dom DOM string
 * @param {*} insert Insert point
 */
function _fnLayoutDom( settings, dom, insert )
{
	var parts = dom.match(/(".*?")|('.*?')|./g);
	var featureNode, option, newNode, next, attr;

	for ( var i=0 ; i<parts.length ; i++ ) {
		featureNode = null;
		option = parts[i];

		if ( option == '<' ) {
			// New container div
			newNode = $('<div/>');

			// Check to see if we should append an id and/or a class name to the container
			next = parts[i+1];

			if ( next[0] == "'" || next[0] == '"' ) {
				attr = next.replace(/['"]/g, '');

				var id = '', className;

				/* The attribute can be in the format of "#id.class", "#id" or "class" This logic
				 * breaks the string into parts and applies them as needed
				 */
				if ( attr.indexOf('.') != -1 ) {
					var split = attr.split('.');

					id = split[0];
					className = split[1];
				}
				else if ( attr[0] == "#" ) {
					id = attr;
				}
				else {
					className = attr;
				}

				newNode
					.attr('id', id.substring(1))
					.addClass(className);

				i++; // Move along the position array
			}

			insert.append( newNode );
			insert = newNode;
		}
		else if ( option == '>' ) {
			// End container div
			insert = insert.parent();
		}
		else if ( option == 't' ) {
			// Table
			featureNode = _fnFeatureHtmlTable( settings );
		}
		else
		{
			DataTable.ext.feature.forEach(function(feature) {
				if ( option == feature.cFeature ) {
					featureNode = feature.fnInit( settings );
				}
			});
		}

		// Add to the display
		if ( featureNode ) {
			insert.append( featureNode );
		}
	}
}


/**
 * Use the DOM source to create up an array of header cells. The idea here is to
 * create a layout grid (array) of rows x columns, which contains a reference
 * to the cell that that point in the grid (regardless of col/rowspan), such that
 * any column / row could be removed and the new grid constructed
 *  @param {node} thead The header/footer element for the table
 *  @returns {array} Calculated layout array
 *  @memberof DataTable#oApi
 */
function _fnDetectHeader ( settings, thead, write )
{
	var columns = settings.aoColumns;
	var rows = $(thead).children('tr');
	var row, cell;
	var i, k, l, iLen, shifted, column, colspan, rowspan;
	var titleRow = settings.titleRow;
	var isHeader = thead && thead.nodeName.toLowerCase() === 'thead';
	var layout = [];
	var unique;
	var shift = function ( a, i, j ) {
		var k = a[i];
		while ( k[j] ) {
			j++;
		}
		return j;
	};

	// We know how many rows there are in the layout - so prep it
	for ( i=0, iLen=rows.length ; i<iLen ; i++ ) {
		layout.push( [] );
	}

	for ( i=0, iLen=rows.length ; i<iLen ; i++ ) {
		row = rows[i];
		column = 0;

		// For every cell in the row..
		cell = row.firstChild;
		while ( cell ) {
			if (
				cell.nodeName.toUpperCase() == 'TD' ||
				cell.nodeName.toUpperCase() == 'TH'
			) {
				var cols = [];
				var jqCell = $(cell);

				// Get the col and rowspan attributes from the DOM and sanitise them
				colspan = cell.getAttribute('colspan') * 1;
				rowspan = cell.getAttribute('rowspan') * 1;
				colspan = (!colspan || colspan===0 || colspan===1) ? 1 : colspan;
				rowspan = (!rowspan || rowspan===0 || rowspan===1) ? 1 : rowspan;

				// There might be colspan cells already in this row, so shift our target
				// accordingly
				shifted = shift( layout, i, column );

				// Cache calculation for unique columns
				unique = colspan === 1 ?
					true :
					false;
				
				// Perform header setup
				if ( write ) {
					if (unique) {
						// Allow column options to be set from HTML attributes
						_fnColumnOptions( settings, shifted, jqCell.data() );
						
						// Get the width for the column. This can be defined from the
						// width attribute, style attribute or `columns.width` option
						var columnDef = columns[shifted];
						var width = cell.getAttribute('width') || null;
						var t = cell.style.width.match(/width:\s*(\d+[pxem%]+)/);
						if ( t ) {
							width = t[1];
						}

						columnDef.sWidthOrig = columnDef.sWidth || width;

						if (isHeader) {
							// Column title handling - can be user set, or read from the DOM
							// This happens before the render, so the original is still in place
							if ( columnDef.sTitle !== null && ! columnDef.autoTitle ) {
								if (
									(titleRow === true && i === 0) || // top row
									(titleRow === false && i === rows.length -1) || // bottom row
									(titleRow === i) || // specific row
									(titleRow === null)
								) {
									cell.innerHTML = columnDef.sTitle;
								}
							}

							if (! columnDef.sTitle && unique) {
								columnDef.sTitle = _stripHtml(cell.innerHTML);
								columnDef.autoTitle = true;
							}
						}
						else {
							// Footer specific operations
							if (columnDef.footer) {
								cell.innerHTML = columnDef.footer;
							}
						}

						// Fall back to the aria-label attribute on the table header if no ariaTitle is
						// provided.
						if (! columnDef.ariaTitle) {
							columnDef.ariaTitle = jqCell.attr("aria-label") || columnDef.sTitle;
						}

						// Column specific class names
						if ( columnDef.className ) {
							jqCell.addClass( columnDef.className );
						}
					}

					// Wrap the column title so we can write to it in future
					if ( $('span.dt-column-title', cell).length === 0) {
						$('<span>')
							.addClass('dt-column-title')
							.append(cell.childNodes)
							.appendTo(cell);
					}

					if (
						settings.orderIndicators &&
						isHeader &&
						jqCell.filter(':not([data-dt-order=disable])').length !== 0 &&
						jqCell.parent(':not([data-dt-order=disable])').length !== 0 &&
						$('span.dt-column-order', cell).length === 0
					) {
						$('<span>')
							.addClass('dt-column-order')
							.appendTo(cell);
					}

					// We need to wrap the elements in the header in another element to use flexbox
					// layout for those elements
					var headerFooter = isHeader ? 'header' : 'footer';

					if ( $('span.dt-column-' + headerFooter, cell).length === 0) {
						$('<div>')
							.addClass('dt-column-' + headerFooter)
							.append(cell.childNodes)
							.appendTo(cell);
					}
				}

				// If there is col / rowspan, copy the information into the layout grid
				for ( l=0 ; l<colspan ; l++ ) {
					for ( k=0 ; k<rowspan ; k++ ) {
						layout[i+k][shifted+l] = {
							cell: cell,
							unique: unique
						};

						layout[i+k].row = row;
					}

					cols.push( shifted+l );
				}

				// Assign an attribute so spanning cells can still be identified
				// as belonging to a column
				cell.setAttribute('data-dt-column', _unique(cols).join(','));
			}

			cell = cell.nextSibling;
		}
	}

	return layout;
}

/**
 * Set the start position for draw
 *  @param {object} oSettings dataTables settings object
 */
function _fnStart( oSettings )
{
	var bServerSide = _fnDataSource( oSettings ) == 'ssp';
	var iInitDisplayStart = oSettings.iInitDisplayStart;

	// Check and see if we have an initial draw position from state saving
	if ( iInitDisplayStart !== undefined && iInitDisplayStart !== -1 )
	{
		oSettings._iDisplayStart = bServerSide ?
			iInitDisplayStart :
			iInitDisplayStart >= oSettings.fnRecordsDisplay() ?
				0 :
				iInitDisplayStart;

		oSettings.iInitDisplayStart = -1;
	}
}

/**
 * Create an Ajax call based on the table's settings, taking into account that
 * parameters can have multiple forms, and backwards compatibility.
 *
 * @param {object} oSettings dataTables settings object
 * @param {array} data Data to send to the server, required by
 *     DataTables - may be augmented by developer callbacks
 * @param {function} fn Callback function to run when data is obtained
 */
function _fnBuildAjax( oSettings, data, fn )
{
	var ajaxData;
	var ajax = oSettings.ajax;
	var instance = oSettings.oInstance;
	var callback = function ( json ) {
		var status = oSettings.jqXHR
			? oSettings.jqXHR.status
			: null;

		if ( json === null || (typeof status === 'number' && status == 204 ) ) {
			json = {};
			_fnAjaxDataSrc( oSettings, json, [] );
		}

		var error = json.error || json.sError;
		if ( error ) {
			_fnLog( oSettings, 0, error );
		}

		// Microsoft often wrap JSON as a string in another JSON object
		// Let's handle that automatically
		if (json.d && typeof json.d === 'string') {
			try {
				json = JSON.parse(json.d);
			}
			catch (e) {
				// noop
			}
		}

		oSettings.json = json;

		_fnCallbackFire( oSettings, null, 'xhr', [oSettings, json, oSettings.jqXHR], true );
		fn( json );
	};

	if ( $.isPlainObject( ajax ) && ajax.data )
	{
		ajaxData = ajax.data;

		var newData = typeof ajaxData === 'function' ?
			ajaxData( data, oSettings ) :  // fn can manipulate data or return
			ajaxData;                      // an object object or array to merge

		// If the function returned something, use that alone
		data = typeof ajaxData === 'function' && newData ?
			newData :
			$.extend( true, data, newData );

		// Remove the data property as we've resolved it already and don't want
		// jQuery to do it again (it is restored at the end of the function)
		delete ajax.data;
	}

	var baseAjax = {
		"url": typeof ajax === 'string' ?
			ajax :
			'',
		"data": data,
		"success": callback,
		"dataType": "json",
		"cache": false,
		"type": oSettings.sServerMethod,
		"error": function (xhr, error) {
			var ret = _fnCallbackFire( oSettings, null, 'xhr', [oSettings, null, oSettings.jqXHR], true );

			if ( ret.indexOf(true) === -1 ) {
				if ( error == "parsererror" ) {
					_fnLog( oSettings, 0, 'Invalid JSON response', 1 );
				}
				else if ( xhr.readyState === 4 ) {
					_fnLog( oSettings, 0, 'Ajax error', 7 );
				}
			}

			_fnProcessingDisplay( oSettings, false );
		}
	};

	// If `ajax` option is an object, extend and override our default base
	if ( $.isPlainObject( ajax ) ) {
		$.extend( baseAjax, ajax )
	}

	// Store the data submitted for the API
	oSettings.oAjaxData = data;

	// Allow plug-ins and external processes to modify the data
	_fnCallbackFire( oSettings, null, 'preXhr', [oSettings, data, baseAjax], true );

	// Custom Ajax option to submit the parameters as a JSON string
	if (baseAjax.submitAs === 'json' && typeof data === 'object') {
		baseAjax.data = JSON.stringify(data);
	}

	if ( typeof ajax === 'function' )
	{
		// Is a function - let the caller define what needs to be done
		oSettings.jqXHR = ajax.call( instance, data, callback, oSettings );
	}
	else if (ajax.url === '') {
		// No url, so don't load any data. Just apply an empty data array
		// to the object for the callback.
		var empty = {};

		DataTable.util.set(ajax.dataSrc)(empty, []);
		callback(empty);
	}
	else {
		// Object to extend the base settings
		oSettings.jqXHR = $.ajax( baseAjax );
	}

	// Restore for next time around
	if ( ajaxData ) {
		ajax.data = ajaxData;
	}
}


/**
 * Update the table using an Ajax call
 *  @param {object} settings dataTables settings object
 *  @returns {boolean} Block the table drawing or not
 *  @memberof DataTable#oApi
 */
function _fnAjaxUpdate( settings )
{
	settings.iDraw++;
	_fnProcessingDisplay( settings, true );

	_fnBuildAjax(
		settings,
		_fnAjaxParameters( settings ),
		function(json) {
			_fnAjaxUpdateDraw( settings, json );
		}
	);
}


/**
 * Build up the parameters in an object needed for a server-side processing
 * request.
 *  @param {object} oSettings dataTables settings object
 *  @returns {bool} block the table drawing or not
 *  @memberof DataTable#oApi
 */
function _fnAjaxParameters( settings )
{
	var
		columns = settings.aoColumns,
		features = settings.oFeatures,
		preSearch = settings.oPreviousSearch,
		preColSearch = settings.aoPreSearchCols,
		colData = function ( idx, prop ) {
			return typeof columns[idx][prop] === 'function' ?
				'function' :
				columns[idx][prop];
		};

	return {
		draw: settings.iDraw,
		columns: columns.map( function ( column, i ) {
			return {
				data: colData(i, 'mData'),
				name: column.sName,
				searchable: column.bSearchable,
				orderable: column.bSortable,
				search: {
					value: preColSearch[i].search,
					regex: preColSearch[i].regex,
					fixed: Object.keys(column.searchFixed).map( function(name) {
						return {
							name: name,
							term: column.searchFixed[name].toString()
						}
					})
				}
			};
		} ),
		order: _fnSortFlatten( settings ).map( function ( val ) {
			return {
				column: val.col,
				dir: val.dir,
				name: colData(val.col, 'sName')
			};
		} ),
		start: settings._iDisplayStart,
		length: features.bPaginate ?
			settings._iDisplayLength :
			-1,
		search: {
			value: preSearch.search,
			regex: preSearch.regex,
			fixed: Object.keys(settings.searchFixed).map( function(name) {
				return {
					name: name,
					term: settings.searchFixed[name].toString()
				}
			})
		}
	};
}


/**
 * Data the data from the server (nuking the old) and redraw the table
 *  @param {object} oSettings dataTables settings object
 *  @param {object} json json data return from the server.
 *  @param {string} json.sEcho Tracking flag for DataTables to match requests
 *  @param {int} json.iTotalRecords Number of records in the data set, not accounting for filtering
 *  @param {int} json.iTotalDisplayRecords Number of records in the data set, accounting for filtering
 *  @param {array} json.aaData The data to display on this page
 *  @param {string} [json.sColumns] Column ordering (sName, comma separated)
 *  @memberof DataTable#oApi
 */
function _fnAjaxUpdateDraw ( settings, json )
{
	var data = _fnAjaxDataSrc(settings, json);
	var draw = _fnAjaxDataSrcParam(settings, 'draw', json);
	var recordsTotal = _fnAjaxDataSrcParam(settings, 'recordsTotal', json);
	var recordsFiltered = _fnAjaxDataSrcParam(settings, 'recordsFiltered', json);

	if ( draw !== undefined ) {
		// Protect against out of sequence returns
		if ( draw*1 < settings.iDraw ) {
			return;
		}
		settings.iDraw = draw * 1;
	}

	// No data in returned object, so rather than an array, we show an empty table
	if ( ! data ) {
		data = [];
	}

	_fnClearTable( settings );
	settings._iRecordsTotal   = parseInt(recordsTotal, 10);
	settings._iRecordsDisplay = parseInt(recordsFiltered, 10);

	for ( var i=0, ien=data.length ; i<ien ; i++ ) {
		_fnAddData( settings, data[i] );
	}
	settings.aiDisplay = settings.aiDisplayMaster.slice();

	_fnColumnTypes(settings);
	_fnDraw( settings, true );
	_fnInitComplete( settings );
	_fnProcessingDisplay( settings, false );
}


/**
 * Get the data from the JSON data source to use for drawing a table. Using
 * `_fnGetObjectDataFn` allows the data to be sourced from a property of the
 * source object, or from a processing function.
 *  @param {object} settings dataTables settings object
 *  @param  {object} json Data source object / array from the server
 *  @return {array} Array of data to use
 */
function _fnAjaxDataSrc ( settings, json, write )
{
	var dataProp = 'data';

	if ($.isPlainObject( settings.ajax ) && settings.ajax.dataSrc !== undefined) {
		// Could in inside a `dataSrc` object, or not!
		var dataSrc = settings.ajax.dataSrc;

		// string, function and object are valid types
		if (typeof dataSrc === 'string' || typeof dataSrc === 'function') {
			dataProp = dataSrc;
		}
		else if (dataSrc.data !== undefined) {
			dataProp = dataSrc.data;
		}
	}

	if ( ! write ) {
		if ( dataProp === 'data' ) {
			// If the default, then we still want to support the old style, and safely ignore
			// it if possible
			return json.aaData || json[dataProp];
		}

		return dataProp !== "" ?
			_fnGetObjectDataFn( dataProp )( json ) :
			json;
	}
	
	// set
	_fnSetObjectDataFn( dataProp )( json, write );
}

/**
 * Very similar to _fnAjaxDataSrc, but for the other SSP properties
 * @param {*} settings DataTables settings object
 * @param {*} param Target parameter
 * @param {*} json JSON data
 * @returns Resolved value
 */
function _fnAjaxDataSrcParam (settings, param, json) {
	var dataSrc = $.isPlainObject( settings.ajax )
		? settings.ajax.dataSrc
		: null;

	if (dataSrc && dataSrc[param]) {
		// Get from custom location
		return _fnGetObjectDataFn( dataSrc[param] )( json );
	}

	// else - Default behaviour
	var old = '';

	// Legacy support
	if (param === 'draw') {
		old = 'sEcho';
	}
	else if (param === 'recordsTotal') {
		old = 'iTotalRecords';
	}
	else if (param === 'recordsFiltered') {
		old = 'iTotalDisplayRecords';
	}

	return json[old] !== undefined
		? json[old]
		: json[param];
}


/**
 * Filter the table using both the global filter and column based filtering
 *  @param {object} settings dataTables settings object
 *  @param {object} input search information
 *  @memberof DataTable#oApi
 */
function _fnFilterComplete ( settings, input )
{
	var columnsSearch = settings.aoPreSearchCols;

	// In server-side processing all filtering is done by the server, so no point hanging around here
	if ( _fnDataSource( settings ) != 'ssp' )
	{
		// Check if any of the rows were invalidated
		_fnFilterData( settings );

		// Start from the full data set
		settings.aiDisplay = settings.aiDisplayMaster.slice();

		// Global filter first
		_fnFilter( settings.aiDisplay, settings, input.search, input );

		$.each(settings.searchFixed, function (name, term) {
			_fnFilter(settings.aiDisplay, settings, term, {});
		});

		// Then individual column filters
		for ( var i=0 ; i<columnsSearch.length ; i++ )
		{
			var col = columnsSearch[i];

			_fnFilter(
				settings.aiDisplay,
				settings,
				col.search,
				col,
				i
			);

			$.each(settings.aoColumns[i].searchFixed, function (name, term) {
				_fnFilter(settings.aiDisplay, settings, term, {}, i);
			});
		}

		// And finally global filtering
		_fnFilterCustom( settings );
	}

	// Tell the draw function we have been filtering
	settings.bFiltered = true;

	_fnCallbackFire( settings, null, 'search', [settings] );
}


/**
 * Apply custom filtering functions
 * 
 * This is legacy now that we have named functions, but it is widely used
 * from 1.x, so it is not yet deprecated.
 *  @param {object} oSettings dataTables settings object
 *  @memberof DataTable#oApi
 */
function _fnFilterCustom( settings )
{
	var filters = DataTable.ext.search;
	var displayRows = settings.aiDisplay;
	var row, rowIdx;

	for ( var i=0, ien=filters.length ; i<ien ; i++ ) {
		var rows = [];

		// Loop over each row and see if it should be included
		for ( var j=0, jen=displayRows.length ; j<jen ; j++ ) {
			rowIdx = displayRows[ j ];
			row = settings.aoData[ rowIdx ];

			if ( filters[i]( settings, row._aFilterData, rowIdx, row._aData, j ) ) {
				rows.push( rowIdx );
			}
		}

		// So the array reference doesn't break set the results into the
		// existing array
		displayRows.length = 0;
		_fnArrayApply(displayRows, rows);
	}
}


/**
 * Filter the data table based on user input and draw the table
 */
function _fnFilter( searchRows, settings, input, options, column )
{
	if ( input === '' ) {
		return;
	}

	var i = 0;
	var matched = [];

	// Search term can be a function, regex or string - if a string we apply our
	// smart filtering regex (assuming the options require that)
	var searchFunc = typeof input === 'function' ? input : null;
	var rpSearch = input instanceof RegExp
		? input
		: searchFunc
			? null
			: _fnFilterCreateSearch( input, options );

	// Then for each row, does the test pass. If not, lop the row from the array
	for (i=0 ; i<searchRows.length ; i++) {
		var row = settings.aoData[ searchRows[i] ];
		var data = column === undefined
			? row._sFilterRow
			: row._aFilterData[ column ];

		if ( (searchFunc && searchFunc(data, row._aData, searchRows[i], column)) || (rpSearch && rpSearch.test(data)) ) {
			matched.push(searchRows[i]);
		}
	}

	// Mutate the searchRows array
	searchRows.length = matched.length;

	for (i=0 ; i<matched.length ; i++) {
		searchRows[i] = matched[i];
	}
}


/**
 * Build a regular expression object suitable for searching a table
 *  @param {string} sSearch string to search for
 *  @param {bool} bRegex treat as a regular expression or not
 *  @param {bool} bSmart perform smart filtering or not
 *  @param {bool} bCaseInsensitive Do case insensitive matching or not
 *  @returns {RegExp} constructed object
 *  @memberof DataTable#oApi
 */
function _fnFilterCreateSearch( search, inOpts )
{
	var not = [];
	var options = $.extend({}, {
		boundary: false,
		caseInsensitive: true,
		exact: false,
		regex: false,
		smart: true
	}, inOpts);

	if (typeof search !== 'string') {
		search = search.toString();
	}

	// Remove diacritics if normalize is set up to do so
	search = _normalize(search);

	if (options.exact) {
		return new RegExp(
			'^'+_fnEscapeRegex(search)+'$',
			options.caseInsensitive ? 'i' : ''
		);
	}

	search = options.regex ?
		search :
		_fnEscapeRegex( search );
	
	if ( options.smart ) {
		/* For smart filtering we want to allow the search to work regardless of
		 * word order. We also want double quoted text to be preserved, so word
		 * order is important - a la google. And a negative look around for
		 * finding rows which don't contain a given string.
		 * 
		 * So this is the sort of thing we want to generate:
		 * 
		 * ^(?=.*?\bone\b)(?=.*?\btwo three\b)(?=.*?\bfour\b).*$
		 */
		var parts = search.match( /!?["\u201C][^"\u201D]+["\u201D]|[^ ]+/g ) || [''];
		var a = parts.map( function ( word ) {
			var negative = false;
			var m;

			// Determine if it is a "does not include"
			if ( word.charAt(0) === '!' ) {
				negative = true;
				word = word.substring(1);
			}

			// Strip the quotes from around matched phrases
			if ( word.charAt(0) === '"' ) {
				m = word.match( /^"(.*)"$/ );
				word = m ? m[1] : word;
			}
			else if ( word.charAt(0) === '\u201C' ) {
				// Smart quote match (iPhone users)
				m = word.match( /^\u201C(.*)\u201D$/ );
				word = m ? m[1] : word;
			}

			// For our "not" case, we need to modify the string that is
			// allowed to match at the end of the expression.
			if (negative) {
				if (word.length > 1) {
					not.push('(?!'+word+')');
				}

				word = '';
			}

			return word.replace(/"/g, '');
		} );

		var match = not.length
			? not.join('')
			: '';

		var boundary = options.boundary
			? '\\b'
			: '';

		search = '^(?=.*?'+boundary+a.join( ')(?=.*?'+boundary )+')('+match+'.)*$';
	}

	return new RegExp( search, options.caseInsensitive ? 'i' : '' );
}


/**
 * Escape a string such that it can be used in a regular expression
 *  @param {string} sVal string to escape
 *  @returns {string} escaped string
 *  @memberof DataTable#oApi
 */
var _fnEscapeRegex = DataTable.util.escapeRegex;

var __filter_div = $('<div>')[0];
var __filter_div_textContent = __filter_div.textContent !== undefined;

// Update the filtering data for each row if needed (by invalidation or first run)
function _fnFilterData ( settings )
{
	var columns = settings.aoColumns;
	var data = settings.aoData;
	var column;
	var j, jen, filterData, cellData, row;
	var wasInvalidated = false;

	for ( var rowIdx=0 ; rowIdx<data.length ; rowIdx++ ) {
		if (! data[rowIdx]) {
			continue;
		}

		row = data[rowIdx];

		if ( ! row._aFilterData ) {
			filterData = [];

			for ( j=0, jen=columns.length ; j<jen ; j++ ) {
				column = columns[j];

				if ( column.bSearchable ) {
					cellData = _fnGetCellData( settings, rowIdx, j, 'filter' );

					// Search in DataTables is string based
					if ( cellData === null ) {
						cellData = '';
					}

					if ( typeof cellData !== 'string' && cellData.toString ) {
						cellData = cellData.toString();
					}
				}
				else {
					cellData = '';
				}

				// If it looks like there is an HTML entity in the string,
				// attempt to decode it so sorting works as expected. Note that
				// we could use a single line of jQuery to do this, but the DOM
				// method used here is much faster https://jsperf.com/html-decode
				if ( cellData.indexOf && cellData.indexOf('&') !== -1 ) {
					__filter_div.innerHTML = cellData;
					cellData = __filter_div_textContent ?
						__filter_div.textContent :
						__filter_div.innerText;
				}

				if ( cellData.replace ) {
					cellData = cellData.replace(/[\r\n\u2028]/g, '');
				}

				filterData.push( cellData );
			}

			row._aFilterData = filterData;
			row._sFilterRow = filterData.join('  ');
			wasInvalidated = true;
		}
	}

	return wasInvalidated;
}


/**
 * Draw the table for the first time, adding all required features
 *  @param {object} settings dataTables settings object
 *  @memberof DataTable#oApi
 */
function _fnInitialise ( settings )
{
	var i;
	var init = settings.oInit;
	var deferLoading = settings.deferLoading;
	var dataSrc = _fnDataSource( settings );

	// Ensure that the table data is fully initialised
	if ( ! settings.bInitialised ) {
		setTimeout( function(){ _fnInitialise( settings ); }, 200 );
		return;
	}

	// Build the header / footer for the table
	_fnBuildHead( settings, 'header' );
	_fnBuildHead( settings, 'footer' );

	// Load the table's state (if needed) and then render around it and draw
	_fnLoadState( settings, init, function () {
		// Then draw the header / footer
		_fnDrawHead( settings, settings.aoHeader );
		_fnDrawHead( settings, settings.aoFooter );

		// Cache the paging start point, as the first redraw will reset it
		var iAjaxStart = settings.iInitDisplayStart

		// Local data load
		// Check if there is data passing into the constructor
		if ( init.aaData ) {
			for ( i=0 ; i<init.aaData.length ; i++ ) {
				_fnAddData( settings, init.aaData[ i ] );
			}
		}
		else if ( deferLoading || dataSrc == 'dom' ) {
			// Grab the data from the page
			_fnAddTr( settings, $(settings.nTBody).children('tr') );
		}

		// Filter not yet applied - copy the display master
		settings.aiDisplay = settings.aiDisplayMaster.slice();

		// Enable features
		_fnAddOptionsHtml( settings );
		_fnSortInit( settings );

		_colGroup( settings );

		/* Okay to show that something is going on now */
		_fnProcessingDisplay( settings, true );

		_fnCallbackFire( settings, null, 'preInit', [settings], true );

		// If there is default sorting required - let's do it. The sort function
		// will do the drawing for us. Otherwise we draw the table regardless of the
		// Ajax source - this allows the table to look initialised for Ajax sourcing
		// data (show 'loading' message possibly)
		_fnReDraw( settings );

		// Server-side processing init complete is done by _fnAjaxUpdateDraw
		if ( dataSrc != 'ssp' || deferLoading ) {
			// if there is an ajax source load the data
			if ( dataSrc == 'ajax' ) {
				_fnBuildAjax( settings, {}, function(json) {
					var aData = _fnAjaxDataSrc( settings, json );

					// Got the data - add it to the table
					for ( i=0 ; i<aData.length ; i++ ) {
						_fnAddData( settings, aData[i] );
					}

					// Reset the init display for cookie saving. We've already done
					// a filter, and therefore cleared it before. So we need to make
					// it appear 'fresh'
					settings.iInitDisplayStart = iAjaxStart;

					_fnReDraw( settings );
					_fnProcessingDisplay( settings, false );
					_fnInitComplete( settings );
				}, settings );
			}
			else {
				_fnInitComplete( settings );
				_fnProcessingDisplay( settings, false );
			}
		}
	} );
}


/**
 * Draw the table for the first time, adding all required features
 *  @param {object} settings dataTables settings object
 *  @memberof DataTable#oApi
 */
function _fnInitComplete ( settings )
{
	if (settings._bInitComplete) {
		return;
	}

	var args = [settings, settings.json];

	settings._bInitComplete = true;

	// Table is fully set up and we have data, so calculate the
	// column widths
	_fnAdjustColumnSizing( settings );

	_fnCallbackFire( settings, null, 'plugin-init', args, true );
	_fnCallbackFire( settings, 'aoInitComplete', 'init', args, true );
}

function _fnLengthChange ( settings, val )
{
	var len = parseInt( val, 10 );
	settings._iDisplayLength = len;

	_fnLengthOverflow( settings );

	// Fire length change event
	_fnCallbackFire( settings, null, 'length', [settings, len] );
}

/**
 * Alter the display settings to change the page
 *  @param {object} settings DataTables settings object
 *  @param {string|int} action Paging action to take: "first", "previous",
 *    "next" or "last" or page number to jump to (integer)
 *  @param [bool] redraw Automatically draw the update or not
 *  @returns {bool} true page has changed, false - no change
 *  @memberof DataTable#oApi
 */
function _fnPageChange ( settings, action, redraw )
{
	var
		start     = settings._iDisplayStart,
		len       = settings._iDisplayLength,
		records   = settings.fnRecordsDisplay();

	if ( records === 0 || len === -1 )
	{
		start = 0;
	}
	else if ( typeof action === "number" )
	{
		start = action * len;

		if ( start > records )
		{
			start = 0;
		}
	}
	else if ( action == "first" )
	{
		start = 0;
	}
	else if ( action == "previous" )
	{
		start = len >= 0 ?
			start - len :
			0;

		if ( start < 0 )
		{
			start = 0;
		}
	}
	else if ( action == "next" )
	{
		if ( start + len < records )
		{
			start += len;
		}
	}
	else if ( action == "last" )
	{
		start = Math.floor( (records-1) / len) * len;
	}
	else if ( action === 'ellipsis' )
	{
		return;
	}
	else
	{
		_fnLog( settings, 0, "Unknown paging action: "+action, 5 );
	}

	var changed = settings._iDisplayStart !== start;
	settings._iDisplayStart = start;

	_fnCallbackFire( settings, null, changed ? 'page' : 'page-nc', [settings] );

	if ( changed && redraw ) {
		_fnDraw( settings );
	}

	return changed;
}


/**
 * Generate the node required for the processing node
 *  @param {object} settings DataTables settings object
 */
function _processingHtml ( settings )
{
	var table = settings.nTable;
	var scrolling = settings.oScroll.sX !== '' || settings.oScroll.sY !== '';

	if ( settings.oFeatures.bProcessing ) {
		var n = $('<div/>', {
				'id': settings.sTableId + '_processing',
				'class': settings.oClasses.processing.container,
				'role': 'status'
			} )
			.html( settings.oLanguage.sProcessing )
			.append('<div><div></div><div></div><div></div><div></div></div>');

		// Different positioning depending on if scrolling is enabled or not
		if (scrolling) {
			n.prependTo( $('div.dt-scroll', settings.nTableWrapper) );
		}
		else {
			n.insertBefore( table );
		}

		$(table).on( 'processing.dt.DT', function (e, s, show) {
			n.css( 'display', show ? 'block' : 'none' );
		} );
	}
}


/**
 * Display or hide the processing indicator
 *  @param {object} settings DataTables settings object
 *  @param {bool} show Show the processing indicator (true) or not (false)
 */
function _fnProcessingDisplay ( settings, show )
{
	// Ignore cases when we are still redrawing
	if (settings.bDrawing && show === false) {
		return;
	}

	_fnCallbackFire( settings, null, 'processing', [settings, show] );
}

/**
 * Show the processing element if an action takes longer than a given time
 *
 * @param {*} settings DataTables settings object
 * @param {*} enable Do (true) or not (false) async processing (local feature enablement)
 * @param {*} run Function to run
 */
function _fnProcessingRun( settings, enable, run ) {
	if (! enable) {
		// Immediate execution, synchronous
		run();
	}
	else {
		_fnProcessingDisplay(settings, true);
		
		// Allow the processing display to show if needed
		setTimeout(function () {
			run();

			_fnProcessingDisplay(settings, false);
		}, 0);
	}
}
/**
 * Add any control elements for the table - specifically scrolling
 *  @param {object} settings dataTables settings object
 *  @returns {node} Node to add to the DOM
 *  @memberof DataTable#oApi
 */
function _fnFeatureHtmlTable ( settings )
{
	var table = $(settings.nTable);

	// Scrolling from here on in
	var scroll = settings.oScroll;

	if ( scroll.sX === '' && scroll.sY === '' ) {
		return settings.nTable;
	}

	var scrollX = scroll.sX;
	var scrollY = scroll.sY;
	var classes = settings.oClasses.scrolling;
	var caption = settings.captionNode;
	var captionSide = caption ? caption._captionSide : null;
	var headerClone = $( table[0].cloneNode(false) );
	var footerClone = $( table[0].cloneNode(false) );
	var footer = table.children('tfoot');
	var _div = '<div/>';
	var size = function ( s ) {
		return !s ? null : _fnStringToCss( s );
	};

	if ( ! footer.length ) {
		footer = null;
	}

	/*
	 * The HTML structure that we want to generate in this function is:
	 *  div - scroller
	 *    div - scroll head
	 *      div - scroll head inner
	 *        table - scroll head table
	 *          thead - thead
	 *    div - scroll body
	 *      table - table (master table)
	 *        thead - thead clone for sizing
	 *        tbody - tbody
	 *    div - scroll foot
	 *      div - scroll foot inner
	 *        table - scroll foot table
	 *          tfoot - tfoot
	 */
	var scroller = $( _div, { 'class': classes.container } )
		.append(
			$(_div, { 'class': classes.header.self } )
				.css( {
					overflow: 'hidden',
					position: 'relative',
					border: 0,
					width: scrollX ? size(scrollX) : '100%'
				} )
				.append(
					$(_div, { 'class': classes.header.inner } )
						.css( {
							'box-sizing': 'content-box',
							width: scroll.sXInner || '100%'
						} )
						.append(
							headerClone
								.removeAttr('id')
								.css( 'margin-left', 0 )
								.append( captionSide === 'top' ? caption : null )
								.append(
									table.children('thead')
								)
						)
				)
		)
		.append(
			$(_div, { 'class': classes.body } )
				.css( {
					position: 'relative',
					overflow: 'auto',
					width: size( scrollX )
				} )
				.append( table )
		);

	if ( footer ) {
		scroller.append(
			$(_div, { 'class': classes.footer.self } )
				.css( {
					overflow: 'hidden',
					border: 0,
					width: scrollX ? size(scrollX) : '100%'
				} )
				.append(
					$(_div, { 'class': classes.footer.inner } )
						.append(
							footerClone
								.removeAttr('id')
								.css( 'margin-left', 0 )
								.append( captionSide === 'bottom' ? caption : null )
								.append(
									table.children('tfoot')
								)
						)
				)
		);
	}

	var children = scroller.children();
	var scrollHead = children[0];
	var scrollBody = children[1];
	var scrollFoot = footer ? children[2] : null;

	// When the body is scrolled, then we also want to scroll the headers
	$(scrollBody).on( 'scroll.DT', function () {
		var scrollLeft = this.scrollLeft;

		scrollHead.scrollLeft = scrollLeft;

		if ( footer ) {
			scrollFoot.scrollLeft = scrollLeft;
		}
	} );

	// When focus is put on the header cells, we might need to scroll the body
	$('th, td', scrollHead).on('focus', function () {
		var scrollLeft = scrollHead.scrollLeft;

		scrollBody.scrollLeft = scrollLeft;

		if ( footer ) {
			scrollBody.scrollLeft = scrollLeft;
		}
	});

	$(scrollBody).css('max-height', scrollY);
	if (! scroll.bCollapse) {
		$(scrollBody).css('height', scrollY);
	}

	settings.nScrollHead = scrollHead;
	settings.nScrollBody = scrollBody;
	settings.nScrollFoot = scrollFoot;

	// On redraw - align columns
	settings.aoDrawCallback.push(_fnScrollDraw);

	return scroller[0];
}



/**
 * Update the header, footer and body tables for resizing - i.e. column
 * alignment.
 *
 * Welcome to the most horrible function DataTables. The process that this
 * function follows is basically:
 *   1. Re-create the table inside the scrolling div
 *   2. Correct colgroup > col values if needed
 *   3. Copy colgroup > col over to header and footer
 *   4. Clean up
 *
 *  @param {object} settings dataTables settings object
 *  @memberof DataTable#oApi
 */
function _fnScrollDraw ( settings )
{
	// Given that this is such a monster function, a lot of variables are use
	// to try and keep the minimised size as small as possible
	var
		scroll         = settings.oScroll,
		barWidth       = scroll.iBarWidth,
		divHeader      = $(settings.nScrollHead),
		divHeaderInner = divHeader.children('div'),
		divHeaderTable = divHeaderInner.children('table'),
		divBodyEl      = settings.nScrollBody,
		divBody        = $(divBodyEl),
		divFooter      = $(settings.nScrollFoot),
		divFooterInner = divFooter.children('div'),
		divFooterTable = divFooterInner.children('table'),
		header         = $(settings.nTHead),
		table          = $(settings.nTable),
		footer         = settings.nTFoot && $('th, td', settings.nTFoot).length ? $(settings.nTFoot) : null,
		browser        = settings.oBrowser,
		headerCopy, footerCopy;

	// If the scrollbar visibility has changed from the last draw, we need to
	// adjust the column sizes as the table width will have changed to account
	// for the scrollbar
	var scrollBarVis = divBodyEl.scrollHeight > divBodyEl.clientHeight;
	
	if ( settings.scrollBarVis !== scrollBarVis && settings.scrollBarVis !== undefined ) {
		settings.scrollBarVis = scrollBarVis;
		_fnAdjustColumnSizing( settings );
		return; // adjust column sizing will call this function again
	}
	else {
		settings.scrollBarVis = scrollBarVis;
	}

	// 1. Re-create the table inside the scrolling div
	// Remove the old minimised thead and tfoot elements in the inner table
	table.children('thead, tfoot').remove();

	// Clone the current header and footer elements and then place it into the inner table
	headerCopy = header.clone().prependTo( table );
	headerCopy.find('th, td').removeAttr('tabindex');
	headerCopy.find('[id]').removeAttr('id');

	if ( footer ) {
		footerCopy = footer.clone().prependTo( table );
		footerCopy.find('[id]').removeAttr('id');
	}

	// 2. Correct colgroup > col values if needed
	// It is possible that the cell sizes are smaller than the content, so we need to
	// correct colgroup>col for such cases. This can happen if the auto width detection
	// uses a cell which has a longer string, but isn't the widest! For example 
	// "Chief Executive Officer (CEO)" is the longest string in the demo, but
	// "Systems Administrator" is actually the widest string since it doesn't collapse.
	// Note the use of translating into a column index to get the `col` element. This
	// is because of Responsive which might remove `col` elements, knocking the alignment
	// of the indexes out.
	if (settings.aiDisplay.length) {
		// Get the column sizes from the first row in the table. This should really be a
		// [].find, but it wasn't supported in Chrome until Sept 2015, and DT has 10 year
		// browser support
		var firstTr = null;
		var start = _fnDataSource( settings ) !== 'ssp'
			? settings._iDisplayStart
			: 0;

		for (i=start ; i<start + settings.aiDisplay.length ; i++) {
			var idx = settings.aiDisplay[i];
			var tr = settings.aoData[idx].nTr;

			if (tr) {
				firstTr = tr;
				break;
			}
		}

		if (firstTr) {
			var colSizes = $(firstTr).children('th, td').map(function (vis) {
				return {
					idx: _fnVisibleToColumnIndex(settings, vis),
					width: $(this).outerWidth()
				};
			});

			// Check against what the colgroup > col is set to and correct if needed
			for (var i=0 ; i<colSizes.length ; i++) {
				var colEl = settings.aoColumns[ colSizes[i].idx ].colEl[0];
				var colWidth = colEl.style.width.replace('px', '');

				if (colWidth !== colSizes[i].width) {
					colEl.style.width = colSizes[i].width + 'px';

					if (scroll.sX) {
						colEl.style.minWidth = colSizes[i].width + 'px';
					}
				}
			}
		}
	}

	// 3. Copy the colgroup over to the header and footer
	divHeaderTable
		.find('colgroup')
		.remove();

	divHeaderTable.append(settings.colgroup.clone());

	if ( footer ) {
		divFooterTable
			.find('colgroup')
			.remove();

		divFooterTable.append(settings.colgroup.clone());
	}

	// "Hide" the header and footer that we used for the sizing. We need to keep
	// the content of the cell so that the width applied to the header and body
	// both match, but we want to hide it completely.
	$('th, td', headerCopy).each(function () {
		$(this.childNodes).wrapAll('<div class="dt-scroll-sizing">');
	});

	if ( footer ) {
		$('th, td', footerCopy).each(function () {
			$(this.childNodes).wrapAll('<div class="dt-scroll-sizing">');
		});
	}

	// 4. Clean up
	// Figure out if there are scrollbar present - if so then we need a the header and footer to
	// provide a bit more space to allow "overflow" scrolling (i.e. past the scrollbar)
	var isScrolling = Math.floor(table.height()) > divBodyEl.clientHeight || divBody.css('overflow-y') == "scroll";
	var paddingSide = 'padding' + (browser.bScrollbarLeft ? 'Left' : 'Right' );

	// Set the width's of the header and footer tables
	var outerWidth = table.outerWidth();

	divHeaderTable.css('width', _fnStringToCss( outerWidth ));
	divHeaderInner
		.css('width', _fnStringToCss( outerWidth ))
		.css(paddingSide, isScrolling ? barWidth+"px" : "0px");

	if ( footer ) {
		divFooterTable.css('width', _fnStringToCss( outerWidth ));
		divFooterInner
			.css('width', _fnStringToCss( outerWidth ))
			.css(paddingSide, isScrolling ? barWidth+"px" : "0px");
	}

	// Correct DOM ordering for colgroup - comes before the thead
	table.children('colgroup').prependTo(table);

	// Adjust the position of the header in case we loose the y-scrollbar
	divBody.trigger('scroll');

	// If sorting or filtering has occurred, jump the scrolling back to the top
	// only if we aren't holding the position
	if ( (settings.bSorted || settings.bFiltered) && ! settings._drawHold ) {
		divBodyEl.scrollTop = 0;
	}
}

/**
 * Calculate the width of columns for the table
 *  @param {object} settings dataTables settings object
 *  @memberof DataTable#oApi
 */
function _fnCalculateColumnWidths ( settings )
{
	// Not interested in doing column width calculation if auto-width is disabled
	if (! settings.oFeatures.bAutoWidth) {
		return;
	}

	var
		table = settings.nTable,
		columns = settings.aoColumns,
		scroll = settings.oScroll,
		scrollY = scroll.sY,
		scrollX = scroll.sX,
		scrollXInner = scroll.sXInner,
		visibleColumns = _fnGetColumns( settings, 'bVisible' ),
		tableWidthAttr = table.getAttribute('width'), // from DOM element
		tableContainer = table.parentNode,
		i, column, columnIdx;
		
	var styleWidth = table.style.width;
	var containerWidth = _fnWrapperWidth(settings);

	// Don't re-run for the same width as the last time
	if (containerWidth === settings.containerWidth) {
		return false;
	}

	settings.containerWidth = containerWidth;

	// If there is no width applied as a CSS style or as an attribute, we assume that
	// the width is intended to be 100%, which is usually is in CSS, but it is very
	// difficult to correctly parse the rules to get the final result.
	if ( ! styleWidth && ! tableWidthAttr) {
		table.style.width = '100%';
		styleWidth = '100%';
	}

	if ( styleWidth && styleWidth.indexOf('%') !== -1 ) {
		tableWidthAttr = styleWidth;
	}

	// Let plug-ins know that we are doing a recalc, in case they have changed any of the
	// visible columns their own way (e.g. Responsive uses display:none).
	_fnCallbackFire(
		settings,
		null,
		'column-calc',
		{visible: visibleColumns},
		false
	);

	// Construct a single row, worst case, table with the widest
	// node in the data, assign any user defined widths, then insert it into
	// the DOM and allow the browser to do all the hard work of calculating
	// table widths
	var tmpTable = $(table.cloneNode())
		.css( 'visibility', 'hidden' )
		.removeAttr( 'id' );

	// Clean up the table body
	tmpTable.append('<tbody>')
	var tr = $('<tr/>').appendTo( tmpTable.find('tbody') );

	// Clone the table header and footer - we can't use the header / footer
	// from the cloned table, since if scrolling is active, the table's
	// real header and footer are contained in different table tags
	tmpTable
		.append( $(settings.nTHead).clone() )
		.append( $(settings.nTFoot).clone() );

	// Remove any assigned widths from the footer (from scrolling)
	tmpTable.find('tfoot th, tfoot td').css('width', '');

	// Apply custom sizing to the cloned header
	tmpTable.find('thead th, thead td').each( function () {
		// Get the `width` from the header layout
		var width = _fnColumnsSumWidth( settings, this, true, false );

		if ( width ) {
			this.style.width = width;

			// For scrollX we need to force the column width otherwise the
			// browser will collapse it. If this width is smaller than the
			// width the column requires, then it will have no effect
			if ( scrollX ) {
				this.style.minWidth = width;

				$( this ).append( $('<div/>').css( {
					width: width,
					margin: 0,
					padding: 0,
					border: 0,
					height: 1
				} ) );
			}
		}
		else {
			this.style.width = '';
		}
	} );

	// Find the widest piece of data for each column and put it into the table
	for ( i=0 ; i<visibleColumns.length ; i++ ) {
		columnIdx = visibleColumns[i];
		column = columns[ columnIdx ];

		var longest = _fnGetMaxLenString(settings, columnIdx);
		var autoClass = _ext.type.className[column.sType];
		var text = longest + column.sContentPadding;
		var insert = longest.indexOf('<') === -1
			? document.createTextNode(text)
			: text
		
		$('<td/>')
			.addClass(autoClass)
			.addClass(column.sClass)
			.append(insert)
			.appendTo(tr);
	}

	// Tidy the temporary table - remove name attributes so there aren't
	// duplicated in the dom (radio elements for example)
	$('[name]', tmpTable).removeAttr('name');

	// Table has been built, attach to the document so we can work with it.
	// A holding element is used, positioned at the top of the container
	// with minimal height, so it has no effect on if the container scrolls
	// or not. Otherwise it might trigger scrolling when it actually isn't
	// needed
	var holder = $('<div/>').css( scrollX || scrollY ?
			{
				position: 'absolute',
				top: 0,
				left: 0,
				height: 1,
				right: 0,
				overflow: 'hidden'
			} :
			{}
		)
		.append( tmpTable )
		.appendTo( tableContainer );

	// When scrolling (X or Y) we want to set the width of the table as 
	// appropriate. However, when not scrolling leave the table width as it
	// is. This results in slightly different, but I think correct behaviour
	if ( scrollX && scrollXInner ) {
		tmpTable.width( scrollXInner );
	}
	else if ( scrollX ) {
		tmpTable.css( 'width', 'auto' );
		tmpTable.removeAttr('width');

		// If there is no width attribute or style, then allow the table to
		// collapse
		if ( tmpTable.outerWidth() < tableContainer.clientWidth && tableWidthAttr ) {
			tmpTable.outerWidth( tableContainer.clientWidth );
		}
	}
	else if ( scrollY ) {
		tmpTable.outerWidth( tableContainer.clientWidth );
	}
	else if ( tableWidthAttr ) {
		tmpTable.outerWidth( tableWidthAttr );
	}

	// Get the width of each column in the constructed table
	var total = 0;
	var bodyCells = tmpTable.find('tbody tr').eq(0).children();

	for ( i=0 ; i<visibleColumns.length ; i++ ) {
		// Use getBounding for sub-pixel accuracy, which we then want to round up!
		var bounding = bodyCells[i].getBoundingClientRect().width;

		// Total is tracked to remove any sub-pixel errors as the outerWidth
		// of the table might not equal the total given here
		total += bounding;

		// Width for each column to use
		columns[ visibleColumns[i] ].sWidth = _fnStringToCss( bounding );
	}

	table.style.width = _fnStringToCss( total );

	// Finished with the table - ditch it
	holder.remove();

	// If there is a width attr, we want to attach an event listener which
	// allows the table sizing to automatically adjust when the window is
	// resized. Use the width attr rather than CSS, since we can't know if the
	// CSS is a relative value or absolute - DOM read is always px.
	if ( tableWidthAttr ) {
		table.style.width = _fnStringToCss( tableWidthAttr );
	}

	if ( (tableWidthAttr || scrollX) && ! settings._reszEvt ) {
		var resize = DataTable.util.throttle( function () {
			var newWidth = _fnWrapperWidth(settings);

			// Don't do it if destroying or the container width is 0
			if (! settings.bDestroying && newWidth !== 0) {
				_fnAdjustColumnSizing( settings );
			}
		} );

		// For browsers that support it (~2020 onwards for wide support) we can watch for the
		// container changing width.
		if (window.ResizeObserver) {
			// This is a tricky beast - if the element is visible when `.observe()` is called,
			// then the callback is immediately run. Which we don't want. If the element isn't
			// visible, then it isn't run, but we want it to run when it is then made visible.
			// This flag allows the above to be satisfied.
			var first = $(settings.nTableWrapper).is(':visible');

			// Use an empty div to attach the observer so it isn't impacted by height changes
			var resizer = $('<div>')
				.css({
					width: '100%',
					height: 0
				})
				.addClass('dt-autosize')
				.appendTo(settings.nTableWrapper);

			settings.resizeObserver = new ResizeObserver(function (e) {
				if (first) {
					first = false;
				}
				else {
					resize();
				}
			});

			settings.resizeObserver.observe(resizer[0]);
		}
		else {
			// For old browsers, the best we can do is listen for a window resize
			$(window).on('resize.DT-'+settings.sInstance, resize);
		}

		settings._reszEvt = true;
	}
}

/**
 * Get the width of the DataTables wrapper element
 *
 * @param {*} settings DataTables settings object
 * @returns Width
 */
function _fnWrapperWidth(settings) {
	return $(settings.nTableWrapper).is(':visible')
		? $(settings.nTableWrapper).width()
		: 0;
}

/**
 * Get the maximum strlen for each data column
 *  @param {object} settings dataTables settings object
 *  @param {int} colIdx column of interest
 *  @returns {string} string of the max length
 *  @memberof DataTable#oApi
 */
function _fnGetMaxLenString( settings, colIdx )
{
	var column = settings.aoColumns[colIdx];

	if (! column.maxLenString) {
		var s, max='', maxLen = -1;
	
		for ( var i=0, ien=settings.aiDisplayMaster.length ; i<ien ; i++ ) {
			var rowIdx = settings.aiDisplayMaster[i];
			var data = _fnGetRowDisplay(settings, rowIdx)[colIdx];

			var cellString = data && typeof data === 'object' && data.nodeType
				? data.innerHTML
				: data+'';

			// Remove id / name attributes from elements so they
			// don't interfere with existing elements
			cellString = cellString
				.replace(/id=".*?"/g, '')
				.replace(/name=".*?"/g, '');

			s = _stripHtml(cellString)
				.replace( /&nbsp;/g, ' ' );
	
			if ( s.length > maxLen ) {
				// We want the HTML in the string, but the length that
				// is important is the stripped string
				max = cellString;
				maxLen = s.length;
			}
		}

		column.maxLenString = max;
	}

	return column.maxLenString;
}


/**
 * Append a CSS unit (only if required) to a string
 *  @param {string} value to css-ify
 *  @returns {string} value with css unit
 *  @memberof DataTable#oApi
 */
function _fnStringToCss( s )
{
	if ( s === null ) {
		return '0px';
	}

	if ( typeof s == 'number' ) {
		return s < 0 ?
			'0px' :
			s+'px';
	}

	// Check it has a unit character already
	return s.match(/\d$/) ?
		s+'px' :
		s;
}

/**
 * Re-insert the `col` elements for current visibility
 *
 * @param {*} settings DT settings
 */
function _colGroup( settings ) {
	var cols = settings.aoColumns;

	settings.colgroup.empty();

	for (i=0 ; i<cols.length ; i++) {
		if (cols[i].bVisible) {
			settings.colgroup.append(cols[i].colEl);
		}
	}
}


function _fnSortInit( settings ) {
	var target = settings.nTHead;
	var headerRows = target.querySelectorAll('tr');
	var titleRow = settings.titleRow;
	var notSelector = ':not([data-dt-order="disable"]):not([data-dt-order="icon-only"])';
	
	// Legacy support for `orderCellsTop`
	if (titleRow === true) {
		target = headerRows[0];
	}
	else if (titleRow === false) {
		target = headerRows[ headerRows.length - 1 ];
	}
	else if (titleRow !== null) {
		target = headerRows[titleRow];
	}
	// else - all rows

	if (settings.orderHandler) {
		_fnSortAttachListener(
			settings,
			target,
			target === settings.nTHead
				? 'tr'+notSelector+' th'+notSelector+', tr'+notSelector+' td'+notSelector
				: 'th'+notSelector+', td'+notSelector
		);
	}

	// Need to resolve the user input array into our internal structure
	var order = [];
	_fnSortResolve( settings, order, settings.aaSorting );

	settings.aaSorting = order;
}


function _fnSortAttachListener(settings, node, selector, column, callback) {
	_fnBindAction( node, selector, function (e) {
		var run = false;
		var columns = column === undefined
			? _fnColumnsFromHeader( e.target )
			: Array.isArray(column)
				? column
				: [column];

		if ( columns.length ) {
			for ( var i=0, ien=columns.length ; i<ien ; i++ ) {
				var ret = _fnSortAdd( settings, columns[i], i, e.shiftKey );

				if (ret !== false) {
					run = true;
				}					

				// If the first entry is no sort, then subsequent
				// sort columns are ignored
				if (settings.aaSorting.length === 1 && settings.aaSorting[0][1] === '') {
					break;
				}
			}

			if (run) {
				_fnProcessingRun(settings, true, function () {
					_fnSort( settings );
					_fnSortDisplay( settings, settings.aiDisplay );

					_fnReDraw( settings, false, false );

					if (callback) {
						callback();
					}
				});
			}
		}
	} );
}

/**
 * Sort the display array to match the master's order
 * @param {*} settings
 */
function _fnSortDisplay(settings, display) {
	if (display.length < 2) {
		return;
	}

	var master = settings.aiDisplayMaster;
	var masterMap = {};
	var map = {};
	var i;

	// Rather than needing an `indexOf` on master array, we can create a map
	for (i=0 ; i<master.length ; i++) {
		masterMap[master[i]] = i;
	}

	// And then cache what would be the indexOf fom the display
	for (i=0 ; i<display.length ; i++) {
		map[display[i]] = masterMap[display[i]];
	}

	display.sort(function(a, b){
		// Short version of this function is simply `master.indexOf(a) - master.indexOf(b);`
		return map[a] - map[b];
	});
}


function _fnSortResolve (settings, nestedSort, sort) {
	var push = function ( a ) {
		if ($.isPlainObject(a)) {
			if (a.idx !== undefined) {
				// Index based ordering
				nestedSort.push([a.idx, a.dir]);
			}
			else if (a.name) {
				// Name based ordering
				var cols = _pluck( settings.aoColumns, 'sName');
				var idx = cols.indexOf(a.name);

				if (idx !== -1) {
					nestedSort.push([idx, a.dir]);
				}
			}
		}
		else {
			// Plain column index and direction pair
			nestedSort.push(a);
		}
	};

	if ( $.isPlainObject(sort) ) {
		// Object
		push(sort);
	}
	else if ( sort.length && typeof sort[0] === 'number' ) {
		// 1D array
		push(sort);
	}
	else if ( sort.length ) {
		// 2D array
		for (var z=0; z<sort.length; z++) {
			push(sort[z]); // Object or array
		}
	}
}


function _fnSortFlatten ( settings )
{
	var
		i, k, kLen,
		aSort = [],
		extSort = DataTable.ext.type.order,
		aoColumns = settings.aoColumns,
		aDataSort, iCol, sType, srcCol,
		fixed = settings.aaSortingFixed,
		fixedObj = $.isPlainObject( fixed ),
		nestedSort = [];
	
	if ( ! settings.oFeatures.bSort ) {
		return aSort;
	}

	// Build the sort array, with pre-fix and post-fix options if they have been
	// specified
	if ( Array.isArray( fixed ) ) {
		_fnSortResolve( settings, nestedSort, fixed );
	}

	if ( fixedObj && fixed.pre ) {
		_fnSortResolve( settings, nestedSort, fixed.pre );
	}

	_fnSortResolve( settings, nestedSort, settings.aaSorting );

	if (fixedObj && fixed.post ) {
		_fnSortResolve( settings, nestedSort, fixed.post );
	}

	for ( i=0 ; i<nestedSort.length ; i++ )
	{
		srcCol = nestedSort[i][0];

		if ( aoColumns[ srcCol ] ) {
			aDataSort = aoColumns[ srcCol ].aDataSort;

			for ( k=0, kLen=aDataSort.length ; k<kLen ; k++ )
			{
				iCol = aDataSort[k];
				sType = aoColumns[ iCol ].sType || 'string';

				if ( nestedSort[i]._idx === undefined ) {
					nestedSort[i]._idx = aoColumns[iCol].asSorting.indexOf(nestedSort[i][1]);
				}

				if ( nestedSort[i][1] ) {
					aSort.push( {
						src:       srcCol,
						col:       iCol,
						dir:       nestedSort[i][1],
						index:     nestedSort[i]._idx,
						type:      sType,
						formatter: extSort[ sType+"-pre" ],
						sorter:    extSort[ sType+"-"+nestedSort[i][1] ]
					} );
				}
			}
		}
	}

	return aSort;
}

/**
 * Change the order of the table
 *  @param {object} oSettings dataTables settings object
 *  @memberof DataTable#oApi
 */
function _fnSort ( oSettings, col, dir )
{
	var
		i, ien, iLen,
		aiOrig = [],
		extSort = DataTable.ext.type.order,
		aoData = oSettings.aoData,
		sortCol,
		displayMaster = oSettings.aiDisplayMaster,
		aSort;

	// Make sure the columns all have types defined
	_fnColumnTypes(oSettings);

	// Allow a specific column to be sorted, which will _not_ alter the display
	// master
	if (col !== undefined) {
		var srcCol = oSettings.aoColumns[col];

		aSort = [{
			src:       col,
			col:       col,
			dir:       dir,
			index:     0,
			type:      srcCol.sType,
			formatter: extSort[ srcCol.sType+"-pre" ],
			sorter:    extSort[ srcCol.sType+"-"+dir ]
		}];
		displayMaster = displayMaster.slice();
	}
	else {
		aSort = _fnSortFlatten( oSettings );
	}

	for ( i=0, ien=aSort.length ; i<ien ; i++ ) {
		sortCol = aSort[i];

		// Load the data needed for the sort, for each cell
		_fnSortData( oSettings, sortCol.col );
	}

	/* No sorting required if server-side or no sorting array */
	if ( _fnDataSource( oSettings ) != 'ssp' && aSort.length !== 0 )
	{
		// Reset the initial positions on each pass so we get a stable sort
		for ( i=0, iLen=displayMaster.length ; i<iLen ; i++ ) {
			aiOrig[ i ] = i;
		}

		// If the first sort is desc, then reverse the array to preserve original
		// order, just in reverse
		if (aSort.length && aSort[0].dir === 'desc' && oSettings.orderDescReverse) {
			aiOrig.reverse();
		}

		/* Do the sort - here we want multi-column sorting based on a given data source (column)
		 * and sorting function (from oSort) in a certain direction. It's reasonably complex to
		 * follow on it's own, but this is what we want (example two column sorting):
		 *  fnLocalSorting = function(a,b){
		 *    var test;
		 *    test = oSort['string-asc']('data11', 'data12');
		 *      if (test !== 0)
		 *        return test;
		 *    test = oSort['numeric-desc']('data21', 'data22');
		 *    if (test !== 0)
		 *      return test;
		 *    return oSort['numeric-asc']( aiOrig[a], aiOrig[b] );
		 *  }
		 * Basically we have a test for each sorting column, if the data in that column is equal,
		 * test the next column. If all columns match, then we use a numeric sort on the row
		 * positions in the original data array to provide a stable sort.
		 */
		displayMaster.sort( function ( a, b ) {
			var
				x, y, k, test, sort,
				len=aSort.length,
				dataA = aoData[a]._aSortData,
				dataB = aoData[b]._aSortData;

			for ( k=0 ; k<len ; k++ ) {
				sort = aSort[k];

				// Data, which may have already been through a `-pre` function
				x = dataA[ sort.col ];
				y = dataB[ sort.col ];

				if (sort.sorter) {
					// If there is a custom sorter (`-asc` or `-desc`) for this
					// data type, use it
					test = sort.sorter(x, y);

					if ( test !== 0 ) {
						return test;
					}
				}
				else {
					// Otherwise, use generic sorting
					test = x<y ? -1 : x>y ? 1 : 0;

					if ( test !== 0 ) {
						return sort.dir === 'asc' ? test : -test;
					}
				}
			}

			x = aiOrig[a];
			y = aiOrig[b];

			return x<y ? -1 : x>y ? 1 : 0;
		} );
	}
	else if ( aSort.length === 0 ) {
		// Apply index order
		displayMaster.sort(function (x, y) {
			return x<y ? -1 : x>y ? 1 : 0;
		});
	}

	if (col === undefined) {
		// Tell the draw function that we have sorted the data
		oSettings.bSorted = true;
		oSettings.sortDetails = aSort;

		_fnCallbackFire( oSettings, null, 'order', [oSettings, aSort] );
	}

	return displayMaster;
}


/**
 * Function to run on user sort request
 *  @param {object} settings dataTables settings object
 *  @param {node} attachTo node to attach the handler to
 *  @param {int} colIdx column sorting index
 *  @param {int} addIndex Counter
 *  @param {boolean} [shift=false] Shift click add
 *  @param {function} [callback] callback function
 *  @memberof DataTable#oApi
 */
function _fnSortAdd ( settings, colIdx, addIndex, shift )
{
	var col = settings.aoColumns[ colIdx ];
	var sorting = settings.aaSorting;
	var asSorting = col.asSorting;
	var nextSortIdx;
	var next = function ( a, overflow ) {
		var idx = a._idx;
		if ( idx === undefined ) {
			idx = asSorting.indexOf(a[1]);
		}

		return idx+1 < asSorting.length ?
			idx+1 :
			overflow ?
				null :
				0;
	};

	if ( ! col.bSortable ) {
		return false;
	}

	// Convert to 2D array if needed
	if ( typeof sorting[0] === 'number' ) {
		sorting = settings.aaSorting = [ sorting ];
	}

	// If appending the sort then we are multi-column sorting
	if ( (shift || addIndex) && settings.oFeatures.bSortMulti ) {
		// Are we already doing some kind of sort on this column?
		var sortIdx = _pluck(sorting, '0').indexOf(colIdx);

		if ( sortIdx !== -1 ) {
			// Yes, modify the sort
			nextSortIdx = next( sorting[sortIdx], true );

			if ( nextSortIdx === null && sorting.length === 1 ) {
				nextSortIdx = 0; // can't remove sorting completely
			}

			if ( nextSortIdx === null ) {
				sorting.splice( sortIdx, 1 );
			}
			else {
				sorting[sortIdx][1] = asSorting[ nextSortIdx ];
				sorting[sortIdx]._idx = nextSortIdx;
			}
		}
		else if (shift) {
			// No sort on this column yet, being added by shift click
			// add it as itself
			sorting.push( [ colIdx, asSorting[0], 0 ] );
			sorting[sorting.length-1]._idx = 0;
		}
		else {
			// No sort on this column yet, being added from a colspan
			// so add with same direction as first column
			sorting.push( [ colIdx, sorting[0][1], 0 ] );
			sorting[sorting.length-1]._idx = 0;
		}
	}
	else if ( sorting.length && sorting[0][0] == colIdx ) {
		// Single column - already sorting on this column, modify the sort
		nextSortIdx = next( sorting[0] );

		sorting.length = 1;
		sorting[0][1] = asSorting[ nextSortIdx ];
		sorting[0]._idx = nextSortIdx;
	}
	else {
		// Single column - sort only on this column
		sorting.length = 0;
		sorting.push( [ colIdx, asSorting[0] ] );
		sorting[0]._idx = 0;
	}
}


/**
 * Set the sorting classes on table's body, Note: it is safe to call this function
 * when bSort and bSortClasses are false
 *  @param {object} oSettings dataTables settings object
 *  @memberof DataTable#oApi
 */
function _fnSortingClasses( settings )
{
	var oldSort = settings.aLastSort;
	var sortClass = settings.oClasses.order.position;
	var sort = _fnSortFlatten( settings );
	var features = settings.oFeatures;
	var i, ien, colIdx;

	if ( features.bSort && features.bSortClasses ) {
		// Remove old sorting classes
		for ( i=0, ien=oldSort.length ; i<ien ; i++ ) {
			colIdx = oldSort[i].src;

			// Remove column sorting
			$( _pluck( settings.aoData, 'anCells', colIdx ) )
				.removeClass( sortClass + (i<2 ? i+1 : 3) );
		}

		// Add new column sorting
		for ( i=0, ien=sort.length ; i<ien ; i++ ) {
			colIdx = sort[i].src;

			$( _pluck( settings.aoData, 'anCells', colIdx ) )
				.addClass( sortClass + (i<2 ? i+1 : 3) );
		}
	}

	settings.aLastSort = sort;
}


// Get the data to sort a column, be it from cache, fresh (populating the
// cache), or from a sort formatter
function _fnSortData( settings, colIdx )
{
	// Custom sorting function - provided by the sort data type
	var column = settings.aoColumns[ colIdx ];
	var customSort = DataTable.ext.order[ column.sSortDataType ];
	var customData;

	if ( customSort ) {
		customData = customSort.call( settings.oInstance, settings, colIdx,
			_fnColumnIndexToVisible( settings, colIdx )
		);
	}

	// Use / populate cache
	var row, cellData;
	var formatter = DataTable.ext.type.order[ column.sType+"-pre" ];
	var data = settings.aoData;

	for ( var rowIdx=0 ; rowIdx<data.length ; rowIdx++ ) {
		// Sparse array
		if (! data[rowIdx]) {
			continue;
		}

		row = data[rowIdx];

		if ( ! row._aSortData ) {
			row._aSortData = [];
		}

		if ( ! row._aSortData[colIdx] || customSort ) {
			cellData = customSort ?
				customData[rowIdx] : // If there was a custom sort function, use data from there
				_fnGetCellData( settings, rowIdx, colIdx, 'sort' );

			row._aSortData[ colIdx ] = formatter ?
				formatter( cellData, settings ) :
				cellData;
		}
	}
}


/**
 * State information for a table
 *
 * @param {*} settings
 * @returns State object
 */
function _fnSaveState ( settings )
{
	if (settings._bLoadingState) {
		return;
	}

	// Sort state saving uses [[idx, order]] structure.
	var sorting = [];
	_fnSortResolve(settings, sorting, settings.aaSorting );

	/* Store the interesting variables */
	var columns = settings.aoColumns;
	var state = {
		time:    +new Date(),
		start:   settings._iDisplayStart,
		length:  settings._iDisplayLength,
		order:   sorting.map(function (sort) {
			// If a column name is available, use it
			return columns[sort[0]] && columns[sort[0]].sName
				? [ columns[sort[0]].sName, sort[1] ]
				: sort.slice();
		} ),
		search:  $.extend({}, settings.oPreviousSearch),
		columns: settings.aoColumns.map( function ( col, i ) {
			return {
				name: col.sName,
				visible: col.bVisible,
				search: $.extend({}, settings.aoPreSearchCols[i])
			};
		} )
	};

	settings.oSavedState = state;
	_fnCallbackFire( settings, "aoStateSaveParams", 'stateSaveParams', [settings, state] );
	
	if ( settings.oFeatures.bStateSave && !settings.bDestroying )
	{
		settings.fnStateSaveCallback.call( settings.oInstance, settings, state );
	}	
}


/**
 * Attempt to load a saved table state
 *  @param {object} oSettings dataTables settings object
 *  @param {object} oInit DataTables init object so we can override settings
 *  @param {function} callback Callback to execute when the state has been loaded
 *  @memberof DataTable#oApi
 */
function _fnLoadState ( settings, init, callback )
{
	if ( ! settings.oFeatures.bStateSave ) {
		callback();
		return;
	}

	var loaded = function(state) {
		_fnImplementState(settings, state, callback);
	}

	var state = settings.fnStateLoadCallback.call( settings.oInstance, settings, loaded );

	if ( state !== undefined ) {
		_fnImplementState( settings, state, callback );
	}
	// otherwise, wait for the loaded callback to be executed

	return true;
}

function _fnImplementState ( settings, s, callback) {
	var i, ien;
	var columns = settings.aoColumns;
	var currentNames = _pluck(settings.aoColumns, 'sName');

	settings._bLoadingState = true;

	// When StateRestore was introduced the state could now be implemented at any time
	// Not just initialisation. To do this an api instance is required in some places
	var api = settings._bInitComplete ? new DataTable.Api(settings) : null;

	if ( ! s || ! s.time ) {
		settings._bLoadingState = false;
		callback();
		return;
	}

	// Reject old data
	var duration = settings.iStateDuration;
	if ( duration > 0 && s.time < +new Date() - (duration*1000) ) {
		settings._bLoadingState = false;
		callback();
		return;
	}

	// Allow custom and plug-in manipulation functions to alter the saved data set and
	// cancelling of loading by returning false
	var abStateLoad = _fnCallbackFire( settings, 'aoStateLoadParams', 'stateLoadParams', [settings, s] );
	if ( abStateLoad.indexOf(false) !== -1 ) {
		settings._bLoadingState = false;
		callback();
		return;
	}

	// Store the saved state so it might be accessed at any time
	settings.oLoadedState = $.extend( true, {}, s );

	// This is needed for ColReorder, which has to happen first to allow all
	// the stored indexes to be usable. It is not publicly documented.
	_fnCallbackFire( settings, null, 'stateLoadInit', [settings, s], true );

	// Page Length
	if ( s.length !== undefined ) {
		// If already initialised just set the value directly so that the select element is also updated
		if (api) {
			api.page.len(s.length)
		}
		else {
			settings._iDisplayLength   = s.length;
		}
	}

	// Restore key features
	if ( s.start !== undefined ) {
		if(api === null) {
			settings._iDisplayStart    = s.start;
			settings.iInitDisplayStart = s.start;
		}
		else {
			_fnPageChange(settings, s.start/settings._iDisplayLength);
		}
	}

	// Order
	if ( s.order !== undefined ) {
		settings.aaSorting = [];
		$.each( s.order, function ( i, col ) {
			var set = [ col[0], col[1] ];

			// A column name was stored and should be used for restore
			if (typeof col[0] === 'string') {
				// Find the name from the current list of column names
				var idx = currentNames.indexOf(col[0]);

				if (idx < 0) {
					// If the column was not found ignore it and continue
					return;
				}

				set[0] = idx;
			}
			else if (set[0] >= columns.length) {
				// If the column index is out of bounds ignore it and continue
				return;
			}

			settings.aaSorting.push(set);
		} );
	}

	// Search
	if ( s.search !== undefined ) {
		$.extend( settings.oPreviousSearch, s.search );
	}

	// Columns
	if ( s.columns ) {
		var set = s.columns;
		var incoming = _pluck(s.columns, 'name');

		// Check if it is a 2.2 style state object with a `name` property for the columns, and if
		// the name was defined. If so, then create a new array that will map the state object
		// given, to the current columns (don't bother if they are already matching tho).
		if (incoming.join('').length && incoming.join('') !== currentNames.join('')) {
			set = [];

			// For each column, try to find the name in the incoming array
			for (i=0 ; i<currentNames.length ; i++) {
				if (currentNames[i] != '') {
					var idx = incoming.indexOf(currentNames[i]);

					if (idx >= 0) {
						set.push(s.columns[idx]);
					}
					else {
						// No matching column name in the state's columns, so this might be a new
						// column and thus can't have a state already.
						set.push({});
					}
				}
				else {
					// If no name, but other columns did have a name, then there is no knowing
					// where this one came from originally so it can't be restored.
					set.push({});
				}
			}
		}

		// If the number of columns to restore is different from current, then all bets are off.
		if (set.length === columns.length) {
			for ( i=0, ien=set.length ; i<ien ; i++ ) {
				var col = set[i];

				// Visibility
				if ( col.visible !== undefined ) {
					// If the api is defined, the table has been initialised so we need to use it rather than internal settings
					if (api) {
						// Don't redraw the columns on every iteration of this loop, we will do this at the end instead
						api.column(i).visible(col.visible, false);
					}
					else {
						columns[i].bVisible = col.visible;
					}
				}

				// Search
				if ( col.search !== undefined ) {
					$.extend( settings.aoPreSearchCols[i], col.search );
				}
			}

			// If the api is defined then we need to adjust the columns once the visibility has been changed
			if (api) {
				api.columns.adjust();
			}
		}
	}

	settings._bLoadingState = false;
	_fnCallbackFire( settings, 'aoStateLoaded', 'stateLoaded', [settings, s] );
	callback();
}

/**
 * Log an error message
 *  @param {object} settings dataTables settings object
 *  @param {int} level log error messages, or display them to the user
 *  @param {string} msg error message
 *  @param {int} tn Technical note id to get more information about the error.
 *  @memberof DataTable#oApi
 */
function _fnLog( settings, level, msg, tn )
{
	msg = 'DataTables warning: '+
		(settings ? 'table id='+settings.sTableId+' - ' : '')+msg;

	if ( tn ) {
		msg += '. For more information about this error, please see '+
		'https://datatables.net/tn/'+tn;
	}

	if ( ! level  ) {
		// Backwards compatibility pre 1.10
		var ext = DataTable.ext;
		var type = ext.sErrMode || ext.errMode;

		if ( settings ) {
			_fnCallbackFire( settings, null, 'dt-error', [ settings, tn, msg ], true );
		}

		if ( type == 'alert' ) {
			alert( msg );
		}
		else if ( type == 'throw' ) {
			throw new Error(msg);
		}
		else if ( typeof type == 'function' ) {
			type( settings, tn, msg );
		}
	}
	else if ( window.console && console.log ) {
		console.log( msg );
	}
}


/**
 * See if a property is defined on one object, if so assign it to the other object
 *  @param {object} ret target object
 *  @param {object} src source object
 *  @param {string} name property
 *  @param {string} [mappedName] name to map too - optional, name used if not given
 *  @memberof DataTable#oApi
 */
function _fnMap( ret, src, name, mappedName )
{
	if ( Array.isArray( name ) ) {
		$.each( name, function (i, val) {
			if ( Array.isArray( val ) ) {
				_fnMap( ret, src, val[0], val[1] );
			}
			else {
				_fnMap( ret, src, val );
			}
		} );

		return;
	}

	if ( mappedName === undefined ) {
		mappedName = name;
	}

	if ( src[name] !== undefined ) {
		ret[mappedName] = src[name];
	}
}


/**
 * Extend objects - very similar to jQuery.extend, but deep copy objects, and
 * shallow copy arrays. The reason we need to do this, is that we don't want to
 * deep copy array init values (such as aaSorting) since the dev wouldn't be
 * able to override them, but we do want to deep copy arrays.
 *  @param {object} out Object to extend
 *  @param {object} extender Object from which the properties will be applied to
 *      out
 *  @param {boolean} breakRefs If true, then arrays will be sliced to take an
 *      independent copy with the exception of the `data` or `aaData` parameters
 *      if they are present. This is so you can pass in a collection to
 *      DataTables and have that used as your data source without breaking the
 *      references
 *  @returns {object} out Reference, just for convenience - out === the return.
 *  @memberof DataTable#oApi
 *  @todo This doesn't take account of arrays inside the deep copied objects.
 */
function _fnExtend( out, extender, breakRefs )
{
	var val;

	for ( var prop in extender ) {
		if ( Object.prototype.hasOwnProperty.call(extender, prop) ) {
			val = extender[prop];

			if ( $.isPlainObject( val ) ) {
				if ( ! $.isPlainObject( out[prop] ) ) {
					out[prop] = {};
				}
				$.extend( true, out[prop], val );
			}
			else if ( breakRefs && prop !== 'data' && prop !== 'aaData' && Array.isArray(val) ) {
				out[prop] = val.slice();
			}
			else {
				out[prop] = val;
			}
		}
	}

	return out;
}


/**
 * Bind an event handers to allow a click or return key to activate the callback.
 * This is good for accessibility since a return on the keyboard will have the
 * same effect as a click, if the element has focus.
 *  @param {element} n Element to bind the action to
 *  @param {object|string} selector Selector (for delegated events) or data object
 *   to pass to the triggered function
 *  @param {function} fn Callback function for when the event is triggered
 *  @memberof DataTable#oApi
 */
function _fnBindAction( n, selector, fn )
{
	$(n)
		.on( 'click.DT', selector, function (e) {
			fn(e);
		} )
		.on( 'keypress.DT', selector, function (e){
			if ( e.which === 13 ) {
				e.preventDefault();
				fn(e);
			}
		} )
		.on( 'selectstart.DT', selector, function () {
			// Don't want a double click resulting in text selection
			return false;
		} );
}


/**
 * Register a callback function. Easily allows a callback function to be added to
 * an array store of callback functions that can then all be called together.
 *  @param {object} settings dataTables settings object
 *  @param {string} store Name of the array storage for the callbacks in oSettings
 *  @param {function} fn Function to be called back
 *  @memberof DataTable#oApi
 */
function _fnCallbackReg( settings, store, fn )
{
	if ( fn ) {
		settings[store].push(fn);
	}
}


/**
 * Fire callback functions and trigger events. Note that the loop over the
 * callback array store is done backwards! Further note that you do not want to
 * fire off triggers in time sensitive applications (for example cell creation)
 * as its slow.
 *  @param {object} settings dataTables settings object
 *  @param {string} callbackArr Name of the array storage for the callbacks in
 *      oSettings
 *  @param {string} eventName Name of the jQuery custom event to trigger. If
 *      null no trigger is fired
 *  @param {array} args Array of arguments to pass to the callback function /
 *      trigger
 *  @param {boolean} [bubbles] True if the event should bubble
 *  @memberof DataTable#oApi
 */
function _fnCallbackFire( settings, callbackArr, eventName, args, bubbles )
{
	var ret = [];

	if ( callbackArr ) {
		ret = settings[callbackArr].slice().reverse().map( function (val) {
			return val.apply( settings.oInstance, args );
		} );
	}

	if ( eventName !== null) {
		var e = $.Event( eventName+'.dt' );
		var table = $(settings.nTable);
		
		// Expose the DataTables API on the event object for easy access
		e.dt = settings.api;

		table[bubbles ?  'trigger' : 'triggerHandler']( e, args );

		// If not yet attached to the document, trigger the event
		// on the body directly to sort of simulate the bubble
		if (bubbles && table.parents('body').length === 0) {
			$('body').trigger( e, args );
		}

		ret.push( e.result );
	}

	return ret;
}


function _fnLengthOverflow ( settings )
{
	var
		start = settings._iDisplayStart,
		end = settings.fnDisplayEnd(),
		len = settings._iDisplayLength;

	/* If we have space to show extra rows (backing up from the end point - then do so */
	if ( start >= end )
	{
		start = end - len;
	}

	// Keep the start record on the current page
	start -= (start % len);

	if ( len === -1 || start < 0 )
	{
		start = 0;
	}

	settings._iDisplayStart = start;
}


function _fnRenderer( settings, type )
{
	var renderer = settings.renderer;
	var host = DataTable.ext.renderer[type];

	if ( $.isPlainObject( renderer ) && renderer[type] ) {
		// Specific renderer for this type. If available use it, otherwise use
		// the default.
		return host[renderer[type]] || host._;
	}
	else if ( typeof renderer === 'string' ) {
		// Common renderer - if there is one available for this type use it,
		// otherwise use the default
		return host[renderer] || host._;
	}

	// Use the default
	return host._;
}


/**
 * Detect the data source being used for the table. Used to simplify the code
 * a little (ajax) and to make it compress a little smaller.
 *
 *  @param {object} settings dataTables settings object
 *  @returns {string} Data source
 *  @memberof DataTable#oApi
 */
function _fnDataSource ( settings )
{
	if ( settings.oFeatures.bServerSide ) {
		return 'ssp';
	}
	else if ( settings.ajax ) {
		return 'ajax';
	}
	return 'dom';
}

/**
 * Common replacement for language strings
 *
 * @param {*} settings DT settings object
 * @param {*} str String with values to replace
 * @param {*} entries Plural number for _ENTRIES_ - can be undefined
 * @returns String
 */
function _fnMacros ( settings, str, entries )
{
	// When infinite scrolling, we are always starting at 1. _iDisplayStart is
	// used only internally
	var
		formatter  = settings.fnFormatNumber,
		start      = settings._iDisplayStart+1,
		len        = settings._iDisplayLength,
		vis        = settings.fnRecordsDisplay(),
		max        = settings.fnRecordsTotal(),
		all        = len === -1;

	return str.
		replace(/_START_/g, formatter.call( settings, start ) ).
		replace(/_END_/g,   formatter.call( settings, settings.fnDisplayEnd() ) ).
		replace(/_MAX_/g,   formatter.call( settings, max ) ).
		replace(/_TOTAL_/g, formatter.call( settings, vis ) ).
		replace(/_PAGE_/g,  formatter.call( settings, all ? 1 : Math.ceil( start / len ) ) ).
		replace(/_PAGES_/g, formatter.call( settings, all ? 1 : Math.ceil( vis / len ) ) ).
		replace(/_ENTRIES_/g, settings.api.i18n('entries', '', entries) ).
		replace(/_ENTRIES-MAX_/g, settings.api.i18n('entries', '', max) ).
		replace(/_ENTRIES-TOTAL_/g, settings.api.i18n('entries', '', vis) );
}

/**
 * Add elements to an array as quickly as possible, but stack stafe.
 *
 * @param {*} arr Array to add the data to
 * @param {*} data Data array that is to be added
 * @returns 
 */
function _fnArrayApply(arr, data) {
	if (! data) {
		return;
	}

	// Chrome can throw a max stack error if apply is called with
	// too large an array, but apply is faster.
	if (data.length < 10000) {
		arr.push.apply(arr, data);
	}
	else {
		for (i=0 ; i<data.length ; i++) {
			arr.push(data[i]);
		}
	}
}

/**
 * Add one or more listeners to the table
 *
 * @param {*} that JQ for the table
 * @param {*} name Event name
 * @param {*} src Listener(s)
 */
function _fnListener(that, name, src) {
	if (!Array.isArray(src)) {
		src = [src];
	}

	for (i=0 ; i<src.length ; i++) {
		that.on(name + '.dt', src[i]);
	}
}



/**
 * Computed structure of the DataTables API, defined by the options passed to
 * `DataTable.Api.register()` when building the API.
 *
 * The structure is built in order to speed creation and extension of the Api
 * objects since the extensions are effectively pre-parsed.
 *
 * The array is an array of objects with the following structure, where this
 * base array represents the Api prototype base:
 *
 *     [
 *       {
 *         name:      'data'                -- string   - Property name
 *         val:       function () {},       -- function - Api method (or undefined if just an object
 *         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result
 *         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property
 *       },
 *       {
 *         name:     'row'
 *         val:       {},
 *         methodExt: [ ... ],
 *         propExt:   [
 *           {
 *             name:      'data'
 *             val:       function () {},
 *             methodExt: [ ... ],
 *             propExt:   [ ... ]
 *           },
 *           ...
 *         ]
 *       }
 *     ]
 *
 * @type {Array}
 * @ignore
 */
var __apiStruct = [];


/**
 * `Array.prototype` reference.
 *
 * @type object
 * @ignore
 */
var __arrayProto = Array.prototype;


/**
 * Abstraction for `context` parameter of the `Api` constructor to allow it to
 * take several different forms for ease of use.
 *
 * Each of the input parameter types will be converted to a DataTables settings
 * object where possible.
 *
 * @param  {string|node|jQuery|object} mixed DataTable identifier. Can be one
 *   of:
 *
 *   * `string` - jQuery selector. Any DataTables' matching the given selector
 *     with be found and used.
 *   * `node` - `TABLE` node which has already been formed into a DataTable.
 *   * `jQuery` - A jQuery object of `TABLE` nodes.
 *   * `object` - DataTables settings object
 *   * `DataTables.Api` - API instance
 * @return {array|null} Matching DataTables settings objects. `null` or
 *   `undefined` is returned if no matching DataTable is found.
 * @ignore
 */
var _toSettings = function ( mixed )
{
	var idx, jq;
	var settings = DataTable.settings;
	var tables = _pluck(settings, 'nTable');

	if ( ! mixed ) {
		return [];
	}
	else if ( mixed.nTable && mixed.oFeatures ) {
		// DataTables settings object
		return [ mixed ];
	}
	else if ( mixed.nodeName && mixed.nodeName.toLowerCase() === 'table' ) {
		// Table node
		idx = tables.indexOf(mixed);
		return idx !== -1 ? [ settings[idx] ] : null;
	}
	else if ( mixed && typeof mixed.settings === 'function' ) {
		return mixed.settings().toArray();
	}
	else if ( typeof mixed === 'string' ) {
		// jQuery selector
		jq = $(mixed).get();
	}
	else if ( mixed instanceof $ ) {
		// jQuery object (also DataTables instance)
		jq = mixed.get();
	}

	if ( jq ) {
		return settings.filter(function (v, idx) {
			return jq.includes(tables[idx]);
		});
	}
};


/**
 * DataTables API class - used to control and interface with  one or more
 * DataTables enhanced tables.
 *
 * The API class is heavily based on jQuery, presenting a chainable interface
 * that you can use to interact with tables. Each instance of the API class has
 * a "context" - i.e. the tables that it will operate on. This could be a single
 * table, all tables on a page or a sub-set thereof.
 *
 * Additionally the API is designed to allow you to easily work with the data in
 * the tables, retrieving and manipulating it as required. This is done by
 * presenting the API class as an array like interface. The contents of the
 * array depend upon the actions requested by each method (for example
 * `rows().nodes()` will return an array of nodes, while `rows().data()` will
 * return an array of objects or arrays depending upon your table's
 * configuration). The API object has a number of array like methods (`push`,
 * `pop`, `reverse` etc) as well as additional helper methods (`each`, `pluck`,
 * `unique` etc) to assist your working with the data held in a table.
 *
 * Most methods (those which return an Api instance) are chainable, which means
 * the return from a method call also has all of the methods available that the
 * top level object had. For example, these two calls are equivalent:
 *
 *     // Not chained
 *     api.row.add( {...} );
 *     api.draw();
 *
 *     // Chained
 *     api.row.add( {...} ).draw();
 *
 * @class DataTable.Api
 * @param {array|object|string|jQuery} context DataTable identifier. This is
 *   used to define which DataTables enhanced tables this API will operate on.
 *   Can be one of:
 *
 *   * `string` - jQuery selector. Any DataTables' matching the given selector
 *     with be found and used.
 *   * `node` - `TABLE` node which has already been formed into a DataTable.
 *   * `jQuery` - A jQuery object of `TABLE` nodes.
 *   * `object` - DataTables settings object
 * @param {array} [data] Data to initialise the Api instance with.
 *
 * @example
 *   // Direct initialisation during DataTables construction
 *   var api = $('#example').DataTable();
 *
 * @example
 *   // Initialisation using a DataTables jQuery object
 *   var api = $('#example').dataTable().api();
 *
 * @example
 *   // Initialisation as a constructor
 *   var api = new DataTable.Api( 'table.dataTable' );
 */
_Api = function ( context, data )
{
	if ( ! (this instanceof _Api) ) {
		return new _Api( context, data );
	}

	var i;
	var settings = [];
	var ctxSettings = function ( o ) {
		var a = _toSettings( o );
		if ( a ) {
			settings.push.apply( settings, a );
		}
	};

	if ( Array.isArray( context ) ) {
		for ( i=0 ; i<context.length ; i++ ) {
			ctxSettings( context[i] );
		}
	}
	else {
		ctxSettings( context );
	}

	// Remove duplicates
	this.context = settings.length > 1
		? _unique( settings )
		: settings;

	// Initial data
	_fnArrayApply(this, data);

	// selector
	this.selector = {
		rows: null,
		cols: null,
		opts: null
	};

	_Api.extend( this, this, __apiStruct );
};

DataTable.Api = _Api;

// Don't destroy the existing prototype, just extend it. Required for jQuery 2's
// isPlainObject.
$.extend( _Api.prototype, {
	any: function ()
	{
		return this.count() !== 0;
	},

	context: [], // array of table settings objects

	count: function ()
	{
		return this.flatten().length;
	},

	each: function ( fn )
	{
		for ( var i=0, ien=this.length ; i<ien; i++ ) {
			fn.call( this, this[i], i, this );
		}

		return this;
	},

	eq: function ( idx )
	{
		var ctx = this.context;

		return ctx.length > idx ?
			new _Api( ctx[idx], this[idx] ) :
			null;
	},

	filter: function ( fn )
	{
		var a = __arrayProto.filter.call( this, fn, this );

		return new _Api( this.context, a );
	},

	flatten: function ()
	{
		var a = [];

		return new _Api( this.context, a.concat.apply( a, this.toArray() ) );
	},

	get: function ( idx )
	{
		return this[ idx ];
	},

	join:    __arrayProto.join,

	includes: function ( find ) {
		return this.indexOf( find ) === -1 ? false : true;
	},

	indexOf: __arrayProto.indexOf,

	iterator: function ( flatten, type, fn, alwaysNew ) {
		var
			a = [], ret,
			i, ien, j, jen,
			context = this.context,
			rows, items, item,
			selector = this.selector;

		// Argument shifting
		if ( typeof flatten === 'string' ) {
			alwaysNew = fn;
			fn = type;
			type = flatten;
			flatten = false;
		}

		for ( i=0, ien=context.length ; i<ien ; i++ ) {
			var apiInst = new _Api( context[i] );

			if ( type === 'table' ) {
				ret = fn.call( apiInst, context[i], i );

				if ( ret !== undefined ) {
					a.push( ret );
				}
			}
			else if ( type === 'columns' || type === 'rows' ) {
				// this has same length as context - one entry for each table
				ret = fn.call( apiInst, context[i], this[i], i );

				if ( ret !== undefined ) {
					a.push( ret );
				}
			}
			else if ( type === 'every' || type === 'column' || type === 'column-rows' || type === 'row' || type === 'cell' ) {
				// columns and rows share the same structure.
				// 'this' is an array of column indexes for each context
				items = this[i];

				if ( type === 'column-rows' ) {
					rows = _selector_row_indexes( context[i], selector.opts );
				}

				for ( j=0, jen=items.length ; j<jen ; j++ ) {
					item = items[j];

					if ( type === 'cell' ) {
						ret = fn.call( apiInst, context[i], item.row, item.column, i, j );
					}
					else {
						ret = fn.call( apiInst, context[i], item, i, j, rows );
					}

					if ( ret !== undefined ) {
						a.push( ret );
					}
				}
			}
		}

		if ( a.length || alwaysNew ) {
			var api = new _Api( context, flatten ? a.concat.apply( [], a ) : a );
			var apiSelector = api.selector;
			apiSelector.rows = selector.rows;
			apiSelector.cols = selector.cols;
			apiSelector.opts = selector.opts;
			return api;
		}
		return this;
	},

	lastIndexOf: __arrayProto.lastIndexOf,

	length:  0,

	map: function ( fn )
	{
		var a = __arrayProto.map.call( this, fn, this );

		return new _Api( this.context, a );
	},

	pluck: function ( prop )
	{
		var fn = DataTable.util.get(prop);

		return this.map( function ( el ) {
			return fn(el);
		} );
	},

	pop:     __arrayProto.pop,

	push:    __arrayProto.push,

	reduce: __arrayProto.reduce,

	reduceRight: __arrayProto.reduceRight,

	reverse: __arrayProto.reverse,

	// Object with rows, columns and opts
	selector: null,

	shift:   __arrayProto.shift,

	slice: function () {
		return new _Api( this.context, this );
	},

	sort:    __arrayProto.sort,

	splice:  __arrayProto.splice,

	toArray: function ()
	{
		return __arrayProto.slice.call( this );
	},

	to$: function ()
	{
		return $( this );
	},

	toJQuery: function ()
	{
		return $( this );
	},

	unique: function ()
	{
		return new _Api( this.context, _unique(this.toArray()) );
	},

	unshift: __arrayProto.unshift
} );


function _api_scope( scope, fn, struc ) {
	return function () {
		var ret = fn.apply( scope || this, arguments );

		// Method extension
		_Api.extend( ret, ret, struc.methodExt );
		return ret;
	};
}

function _api_find( src, name ) {
	for ( var i=0, ien=src.length ; i<ien ; i++ ) {
		if ( src[i].name === name ) {
			return src[i];
		}
	}
	return null;
}

window.__apiStruct = __apiStruct;

_Api.extend = function ( scope, obj, ext )
{
	// Only extend API instances and static properties of the API
	if ( ! ext.length || ! obj || ( ! (obj instanceof _Api) && ! obj.__dt_wrapper ) ) {
		return;
	}

	var
		i, ien,
		struct;

	for ( i=0, ien=ext.length ; i<ien ; i++ ) {
		struct = ext[i];

		if (struct.name === '__proto__') {
			continue;
		}

		// Value
		obj[ struct.name ] = struct.type === 'function' ?
			_api_scope( scope, struct.val, struct ) :
			struct.type === 'object' ?
				{} :
				struct.val;

		obj[ struct.name ].__dt_wrapper = true;

		// Property extension
		_Api.extend( scope, obj[ struct.name ], struct.propExt );
	}
};

//     [
//       {
//         name:      'data'                -- string   - Property name
//         val:       function () {},       -- function - Api method (or undefined if just an object
//         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result
//         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property
//       },
//       {
//         name:     'row'
//         val:       {},
//         methodExt: [ ... ],
//         propExt:   [
//           {
//             name:      'data'
//             val:       function () {},
//             methodExt: [ ... ],
//             propExt:   [ ... ]
//           },
//           ...
//         ]
//       }
//     ]


_Api.register = _api_register = function ( name, val )
{
	if ( Array.isArray( name ) ) {
		for ( var j=0, jen=name.length ; j<jen ; j++ ) {
			_Api.register( name[j], val );
		}
		return;
	}

	var
		i, ien,
		heir = name.split('.'),
		struct = __apiStruct,
		key, method;

	for ( i=0, ien=heir.length ; i<ien ; i++ ) {
		method = heir[i].indexOf('()') !== -1;
		key = method ?
			heir[i].replace('()', '') :
			heir[i];

		var src = _api_find( struct, key );
		if ( ! src ) {
			src = {
				name:      key,
				val:       {},
				methodExt: [],
				propExt:   [],
				type:      'object'
			};
			struct.push( src );
		}

		if ( i === ien-1 ) {
			src.val = val;
			src.type = typeof val === 'function' ?
				'function' :
				$.isPlainObject( val ) ?
					'object' :
					'other';
		}
		else {
			struct = method ?
				src.methodExt :
				src.propExt;
		}
	}
};

_Api.registerPlural = _api_registerPlural = function ( pluralName, singularName, val ) {
	_Api.register( pluralName, val );

	_Api.register( singularName, function () {
		var ret = val.apply( this, arguments );

		if ( ret === this ) {
			// Returned item is the API instance that was passed in, return it
			return this;
		}
		else if ( ret instanceof _Api ) {
			// New API instance returned, want the value from the first item
			// in the returned array for the singular result.
			return ret.length ?
				Array.isArray( ret[0] ) ?
					new _Api( ret.context, ret[0] ) : // Array results are 'enhanced'
					ret[0] :
				undefined;
		}

		// Non-API return - just fire it back
		return ret;
	} );
};


/**
 * Selector for HTML tables. Apply the given selector to the give array of
 * DataTables settings objects.
 *
 * @param {string|integer} [selector] jQuery selector string or integer
 * @param  {array} Array of DataTables settings objects to be filtered
 * @return {array}
 * @ignore
 */
var __table_selector = function ( selector, a )
{
	if ( Array.isArray(selector) ) {
		var result = [];

		selector.forEach(function (sel) {
			var inner = __table_selector(sel, a);

			_fnArrayApply(result, inner);
		});

		return result.filter( function (item) {
			return item;
		});
	}

	// Integer is used to pick out a table by index
	if ( typeof selector === 'number' ) {
		return [ a[ selector ] ];
	}

	// Perform a jQuery selector on the table nodes
	var nodes = a.map( function (el) {
		return el.nTable;
	} );

	return $(nodes)
		.filter( selector )
		.map( function () {
			// Need to translate back from the table node to the settings
			var idx = nodes.indexOf(this);
			return a[ idx ];
		} )
		.toArray();
};



/**
 * Context selector for the API's context (i.e. the tables the API instance
 * refers to.
 *
 * @name    DataTable.Api#tables
 * @param {string|integer} [selector] Selector to pick which tables the iterator
 *   should operate on. If not given, all tables in the current context are
 *   used. This can be given as a jQuery selector (for example `':gt(0)'`) to
 *   select multiple tables or as an integer to select a single table.
 * @returns {DataTable.Api} Returns a new API instance if a selector is given.
 */
_api_register( 'tables()', function ( selector ) {
	// A new instance is created if there was a selector specified
	return selector !== undefined && selector !== null ?
		new _Api( __table_selector( selector, this.context ) ) :
		this;
} );


_api_register( 'table()', function ( selector ) {
	var tables = this.tables( selector );
	var ctx = tables.context;

	// Truncate to the first matched table
	return ctx.length ?
		new _Api( ctx[0] ) :
		tables;
} );

// Common methods, combined to reduce size
[
	['nodes', 'node', 'nTable'],
	['body', 'body', 'nTBody'],
	['header', 'header', 'nTHead'],
	['footer', 'footer', 'nTFoot'],
].forEach(function (item) {
	_api_registerPlural(
		'tables().' + item[0] + '()',
		'table().' + item[1] + '()' ,
		function () {
			return this.iterator( 'table', function ( ctx ) {
				return ctx[item[2]];
			}, 1 );
		}
	);
});

// Structure methods
[
	['header', 'aoHeader'],
	['footer', 'aoFooter'],
].forEach(function (item) {
	_api_register( 'table().' + item[0] + '.structure()' , function (selector) {
		var indexes = this.columns(selector).indexes().flatten().toArray();
		var ctx = this.context[0];
		var structure = _fnHeaderLayout(ctx, ctx[item[1]], indexes);

		// The structure is in column index order - but from this method we want the return to be
		// in the columns() selector API order. In order to do that we need to map from one form
		// to the other
		var orderedIndexes = indexes.slice().sort(function (a, b) {
			return a - b;
		});

		return structure.map(function (row) {
			return indexes.map(function (colIdx) {
				return row[orderedIndexes.indexOf(colIdx)];
			});
		});
	});
});


_api_registerPlural( 'tables().containers()', 'table().container()' , function () {
	return this.iterator( 'table', function ( ctx ) {
		return ctx.nTableWrapper;
	}, 1 );
} );

_api_register( 'tables().every()', function ( fn ) {
	var that = this;

	return this.iterator('table', function (s, i) {
		fn.call(that.table(i), i);
	});
});

_api_register( 'caption()', function ( value, side ) {
	var context = this.context;

	// Getter - return existing node's content
	if ( value === undefined ) {
		var caption = context[0].captionNode;

		return caption && context.length ?
			caption.innerHTML : 
			null;
	}

	return this.iterator( 'table', function ( ctx ) {
		var table = $(ctx.nTable);
		var caption = $(ctx.captionNode);
		var container = $(ctx.nTableWrapper);

		// Create the node if it doesn't exist yet
		if ( ! caption.length ) {
			caption = $('<caption/>').html( value );
			ctx.captionNode = caption[0];

			// If side isn't set, we need to insert into the document to let the
			// CSS decide so we can read it back, otherwise there is no way to
			// know if the CSS would put it top or bottom for scrolling
			if (! side) {
				table.prepend(caption);

				side = caption.css('caption-side');
			}
		}

		caption.html( value );

		if ( side ) {
			caption.css( 'caption-side', side );
			caption[0]._captionSide = side;
		}

		if (container.find('div.dataTables_scroll').length) {
			var selector = (side === 'top' ? 'Head' : 'Foot');

			container.find('div.dataTables_scroll'+ selector +' table').prepend(caption);
		}
		else {
			table.prepend(caption);
		}
	}, 1 );
} );

_api_register( 'caption.node()', function () {
	var ctx = this.context;

	return ctx.length ? ctx[0].captionNode : null;
} );


/**
 * Redraw the tables in the current context.
 */
_api_register( 'draw()', function ( paging ) {
	return this.iterator( 'table', function ( settings ) {
		if ( paging === 'page' ) {
			_fnDraw( settings );
		}
		else {
			if ( typeof paging === 'string' ) {
				paging = paging === 'full-hold' ?
					false :
					true;
			}

			_fnReDraw( settings, paging===false );
		}
	} );
} );



/**
 * Get the current page index.
 *
 * @return {integer} Current page index (zero based)
 *//**
 * Set the current page.
 *
 * Note that if you attempt to show a page which does not exist, DataTables will
 * not throw an error, but rather reset the paging.
 *
 * @param {integer|string} action The paging action to take. This can be one of:
 *  * `integer` - The page index to jump to
 *  * `string` - An action to take:
 *    * `first` - Jump to first page.
 *    * `next` - Jump to the next page
 *    * `previous` - Jump to previous page
 *    * `last` - Jump to the last page.
 * @returns {DataTables.Api} this
 */
_api_register( 'page()', function ( action ) {
	if ( action === undefined ) {
		return this.page.info().page; // not an expensive call
	}

	// else, have an action to take on all tables
	return this.iterator( 'table', function ( settings ) {
		_fnPageChange( settings, action );
	} );
} );


/**
 * Paging information for the first table in the current context.
 *
 * If you require paging information for another table, use the `table()` method
 * with a suitable selector.
 *
 * @return {object} Object with the following properties set:
 *  * `page` - Current page index (zero based - i.e. the first page is `0`)
 *  * `pages` - Total number of pages
 *  * `start` - Display index for the first record shown on the current page
 *  * `end` - Display index for the last record shown on the current page
 *  * `length` - Display length (number of records). Note that generally `start
 *    + length = end`, but this is not always true, for example if there are
 *    only 2 records to show on the final page, with a length of 10.
 *  * `recordsTotal` - Full data set length
 *  * `recordsDisplay` - Data set length once the current filtering criterion
 *    are applied.
 */
_api_register( 'page.info()', function () {
	if ( this.context.length === 0 ) {
		return undefined;
	}

	var
		settings   = this.context[0],
		start      = settings._iDisplayStart,
		len        = settings.oFeatures.bPaginate ? settings._iDisplayLength : -1,
		visRecords = settings.fnRecordsDisplay(),
		all        = len === -1;

	return {
		"page":           all ? 0 : Math.floor( start / len ),
		"pages":          all ? 1 : Math.ceil( visRecords / len ),
		"start":          start,
		"end":            settings.fnDisplayEnd(),
		"length":         len,
		"recordsTotal":   settings.fnRecordsTotal(),
		"recordsDisplay": visRecords,
		"serverSide":     _fnDataSource( settings ) === 'ssp'
	};
} );


/**
 * Get the current page length.
 *
 * @return {integer} Current page length. Note `-1` indicates that all records
 *   are to be shown.
 *//**
 * Set the current page length.
 *
 * @param {integer} Page length to set. Use `-1` to show all records.
 * @returns {DataTables.Api} this
 */
_api_register( 'page.len()', function ( len ) {
	// Note that we can't call this function 'length()' because `length`
	// is a Javascript property of functions which defines how many arguments
	// the function expects.
	if ( len === undefined ) {
		return this.context.length !== 0 ?
			this.context[0]._iDisplayLength :
			undefined;
	}

	// else, set the page length
	return this.iterator( 'table', function ( settings ) {
		_fnLengthChange( settings, len );
	} );
} );



var __reload = function ( settings, holdPosition, callback ) {
	// Use the draw event to trigger a callback
	if ( callback ) {
		var api = new _Api( settings );

		api.one( 'draw', function () {
			callback( api.ajax.json() );
		} );
	}

	if ( _fnDataSource( settings ) == 'ssp' ) {
		_fnReDraw( settings, holdPosition );
	}
	else {
		_fnProcessingDisplay( settings, true );

		// Cancel an existing request
		var xhr = settings.jqXHR;
		if ( xhr && xhr.readyState !== 4 ) {
			xhr.abort();
		}

		// Trigger xhr
		_fnBuildAjax( settings, {}, function( json ) {
			_fnClearTable( settings );

			var data = _fnAjaxDataSrc( settings, json );
			for ( var i=0, ien=data.length ; i<ien ; i++ ) {
				_fnAddData( settings, data[i] );
			}

			_fnReDraw( settings, holdPosition );
			_fnInitComplete( settings );
			_fnProcessingDisplay( settings, false );
		} );
	}
};


/**
 * Get the JSON response from the last Ajax request that DataTables made to the
 * server. Note that this returns the JSON from the first table in the current
 * context.
 *
 * @return {object} JSON received from the server.
 */
_api_register( 'ajax.json()', function () {
	var ctx = this.context;

	if ( ctx.length > 0 ) {
		return ctx[0].json;
	}

	// else return undefined;
} );


/**
 * Get the data submitted in the last Ajax request
 */
_api_register( 'ajax.params()', function () {
	var ctx = this.context;

	if ( ctx.length > 0 ) {
		return ctx[0].oAjaxData;
	}

	// else return undefined;
} );


/**
 * Reload tables from the Ajax data source. Note that this function will
 * automatically re-draw the table when the remote data has been loaded.
 *
 * @param {boolean} [reset=true] Reset (default) or hold the current paging
 *   position. A full re-sort and re-filter is performed when this method is
 *   called, which is why the pagination reset is the default action.
 * @returns {DataTables.Api} this
 */
_api_register( 'ajax.reload()', function ( callback, resetPaging ) {
	return this.iterator( 'table', function (settings) {
		__reload( settings, resetPaging===false, callback );
	} );
} );


/**
 * Get the current Ajax URL. Note that this returns the URL from the first
 * table in the current context.
 *
 * @return {string} Current Ajax source URL
 *//**
 * Set the Ajax URL. Note that this will set the URL for all tables in the
 * current context.
 *
 * @param {string} url URL to set.
 * @returns {DataTables.Api} this
 */
_api_register( 'ajax.url()', function ( url ) {
	var ctx = this.context;

	if ( url === undefined ) {
		// get
		if ( ctx.length === 0 ) {
			return undefined;
		}
		ctx = ctx[0];

		return $.isPlainObject( ctx.ajax ) ?
			ctx.ajax.url :
			ctx.ajax;
	}

	// set
	return this.iterator( 'table', function ( settings ) {
		if ( $.isPlainObject( settings.ajax ) ) {
			settings.ajax.url = url;
		}
		else {
			settings.ajax = url;
		}
	} );
} );


/**
 * Load data from the newly set Ajax URL. Note that this method is only
 * available when `ajax.url()` is used to set a URL. Additionally, this method
 * has the same effect as calling `ajax.reload()` but is provided for
 * convenience when setting a new URL. Like `ajax.reload()` it will
 * automatically redraw the table once the remote data has been loaded.
 *
 * @returns {DataTables.Api} this
 */
_api_register( 'ajax.url().load()', function ( callback, resetPaging ) {
	// Same as a reload, but makes sense to present it for easy access after a
	// url change
	return this.iterator( 'table', function ( ctx ) {
		__reload( ctx, resetPaging===false, callback );
	} );
} );




var _selector_run = function ( type, selector, selectFn, settings, opts )
{
	var
		out = [], res,
		i, ien,
		selectorType = typeof selector;

	// Can't just check for isArray here, as an API or jQuery instance might be
	// given with their array like look
	if ( ! selector || selectorType === 'string' || selectorType === 'function' || selector.length === undefined ) {
		selector = [ selector ];
	}

	for ( i=0, ien=selector.length ; i<ien ; i++ ) {
		res = selectFn( typeof selector[i] === 'string' ? selector[i].trim() : selector[i] );

		// Remove empty items
		res = res.filter( function (item) {
			return item !== null && item !== undefined;
		});

		if ( res && res.length ) {
			out = out.concat( res );
		}
	}

	// selector extensions
	var ext = _ext.selector[ type ];
	if ( ext.length ) {
		for ( i=0, ien=ext.length ; i<ien ; i++ ) {
			out = ext[i]( settings, opts, out );
		}
	}

	return _unique( out );
};


var _selector_opts = function ( opts )
{
	if ( ! opts ) {
		opts = {};
	}

	// Backwards compatibility for 1.9- which used the terminology filter rather
	// than search
	if ( opts.filter && opts.search === undefined ) {
		opts.search = opts.filter;
	}

	return $.extend( {
		columnOrder: 'implied',
		search: 'none',
		order: 'current',
		page: 'all'
	}, opts );
};


// Reduce the API instance to the first item found
var _selector_first = function ( old )
{
	var inst = new _Api(old.context[0]);

	// Use a push rather than passing to the constructor, since it will
	// merge arrays down automatically, which isn't what is wanted here
	if (old.length) {
		inst.push( old[0] );
	}

	inst.selector = old.selector;

	// Limit to a single row / column / cell
	if (inst.length && inst[0].length > 1) {
		inst[0].splice(1);
	}

	return inst;
};


var _selector_row_indexes = function ( settings, opts )
{
	var
		i, ien, tmp, a=[],
		displayFiltered = settings.aiDisplay,
		displayMaster = settings.aiDisplayMaster;

	var
		search = opts.search,  // none, applied, removed
		order  = opts.order,   // applied, current, index (original - compatibility with 1.9)
		page   = opts.page;    // all, current

	if ( _fnDataSource( settings ) == 'ssp' ) {
		// In server-side processing mode, most options are irrelevant since
		// rows not shown don't exist and the index order is the applied order
		// Removed is a special case - for consistency just return an empty
		// array
		return search === 'removed' ?
			[] :
			_range( 0, displayMaster.length );
	}

	if ( page == 'current' ) {
		// Current page implies that order=current and filter=applied, since it is
		// fairly senseless otherwise, regardless of what order and search actually
		// are
		for ( i=settings._iDisplayStart, ien=settings.fnDisplayEnd() ; i<ien ; i++ ) {
			a.push( displayFiltered[i] );
		}
	}
	else if ( order == 'current' || order == 'applied' ) {
		if ( search == 'none') {
			a = displayMaster.slice();
		}
		else if ( search == 'applied' ) {
			a = displayFiltered.slice();
		}
		else if ( search == 'removed' ) {
			// O(n+m) solution by creating a hash map
			var displayFilteredMap = {};

			for ( i=0, ien=displayFiltered.length ; i<ien ; i++ ) {
				displayFilteredMap[displayFiltered[i]] = null;
			}

			displayMaster.forEach(function (item) {
				if (! Object.prototype.hasOwnProperty.call(displayFilteredMap, item)) {
					a.push(item);
				}
			});
		}
	}
	else if ( order == 'index' || order == 'original' ) {
		for ( i=0, ien=settings.aoData.length ; i<ien ; i++ ) {
			if (! settings.aoData[i]) {
				continue;
			}

			if ( search == 'none' ) {
				a.push( i );
			}
			else { // applied | removed
				tmp = displayFiltered.indexOf(i);

				if ((tmp === -1 && search == 'removed') ||
					(tmp >= 0   && search == 'applied') )
				{
					a.push( i );
				}
			}
		}
	}
	else if ( typeof order === 'number' ) {
		// Order the rows by the given column
		var ordered = _fnSort(settings, order, 'asc');

		if (search === 'none') {
			a = ordered;
		}
		else { // applied | removed
			for (i=0; i<ordered.length; i++) {
				tmp = displayFiltered.indexOf(ordered[i]);

				if ((tmp === -1 && search == 'removed') ||
					(tmp >= 0   && search == 'applied') )
				{
					a.push( ordered[i] );
				}
			}
		}
	}

	return a;
};


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Rows
 *
 * {}          - no selector - use all available rows
 * {integer}   - row aoData index
 * {node}      - TR node
 * {string}    - jQuery selector to apply to the TR elements
 * {array}     - jQuery array of nodes, or simply an array of TR nodes
 *
 */
var __row_selector = function ( settings, selector, opts )
{
	var rows;
	var run = function ( sel ) {
		var selInt = _intVal( sel );
		var aoData = settings.aoData;

		// Short cut - selector is a number and no options provided (default is
		// all records, so no need to check if the index is in there, since it
		// must be - dev error if the index doesn't exist).
		if ( selInt !== null && ! opts ) {
			return [ selInt ];
		}

		if ( ! rows ) {
			rows = _selector_row_indexes( settings, opts );
		}

		if ( selInt !== null && rows.indexOf(selInt) !== -1 ) {
			// Selector - integer
			return [ selInt ];
		}
		else if ( sel === null || sel === undefined || sel === '' ) {
			// Selector - none
			return rows;
		}

		// Selector - function
		if ( typeof sel === 'function' ) {
			return rows.map( function (idx) {
				var row = aoData[ idx ];
				return sel( idx, row._aData, row.nTr ) ? idx : null;
			} );
		}

		// Selector - node
		if ( sel.nodeName ) {
			var rowIdx = sel._DT_RowIndex;  // Property added by DT for fast lookup
			var cellIdx = sel._DT_CellIndex;

			if ( rowIdx !== undefined ) {
				// Make sure that the row is actually still present in the table
				return aoData[ rowIdx ] && aoData[ rowIdx ].nTr === sel ?
					[ rowIdx ] :
					[];
			}
			else if ( cellIdx ) {
				return aoData[ cellIdx.row ] && aoData[ cellIdx.row ].nTr === sel.parentNode ?
					[ cellIdx.row ] :
					[];
			}
			else {
				var host = $(sel).closest('*[data-dt-row]');
				return host.length ?
					[ host.data('dt-row') ] :
					[];
			}
		}

		// ID selector. Want to always be able to select rows by id, regardless
		// of if the tr element has been created or not, so can't rely upon
		// jQuery here - hence a custom implementation. This does not match
		// Sizzle's fast selector or HTML4 - in HTML5 the ID can be anything,
		// but to select it using a CSS selector engine (like Sizzle or
		// querySelect) it would need to need to be escaped for some characters.
		// DataTables simplifies this for row selectors since you can select
		// only a row. A # indicates an id any anything that follows is the id -
		// unescaped.
		if ( typeof sel === 'string' && sel.charAt(0) === '#' ) {
			// get row index from id
			var rowObj = settings.aIds[ sel.replace( /^#/, '' ) ];
			if ( rowObj !== undefined ) {
				return [ rowObj.idx ];
			}

			// need to fall through to jQuery in case there is DOM id that
			// matches
		}
		
		// Get nodes in the order from the `rows` array with null values removed
		var nodes = _removeEmpty(
			_pluck_order( settings.aoData, rows, 'nTr' )
		);

		// Selector - jQuery selector string, array of nodes or jQuery object/
		// As jQuery's .filter() allows jQuery objects to be passed in filter,
		// it also allows arrays, so this will cope with all three options
		return $(nodes)
			.filter( sel )
			.map( function () {
				return this._DT_RowIndex;
			} )
			.toArray();
	};

	var matched = _selector_run( 'row', selector, run, settings, opts );

	if (opts.order === 'current' || opts.order === 'applied') {
		_fnSortDisplay(settings, matched);
	}

	return matched;
};


_api_register( 'rows()', function ( selector, opts ) {
	// argument shifting
	if ( selector === undefined ) {
		selector = '';
	}
	else if ( $.isPlainObject( selector ) ) {
		opts = selector;
		selector = '';
	}

	opts = _selector_opts( opts );

	var inst = this.iterator( 'table', function ( settings ) {
		return __row_selector( settings, selector, opts );
	}, 1 );

	// Want argument shifting here and in __row_selector?
	inst.selector.rows = selector;
	inst.selector.opts = opts;

	return inst;
} );

_api_register( 'rows().nodes()', function () {
	return this.iterator( 'row', function ( settings, row ) {
		return settings.aoData[ row ].nTr || undefined;
	}, 1 );
} );

_api_register( 'rows().data()', function () {
	return this.iterator( true, 'rows', function ( settings, rows ) {
		return _pluck_order( settings.aoData, rows, '_aData' );
	}, 1 );
} );

_api_registerPlural( 'rows().cache()', 'row().cache()', function ( type ) {
	return this.iterator( 'row', function ( settings, row ) {
		var r = settings.aoData[ row ];
		return type === 'search' ? r._aFilterData : r._aSortData;
	}, 1 );
} );

_api_registerPlural( 'rows().invalidate()', 'row().invalidate()', function ( src ) {
	return this.iterator( 'row', function ( settings, row ) {
		_fnInvalidate( settings, row, src );
	} );
} );

_api_registerPlural( 'rows().indexes()', 'row().index()', function () {
	return this.iterator( 'row', function ( settings, row ) {
		return row;
	}, 1 );
} );

_api_registerPlural( 'rows().ids()', 'row().id()', function ( hash ) {
	var a = [];
	var context = this.context;

	// `iterator` will drop undefined values, but in this case we want them
	for ( var i=0, ien=context.length ; i<ien ; i++ ) {
		for ( var j=0, jen=this[i].length ; j<jen ; j++ ) {
			var id = context[i].rowIdFn( context[i].aoData[ this[i][j] ]._aData );
			a.push( (hash === true ? '#' : '' )+ id );
		}
	}

	return new _Api( context, a );
} );

_api_registerPlural( 'rows().remove()', 'row().remove()', function () {
	this.iterator( 'row', function ( settings, row ) {
		var data = settings.aoData;
		var rowData = data[ row ];

		// Delete from the display arrays
		var idx = settings.aiDisplayMaster.indexOf(row);
		if (idx !== -1) {
			settings.aiDisplayMaster.splice(idx, 1);
		}

		// For server-side processing tables - subtract the deleted row from the count
		if ( settings._iRecordsDisplay > 0 ) {
			settings._iRecordsDisplay--;
		}

		// Check for an 'overflow' they case for displaying the table
		_fnLengthOverflow( settings );

		// Remove the row's ID reference if there is one
		var id = settings.rowIdFn( rowData._aData );
		if ( id !== undefined ) {
			delete settings.aIds[ id ];
		}

		data[row] = null;
	} );

	return this;
} );


_api_register( 'rows.add()', function ( rows ) {
	var newRows = this.iterator( 'table', function ( settings ) {
			var row, i, ien;
			var out = [];

			for ( i=0, ien=rows.length ; i<ien ; i++ ) {
				row = rows[i];

				if ( row.nodeName && row.nodeName.toUpperCase() === 'TR' ) {
					out.push( _fnAddTr( settings, row )[0] );
				}
				else {
					out.push( _fnAddData( settings, row ) );
				}
			}

			return out;
		}, 1 );

	// Return an Api.rows() extended instance, so rows().nodes() etc can be used
	var modRows = this.rows( -1 );
	modRows.pop();
	_fnArrayApply(modRows, newRows);

	return modRows;
} );





/**
 *
 */
_api_register( 'row()', function ( selector, opts ) {
	return _selector_first( this.rows( selector, opts ) );
} );


_api_register( 'row().data()', function ( data ) {
	var ctx = this.context;

	if ( data === undefined ) {
		// Get
		return ctx.length && this.length && this[0].length ?
			ctx[0].aoData[ this[0] ]._aData :
			undefined;
	}

	// Set
	var row = ctx[0].aoData[ this[0] ];
	row._aData = data;

	// If the DOM has an id, and the data source is an array
	if ( Array.isArray( data ) && row.nTr && row.nTr.id ) {
		_fnSetObjectDataFn( ctx[0].rowId )( data, row.nTr.id );
	}

	// Automatically invalidate
	_fnInvalidate( ctx[0], this[0], 'data' );

	return this;
} );


_api_register( 'row().node()', function () {
	var ctx = this.context;

	if (ctx.length && this.length && this[0].length) {
		var row = ctx[0].aoData[ this[0] ];

		if (row && row.nTr) {
			return row.nTr;
		}
	}

	return null;
} );


_api_register( 'row.add()', function ( row ) {
	// Allow a jQuery object to be passed in - only a single row is added from
	// it though - the first element in the set
	if ( row instanceof $ && row.length ) {
		row = row[0];
	}

	var rows = this.iterator( 'table', function ( settings ) {
		if ( row.nodeName && row.nodeName.toUpperCase() === 'TR' ) {
			return _fnAddTr( settings, row )[0];
		}
		return _fnAddData( settings, row );
	} );

	// Return an Api.rows() extended instance, with the newly added row selected
	return this.row( rows[0] );
} );


$(document).on('plugin-init.dt', function (e, context) {
	var api = new _Api( context );

	api.on( 'stateSaveParams.DT', function ( e, settings, d ) {
		// This could be more compact with the API, but it is a lot faster as a simple
		// internal loop
		var idFn = settings.rowIdFn;
		var rows = settings.aiDisplayMaster;
		var ids = [];

		for (var i=0 ; i<rows.length ; i++) {
			var rowIdx = rows[i];
			var data = settings.aoData[rowIdx];

			if (data._detailsShow) {
				ids.push( '#' + idFn(data._aData) );
			}
		}

		d.childRows = ids;
	});

	// For future state loads (e.g. with StateRestore)
	api.on( 'stateLoaded.DT', function (e, settings, state) {
		__details_state_load( api, state );
	});

	// And the initial load state
	__details_state_load( api, api.state.loaded() );
});

var __details_state_load = function (api, state)
{
	if ( state && state.childRows ) {
		api
			.rows( state.childRows.map(function (id) {
				// Escape any `:` characters from the row id. Accounts for
				// already escaped characters.
				return id.replace(/([^:\\]*(?:\\.[^:\\]*)*):/g, "$1\\:");
			}) )
			.every( function () {
				_fnCallbackFire( api.settings()[0], null, 'requestChild', [ this ] )
			});
	}
}

var __details_add = function ( ctx, row, data, klass )
{
	// Convert to array of TR elements
	var rows = [];
	var addRow = function ( r, k ) {
		// Recursion to allow for arrays of jQuery objects
		if ( Array.isArray( r ) || r instanceof $ ) {
			for ( var i=0, ien=r.length ; i<ien ; i++ ) {
				addRow( r[i], k );
			}
			return;
		}

		// If we get a TR element, then just add it directly - up to the dev
		// to add the correct number of columns etc
		if ( r.nodeName && r.nodeName.toLowerCase() === 'tr' ) {
			r.setAttribute( 'data-dt-row', row.idx );
			rows.push( r );
		}
		else {
			// Otherwise create a row with a wrapper
			var created = $('<tr><td></td></tr>')
				.attr( 'data-dt-row', row.idx )
				.addClass( k );
			
			$('td', created)
				.addClass( k )
				.html( r )[0].colSpan = _fnVisbleColumns( ctx );

			rows.push( created[0] );
		}
	};

	addRow( data, klass );

	if ( row._details ) {
		row._details.detach();
	}

	row._details = $(rows);

	// If the children were already shown, that state should be retained
	if ( row._detailsShow ) {
		row._details.insertAfter( row.nTr );
	}
};


// Make state saving of child row details async to allow them to be batch processed
var __details_state = DataTable.util.throttle(
	function (ctx) {
		_fnSaveState( ctx[0] )
	},
	500
);


var __details_remove = function ( api, idx )
{
	var ctx = api.context;

	if ( ctx.length ) {
		var row = ctx[0].aoData[ idx !== undefined ? idx : api[0] ];

		if ( row && row._details ) {
			row._details.remove();

			row._detailsShow = undefined;
			row._details = undefined;
			$( row.nTr ).removeClass( 'dt-hasChild' );
			__details_state( ctx );
		}
	}
};


var __details_display = function ( api, show ) {
	var ctx = api.context;

	if ( ctx.length && api.length ) {
		var row = ctx[0].aoData[ api[0] ];

		if ( row._details ) {
			row._detailsShow = show;

			if ( show ) {
				row._details.insertAfter( row.nTr );
				$( row.nTr ).addClass( 'dt-hasChild' );
			}
			else {
				row._details.detach();
				$( row.nTr ).removeClass( 'dt-hasChild' );
			}

			_fnCallbackFire( ctx[0], null, 'childRow', [ show, api.row( api[0] ) ] )

			__details_events( ctx[0] );
			__details_state( ctx );
		}
	}
};


var __details_events = function ( settings )
{
	var api = new _Api( settings );
	var namespace = '.dt.DT_details';
	var drawEvent = 'draw'+namespace;
	var colvisEvent = 'column-sizing'+namespace;
	var destroyEvent = 'destroy'+namespace;
	var data = settings.aoData;

	api.off( drawEvent +' '+ colvisEvent +' '+ destroyEvent );

	if ( _pluck( data, '_details' ).length > 0 ) {
		// On each draw, insert the required elements into the document
		api.on( drawEvent, function ( e, ctx ) {
			if ( settings !== ctx ) {
				return;
			}

			api.rows( {page:'current'} ).eq(0).each( function (idx) {
				// Internal data grab
				var row = data[ idx ];

				if ( row._detailsShow ) {
					row._details.insertAfter( row.nTr );
				}
			} );
		} );

		// Column visibility change - update the colspan
		api.on( colvisEvent, function ( e, ctx ) {
			if ( settings !== ctx ) {
				return;
			}

			// Update the colspan for the details rows (note, only if it already has
			// a colspan)
			var row, visible = _fnVisbleColumns( ctx );

			for ( var i=0, ien=data.length ; i<ien ; i++ ) {
				row = data[i];

				if ( row && row._details ) {
					row._details.each(function () {
						var el = $(this).children('td');

						if (el.length == 1) {
							el.attr('colspan', visible);
						}
					});
				}
			}
		} );

		// Table destroyed - nuke any child rows
		api.on( destroyEvent, function ( e, ctx ) {
			if ( settings !== ctx ) {
				return;
			}

			for ( var i=0, ien=data.length ; i<ien ; i++ ) {
				if ( data[i] && data[i]._details ) {
					__details_remove( api, i );
				}
			}
		} );
	}
};

// Strings for the method names to help minification
var _emp = '';
var _child_obj = _emp+'row().child';
var _child_mth = _child_obj+'()';

// data can be:
//  tr
//  string
//  jQuery or array of any of the above
_api_register( _child_mth, function ( data, klass ) {
	var ctx = this.context;

	if ( data === undefined ) {
		// get
		return ctx.length && this.length && ctx[0].aoData[ this[0] ]
			? ctx[0].aoData[ this[0] ]._details
			: undefined;
	}
	else if ( data === true ) {
		// show
		this.child.show();
	}
	else if ( data === false ) {
		// remove
		__details_remove( this );
	}
	else if ( ctx.length && this.length ) {
		// set
		__details_add( ctx[0], ctx[0].aoData[ this[0] ], data, klass );
	}

	return this;
} );


_api_register( [
	_child_obj+'.show()',
	_child_mth+'.show()' // only when `child()` was called with parameters (without
], function () {         // it returns an object and this method is not executed)
	__details_display( this, true );
	return this;
} );


_api_register( [
	_child_obj+'.hide()',
	_child_mth+'.hide()' // only when `child()` was called with parameters (without
], function () {         // it returns an object and this method is not executed)
	__details_display( this, false );
	return this;
} );


_api_register( [
	_child_obj+'.remove()',
	_child_mth+'.remove()' // only when `child()` was called with parameters (without
], function () {           // it returns an object and this method is not executed)
	__details_remove( this );
	return this;
} );


_api_register( _child_obj+'.isShown()', function () {
	var ctx = this.context;

	if ( ctx.length && this.length && ctx[0].aoData[ this[0] ] ) {
		// _detailsShown as false or undefined will fall through to return false
		return ctx[0].aoData[ this[0] ]._detailsShow || false;
	}
	return false;
} );



/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Columns
 *
 * {integer}           - column index (>=0 count from left, <0 count from right)
 * "{integer}:visIdx"  - visible column index (i.e. translate to column index)  (>=0 count from left, <0 count from right)
 * "{integer}:visible" - alias for {integer}:visIdx  (>=0 count from left, <0 count from right)
 * "{string}:name"     - column name
 * "{string}"          - jQuery selector on column header nodes
 *
 */

// can be an array of these items, comma separated list, or an array of comma
// separated lists

var __re_column_selector = /^([^:]+)?:(name|title|visIdx|visible)$/;


// r1 and r2 are redundant - but it means that the parameters match for the
// iterator callback in columns().data()
var __columnData = function ( settings, column, r1, r2, rows, type ) {
	var a = [];
	for ( var row=0, ien=rows.length ; row<ien ; row++ ) {
		a.push( _fnGetCellData( settings, rows[row], column, type ) );
	}
	return a;
};


var __column_header = function ( settings, column, row ) {
	var header = settings.aoHeader;
	var titleRow = settings.titleRow;
	var target = null;

	if (row !== undefined) {
		target = row;
	}
	else if (titleRow === true) { // legacy orderCellsTop support
		target = 0;
	}
	else if (titleRow === false) {
		target = header.length - 1;
	}
	else if (titleRow !== null) {
		target = titleRow;
	}
	else {
		// Automatic - find the _last_ unique cell from the top that is not empty (last for
		// backwards compatibility)
		for (var i=0 ; i<header.length ; i++) {
			if (header[i][column].unique && $('span.dt-column-title', header[i][column].cell).text()) {
				target = i;
			}
		}

		if (target === null) {
			target = 0;
		}
	}

	return header[target][column].cell;
};

var __column_header_cells = function (header) {
	var out = [];

	for (var i=0 ; i<header.length ; i++) {
		for (var j=0 ; j<header[i].length ; j++) {
			var cell = header[i][j].cell;

			if (!out.includes(cell)) {
				out.push(cell);
			}
		}
	}

	return out;
}

var __column_selector = function ( settings, selector, opts )
{
	var
		columns = settings.aoColumns,
		names, titles,
		nodes = __column_header_cells(settings.aoHeader);
	
	var run = function ( s ) {
		var selInt = _intVal( s );

		// Selector - all
		if ( s === '' ) {
			return _range( columns.length );
		}

		// Selector - index
		if ( selInt !== null ) {
			return [ selInt >= 0 ?
				selInt : // Count from left
				columns.length + selInt // Count from right (+ because its a negative value)
			];
		}

		// Selector = function
		if ( typeof s === 'function' ) {
			var rows = _selector_row_indexes( settings, opts );

			return columns.map(function (col, idx) {
				return s(
						idx,
						__columnData( settings, idx, 0, 0, rows ),
						__column_header( settings, idx )
					) ? idx : null;
			});
		}

		// jQuery or string selector
		var match = typeof s === 'string' ?
			s.match( __re_column_selector ) :
			'';

		if ( match ) {
			switch( match[2] ) {
				case 'visIdx':
				case 'visible':
					// Selector is a column index
					if (match[1] && match[1].match(/^\d+$/)) {
						var idx = parseInt( match[1], 10 );

						// Visible index given, convert to column index
						if ( idx < 0 ) {
							// Counting from the right
							var visColumns = columns.map( function (col,i) {
								return col.bVisible ? i : null;
							} );
							return [ visColumns[ visColumns.length + idx ] ];
						}
						// Counting from the left
						return [ _fnVisibleToColumnIndex( settings, idx ) ];
					}
					
					return columns.map( function (col, idx) {
						// Not visible, can't match
						if (! col.bVisible) {
							return null;
						}

						// Selector
						if (match[1]) {
							return $(nodes[idx]).filter(match[1]).length > 0 ? idx : null;
						}

						// `:visible` on its own
						return idx;
					} );

				case 'name':
					// Don't get names, unless needed, and only get once if it is
					if (!names) {
						names = _pluck( columns, 'sName' );
					}

					// match by name. `names` is column index complete and in order
					return names.map( function (name, i) {
						return name === match[1] ? i : null;
					} );

				case 'title':
					if (!titles) {
						titles = _pluck( columns, 'sTitle' );
					}

					// match by column title
					return titles.map( function (title, i) {
						return title === match[1] ? i : null;
					} );

				default:
					return [];
			}
		}

		// Cell in the table body
		if ( s.nodeName && s._DT_CellIndex ) {
			return [ s._DT_CellIndex.column ];
		}

		// jQuery selector on the TH elements for the columns
		var jqResult = $( nodes )
			.filter( s )
			.map( function () {
				return _fnColumnsFromHeader( this ); // `nodes` is column index complete and in order
			} )
			.toArray()
			.sort(function (a, b) {
				return a - b;
			});

		if ( jqResult.length || ! s.nodeName ) {
			return jqResult;
		}

		// Otherwise a node which might have a `dt-column` data attribute, or be
		// a child or such an element
		var host = $(s).closest('*[data-dt-column]');
		return host.length ?
			[ host.data('dt-column') ] :
			[];
	};

	var selected = _selector_run( 'column', selector, run, settings, opts );

	return opts.columnOrder && opts.columnOrder === 'index'
		? selected.sort(function (a, b) { return a - b; })
		: selected; // implied
};


var __setColumnVis = function ( settings, column, vis ) {
	var
		cols = settings.aoColumns,
		col  = cols[ column ],
		data = settings.aoData,
		cells, i, ien, tr;

	// Get
	if ( vis === undefined ) {
		return col.bVisible;
	}

	// Set
	// No change
	if ( col.bVisible === vis ) {
		return false;
	}

	if ( vis ) {
		// Insert column
		// Need to decide if we should use appendChild or insertBefore
		var insertBefore = _pluck(cols, 'bVisible').indexOf(true, column+1);

		for ( i=0, ien=data.length ; i<ien ; i++ ) {
			if (data[i]) {
				tr = data[i].nTr;
				cells = data[i].anCells;

				if ( tr ) {
					// insertBefore can act like appendChild if 2nd arg is null
					tr.insertBefore( cells[ column ], cells[ insertBefore ] || null );
				}
			}
		}
	}
	else {
		// Remove column
		$( _pluck( settings.aoData, 'anCells', column ) ).detach();
	}

	// Common actions
	col.bVisible = vis;

	_colGroup(settings);
	
	return true;
};


_api_register( 'columns()', function ( selector, opts ) {
	// argument shifting
	if ( selector === undefined ) {
		selector = '';
	}
	else if ( $.isPlainObject( selector ) ) {
		opts = selector;
		selector = '';
	}

	opts = _selector_opts( opts );

	var inst = this.iterator( 'table', function ( settings ) {
		return __column_selector( settings, selector, opts );
	}, 1 );

	// Want argument shifting here and in _row_selector?
	inst.selector.cols = selector;
	inst.selector.opts = opts;

	return inst;
} );

_api_registerPlural( 'columns().header()', 'column().header()', function ( row ) {
	return this.iterator( 'column', function (settings, column) {
		return __column_header(settings, column, row);
	}, 1 );
} );

_api_registerPlural( 'columns().footer()', 'column().footer()', function ( row ) {
	return this.iterator( 'column', function ( settings, column ) {
		var footer = settings.aoFooter;

		if (! footer.length) {
			return null;
		}

		return settings.aoFooter[row !== undefined ? row : 0][column].cell;
	}, 1 );
} );

_api_registerPlural( 'columns().data()', 'column().data()', function () {
	return this.iterator( 'column-rows', __columnData, 1 );
} );

_api_registerPlural( 'columns().render()', 'column().render()', function ( type ) {
	return this.iterator( 'column-rows', function ( settings, column, i, j, rows ) {
		return __columnData( settings, column, i, j, rows, type );
	}, 1 );
} );

_api_registerPlural( 'columns().dataSrc()', 'column().dataSrc()', function () {
	return this.iterator( 'column', function ( settings, column ) {
		return settings.aoColumns[column].mData;
	}, 1 );
} );

_api_registerPlural( 'columns().cache()', 'column().cache()', function ( type ) {
	return this.iterator( 'column-rows', function ( settings, column, i, j, rows ) {
		return _pluck_order( settings.aoData, rows,
			type === 'search' ? '_aFilterData' : '_aSortData', column
		);
	}, 1 );
} );

_api_registerPlural( 'columns().init()', 'column().init()', function () {
	return this.iterator( 'column', function ( settings, column ) {
		return settings.aoColumns[column];
	}, 1 );
} );

_api_registerPlural( 'columns().names()', 'column().name()', function () {
	return this.iterator( 'column', function ( settings, column ) {
		return settings.aoColumns[column].sName;
	}, 1 );
} );

_api_registerPlural( 'columns().nodes()', 'column().nodes()', function () {
	return this.iterator( 'column-rows', function ( settings, column, i, j, rows ) {
		return _pluck_order( settings.aoData, rows, 'anCells', column ) ;
	}, 1 );
} );

_api_registerPlural( 'columns().titles()', 'column().title()', function (title, row) {
	return this.iterator( 'column', function ( settings, column ) {
		// Argument shifting
		if (typeof title === 'number') {
			row = title;
			title = undefined;
		}

		var span = $('span.dt-column-title', this.column(column).header(row));

		if (title !== undefined) {
			span.html(title);
			return this;
		}

		return span.html();
	}, 1 );
} );

_api_registerPlural( 'columns().types()', 'column().type()', function () {
	return this.iterator( 'column', function ( settings, column ) {
		var type = settings.aoColumns[column].sType;

		// If the type was invalidated, then resolve it. This actually does
		// all columns at the moment. Would only happen once if getting all
		// column's data types.
		if (! type) {
			_fnColumnTypes(settings);
		}

		return type;
	}, 1 );
} );

_api_registerPlural( 'columns().visible()', 'column().visible()', function ( vis, calc ) {
	var that = this;
	var changed = [];
	var ret = this.iterator( 'column', function ( settings, column ) {
		if ( vis === undefined ) {
			return settings.aoColumns[ column ].bVisible;
		} // else
		
		if (__setColumnVis( settings, column, vis )) {
			changed.push(column);
		}
	} );

	// Group the column visibility changes
	if ( vis !== undefined ) {
		this.iterator( 'table', function ( settings ) {
			// Redraw the header after changes
			_fnDrawHead( settings, settings.aoHeader );
			_fnDrawHead( settings, settings.aoFooter );
	
			// Update colspan for no records display. Child rows and extensions will use their own
			// listeners to do this - only need to update the empty table item here
			if ( ! settings.aiDisplay.length ) {
				$(settings.nTBody).find('td[colspan]').attr('colspan', _fnVisbleColumns(settings));
			}
	
			_fnSaveState( settings );

			// Second loop once the first is done for events
			that.iterator( 'column', function ( settings, column ) {
				if (changed.includes(column)) {
					_fnCallbackFire( settings, null, 'column-visibility', [settings, column, vis, calc] );
				}
			} );

			if ( changed.length && (calc === undefined || calc) ) {
				that.columns.adjust();
			}
		});
	}

	return ret;
} );

_api_registerPlural( 'columns().widths()', 'column().width()', function () {
	// Injects a fake row into the table for just a moment so the widths can
	// be read, regardless of colspan in the header and rows being present in
	// the body
	var columns = this.columns(':visible').count();
	var row = $('<tr>').html('<td>' + Array(columns).join('</td><td>') + '</td>');

	$(this.table().body()).append(row);

	var widths = row.children().map(function () {
		return $(this).outerWidth();
	});

	row.remove();
	
	return this.iterator( 'column', function ( settings, column ) {
		var visIdx = _fnColumnIndexToVisible( settings, column );

		return visIdx !== null ? widths[visIdx] : 0;
	}, 1);
} );

_api_registerPlural( 'columns().indexes()', 'column().index()', function ( type ) {
	return this.iterator( 'column', function ( settings, column ) {
		return type === 'visible' ?
			_fnColumnIndexToVisible( settings, column ) :
			column;
	}, 1 );
} );

_api_register( 'columns.adjust()', function () {
	return this.iterator( 'table', function ( settings ) {
		// Force a column sizing to happen with a manual call - otherwise it can skip
		// if the size hasn't changed
		settings.containerWidth = -1;

		_fnAdjustColumnSizing( settings );
	}, 1 );
} );

_api_register( 'column.index()', function ( type, idx ) {
	if ( this.context.length !== 0 ) {
		var ctx = this.context[0];

		if ( type === 'fromVisible' || type === 'toData' ) {
			return _fnVisibleToColumnIndex( ctx, idx );
		}
		else if ( type === 'fromData' || type === 'toVisible' ) {
			return _fnColumnIndexToVisible( ctx, idx );
		}
	}
} );

_api_register( 'column()', function ( selector, opts ) {
	return _selector_first( this.columns( selector, opts ) );
} );

var __cell_selector = function ( settings, selector, opts )
{
	var data = settings.aoData;
	var rows = _selector_row_indexes( settings, opts );
	var cells = _removeEmpty( _pluck_order( data, rows, 'anCells' ) );
	var allCells = $(_flatten( [], cells ));
	var row;
	var columns = settings.aoColumns.length;
	var a, i, ien, j, o, host;

	var run = function ( s ) {
		var fnSelector = typeof s === 'function';

		if ( s === null || s === undefined || fnSelector ) {
			// All cells and function selectors
			a = [];

			for ( i=0, ien=rows.length ; i<ien ; i++ ) {
				row = rows[i];

				for ( j=0 ; j<columns ; j++ ) {
					o = {
						row: row,
						column: j
					};

					if ( fnSelector ) {
						// Selector - function
						host = data[ row ];

						if ( s( o, _fnGetCellData(settings, row, j), host.anCells ? host.anCells[j] : null ) ) {
							a.push( o );
						}
					}
					else {
						// Selector - all
						a.push( o );
					}
				}
			}

			return a;
		}
		
		// Selector - index
		if ( $.isPlainObject( s ) ) {
			// Valid cell index and its in the array of selectable rows
			return s.column !== undefined && s.row !== undefined && rows.indexOf(s.row) !== -1 ?
				[s] :
				[];
		}

		// Selector - jQuery filtered cells
		var jqResult = allCells
			.filter( s )
			.map( function (i, el) {
				return { // use a new object, in case someone changes the values
					row:    el._DT_CellIndex.row,
					column: el._DT_CellIndex.column
				};
			} )
			.toArray();

		if ( jqResult.length || ! s.nodeName ) {
			return jqResult;
		}

		// Otherwise the selector is a node, and there is one last option - the
		// element might be a child of an element which has dt-row and dt-column
		// data attributes
		host = $(s).closest('*[data-dt-row]');
		return host.length ?
			[ {
				row: host.data('dt-row'),
				column: host.data('dt-column')
			} ] :
			[];
	};

	return _selector_run( 'cell', selector, run, settings, opts );
};




_api_register( 'cells()', function ( rowSelector, columnSelector, opts ) {
	// Argument shifting
	if ( $.isPlainObject( rowSelector ) ) {
		// Indexes
		if ( rowSelector.row === undefined ) {
			// Selector options in first parameter
			opts = rowSelector;
			rowSelector = null;
		}
		else {
			// Cell index objects in first parameter
			opts = columnSelector;
			columnSelector = null;
		}
	}
	if ( $.isPlainObject( columnSelector ) ) {
		opts = columnSelector;
		columnSelector = null;
	}

	// Cell selector
	if ( columnSelector === null || columnSelector === undefined ) {
		return this.iterator( 'table', function ( settings ) {
			return __cell_selector( settings, rowSelector, _selector_opts( opts ) );
		} );
	}

	// The default built in options need to apply to row and columns
	var internalOpts = opts ? {
		page: opts.page,
		order: opts.order,
		search: opts.search
	} : {};

	// Row + column selector
	var columns = this.columns( columnSelector, internalOpts );
	var rows = this.rows( rowSelector, internalOpts );
	var i, ien, j, jen;

	var cellsNoOpts = this.iterator( 'table', function ( settings, idx ) {
		var a = [];

		for ( i=0, ien=rows[idx].length ; i<ien ; i++ ) {
			for ( j=0, jen=columns[idx].length ; j<jen ; j++ ) {
				a.push( {
					row:    rows[idx][i],
					column: columns[idx][j]
				} );
			}
		}

		return a;
	}, 1 );

	// There is currently only one extension which uses a cell selector extension
	// It is a _major_ performance drag to run this if it isn't needed, so this is
	// an extension specific check at the moment
	var cells = opts && opts.selected ?
		this.cells( cellsNoOpts, opts ) :
		cellsNoOpts;

	$.extend( cells.selector, {
		cols: columnSelector,
		rows: rowSelector,
		opts: opts
	} );

	return cells;
} );


_api_registerPlural( 'cells().nodes()', 'cell().node()', function () {
	return this.iterator( 'cell', function ( settings, row, column ) {
		var data = settings.aoData[ row ];

		return data && data.anCells ?
			data.anCells[ column ] :
			undefined;
	}, 1 );
} );


_api_register( 'cells().data()', function () {
	return this.iterator( 'cell', function ( settings, row, column ) {
		return _fnGetCellData( settings, row, column );
	}, 1 );
} );


_api_registerPlural( 'cells().cache()', 'cell().cache()', function ( type ) {
	type = type === 'search' ? '_aFilterData' : '_aSortData';

	return this.iterator( 'cell', function ( settings, row, column ) {
		return settings.aoData[ row ][ type ][ column ];
	}, 1 );
} );


_api_registerPlural( 'cells().render()', 'cell().render()', function ( type ) {
	return this.iterator( 'cell', function ( settings, row, column ) {
		return _fnGetCellData( settings, row, column, type );
	}, 1 );
} );


_api_registerPlural( 'cells().indexes()', 'cell().index()', function () {
	return this.iterator( 'cell', function ( settings, row, column ) {
		return {
			row: row,
			column: column,
			columnVisible: _fnColumnIndexToVisible( settings, column )
		};
	}, 1 );
} );


_api_registerPlural( 'cells().invalidate()', 'cell().invalidate()', function ( src ) {
	return this.iterator( 'cell', function ( settings, row, column ) {
		_fnInvalidate( settings, row, src, column );
	} );
} );



_api_register( 'cell()', function ( rowSelector, columnSelector, opts ) {
	return _selector_first( this.cells( rowSelector, columnSelector, opts ) );
} );


_api_register( 'cell().data()', function ( data ) {
	var ctx = this.context;
	var cell = this[0];

	if ( data === undefined ) {
		// Get
		return ctx.length && cell.length ?
			_fnGetCellData( ctx[0], cell[0].row, cell[0].column ) :
			undefined;
	}

	// Set
	_fnSetCellData( ctx[0], cell[0].row, cell[0].column, data );
	_fnInvalidate( ctx[0], cell[0].row, 'data', cell[0].column );

	return this;
} );



/**
 * Get current ordering (sorting) that has been applied to the table.
 *
 * @returns {array} 2D array containing the sorting information for the first
 *   table in the current context. Each element in the parent array represents
 *   a column being sorted upon (i.e. multi-sorting with two columns would have
 *   2 inner arrays). The inner arrays may have 2 or 3 elements. The first is
 *   the column index that the sorting condition applies to, the second is the
 *   direction of the sort (`desc` or `asc`) and, optionally, the third is the
 *   index of the sorting order from the `column.sorting` initialisation array.
 *//**
 * Set the ordering for the table.
 *
 * @param {integer} order Column index to sort upon.
 * @param {string} direction Direction of the sort to be applied (`asc` or `desc`)
 * @returns {DataTables.Api} this
 *//**
 * Set the ordering for the table.
 *
 * @param {array} order 1D array of sorting information to be applied.
 * @param {array} [...] Optional additional sorting conditions
 * @returns {DataTables.Api} this
 *//**
 * Set the ordering for the table.
 *
 * @param {array} order 2D array of sorting information to be applied.
 * @returns {DataTables.Api} this
 */
_api_register( 'order()', function ( order, dir ) {
	var ctx = this.context;
	var args = Array.prototype.slice.call( arguments );

	if ( order === undefined ) {
		// get
		return ctx.length !== 0 ?
			ctx[0].aaSorting :
			undefined;
	}

	// set
	if ( typeof order === 'number' ) {
		// Simple column / direction passed in
		order = [ [ order, dir ] ];
	}
	else if ( args.length > 1 ) {
		// Arguments passed in (list of 1D arrays)
		order = args;
	}
	// otherwise a 2D array was passed in

	return this.iterator( 'table', function ( settings ) {
		var resolved = [];
		_fnSortResolve(settings, resolved, order);

		settings.aaSorting = resolved;
	} );
} );


/**
 * Attach a sort listener to an element for a given column
 *
 * @param {node|jQuery|string} node Identifier for the element(s) to attach the
 *   listener to. This can take the form of a single DOM node, a jQuery
 *   collection of nodes or a jQuery selector which will identify the node(s).
 * @param {integer} column the column that a click on this node will sort on
 * @param {function} [callback] callback function when sort is run
 * @returns {DataTables.Api} this
 */
_api_register( 'order.listener()', function ( node, column, callback ) {
	return this.iterator( 'table', function ( settings ) {
		_fnSortAttachListener(settings, node, {}, column, callback);
	} );
} );


_api_register( 'order.fixed()', function ( set ) {
	if ( ! set ) {
		var ctx = this.context;
		var fixed = ctx.length ?
			ctx[0].aaSortingFixed :
			undefined;

		return Array.isArray( fixed ) ?
			{ pre: fixed } :
			fixed;
	}

	return this.iterator( 'table', function ( settings ) {
		settings.aaSortingFixed = $.extend( true, {}, set );
	} );
} );


// Order by the selected column(s)
_api_register( [
	'columns().order()',
	'column().order()'
], function ( dir ) {
	var that = this;

	if ( ! dir ) {
		return this.iterator( 'column', function ( settings, idx ) {
			var sort = _fnSortFlatten( settings );

			for ( var i=0, ien=sort.length ; i<ien ; i++ ) {
				if ( sort[i].col === idx ) {
					return sort[i].dir;
				}
			}

			return null;
		}, 1 );
	}
	else {
		return this.iterator( 'table', function ( settings, i ) {
			settings.aaSorting = that[i].map( function (col) {
				return [ col, dir ];
			} );
		} );
	}
} );

_api_registerPlural('columns().orderable()', 'column().orderable()', function ( directions ) {
	return this.iterator( 'column', function ( settings, idx ) {
		var col = settings.aoColumns[idx];

		return directions ?
			col.asSorting :
			col.bSortable;
	}, 1 );
} );


_api_register( 'processing()', function ( show ) {
	return this.iterator( 'table', function ( ctx ) {
		_fnProcessingDisplay( ctx, show );
	} );
} );


_api_register( 'search()', function ( input, regex, smart, caseInsen ) {
	var ctx = this.context;

	if ( input === undefined ) {
		// get
		return ctx.length !== 0 ?
			ctx[0].oPreviousSearch.search :
			undefined;
	}

	// set
	return this.iterator( 'table', function ( settings ) {
		if ( ! settings.oFeatures.bFilter ) {
			return;
		}

		if (typeof regex === 'object') {
			// New style options to pass to the search builder
			_fnFilterComplete( settings, $.extend( settings.oPreviousSearch, regex, {
				search: input
			} ) );
		}
		else {
			// Compat for the old options
			_fnFilterComplete( settings, $.extend( settings.oPreviousSearch, {
				search: input,
				regex:  regex === null ? false : regex,
				smart:  smart === null ? true  : smart,
				caseInsensitive: caseInsen === null ? true : caseInsen
			} ) );
		}
	} );
} );

_api_register( 'search.fixed()', function ( name, search ) {
	var ret = this.iterator( true, 'table', function ( settings ) {
		var fixed = settings.searchFixed;

		if (! name) {
			return Object.keys(fixed);
		}
		else if (search === undefined) {
			return fixed[name];
		}
		else if (search === null) {
			delete fixed[name];
		}
		else {
			fixed[name] = search;
		}

		return this;
	} );

	return name !== undefined && search === undefined
		? ret[0]
		: ret;
} );

_api_registerPlural(
	'columns().search()',
	'column().search()',
	function ( input, regex, smart, caseInsen ) {
		return this.iterator( 'column', function ( settings, column ) {
			var preSearch = settings.aoPreSearchCols;

			if ( input === undefined ) {
				// get
				return preSearch[ column ].search;
			}

			// set
			if ( ! settings.oFeatures.bFilter ) {
				return;
			}

			if (typeof regex === 'object') {
				// New style options to pass to the search builder
				$.extend( preSearch[ column ], regex, {
					search: input
				} );
			}
			else {
				// Old style (with not all options available)
				$.extend( preSearch[ column ], {
					search: input,
					regex:  regex === null ? false : regex,
					smart:  smart === null ? true  : smart,
					caseInsensitive: caseInsen === null ? true : caseInsen
				} );
			}

			_fnFilterComplete( settings, settings.oPreviousSearch );
		} );
	}
);

_api_register([
		'columns().search.fixed()',
		'column().search.fixed()'
	],
	function ( name, search ) {
		var ret = this.iterator( true, 'column', function ( settings, colIdx ) {
			var fixed = settings.aoColumns[colIdx].searchFixed;

			if (! name) {
				return Object.keys(fixed);
			}
			else if (search === undefined) {
				return fixed[name] || null;
			}
			else if (search === null) {
				delete fixed[name];
			}
			else {
				fixed[name] = search;
			}

			return this;
		} );

		return name !== undefined && search === undefined
			? ret[0]
			: ret;
	}
);
/*
 * State API methods
 */

_api_register( 'state()', function ( set, ignoreTime ) {
	// getter
	if ( ! set ) {
		return this.context.length ?
			this.context[0].oSavedState :
			null;
	}

	var setMutate = $.extend( true, {}, set );

	// setter
	return this.iterator( 'table', function ( settings ) {
		if ( ignoreTime !== false ) {
			setMutate.time = +new Date() + 100;
		}

		_fnImplementState( settings, setMutate, function(){} );
	} );
} );


_api_register( 'state.clear()', function () {
	return this.iterator( 'table', function ( settings ) {
		// Save an empty object
		settings.fnStateSaveCallback.call( settings.oInstance, settings, {} );
	} );
} );


_api_register( 'state.loaded()', function () {
	return this.context.length ?
		this.context[0].oLoadedState :
		null;
} );


_api_register( 'state.save()', function () {
	return this.iterator( 'table', function ( settings ) {
		_fnSaveState( settings );
	} );
} );

// Can be assigned in DateTable.use() - note luxon and moment vars are in helpers.js
var __bootstrap;
var __foundation;

/**
 * Set the libraries that DataTables uses, or the global objects.
 * Note that the arguments can be either way around (legacy support)
 * and the second is optional. See docs.
 */
DataTable.use = function (arg1, arg2) {
	// Reverse arguments for legacy support
	var module = typeof arg1 === 'string'
		? arg2
		: arg1;
	var type = typeof arg2 === 'string'
		? arg2
		: arg1;

	// Getter
	if (module === undefined && typeof type === 'string') {
		switch (type) {
			case 'lib':
			case 'jq':
				return $;

			case 'win':
				return window;

			case 'datetime':
				return DataTable.DateTime;

			case 'luxon':
				return __luxon;

			case 'moment':
				return __moment;

			case 'bootstrap':
				// Use local if set, otherwise try window, which could be undefined
				return __bootstrap || window.bootstrap;

			case 'foundation':
				// Ditto
				return __foundation || window.Foundation;

			default:
				return null;
		}
	}

	// Setter
	if (type === 'lib' || type === 'jq' || (module && module.fn && module.fn.jquery)) {
		$ = module;
	}
	else if (type === 'win' || (module && module.document)) {
		window = module;
		document = module.document;
	}
	else if (type === 'datetime' || (module && module.type === 'DateTime')) {
		DataTable.DateTime = module;
	}
	else if (type === 'luxon' || (module && module.FixedOffsetZone)) {
		__luxon = module;
	}
	else if (type === 'moment' || (module && module.isMoment)) {
		__moment = module;
	}
	else if (type === 'bootstrap' || (module && module.Modal && module.Modal.NAME === 'modal'))
	{
		// This is currently for BS5 only. BS3/4 attach to jQuery, so no need to use `.use()`
		__bootstrap = module;
	}
	else if (type === 'foundation' || (module && module.Reveal)) {
		__foundation = module;
	}
}

/**
 * CommonJS factory function pass through. This will check if the arguments
 * given are a window object or a jQuery object. If so they are set
 * accordingly.
 * @param {*} root Window
 * @param {*} jq jQUery
 * @returns {boolean} Indicator
 */
DataTable.factory = function (root, jq) {
	var is = false;

	// Test if the first parameter is a window object
	if (root && root.document) {
		window = root;
		document = root.document;
	}

	// Test if the second parameter is a jQuery object
	if (jq && jq.fn && jq.fn.jquery) {
		$ = jq;
		is = true;
	}

	return is;
}

/**
 * Provide a common method for plug-ins to check the version of DataTables being
 * used, in order to ensure compatibility.
 *
 *  @param {string} version Version string to check for, in the format "X.Y.Z".
 *    Note that the formats "X" and "X.Y" are also acceptable.
 *  @param {string} [version2=current DataTables version] As above, but optional.
 *   If not given the current DataTables version will be used.
 *  @returns {boolean} true if this version of DataTables is greater or equal to
 *    the required version, or false if this version of DataTales is not
 *    suitable
 *  @static
 *  @dtopt API-Static
 *
 *  @example
 *    alert( $.fn.dataTable.versionCheck( '1.9.0' ) );
 */
DataTable.versionCheck = function( version, version2 )
{
	var aThis = version2 ?
		version2.split('.') :
		DataTable.version.split('.');
	var aThat = version.split('.');
	var iThis, iThat;

	for ( var i=0, iLen=aThat.length ; i<iLen ; i++ ) {
		iThis = parseInt( aThis[i], 10 ) || 0;
		iThat = parseInt( aThat[i], 10 ) || 0;

		// Parts are the same, keep comparing
		if (iThis === iThat) {
			continue;
		}

		// Parts are different, return immediately
		return iThis > iThat;
	}

	return true;
};


/**
 * Check if a `<table>` node is a DataTable table already or not.
 *
 *  @param {node|jquery|string} table Table node, jQuery object or jQuery
 *      selector for the table to test. Note that if more than more than one
 *      table is passed on, only the first will be checked
 *  @returns {boolean} true the table given is a DataTable, or false otherwise
 *  @static
 *  @dtopt API-Static
 *
 *  @example
 *    if ( ! $.fn.DataTable.isDataTable( '#example' ) ) {
 *      $('#example').dataTable();
 *    }
 */
DataTable.isDataTable = function ( table )
{
	var t = $(table).get(0);
	var is = false;

	if ( table instanceof DataTable.Api ) {
		return true;
	}

	$.each( DataTable.settings, function (i, o) {
		var head = o.nScrollHead ? $('table', o.nScrollHead)[0] : null;
		var foot = o.nScrollFoot ? $('table', o.nScrollFoot)[0] : null;

		if ( o.nTable === t || head === t || foot === t ) {
			is = true;
		}
	} );

	return is;
};


/**
 * Get all DataTable tables that have been initialised - optionally you can
 * select to get only currently visible tables.
 *
 *  @param {boolean} [visible=false] Flag to indicate if you want all (default)
 *    or visible tables only.
 *  @returns {array} Array of `table` nodes (not DataTable instances) which are
 *    DataTables
 *  @static
 *  @dtopt API-Static
 *
 *  @example
 *    $.each( $.fn.dataTable.tables(true), function () {
 *      $(table).DataTable().columns.adjust();
 *    } );
 */
DataTable.tables = function ( visible )
{
	var api = false;

	if ( $.isPlainObject( visible ) ) {
		api = visible.api;
		visible = visible.visible;
	}

	var a = DataTable.settings
		.filter( function (o) {
			return !visible || (visible && $(o.nTable).is(':visible')) 
				? true
				: false;
		} )
		.map( function (o) {
			return o.nTable;
		});

	return api ?
		new _Api( a ) :
		a;
};


/**
 * Convert from camel case parameters to Hungarian notation. This is made public
 * for the extensions to provide the same ability as DataTables core to accept
 * either the 1.9 style Hungarian notation, or the 1.10+ style camelCase
 * parameters.
 *
 *  @param {object} src The model object which holds all parameters that can be
 *    mapped.
 *  @param {object} user The object to convert from camel case to Hungarian.
 *  @param {boolean} force When set to `true`, properties which already have a
 *    Hungarian value in the `user` object will be overwritten. Otherwise they
 *    won't be.
 */
DataTable.camelToHungarian = _fnCamelToHungarian;



/**
 *
 */
_api_register( '$()', function ( selector, opts ) {
	var
		rows   = this.rows( opts ).nodes(), // Get all rows
		jqRows = $(rows);

	return $( [].concat(
		jqRows.filter( selector ).toArray(),
		jqRows.find( selector ).toArray()
	) );
} );


// jQuery functions to operate on the tables
$.each( [ 'on', 'one', 'off' ], function (i, key) {
	_api_register( key+'()', function ( /* event, handler */ ) {
		var args = Array.prototype.slice.call(arguments);

		// Add the `dt` namespace automatically if it isn't already present
		args[0] = args[0].split( /\s/ ).map( function ( e ) {
			return ! e.match(/\.dt\b/) ?
				e+'.dt' :
				e;
			} ).join( ' ' );

		var inst = $( this.tables().nodes() );
		inst[key].apply( inst, args );
		return this;
	} );
} );


_api_register( 'clear()', function () {
	return this.iterator( 'table', function ( settings ) {
		_fnClearTable( settings );
	} );
} );


_api_register( 'error()', function (msg) {
	return this.iterator( 'table', function ( settings ) {
		_fnLog( settings, 0, msg );
	} );
} );


_api_register( 'settings()', function () {
	return new _Api( this.context, this.context );
} );


_api_register( 'init()', function () {
	var ctx = this.context;
	return ctx.length ? ctx[0].oInit : null;
} );


_api_register( 'data()', function () {
	return this.iterator( 'table', function ( settings ) {
		return _pluck( settings.aoData, '_aData' );
	} ).flatten();
} );


_api_register( 'trigger()', function ( name, args, bubbles ) {
	return this.iterator( 'table', function ( settings ) {
		return _fnCallbackFire( settings, null, name, args, bubbles );
	} ).flatten();
} );


_api_register( 'ready()', function ( fn ) {
	var ctx = this.context;

	// Get status of first table
	if (! fn) {
		return ctx.length
			? (ctx[0]._bInitComplete || false)
			: null;
	}

	// Function to run either once the table becomes ready or
	// immediately if it is already ready.
	return this.tables().every(function () {
		var api = this;

		if (this.context[0]._bInitComplete) {
			fn.call(api);
		}
		else {
			this.on('init.dt.DT', function () {
				fn.call(api);
			});
		}
	} );
} );


_api_register( 'destroy()', function ( remove ) {
	remove = remove || false;

	return this.iterator( 'table', function ( settings ) {
		var classes   = settings.oClasses;
		var table     = settings.nTable;
		var tbody     = settings.nTBody;
		var thead     = settings.nTHead;
		var tfoot     = settings.nTFoot;
		var jqTable   = $(table);
		var jqTbody   = $(tbody);
		var jqWrapper = $(settings.nTableWrapper);
		var rows      = settings.aoData.map( function (r) { return r ? r.nTr : null; } );
		var orderClasses = classes.order;

		// Flag to note that the table is currently being destroyed - no action
		// should be taken
		settings.bDestroying = true;

		// Fire off the destroy callbacks for plug-ins etc
		_fnCallbackFire( settings, "aoDestroyCallback", "destroy", [settings], true );

		// If not being removed from the document, make all columns visible
		if ( ! remove ) {
			new _Api( settings ).columns().visible( true );
		}

		// Container width change listener
		if (settings.resizeObserver) {
			settings.resizeObserver.disconnect();
		}

		// Blitz all `DT` namespaced events (these are internal events, the
		// lowercase, `dt` events are user subscribed and they are responsible
		// for removing them
		jqWrapper.off('.DT').find(':not(tbody *)').off('.DT');
		$(window).off('.DT-'+settings.sInstance);

		// When scrolling we had to break the table up - restore it
		if ( table != thead.parentNode ) {
			jqTable.children('thead').detach();
			jqTable.append( thead );
		}

		if ( tfoot && table != tfoot.parentNode ) {
			jqTable.children('tfoot').detach();
			jqTable.append( tfoot );
		}

		// Clean up the header / footer
		cleanHeader(thead, 'header');
		cleanHeader(tfoot, 'footer');
		settings.colgroup.remove();

		settings.aaSorting = [];
		settings.aaSortingFixed = [];
		_fnSortingClasses( settings );

		$(jqTable).find('th, td').removeClass(
			$.map(DataTable.ext.type.className, function (v) {
				return v;
			}).join(' ')
		);

		$('th, td', thead)
			.removeClass(
				orderClasses.none + ' ' +
				orderClasses.canAsc + ' ' +
				orderClasses.canDesc + ' ' +
				orderClasses.isAsc + ' ' +
				orderClasses.isDesc
			)
			.css('width', '')
			.removeAttr('aria-sort');

		// Add the TR elements back into the table in their original order
		jqTbody.children().detach();
		jqTbody.append( rows );

		var orig = settings.nTableWrapper.parentNode;
		var insertBefore = settings.nTableWrapper.nextSibling;

		// Remove the DataTables generated nodes, events and classes
		var removedMethod = remove ? 'remove' : 'detach';
		jqTable[ removedMethod ]();
		jqWrapper[ removedMethod ]();

		// If we need to reattach the table to the document
		if ( ! remove && orig ) {
			// insertBefore acts like appendChild if !arg[1]
			orig.insertBefore( table, insertBefore );

			// Restore the width of the original table - was read from the style property,
			// so we can restore directly to that
			jqTable
				.css( 'width', settings.sDestroyWidth )
				.removeClass( classes.table );
		}

		/* Remove the settings object from the settings array */
		var idx = DataTable.settings.indexOf(settings);
		if ( idx !== -1 ) {
			DataTable.settings.splice( idx, 1 );
		}
	} );
} );


// Add the `every()` method for rows, columns and cells in a compact form
$.each( [ 'column', 'row', 'cell' ], function ( i, type ) {
	_api_register( type+'s().every()', function ( fn ) {
		var opts = this.selector.opts;
		var api = this;
		var inst;
		var counter = 0;

		return this.iterator( 'every', function ( settings, selectedIdx, tableIdx ) {
			inst = api[ type ](selectedIdx, opts);

			if (type === 'cell') {
				fn.call(inst, inst[0][0].row, inst[0][0].column, tableIdx, counter);
			}
			else {
				fn.call(inst, selectedIdx, tableIdx, counter);
			}

			counter++;
		} );
	} );
} );


// i18n method for extensions to be able to use the language object from the
// DataTable
_api_register( 'i18n()', function ( token, def, plural ) {
	var ctx = this.context[0];
	var resolved = _fnGetObjectDataFn( token )( ctx.oLanguage );

	if ( resolved === undefined ) {
		resolved = def;
	}

	if ( $.isPlainObject( resolved ) ) {
		resolved = plural !== undefined && resolved[ plural ] !== undefined ?
			resolved[ plural ] :
			resolved._;
	}

	return typeof resolved === 'string'
		? resolved.replace( '%d', plural ) // nb: plural might be undefined,
		: resolved;
} );

// Needed for header and footer, so pulled into its own function
function cleanHeader(node, className) {
	$(node).find('span.dt-column-order').remove();
	$(node).find('span.dt-column-title').each(function () {
		var title = $(this).html();
		$(this).parent().parent().append(title);
		$(this).remove();
	});
	$(node).find('div.dt-column-' + className).remove();

	$('th, td', node).removeAttr('data-dt-column');
}

/**
 * Version string for plug-ins to check compatibility. Allowed format is
 * `a.b.c-d` where: a:int, b:int, c:int, d:string(dev|beta|alpha). `d` is used
 * only for non-release builds. See https://semver.org/ for more information.
 *  @member
 *  @type string
 *  @default Version number
 */
DataTable.version = "2.3.1";

/**
 * Private data store, containing all of the settings objects that are
 * created for the tables on a given page.
 *
 * Note that the `DataTable.settings` object is aliased to
 * `jQuery.fn.dataTableExt` through which it may be accessed and
 * manipulated, or `jQuery.fn.dataTable.settings`.
 *  @member
 *  @type array
 *  @default []
 *  @private
 */
DataTable.settings = [];

/**
 * Object models container, for the various models that DataTables has
 * available to it. These models define the objects that are used to hold
 * the active state and configuration of the table.
 *  @namespace
 */
DataTable.models = {};



/**
 * Template object for the way in which DataTables holds information about
 * search information for the global filter and individual column filters.
 *  @namespace
 */
DataTable.models.oSearch = {
	/**
	 * Flag to indicate if the filtering should be case insensitive or not
	 */
	"caseInsensitive": true,

	/**
	 * Applied search term
	 */
	"search": "",

	/**
	 * Flag to indicate if the search term should be interpreted as a
	 * regular expression (true) or not (false) and therefore and special
	 * regex characters escaped.
	 */
	"regex": false,

	/**
	 * Flag to indicate if DataTables is to use its smart filtering or not.
	 */
	"smart": true,

	/**
	 * Flag to indicate if DataTables should only trigger a search when
	 * the return key is pressed.
	 */
	"return": false
};




/**
 * Template object for the way in which DataTables holds information about
 * each individual row. This is the object format used for the settings
 * aoData array.
 *  @namespace
 */
DataTable.models.oRow = {
	/**
	 * TR element for the row
	 */
	"nTr": null,

	/**
	 * Array of TD elements for each row. This is null until the row has been
	 * created.
	 */
	"anCells": null,

	/**
	 * Data object from the original data source for the row. This is either
	 * an array if using the traditional form of DataTables, or an object if
	 * using mData options. The exact type will depend on the passed in
	 * data from the data source, or will be an array if using DOM a data
	 * source.
	 */
	"_aData": [],

	/**
	 * Sorting data cache - this array is ostensibly the same length as the
	 * number of columns (although each index is generated only as it is
	 * needed), and holds the data that is used for sorting each column in the
	 * row. We do this cache generation at the start of the sort in order that
	 * the formatting of the sort data need be done only once for each cell
	 * per sort. This array should not be read from or written to by anything
	 * other than the master sorting methods.
	 */
	"_aSortData": null,

	/**
	 * Per cell filtering data cache. As per the sort data cache, used to
	 * increase the performance of the filtering in DataTables
	 */
	"_aFilterData": null,

	/**
	 * Filtering data cache. This is the same as the cell filtering cache, but
	 * in this case a string rather than an array. This is easily computed with
	 * a join on `_aFilterData`, but is provided as a cache so the join isn't
	 * needed on every search (memory traded for performance)
	 */
	"_sFilterRow": null,

	/**
	 * Denote if the original data source was from the DOM, or the data source
	 * object. This is used for invalidating data, so DataTables can
	 * automatically read data from the original source, unless uninstructed
	 * otherwise.
	 */
	"src": null,

	/**
	 * Index in the aoData array. This saves an indexOf lookup when we have the
	 * object, but want to know the index
	 */
	"idx": -1,

	/**
	 * Cached display value
	 */
	displayData: null
};


/**
 * Template object for the column information object in DataTables. This object
 * is held in the settings aoColumns array and contains all the information that
 * DataTables needs about each individual column.
 *
 * Note that this object is related to {@link DataTable.defaults.column}
 * but this one is the internal data store for DataTables's cache of columns.
 * It should NOT be manipulated outside of DataTables. Any configuration should
 * be done through the initialisation options.
 *  @namespace
 */
DataTable.models.oColumn = {
	/**
	 * Column index.
	 */
	"idx": null,

	/**
	 * A list of the columns that sorting should occur on when this column
	 * is sorted. That this property is an array allows multi-column sorting
	 * to be defined for a column (for example first name / last name columns
	 * would benefit from this). The values are integers pointing to the
	 * columns to be sorted on (typically it will be a single integer pointing
	 * at itself, but that doesn't need to be the case).
	 */
	"aDataSort": null,

	/**
	 * Define the sorting directions that are applied to the column, in sequence
	 * as the column is repeatedly sorted upon - i.e. the first value is used
	 * as the sorting direction when the column if first sorted (clicked on).
	 * Sort it again (click again) and it will move on to the next index.
	 * Repeat until loop.
	 */
	"asSorting": null,

	/**
	 * Flag to indicate if the column is searchable, and thus should be included
	 * in the filtering or not.
	 */
	"bSearchable": null,

	/**
	 * Flag to indicate if the column is sortable or not.
	 */
	"bSortable": null,

	/**
	 * Flag to indicate if the column is currently visible in the table or not
	 */
	"bVisible": null,

	/**
	 * Store for manual type assignment using the `column.type` option. This
	 * is held in store so we can manipulate the column's `sType` property.
	 */
	"_sManualType": null,

	/**
	 * Flag to indicate if HTML5 data attributes should be used as the data
	 * source for filtering or sorting. True is either are.
	 */
	"_bAttrSrc": false,

	/**
	 * Developer definable function that is called whenever a cell is created (Ajax source,
	 * etc) or processed for input (DOM source). This can be used as a compliment to mRender
	 * allowing you to modify the DOM element (add background colour for example) when the
	 * element is available.
	 */
	"fnCreatedCell": null,

	/**
	 * Function to get data from a cell in a column. You should <b>never</b>
	 * access data directly through _aData internally in DataTables - always use
	 * the method attached to this property. It allows mData to function as
	 * required. This function is automatically assigned by the column
	 * initialisation method
	 */
	"fnGetData": null,

	/**
	 * Function to set data for a cell in the column. You should <b>never</b>
	 * set the data directly to _aData internally in DataTables - always use
	 * this method. It allows mData to function as required. This function
	 * is automatically assigned by the column initialisation method
	 */
	"fnSetData": null,

	/**
	 * Property to read the value for the cells in the column from the data
	 * source array / object. If null, then the default content is used, if a
	 * function is given then the return from the function is used.
	 */
	"mData": null,

	/**
	 * Partner property to mData which is used (only when defined) to get
	 * the data - i.e. it is basically the same as mData, but without the
	 * 'set' option, and also the data fed to it is the result from mData.
	 * This is the rendering method to match the data method of mData.
	 */
	"mRender": null,

	/**
	 * The class to apply to all TD elements in the table's TBODY for the column
	 */
	"sClass": null,

	/**
	 * When DataTables calculates the column widths to assign to each column,
	 * it finds the longest string in each column and then constructs a
	 * temporary table and reads the widths from that. The problem with this
	 * is that "mmm" is much wider then "iiii", but the latter is a longer
	 * string - thus the calculation can go wrong (doing it properly and putting
	 * it into an DOM object and measuring that is horribly(!) slow). Thus as
	 * a "work around" we provide this option. It will append its value to the
	 * text that is found to be the longest string for the column - i.e. padding.
	 */
	"sContentPadding": null,

	/**
	 * Allows a default value to be given for a column's data, and will be used
	 * whenever a null data source is encountered (this can be because mData
	 * is set to null, or because the data source itself is null).
	 */
	"sDefaultContent": null,

	/**
	 * Name for the column, allowing reference to the column by name as well as
	 * by index (needs a lookup to work by name).
	 */
	"sName": null,

	/**
	 * Custom sorting data type - defines which of the available plug-ins in
	 * afnSortData the custom sorting will use - if any is defined.
	 */
	"sSortDataType": 'std',

	/**
	 * Class to be applied to the header element when sorting on this column
	 */
	"sSortingClass": null,

	/**
	 * Title of the column - what is seen in the TH element (nTh).
	 */
	"sTitle": null,

	/**
	 * Column sorting and filtering type
	 */
	"sType": null,

	/**
	 * Width of the column
	 */
	"sWidth": null,

	/**
	 * Width of the column when it was first "encountered"
	 */
	"sWidthOrig": null,

	/** Cached string which is the longest in the column */
	maxLenString: null,

	/**
	 * Store for named searches
	 */
	searchFixed: null
};


/*
 * Developer note: The properties of the object below are given in Hungarian
 * notation, that was used as the interface for DataTables prior to v1.10, however
 * from v1.10 onwards the primary interface is camel case. In order to avoid
 * breaking backwards compatibility utterly with this change, the Hungarian
 * version is still, internally the primary interface, but is is not documented
 * - hence the @name tags in each doc comment. This allows a Javascript function
 * to create a map from Hungarian notation to camel case (going the other direction
 * would require each property to be listed, which would add around 3K to the size
 * of DataTables, while this method is about a 0.5K hit).
 *
 * Ultimately this does pave the way for Hungarian notation to be dropped
 * completely, but that is a massive amount of work and will break current
 * installs (therefore is on-hold until v2).
 */

/**
 * Initialisation options that can be given to DataTables at initialisation
 * time.
 *  @namespace
 */
DataTable.defaults = {
	/**
	 * An array of data to use for the table, passed in at initialisation which
	 * will be used in preference to any data which is already in the DOM. This is
	 * particularly useful for constructing tables purely in Javascript, for
	 * example with a custom Ajax call.
	 */
	"aaData": null,


	/**
	 * If ordering is enabled, then DataTables will perform a first pass sort on
	 * initialisation. You can define which column(s) the sort is performed
	 * upon, and the sorting direction, with this variable. The `sorting` array
	 * should contain an array for each column to be sorted initially containing
	 * the column's index and a direction string ('asc' or 'desc').
	 */
	"aaSorting": [[0,'asc']],


	/**
	 * This parameter is basically identical to the `sorting` parameter, but
	 * cannot be overridden by user interaction with the table. What this means
	 * is that you could have a column (visible or hidden) which the sorting
	 * will always be forced on first - any sorting after that (from the user)
	 * will then be performed as required. This can be useful for grouping rows
	 * together.
	 */
	"aaSortingFixed": [],


	/**
	 * DataTables can be instructed to load data to display in the table from a
	 * Ajax source. This option defines how that Ajax call is made and where to.
	 *
	 * The `ajax` property has three different modes of operation, depending on
	 * how it is defined. These are:
	 *
	 * * `string` - Set the URL from where the data should be loaded from.
	 * * `object` - Define properties for `jQuery.ajax`.
	 * * `function` - Custom data get function
	 *
	 * `string`
	 * --------
	 *
	 * As a string, the `ajax` property simply defines the URL from which
	 * DataTables will load data.
	 *
	 * `object`
	 * --------
	 *
	 * As an object, the parameters in the object are passed to
	 * [jQuery.ajax](https://api.jquery.com/jQuery.ajax/) allowing fine control
	 * of the Ajax request. DataTables has a number of default parameters which
	 * you can override using this option. Please refer to the jQuery
	 * documentation for a full description of the options available, although
	 * the following parameters provide additional options in DataTables or
	 * require special consideration:
	 *
	 * * `data` - As with jQuery, `data` can be provided as an object, but it
	 *   can also be used as a function to manipulate the data DataTables sends
	 *   to the server. The function takes a single parameter, an object of
	 *   parameters with the values that DataTables has readied for sending. An
	 *   object may be returned which will be merged into the DataTables
	 *   defaults, or you can add the items to the object that was passed in and
	 *   not return anything from the function. This supersedes `fnServerParams`
	 *   from DataTables 1.9-.
	 *
	 * * `dataSrc` - By default DataTables will look for the property `data` (or
	 *   `aaData` for compatibility with DataTables 1.9-) when obtaining data
	 *   from an Ajax source or for server-side processing - this parameter
	 *   allows that property to be changed. You can use Javascript dotted
	 *   object notation to get a data source for multiple levels of nesting, or
	 *   it my be used as a function. As a function it takes a single parameter,
	 *   the JSON returned from the server, which can be manipulated as
	 *   required, with the returned value being that used by DataTables as the
	 *   data source for the table.
	 *
	 * * `success` - Should not be overridden it is used internally in
	 *   DataTables. To manipulate / transform the data returned by the server
	 *   use `ajax.dataSrc`, or use `ajax` as a function (see below).
	 *
	 * `function`
	 * ----------
	 *
	 * As a function, making the Ajax call is left up to yourself allowing
	 * complete control of the Ajax request. Indeed, if desired, a method other
	 * than Ajax could be used to obtain the required data, such as Web storage
	 * or an AIR database.
	 *
	 * The function is given four parameters and no return is required. The
	 * parameters are:
	 *
	 * 1. _object_ - Data to send to the server
	 * 2. _function_ - Callback function that must be executed when the required
	 *    data has been obtained. That data should be passed into the callback
	 *    as the only parameter
	 * 3. _object_ - DataTables settings object for the table
	 */
	"ajax": null,


	/**
	 * This parameter allows you to readily specify the entries in the length drop
	 * down menu that DataTables shows when pagination is enabled. It can be
	 * either a 1D array of options which will be used for both the displayed
	 * option and the value, or a 2D array which will use the array in the first
	 * position as the value, and the array in the second position as the
	 * displayed options (useful for language strings such as 'All').
	 *
	 * Note that the `pageLength` property will be automatically set to the
	 * first value given in this array, unless `pageLength` is also provided.
	 */
	"aLengthMenu": [ 10, 25, 50, 100 ],


	/**
	 * The `columns` option in the initialisation parameter allows you to define
	 * details about the way individual columns behave. For a full list of
	 * column options that can be set, please see
	 * {@link DataTable.defaults.column}. Note that if you use `columns` to
	 * define your columns, you must have an entry in the array for every single
	 * column that you have in your table (these can be null if you don't which
	 * to specify any options).
	 */
	"aoColumns": null,

	/**
	 * Very similar to `columns`, `columnDefs` allows you to target a specific
	 * column, multiple columns, or all columns, using the `targets` property of
	 * each object in the array. This allows great flexibility when creating
	 * tables, as the `columnDefs` arrays can be of any length, targeting the
	 * columns you specifically want. `columnDefs` may use any of the column
	 * options available: {@link DataTable.defaults.column}, but it _must_
	 * have `targets` defined in each object in the array. Values in the `targets`
	 * array may be:
	 *   <ul>
	 *     <li>a string - class name will be matched on the TH for the column</li>
	 *     <li>0 or a positive integer - column index counting from the left</li>
	 *     <li>a negative integer - column index counting from the right</li>
	 *     <li>the string "_all" - all columns (i.e. assign a default)</li>
	 *   </ul>
	 */
	"aoColumnDefs": null,


	/**
	 * Basically the same as `search`, this parameter defines the individual column
	 * filtering state at initialisation time. The array must be of the same size
	 * as the number of columns, and each element be an object with the parameters
	 * `search` and `escapeRegex` (the latter is optional). 'null' is also
	 * accepted and the default will be used.
	 */
	"aoSearchCols": [],


	/**
	 * Enable or disable automatic column width calculation. This can be disabled
	 * as an optimisation (it takes some time to calculate the widths) if the
	 * tables widths are passed in using `columns`.
	 */
	"bAutoWidth": true,


	/**
	 * Deferred rendering can provide DataTables with a huge speed boost when you
	 * are using an Ajax or JS data source for the table. This option, when set to
	 * true, will cause DataTables to defer the creation of the table elements for
	 * each row until they are needed for a draw - saving a significant amount of
	 * time.
	 */
	"bDeferRender": true,


	/**
	 * Replace a DataTable which matches the given selector and replace it with
	 * one which has the properties of the new initialisation object passed. If no
	 * table matches the selector, then the new DataTable will be constructed as
	 * per normal.
	 */
	"bDestroy": false,


	/**
	 * Enable or disable filtering of data. Filtering in DataTables is "smart" in
	 * that it allows the end user to input multiple words (space separated) and
	 * will match a row containing those words, even if not in the order that was
	 * specified (this allow matching across multiple columns). Note that if you
	 * wish to use filtering in DataTables this must remain 'true' - to remove the
	 * default filtering input box and retain filtering abilities, please use
	 * {@link DataTable.defaults.dom}.
	 */
	"bFilter": true,

	/**
	 * Used only for compatiblity with DT1
	 * @deprecated
	 */
	"bInfo": true,

	/**
	 * Used only for compatiblity with DT1
	 * @deprecated
	 */
	"bLengthChange": true,

	/**
	 * Enable or disable pagination.
	 */
	"bPaginate": true,


	/**
	 * Enable or disable the display of a 'processing' indicator when the table is
	 * being processed (e.g. a sort). This is particularly useful for tables with
	 * large amounts of data where it can take a noticeable amount of time to sort
	 * the entries.
	 */
	"bProcessing": false,


	/**
	 * Retrieve the DataTables object for the given selector. Note that if the
	 * table has already been initialised, this parameter will cause DataTables
	 * to simply return the object that has already been set up - it will not take
	 * account of any changes you might have made to the initialisation object
	 * passed to DataTables (setting this parameter to true is an acknowledgement
	 * that you understand this). `destroy` can be used to reinitialise a table if
	 * you need.
	 */
	"bRetrieve": false,


	/**
	 * When vertical (y) scrolling is enabled, DataTables will force the height of
	 * the table's viewport to the given height at all times (useful for layout).
	 * However, this can look odd when filtering data down to a small data set,
	 * and the footer is left "floating" further down. This parameter (when
	 * enabled) will cause DataTables to collapse the table's viewport down when
	 * the result set will fit within the given Y height.
	 */
	"bScrollCollapse": false,


	/**
	 * Configure DataTables to use server-side processing. Note that the
	 * `ajax` parameter must also be given in order to give DataTables a
	 * source to obtain the required data for each draw.
	 */
	"bServerSide": false,


	/**
	 * Enable or disable sorting of columns. Sorting of individual columns can be
	 * disabled by the `sortable` option for each column.
	 */
	"bSort": true,


	/**
	 * Enable or display DataTables' ability to sort multiple columns at the
	 * same time (activated by shift-click by the user).
	 */
	"bSortMulti": true,


	/**
	 * Allows control over whether DataTables should use the top (true) unique
	 * cell that is found for a single column, or the bottom (false - default).
	 * This is useful when using complex headers.
	 */
	"bSortCellsTop": null,


	/** Specify which row is the title row in the header. Replacement for bSortCellsTop */
	titleRow: null,


	/**
	 * Enable or disable the addition of the classes `sorting\_1`, `sorting\_2` and
	 * `sorting\_3` to the columns which are currently being sorted on. This is
	 * presented as a feature switch as it can increase processing time (while
	 * classes are removed and added) so for large data sets you might want to
	 * turn this off.
	 */
	"bSortClasses": true,


	/**
	 * Enable or disable state saving. When enabled HTML5 `localStorage` will be
	 * used to save table display information such as pagination information,
	 * display length, filtering and sorting. As such when the end user reloads
	 * the page the display display will match what thy had previously set up.
	 */
	"bStateSave": false,


	/**
	 * This function is called when a TR element is created (and all TD child
	 * elements have been inserted), or registered if using a DOM source, allowing
	 * manipulation of the TR element (adding classes etc).
	 */
	"fnCreatedRow": null,


	/**
	 * This function is called on every 'draw' event, and allows you to
	 * dynamically modify any aspect you want about the created DOM.
	 */
	"fnDrawCallback": null,


	/**
	 * Identical to fnHeaderCallback() but for the table footer this function
	 * allows you to modify the table footer on every 'draw' event.
	 */
	"fnFooterCallback": null,


	/**
	 * When rendering large numbers in the information element for the table
	 * (i.e. "Showing 1 to 10 of 57 entries") DataTables will render large numbers
	 * to have a comma separator for the 'thousands' units (e.g. 1 million is
	 * rendered as "1,000,000") to help readability for the end user. This
	 * function will override the default method DataTables uses.
	 */
	"fnFormatNumber": function ( toFormat ) {
		return toFormat.toString().replace(
			/\B(?=(\d{3})+(?!\d))/g,
			this.oLanguage.sThousands
		);
	},


	/**
	 * This function is called on every 'draw' event, and allows you to
	 * dynamically modify the header row. This can be used to calculate and
	 * display useful information about the table.
	 */
	"fnHeaderCallback": null,


	/**
	 * The information element can be used to convey information about the current
	 * state of the table. Although the internationalisation options presented by
	 * DataTables are quite capable of dealing with most customisations, there may
	 * be times where you wish to customise the string further. This callback
	 * allows you to do exactly that.
	 */
	"fnInfoCallback": null,


	/**
	 * Called when the table has been initialised. Normally DataTables will
	 * initialise sequentially and there will be no need for this function,
	 * however, this does not hold true when using external language information
	 * since that is obtained using an async XHR call.
	 */
	"fnInitComplete": null,


	/**
	 * Called at the very start of each table draw and can be used to cancel the
	 * draw by returning false, any other return (including undefined) results in
	 * the full draw occurring).
	 */
	"fnPreDrawCallback": null,


	/**
	 * This function allows you to 'post process' each row after it have been
	 * generated for each table draw, but before it is rendered on screen. This
	 * function might be used for setting the row class name etc.
	 */
	"fnRowCallback": null,


	/**
	 * Load the table state. With this function you can define from where, and how, the
	 * state of a table is loaded. By default DataTables will load from `localStorage`
	 * but you might wish to use a server-side database or cookies.
	 */
	"fnStateLoadCallback": function ( settings ) {
		try {
			return JSON.parse(
				(settings.iStateDuration === -1 ? sessionStorage : localStorage).getItem(
					'DataTables_'+settings.sInstance+'_'+location.pathname
				)
			);
		} catch (e) {
			return {};
		}
	},


	/**
	 * Callback which allows modification of the saved state prior to loading that state.
	 * This callback is called when the table is loading state from the stored data, but
	 * prior to the settings object being modified by the saved state. Note that for
	 * plug-in authors, you should use the `stateLoadParams` event to load parameters for
	 * a plug-in.
	 */
	"fnStateLoadParams": null,


	/**
	 * Callback that is called when the state has been loaded from the state saving method
	 * and the DataTables settings object has been modified as a result of the loaded state.
	 */
	"fnStateLoaded": null,


	/**
	 * Save the table state. This function allows you to define where and how the state
	 * information for the table is stored By default DataTables will use `localStorage`
	 * but you might wish to use a server-side database or cookies.
	 */
	"fnStateSaveCallback": function ( settings, data ) {
		try {
			(settings.iStateDuration === -1 ? sessionStorage : localStorage).setItem(
				'DataTables_'+settings.sInstance+'_'+location.pathname,
				JSON.stringify( data )
			);
		} catch (e) {
			// noop
		}
	},


	/**
	 * Callback which allows modification of the state to be saved. Called when the table
	 * has changed state a new state save is required. This method allows modification of
	 * the state saving object prior to actually doing the save, including addition or
	 * other state properties or modification. Note that for plug-in authors, you should
	 * use the `stateSaveParams` event to save parameters for a plug-in.
	 */
	"fnStateSaveParams": null,


	/**
	 * Duration for which the saved state information is considered valid. After this period
	 * has elapsed the state will be returned to the default.
	 * Value is given in seconds.
	 */
	"iStateDuration": 7200,


	/**
	 * Number of rows to display on a single page when using pagination. If
	 * feature enabled (`lengthChange`) then the end user will be able to override
	 * this to a custom setting using a pop-up menu.
	 */
	"iDisplayLength": 10,


	/**
	 * Define the starting point for data display when using DataTables with
	 * pagination. Note that this parameter is the number of records, rather than
	 * the page number, so if you have 10 records per page and want to start on
	 * the third page, it should be "20".
	 */
	"iDisplayStart": 0,


	/**
	 * By default DataTables allows keyboard navigation of the table (sorting, paging,
	 * and filtering) by adding a `tabindex` attribute to the required elements. This
	 * allows you to tab through the controls and press the enter key to activate them.
	 * The tabindex is default 0, meaning that the tab follows the flow of the document.
	 * You can overrule this using this parameter if you wish. Use a value of -1 to
	 * disable built-in keyboard navigation.
	 */
	"iTabIndex": 0,


	/**
	 * Classes that DataTables assigns to the various components and features
	 * that it adds to the HTML table. This allows classes to be configured
	 * during initialisation in addition to through the static
	 * {@link DataTable.ext.oStdClasses} object).
	 */
	"oClasses": {},


	/**
	 * All strings that DataTables uses in the user interface that it creates
	 * are defined in this object, allowing you to modified them individually or
	 * completely replace them all as required.
	 */
	"oLanguage": {
		/**
		 * Strings that are used for WAI-ARIA labels and controls only (these are not
		 * actually visible on the page, but will be read by screenreaders, and thus
		 * must be internationalised as well).
		 */
		"oAria": {
			/**
			 * ARIA label that is added to the table headers when the column may be sorted
			 */
			"orderable": ": Activate to sort",

			/**
			 * ARIA label that is added to the table headers when the column is currently being sorted
			 */
			"orderableReverse": ": Activate to invert sorting",

			/**
			 * ARIA label that is added to the table headers when the column is currently being 
			 * sorted and next step is to remove sorting
			 */
			"orderableRemove": ": Activate to remove sorting",

			paginate: {
				first: 'First',
				last: 'Last',
				next: 'Next',
				previous: 'Previous',
				number: ''
			}
		},

		/**
		 * Pagination string used by DataTables for the built-in pagination
		 * control types.
		 */
		"oPaginate": {
			/**
			 * Label and character for first page button (Â«)
			 */
			"sFirst": "\u00AB",

			/**
			 * Last page button (Â»)
			 */
			"sLast": "\u00BB",

			/**
			 * Next page button (âº)
			 */
			"sNext": "\u203A",

			/**
			 * Previous page button (â¹)
			 */
			"sPrevious": "\u2039",
		},

		/**
		 * Plural object for the data type the table is showing
		 */
		entries: {
			_: "entries",
			1: "entry"
		},

		/**
		 * Page length options
		 */
		lengthLabels: {
			'-1': 'All'
		},

		/**
		 * This string is shown in preference to `zeroRecords` when the table is
		 * empty of data (regardless of filtering). Note that this is an optional
		 * parameter - if it is not given, the value of `zeroRecords` will be used
		 * instead (either the default or given value).
		 */
		"sEmptyTable": "No data available in table",


		/**
		 * This string gives information to the end user about the information
		 * that is current on display on the page. The following tokens can be
		 * used in the string and will be dynamically replaced as the table
		 * display updates. This tokens can be placed anywhere in the string, or
		 * removed as needed by the language requires:
		 *
		 * * `\_START\_` - Display index of the first record on the current page
		 * * `\_END\_` - Display index of the last record on the current page
		 * * `\_TOTAL\_` - Number of records in the table after filtering
		 * * `\_MAX\_` - Number of records in the table without filtering
		 * * `\_PAGE\_` - Current page number
		 * * `\_PAGES\_` - Total number of pages of data in the table
		 */
		"sInfo": "Showing _START_ to _END_ of _TOTAL_ _ENTRIES-TOTAL_",


		/**
		 * Display information string for when the table is empty. Typically the
		 * format of this string should match `info`.
		 */
		"sInfoEmpty": "Showing 0 to 0 of 0 _ENTRIES-TOTAL_",


		/**
		 * When a user filters the information in a table, this string is appended
		 * to the information (`info`) to give an idea of how strong the filtering
		 * is. The variable _MAX_ is dynamically updated.
		 */
		"sInfoFiltered": "(filtered from _MAX_ total _ENTRIES-MAX_)",


		/**
		 * If can be useful to append extra information to the info string at times,
		 * and this variable does exactly that. This information will be appended to
		 * the `info` (`infoEmpty` and `infoFiltered` in whatever combination they are
		 * being used) at all times.
		 */
		"sInfoPostFix": "",


		/**
		 * This decimal place operator is a little different from the other
		 * language options since DataTables doesn't output floating point
		 * numbers, so it won't ever use this for display of a number. Rather,
		 * what this parameter does is modify the sort methods of the table so
		 * that numbers which are in a format which has a character other than
		 * a period (`.`) as a decimal place will be sorted numerically.
		 *
		 * Note that numbers with different decimal places cannot be shown in
		 * the same table and still be sortable, the table must be consistent.
		 * However, multiple different tables on the page can use different
		 * decimal place characters.
		 */
		"sDecimal": "",


		/**
		 * DataTables has a build in number formatter (`formatNumber`) which is
		 * used to format large numbers that are used in the table information.
		 * By default a comma is used, but this can be trivially changed to any
		 * character you wish with this parameter.
		 */
		"sThousands": ",",


		/**
		 * Detail the action that will be taken when the drop down menu for the
		 * pagination length option is changed. The '_MENU_' variable is replaced
		 * with a default select list of 10, 25, 50 and 100, and can be replaced
		 * with a custom select box if required.
		 */
		"sLengthMenu": "_MENU_ _ENTRIES_ per page",


		/**
		 * When using Ajax sourced data and during the first draw when DataTables is
		 * gathering the data, this message is shown in an empty row in the table to
		 * indicate to the end user the the data is being loaded. Note that this
		 * parameter is not used when loading data by server-side processing, just
		 * Ajax sourced data with client-side processing.
		 */
		"sLoadingRecords": "Loading...",


		/**
		 * Text which is displayed when the table is processing a user action
		 * (usually a sort command or similar).
		 */
		"sProcessing": "",


		/**
		 * Details the actions that will be taken when the user types into the
		 * filtering input text box. The variable "_INPUT_", if used in the string,
		 * is replaced with the HTML text box for the filtering input allowing
		 * control over where it appears in the string. If "_INPUT_" is not given
		 * then the input box is appended to the string automatically.
		 */
		"sSearch": "Search:",


		/**
		 * Assign a `placeholder` attribute to the search `input` element
		 *  @type string
		 *  @default 
		 *
		 *  @dtopt Language
		 *  @name DataTable.defaults.language.searchPlaceholder
		 */
		"sSearchPlaceholder": "",


		/**
		 * All of the language information can be stored in a file on the
		 * server-side, which DataTables will look up if this parameter is passed.
		 * It must store the URL of the language file, which is in a JSON format,
		 * and the object has the same properties as the oLanguage object in the
		 * initialiser object (i.e. the above parameters). Please refer to one of
		 * the example language files to see how this works in action.
		 */
		"sUrl": "",


		/**
		 * Text shown inside the table records when the is no information to be
		 * displayed after filtering. `emptyTable` is shown when there is simply no
		 * information in the table at all (regardless of filtering).
		 */
		"sZeroRecords": "No matching records found"
	},


	/** The initial data order is reversed when `desc` ordering */
	orderDescReverse: true,


	/**
	 * This parameter allows you to have define the global filtering state at
	 * initialisation time. As an object the `search` parameter must be
	 * defined, but all other parameters are optional. When `regex` is true,
	 * the search string will be treated as a regular expression, when false
	 * (default) it will be treated as a straight string. When `smart`
	 * DataTables will use it's smart filtering methods (to word match at
	 * any point in the data), when false this will not be done.
	 */
	"oSearch": $.extend( {}, DataTable.models.oSearch ),


	/**
	 * Table and control layout. This replaces the legacy `dom` option.
	 */
	layout: {
		topStart: 'pageLength',
		topEnd: 'search',
		bottomStart: 'info',
		bottomEnd: 'paging'
	},


	/**
	 * Legacy DOM layout option
	 */
	"sDom": null,


	/**
	 * Search delay option. This will throttle full table searches that use the
	 * DataTables provided search input element (it does not effect calls to
	 * `dt-api search()`, providing a delay before the search is made.
	 */
	"searchDelay": null,


	/**
	 * DataTables features six different built-in options for the buttons to
	 * display for pagination control:
	 *
	 * * `numbers` - Page number buttons only
	 * * `simple` - 'Previous' and 'Next' buttons only
	 * * 'simple_numbers` - 'Previous' and 'Next' buttons, plus page numbers
	 * * `full` - 'First', 'Previous', 'Next' and 'Last' buttons
	 * * `full_numbers` - 'First', 'Previous', 'Next' and 'Last' buttons, plus page numbers
	 * * `first_last_numbers` - 'First' and 'Last' buttons, plus page numbers
	 */
	"sPaginationType": "",


	/**
	 * Enable horizontal scrolling. When a table is too wide to fit into a
	 * certain layout, or you have a large number of columns in the table, you
	 * can enable x-scrolling to show the table in a viewport, which can be
	 * scrolled. This property can be `true` which will allow the table to
	 * scroll horizontally when needed, or any CSS unit, or a number (in which
	 * case it will be treated as a pixel measurement). Setting as simply `true`
	 * is recommended.
	 */
	"sScrollX": "",


	/**
	 * This property can be used to force a DataTable to use more width than it
	 * might otherwise do when x-scrolling is enabled. For example if you have a
	 * table which requires to be well spaced, this parameter is useful for
	 * "over-sizing" the table, and thus forcing scrolling. This property can by
	 * any CSS unit, or a number (in which case it will be treated as a pixel
	 * measurement).
	 */
	"sScrollXInner": "",


	/**
	 * Enable vertical scrolling. Vertical scrolling will constrain the DataTable
	 * to the given height, and enable scrolling for any data which overflows the
	 * current viewport. This can be used as an alternative to paging to display
	 * a lot of data in a small area (although paging and scrolling can both be
	 * enabled at the same time). This property can be any CSS unit, or a number
	 * (in which case it will be treated as a pixel measurement).
	 */
	"sScrollY": "",


	/**
	 * __Deprecated__ The functionality provided by this parameter has now been
	 * superseded by that provided through `ajax`, which should be used instead.
	 *
	 * Set the HTTP method that is used to make the Ajax call for server-side
	 * processing or Ajax sourced data.
	 */
	"sServerMethod": "GET",


	/**
	 * DataTables makes use of renderers when displaying HTML elements for
	 * a table. These renderers can be added or modified by plug-ins to
	 * generate suitable mark-up for a site. For example the Bootstrap
	 * integration plug-in for DataTables uses a paging button renderer to
	 * display pagination buttons in the mark-up required by Bootstrap.
	 *
	 * For further information about the renderers available see
	 * DataTable.ext.renderer
	 */
	"renderer": null,


	/**
	 * Set the data property name that DataTables should use to get a row's id
	 * to set as the `id` property in the node.
	 */
	"rowId": "DT_RowId",


	/**
	 * Caption value
	 */
	"caption": null,


	/**
	 * For server-side processing - use the data from the DOM for the first draw
	 */
	iDeferLoading: null,

	/** Event listeners */
	on: null
};

_fnHungarianMap( DataTable.defaults );



/*
 * Developer note - See note in model.defaults.js about the use of Hungarian
 * notation and camel case.
 */

/**
 * Column options that can be given to DataTables at initialisation time.
 *  @namespace
 */
DataTable.defaults.column = {
	/**
	 * Define which column(s) an order will occur on for this column. This
	 * allows a column's ordering to take multiple columns into account when
	 * doing a sort or use the data from a different column. For example first
	 * name / last name columns make sense to do a multi-column sort over the
	 * two columns.
	 */
	"aDataSort": null,
	"iDataSort": -1,

	ariaTitle: '',


	/**
	 * You can control the default ordering direction, and even alter the
	 * behaviour of the sort handler (i.e. only allow ascending ordering etc)
	 * using this parameter.
	 */
	"asSorting": [ 'asc', 'desc', '' ],


	/**
	 * Enable or disable filtering on the data in this column.
	 */
	"bSearchable": true,


	/**
	 * Enable or disable ordering on this column.
	 */
	"bSortable": true,


	/**
	 * Enable or disable the display of this column.
	 */
	"bVisible": true,


	/**
	 * Developer definable function that is called whenever a cell is created (Ajax source,
	 * etc) or processed for input (DOM source). This can be used as a compliment to mRender
	 * allowing you to modify the DOM element (add background colour for example) when the
	 * element is available.
	 */
	"fnCreatedCell": null,


	/**
	 * This property can be used to read data from any data source property,
	 * including deeply nested objects / properties. `data` can be given in a
	 * number of different ways which effect its behaviour:
	 *
	 * * `integer` - treated as an array index for the data source. This is the
	 *   default that DataTables uses (incrementally increased for each column).
	 * * `string` - read an object property from the data source. There are
	 *   three 'special' options that can be used in the string to alter how
	 *   DataTables reads the data from the source object:
	 *    * `.` - Dotted Javascript notation. Just as you use a `.` in
	 *      Javascript to read from nested objects, so to can the options
	 *      specified in `data`. For example: `browser.version` or
	 *      `browser.name`. If your object parameter name contains a period, use
	 *      `\\` to escape it - i.e. `first\\.name`.
	 *    * `[]` - Array notation. DataTables can automatically combine data
	 *      from and array source, joining the data with the characters provided
	 *      between the two brackets. For example: `name[, ]` would provide a
	 *      comma-space separated list from the source array. If no characters
	 *      are provided between the brackets, the original array source is
	 *      returned.
	 *    * `()` - Function notation. Adding `()` to the end of a parameter will
	 *      execute a function of the name given. For example: `browser()` for a
	 *      simple function on the data source, `browser.version()` for a
	 *      function in a nested property or even `browser().version` to get an
	 *      object property if the function called returns an object. Note that
	 *      function notation is recommended for use in `render` rather than
	 *      `data` as it is much simpler to use as a renderer.
	 * * `null` - use the original data source for the row rather than plucking
	 *   data directly from it. This action has effects on two other
	 *   initialisation options:
	 *    * `defaultContent` - When null is given as the `data` option and
	 *      `defaultContent` is specified for the column, the value defined by
	 *      `defaultContent` will be used for the cell.
	 *    * `render` - When null is used for the `data` option and the `render`
	 *      option is specified for the column, the whole data source for the
	 *      row is used for the renderer.
	 * * `function` - the function given will be executed whenever DataTables
	 *   needs to set or get the data for a cell in the column. The function
	 *   takes three parameters:
	 *    * Parameters:
	 *      * `{array|object}` The data source for the row
	 *      * `{string}` The type call data requested - this will be 'set' when
	 *        setting data or 'filter', 'display', 'type', 'sort' or undefined
	 *        when gathering data. Note that when `undefined` is given for the
	 *        type DataTables expects to get the raw data for the object back<
	 *      * `{*}` Data to set when the second parameter is 'set'.
	 *    * Return:
	 *      * The return value from the function is not required when 'set' is
	 *        the type of call, but otherwise the return is what will be used
	 *        for the data requested.
	 *
	 * Note that `data` is a getter and setter option. If you just require
	 * formatting of data for output, you will likely want to use `render` which
	 * is simply a getter and thus simpler to use.
	 *
	 * Note that prior to DataTables 1.9.2 `data` was called `mDataProp`. The
	 * name change reflects the flexibility of this property and is consistent
	 * with the naming of mRender. If 'mDataProp' is given, then it will still
	 * be used by DataTables, as it automatically maps the old name to the new
	 * if required.
	 */
	"mData": null,


	/**
	 * This property is the rendering partner to `data` and it is suggested that
	 * when you want to manipulate data for display (including filtering,
	 * sorting etc) without altering the underlying data for the table, use this
	 * property. `render` can be considered to be the the read only companion to
	 * `data` which is read / write (then as such more complex). Like `data`
	 * this option can be given in a number of different ways to effect its
	 * behaviour:
	 *
	 * * `integer` - treated as an array index for the data source. This is the
	 *   default that DataTables uses (incrementally increased for each column).
	 * * `string` - read an object property from the data source. There are
	 *   three 'special' options that can be used in the string to alter how
	 *   DataTables reads the data from the source object:
	 *    * `.` - Dotted Javascript notation. Just as you use a `.` in
	 *      Javascript to read from nested objects, so to can the options
	 *      specified in `data`. For example: `browser.version` or
	 *      `browser.name`. If your object parameter name contains a period, use
	 *      `\\` to escape it - i.e. `first\\.name`.
	 *    * `[]` - Array notation. DataTables can automatically combine data
	 *      from and array source, joining the data with the characters provided
	 *      between the two brackets. For example: `name[, ]` would provide a
	 *      comma-space separated list from the source array. If no characters
	 *      are provided between the brackets, the original array source is
	 *      returned.
	 *    * `()` - Function notation. Adding `()` to the end of a parameter will
	 *      execute a function of the name given. For example: `browser()` for a
	 *      simple function on the data source, `browser.version()` for a
	 *      function in a nested property or even `browser().version` to get an
	 *      object property if the function called returns an object.
	 * * `object` - use different data for the different data types requested by
	 *   DataTables ('filter', 'display', 'type' or 'sort'). The property names
	 *   of the object is the data type the property refers to and the value can
	 *   defined using an integer, string or function using the same rules as
	 *   `render` normally does. Note that an `_` option _must_ be specified.
	 *   This is the default value to use if you haven't specified a value for
	 *   the data type requested by DataTables.
	 * * `function` - the function given will be executed whenever DataTables
	 *   needs to set or get the data for a cell in the column. The function
	 *   takes three parameters:
	 *    * Parameters:
	 *      * {array|object} The data source for the row (based on `data`)
	 *      * {string} The type call data requested - this will be 'filter',
	 *        'display', 'type' or 'sort'.
	 *      * {array|object} The full data source for the row (not based on
	 *        `data`)
	 *    * Return:
	 *      * The return value from the function is what will be used for the
	 *        data requested.
	 */
	"mRender": null,


	/**
	 * Change the cell type created for the column - either TD cells or TH cells. This
	 * can be useful as TH cells have semantic meaning in the table body, allowing them
	 * to act as a header for a row (you may wish to add scope='row' to the TH elements).
	 */
	"sCellType": "td",


	/**
	 * Class to give to each cell in this column.
	 */
	"sClass": "",

	/**
	 * When DataTables calculates the column widths to assign to each column,
	 * it finds the longest string in each column and then constructs a
	 * temporary table and reads the widths from that. The problem with this
	 * is that "mmm" is much wider then "iiii", but the latter is a longer
	 * string - thus the calculation can go wrong (doing it properly and putting
	 * it into an DOM object and measuring that is horribly(!) slow). Thus as
	 * a "work around" we provide this option. It will append its value to the
	 * text that is found to be the longest string for the column - i.e. padding.
	 * Generally you shouldn't need this!
	 */
	"sContentPadding": "",


	/**
	 * Allows a default value to be given for a column's data, and will be used
	 * whenever a null data source is encountered (this can be because `data`
	 * is set to null, or because the data source itself is null).
	 */
	"sDefaultContent": null,


	/**
	 * This parameter is only used in DataTables' server-side processing. It can
	 * be exceptionally useful to know what columns are being displayed on the
	 * client side, and to map these to database fields. When defined, the names
	 * also allow DataTables to reorder information from the server if it comes
	 * back in an unexpected order (i.e. if you switch your columns around on the
	 * client-side, your server-side code does not also need updating).
	 */
	"sName": "",


	/**
	 * Defines a data source type for the ordering which can be used to read
	 * real-time information from the table (updating the internally cached
	 * version) prior to ordering. This allows ordering to occur on user
	 * editable elements such as form inputs.
	 */
	"sSortDataType": "std",


	/**
	 * The title of this column.
	 */
	"sTitle": null,


	/**
	 * The type allows you to specify how the data for this column will be
	 * ordered. Four types (string, numeric, date and html (which will strip
	 * HTML tags before ordering)) are currently available. Note that only date
	 * formats understood by Javascript's Date() object will be accepted as type
	 * date. For example: "Mar 26, 2008 5:03 PM". May take the values: 'string',
	 * 'numeric', 'date' or 'html' (by default). Further types can be adding
	 * through plug-ins.
	 */
	"sType": null,


	/**
	 * Defining the width of the column, this parameter may take any CSS value
	 * (3em, 20px etc). DataTables applies 'smart' widths to columns which have not
	 * been given a specific width through this interface ensuring that the table
	 * remains readable.
	 */
	"sWidth": null
};

_fnHungarianMap( DataTable.defaults.column );



/**
 * DataTables settings object - this holds all the information needed for a
 * given table, including configuration, data and current application of the
 * table options. DataTables does not have a single instance for each DataTable
 * with the settings attached to that instance, but rather instances of the
 * DataTable "class" are created on-the-fly as needed (typically by a
 * $().dataTable() call) and the settings object is then applied to that
 * instance.
 *
 * Note that this object is related to {@link DataTable.defaults} but this
 * one is the internal data store for DataTables's cache of columns. It should
 * NOT be manipulated outside of DataTables. Any configuration should be done
 * through the initialisation options.
 */
DataTable.models.oSettings = {
	/**
	 * Primary features of DataTables and their enablement state.
	 */
	"oFeatures": {

		/**
		 * Flag to say if DataTables should automatically try to calculate the
		 * optimum table and columns widths (true) or not (false).
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 */
		"bAutoWidth": null,

		/**
		 * Delay the creation of TR and TD elements until they are actually
		 * needed by a driven page draw. This can give a significant speed
		 * increase for Ajax source and Javascript source data, but makes no
		 * difference at all for DOM and server-side processing tables.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 */
		"bDeferRender": null,

		/**
		 * Enable filtering on the table or not. Note that if this is disabled
		 * then there is no filtering at all on the table, including fnFilter.
		 * To just remove the filtering input use sDom and remove the 'f' option.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 */
		"bFilter": null,

		/**
		 * Used only for compatiblity with DT1
		 * @deprecated
		 */
		"bInfo": true,

		/**
		 * Used only for compatiblity with DT1
		 * @deprecated
		 */
		"bLengthChange": true,

		/**
		 * Pagination enabled or not. Note that if this is disabled then length
		 * changing must also be disabled.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 */
		"bPaginate": null,

		/**
		 * Processing indicator enable flag whenever DataTables is enacting a
		 * user request - typically an Ajax request for server-side processing.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 */
		"bProcessing": null,

		/**
		 * Server-side processing enabled flag - when enabled DataTables will
		 * get all data from the server for every draw - there is no filtering,
		 * sorting or paging done on the client-side.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 */
		"bServerSide": null,

		/**
		 * Sorting enablement flag.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 */
		"bSort": null,

		/**
		 * Multi-column sorting
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 */
		"bSortMulti": null,

		/**
		 * Apply a class to the columns which are being sorted to provide a
		 * visual highlight or not. This can slow things down when enabled since
		 * there is a lot of DOM interaction.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 */
		"bSortClasses": null,

		/**
		 * State saving enablement flag.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 */
		"bStateSave": null
	},


	/**
	 * Scrolling settings for a table.
	 */
	"oScroll": {
		/**
		 * When the table is shorter in height than sScrollY, collapse the
		 * table container down to the height of the table (when true).
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 */
		"bCollapse": null,

		/**
		 * Width of the scrollbar for the web-browser's platform. Calculated
		 * during table initialisation.
		 */
		"iBarWidth": 0,

		/**
		 * Viewport width for horizontal scrolling. Horizontal scrolling is
		 * disabled if an empty string.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 */
		"sX": null,

		/**
		 * Width to expand the table to when using x-scrolling. Typically you
		 * should not need to use this.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @deprecated
		 */
		"sXInner": null,

		/**
		 * Viewport height for vertical scrolling. Vertical scrolling is disabled
		 * if an empty string.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 */
		"sY": null
	},

	/**
	 * Language information for the table.
	 */
	"oLanguage": {
		/**
		 * Information callback function. See
		 * {@link DataTable.defaults.fnInfoCallback}
		 */
		"fnInfoCallback": null
	},

	/**
	 * Browser support parameters
	 */
	"oBrowser": {
		/**
		 * Determine if the vertical scrollbar is on the right or left of the
		 * scrolling container - needed for rtl language layout, although not
		 * all browsers move the scrollbar (Safari).
		 */
		"bScrollbarLeft": false,

		/**
		 * Browser scrollbar width
		 */
		"barWidth": 0
	},


	"ajax": null,


	/**
	 * Array referencing the nodes which are used for the features. The
	 * parameters of this object match what is allowed by sDom - i.e.
	 *   <ul>
	 *     <li>'l' - Length changing</li>
	 *     <li>'f' - Filtering input</li>
	 *     <li>'t' - The table!</li>
	 *     <li>'i' - Information</li>
	 *     <li>'p' - Pagination</li>
	 *     <li>'r' - pRocessing</li>
	 *   </ul>
	 */
	"aanFeatures": [],

	/**
	 * Store data information - see {@link DataTable.models.oRow} for detailed
	 * information.
	 */
	"aoData": [],

	/**
	 * Array of indexes which are in the current display (after filtering etc)
	 */
	"aiDisplay": [],

	/**
	 * Array of indexes for display - no filtering
	 */
	"aiDisplayMaster": [],

	/**
	 * Map of row ids to data indexes
	 */
	"aIds": {},

	/**
	 * Store information about each column that is in use
	 */
	"aoColumns": [],

	/**
	 * Store information about the table's header
	 */
	"aoHeader": [],

	/**
	 * Store information about the table's footer
	 */
	"aoFooter": [],

	/**
	 * Store the applied global search information in case we want to force a
	 * research or compare the old search to a new one.
	 * Note that this parameter will be set by the initialisation routine. To
	 * set a default use {@link DataTable.defaults}.
	 */
	"oPreviousSearch": {},

	/**
	 * Store for named searches
	 */
	searchFixed: {},

	/**
	 * Store the applied search for each column - see
	 * {@link DataTable.models.oSearch} for the format that is used for the
	 * filtering information for each column.
	 */
	"aoPreSearchCols": [],

	/**
	 * Sorting that is applied to the table. Note that the inner arrays are
	 * used in the following manner:
	 * <ul>
	 *   <li>Index 0 - column number</li>
	 *   <li>Index 1 - current sorting direction</li>
	 * </ul>
	 * Note that this parameter will be set by the initialisation routine. To
	 * set a default use {@link DataTable.defaults}.
	 */
	"aaSorting": null,

	/**
	 * Sorting that is always applied to the table (i.e. prefixed in front of
	 * aaSorting).
	 * Note that this parameter will be set by the initialisation routine. To
	 * set a default use {@link DataTable.defaults}.
	 */
	"aaSortingFixed": [],

	/**
	 * If restoring a table - we should restore its width
	 */
	"sDestroyWidth": 0,

	/**
	 * Callback functions array for every time a row is inserted (i.e. on a draw).
	 */
	"aoRowCallback": [],

	/**
	 * Callback functions for the header on each draw.
	 */
	"aoHeaderCallback": [],

	/**
	 * Callback function for the footer on each draw.
	 */
	"aoFooterCallback": [],

	/**
	 * Array of callback functions for draw callback functions
	 */
	"aoDrawCallback": [],

	/**
	 * Array of callback functions for row created function
	 */
	"aoRowCreatedCallback": [],

	/**
	 * Callback functions for just before the table is redrawn. A return of
	 * false will be used to cancel the draw.
	 */
	"aoPreDrawCallback": [],

	/**
	 * Callback functions for when the table has been initialised.
	 */
	"aoInitComplete": [],


	/**
	 * Callbacks for modifying the settings to be stored for state saving, prior to
	 * saving state.
	 */
	"aoStateSaveParams": [],

	/**
	 * Callbacks for modifying the settings that have been stored for state saving
	 * prior to using the stored values to restore the state.
	 */
	"aoStateLoadParams": [],

	/**
	 * Callbacks for operating on the settings object once the saved state has been
	 * loaded
	 */
	"aoStateLoaded": [],

	/**
	 * Cache the table ID for quick access
	 */
	"sTableId": "",

	/**
	 * The TABLE node for the main table
	 */
	"nTable": null,

	/**
	 * Permanent ref to the thead element
	 */
	"nTHead": null,

	/**
	 * Permanent ref to the tfoot element - if it exists
	 */
	"nTFoot": null,

	/**
	 * Permanent ref to the tbody element
	 */
	"nTBody": null,

	/**
	 * Cache the wrapper node (contains all DataTables controlled elements)
	 */
	"nTableWrapper": null,

	/**
	 * Indicate if all required information has been read in
	 */
	"bInitialised": false,

	/**
	 * Information about open rows. Each object in the array has the parameters
	 * 'nTr' and 'nParent'
	 */
	"aoOpenRows": [],

	/**
	 * Dictate the positioning of DataTables' control elements - see
	 * {@link DataTable.model.oInit.sDom}.
	 * Note that this parameter will be set by the initialisation routine. To
	 * set a default use {@link DataTable.defaults}.
	 */
	"sDom": null,

	/**
	 * Search delay (in mS)
	 */
	"searchDelay": null,

	/**
	 * Which type of pagination should be used.
	 * Note that this parameter will be set by the initialisation routine. To
	 * set a default use {@link DataTable.defaults}.
	 */
	"sPaginationType": "two_button",

	/**
	 * Number of paging controls on the page. Only used for backwards compatibility
	 */
	pagingControls: 0,

	/**
	 * The state duration (for `stateSave`) in seconds.
	 * Note that this parameter will be set by the initialisation routine. To
	 * set a default use {@link DataTable.defaults}.
	 */
	"iStateDuration": 0,

	/**
	 * Array of callback functions for state saving. Each array element is an
	 * object with the following parameters:
	 *   <ul>
	 *     <li>function:fn - function to call. Takes two parameters, oSettings
	 *       and the JSON string to save that has been thus far created. Returns
	 *       a JSON string to be inserted into a json object
	 *       (i.e. '"param": [ 0, 1, 2]')</li>
	 *     <li>string:sName - name of callback</li>
	 *   </ul>
	 */
	"aoStateSave": [],

	/**
	 * Array of callback functions for state loading. Each array element is an
	 * object with the following parameters:
	 *   <ul>
	 *     <li>function:fn - function to call. Takes two parameters, oSettings
	 *       and the object stored. May return false to cancel state loading</li>
	 *     <li>string:sName - name of callback</li>
	 *   </ul>
	 */
	"aoStateLoad": [],

	/**
	 * State that was saved. Useful for back reference
	 */
	"oSavedState": null,

	/**
	 * State that was loaded. Useful for back reference
	 */
	"oLoadedState": null,

	/**
	 * Note if draw should be blocked while getting data
	 */
	"bAjaxDataGet": true,

	/**
	 * The last jQuery XHR object that was used for server-side data gathering.
	 * This can be used for working with the XHR information in one of the
	 * callbacks
	 */
	"jqXHR": null,

	/**
	 * JSON returned from the server in the last Ajax request
	 */
	"json": undefined,

	/**
	 * Data submitted as part of the last Ajax request
	 */
	"oAjaxData": undefined,

	/**
	 * Send the XHR HTTP method - GET or POST (could be PUT or DELETE if
	 * required).
	 * Note that this parameter will be set by the initialisation routine. To
	 * set a default use {@link DataTable.defaults}.
	 */
	"sServerMethod": null,

	/**
	 * Format numbers for display.
	 * Note that this parameter will be set by the initialisation routine. To
	 * set a default use {@link DataTable.defaults}.
	 */
	"fnFormatNumber": null,

	/**
	 * List of options that can be used for the user selectable length menu.
	 * Note that this parameter will be set by the initialisation routine. To
	 * set a default use {@link DataTable.defaults}.
	 */
	"aLengthMenu": null,

	/**
	 * Counter for the draws that the table does. Also used as a tracker for
	 * server-side processing
	 */
	"iDraw": 0,

	/**
	 * Indicate if a redraw is being done - useful for Ajax
	 */
	"bDrawing": false,

	/**
	 * Draw index (iDraw) of the last error when parsing the returned data
	 */
	"iDrawError": -1,

	/**
	 * Paging display length
	 */
	"_iDisplayLength": 10,

	/**
	 * Paging start point - aiDisplay index
	 */
	"_iDisplayStart": 0,

	/**
	 * Server-side processing - number of records in the result set
	 * (i.e. before filtering), Use fnRecordsTotal rather than
	 * this property to get the value of the number of records, regardless of
	 * the server-side processing setting.
	 */
	"_iRecordsTotal": 0,

	/**
	 * Server-side processing - number of records in the current display set
	 * (i.e. after filtering). Use fnRecordsDisplay rather than
	 * this property to get the value of the number of records, regardless of
	 * the server-side processing setting.
	 */
	"_iRecordsDisplay": 0,

	/**
	 * The classes to use for the table
	 */
	"oClasses": {},

	/**
	 * Flag attached to the settings object so you can check in the draw
	 * callback if filtering has been done in the draw. Deprecated in favour of
	 * events.
	 *  @deprecated
	 */
	"bFiltered": false,

	/**
	 * Flag attached to the settings object so you can check in the draw
	 * callback if sorting has been done in the draw. Deprecated in favour of
	 * events.
	 *  @deprecated
	 */
	"bSorted": false,

	/**
	 * Indicate that if multiple rows are in the header and there is more than
	 * one unique cell per column. Replaced by titleRow
	 */
	"bSortCellsTop": null,

	/**
	 * Initialisation object that is used for the table
	 */
	"oInit": null,

	/**
	 * Destroy callback functions - for plug-ins to attach themselves to the
	 * destroy so they can clean up markup and events.
	 */
	"aoDestroyCallback": [],


	/**
	 * Get the number of records in the current record set, before filtering
	 */
	"fnRecordsTotal": function ()
	{
		return _fnDataSource( this ) == 'ssp' ?
			this._iRecordsTotal * 1 :
			this.aiDisplayMaster.length;
	},

	/**
	 * Get the number of records in the current record set, after filtering
	 */
	"fnRecordsDisplay": function ()
	{
		return _fnDataSource( this ) == 'ssp' ?
			this._iRecordsDisplay * 1 :
			this.aiDisplay.length;
	},

	/**
	 * Get the display end point - aiDisplay index
	 */
	"fnDisplayEnd": function ()
	{
		var
			len      = this._iDisplayLength,
			start    = this._iDisplayStart,
			calc     = start + len,
			records  = this.aiDisplay.length,
			features = this.oFeatures,
			paginate = features.bPaginate;

		if ( features.bServerSide ) {
			return paginate === false || len === -1 ?
				start + records :
				Math.min( start+len, this._iRecordsDisplay );
		}
		else {
			return ! paginate || calc>records || len===-1 ?
				records :
				calc;
		}
	},

	/**
	 * The DataTables object for this table
	 */
	"oInstance": null,

	/**
	 * Unique identifier for each instance of the DataTables object. If there
	 * is an ID on the table node, then it takes that value, otherwise an
	 * incrementing internal counter is used.
	 */
	"sInstance": null,

	/**
	 * tabindex attribute value that is added to DataTables control elements, allowing
	 * keyboard navigation of the table and its controls.
	 */
	"iTabIndex": 0,

	/**
	 * DIV container for the footer scrolling table if scrolling
	 */
	"nScrollHead": null,

	/**
	 * DIV container for the footer scrolling table if scrolling
	 */
	"nScrollFoot": null,

	/**
	 * Last applied sort
	 */
	"aLastSort": [],

	/**
	 * Stored plug-in instances
	 */
	"oPlugins": {},

	/**
	 * Function used to get a row's id from the row's data
	 */
	"rowIdFn": null,

	/**
	 * Data location where to store a row's id
	 */
	"rowId": null,

	caption: '',

	captionNode: null,

	colgroup: null,

	/** Delay loading of data */
	deferLoading: null,

	/** Allow auto type detection */
	typeDetect: true,

	/** ResizeObserver for the container div */
	resizeObserver: null,

	/** Keep a record of the last size of the container, so we can skip duplicates */
	containerWidth: -1,

	/** Reverse the initial order of the data set on desc ordering */
	orderDescReverse: null,

	/** Show / hide ordering indicators in headers */
	orderIndicators: true,

	/** Default ordering listener */
	orderHandler: true,

	/** Title row indicator */
	titleRow: null
};

/**
 * Extension object for DataTables that is used to provide all extension
 * options.
 *
 * Note that the `DataTable.ext` object is available through
 * `jQuery.fn.dataTable.ext` where it may be accessed and manipulated. It is
 * also aliased to `jQuery.fn.dataTableExt` for historic reasons.
 *  @namespace
 *  @extends DataTable.models.ext
 */


var extPagination = DataTable.ext.pager;

// Paging buttons configuration
$.extend( extPagination, {
	simple: function () {
		return [ 'previous', 'next' ];
	},

	full: function () {
		return [ 'first', 'previous', 'next', 'last' ];
	},

	numbers: function () {
		return [ 'numbers' ];
	},

	simple_numbers: function () {
		return [ 'previous', 'numbers', 'next' ];
	},

	full_numbers: function () {
		return [ 'first', 'previous', 'numbers', 'next', 'last' ];
	},

	first_last: function () {
		return ['first', 'last'];
	},

	first_last_numbers: function () {
		return ['first', 'numbers', 'last'];
	},

	// For testing and plug-ins to use
	_numbers: _pagingNumbers,

	// Number of number buttons - legacy, use `numbers` option for paging feature
	numbers_length: 7
} );


$.extend( true, DataTable.ext.renderer, {
	pagingButton: {
		_: function (settings, buttonType, content, active, disabled) {
			var classes = settings.oClasses.paging;
			var btnClasses = [classes.button];
			var btn;

			if (active) {
				btnClasses.push(classes.active);
			}

			if (disabled) {
				btnClasses.push(classes.disabled)
			}

			if (buttonType === 'ellipsis') {
				btn = $('<span class="ellipsis"></span>').html(content)[0];
			}
			else {
				btn = $('<button>', {
					class: btnClasses.join(' '),
					role: 'link',
					type: 'button'
				}).html(content);
			}

			return {
				display: btn,
				clicker: btn
			}
		}
	},

	pagingContainer: {
		_: function (settings, buttons) {
			// No wrapping element - just append directly to the host
			return buttons;
		}
	}
} );

// Common function to remove new lines, strip HTML and diacritic control
var _filterString = function (stripHtml, normalize) {
	return function (str) {
		if (_empty(str) || typeof str !== 'string') {
			return str;
		}

		str = str.replace( _re_new_lines, " " );

		if (stripHtml) {
			str = _stripHtml(str);
		}

		if (normalize) {
			str = _normalize(str, false);
		}

		return str;
	};
}

/*
 * Public helper functions. These aren't used internally by DataTables, or
 * called by any of the options passed into DataTables, but they can be used
 * externally by developers working with DataTables. They are helper functions
 * to make working with DataTables a little bit easier.
 */

/**
 * Common logic for moment, luxon or a date action.
 *
 * Happens after __mldObj, so don't need to call `resolveWindowsLibs` again
 */
function __mld( dtLib, momentFn, luxonFn, dateFn, arg1 ) {
	if (__moment) {
		return dtLib[momentFn]( arg1 );
	}
	else if (__luxon) {
		return dtLib[luxonFn]( arg1 );
	}
	
	return dateFn ? dtLib[dateFn]( arg1 ) : dtLib;
}


var __mlWarning = false;
var __luxon; // Can be assigned in DateTable.use()
var __moment; // Can be assigned in DateTable.use()

/**
 * 
 */
function resolveWindowLibs() {
	if (window.luxon && ! __luxon) {
		__luxon = window.luxon;
	}
	
	if (window.moment && ! __moment) {
		__moment = window.moment;
	}
}

function __mldObj (d, format, locale) {
	var dt;

	resolveWindowLibs();

	if (__moment) {
		dt = __moment.utc( d, format, locale, true );

		if (! dt.isValid()) {
			return null;
		}
	}
	else if (__luxon) {
		dt = format && typeof d === 'string'
			? __luxon.DateTime.fromFormat( d, format )
			: __luxon.DateTime.fromISO( d );

		if (! dt.isValid) {
			return null;
		}

		dt = dt.setLocale(locale);
	}
	else if (! format) {
		// No format given, must be ISO
		dt = new Date(d);
	}
	else {
		if (! __mlWarning) {
			alert('DataTables warning: Formatted date without Moment.js or Luxon - https://datatables.net/tn/17');
		}

		__mlWarning = true;
	}

	return dt;
}

// Wrapper for date, datetime and time which all operate the same way with the exception of
// the output string for auto locale support
function __mlHelper (localeString) {
	return function ( from, to, locale, def ) {
		// Luxon and Moment support
		// Argument shifting
		if ( arguments.length === 0 ) {
			locale = 'en';
			to = null; // means toLocaleString
			from = null; // means iso8601
		}
		else if ( arguments.length === 1 ) {
			locale = 'en';
			to = from;
			from = null;
		}
		else if ( arguments.length === 2 ) {
			locale = to;
			to = from;
			from = null;
		}

		var typeName = 'datetime' + (to ? '-' + to : '');

		// Add type detection and sorting specific to this date format - we need to be able to identify
		// date type columns as such, rather than as numbers in extensions. Hence the need for this.
		if (! DataTable.ext.type.order[typeName + '-pre']) {
			DataTable.type(typeName, {
				detect: function (d) {
					// The renderer will give the value to type detect as the type!
					return d === typeName ? typeName : false;
				},
				order: {
					pre: function (d) {
						// The renderer gives us Moment, Luxon or Date obects for the sorting, all of which have a
						// `valueOf` which gives milliseconds epoch
						return d.valueOf();
					}
				},
				className: 'dt-right'
			});
		}
	
		return function ( d, type ) {
			// Allow for a default value
			if (d === null || d === undefined) {
				if (def === '--now') {
					// We treat everything as UTC further down, so no changes are
					// made, as such need to get the local date / time as if it were
					// UTC
					var local = new Date();
					d = new Date( Date.UTC(
						local.getFullYear(), local.getMonth(), local.getDate(),
						local.getHours(), local.getMinutes(), local.getSeconds()
					) );
				}
				else {
					d = '';
				}
			}

			if (type === 'type') {
				// Typing uses the type name for fast matching
				return typeName;
			}

			if (d === '') {
				return type !== 'sort'
					? ''
					: __mldObj('0000-01-01 00:00:00', null, locale);
			}

			// Shortcut. If `from` and `to` are the same, we are using the renderer to
			// format for ordering, not display - its already in the display format.
			if ( to !== null && from === to && type !== 'sort' && type !== 'type' && ! (d instanceof Date) ) {
				return d;
			}

			var dt = __mldObj(d, from, locale);

			if (dt === null) {
				return d;
			}

			if (type === 'sort') {
				return dt;
			}
			
			var formatted = to === null
				? __mld(dt, 'toDate', 'toJSDate', '')[localeString]()
				: __mld(dt, 'format', 'toFormat', 'toISOString', to);

			// XSS protection
			return type === 'display' ?
				_escapeHtml( formatted ) :
				formatted;
		};
	}
}

// Based on locale, determine standard number formatting
// Fallback for legacy browsers is US English
var __thousands = ',';
var __decimal = '.';

if (window.Intl !== undefined) {
	try {
		var num = new Intl.NumberFormat().formatToParts(100000.1);
	
		for (var i=0 ; i<num.length ; i++) {
			if (num[i].type === 'group') {
				__thousands = num[i].value;
			}
			else if (num[i].type === 'decimal') {
				__decimal = num[i].value;
			}
		}
	}
	catch (e) {
		// noop
	}
}

// Formatted date time detection - use by declaring the formats you are going to use
DataTable.datetime = function ( format, locale ) {
	var typeName = 'datetime-' + format;

	if (! locale) {
		locale = 'en';
	}

	if (! DataTable.ext.type.order[typeName]) {
		DataTable.type(typeName, {
			detect: function (d) {
				var dt = __mldObj(d, format, locale);
				return d === '' || dt ? typeName : false;
			},
			order: {
				pre: function (d) {
					return __mldObj(d, format, locale) || 0;
				}
			},
			className: 'dt-right'
		});
	}
}

/**
 * Helpers for `columns.render`.
 *
 * The options defined here can be used with the `columns.render` initialisation
 * option to provide a display renderer. The following functions are defined:
 *
 * * `moment` - Uses the MomentJS library to convert from a given format into another.
 * This renderer has three overloads:
 *   * 1 parameter:
 *     * `string` - Format to convert to (assumes input is ISO8601 and locale is `en`)
 *   * 2 parameters:
 *     * `string` - Format to convert from
 *     * `string` - Format to convert to. Assumes `en` locale
 *   * 3 parameters:
 *     * `string` - Format to convert from
 *     * `string` - Format to convert to
 *     * `string` - Locale
 * * `number` - Will format numeric data (defined by `columns.data`) for
 *   display, retaining the original unformatted data for sorting and filtering.
 *   It takes 5 parameters:
 *   * `string` - Thousands grouping separator
 *   * `string` - Decimal point indicator
 *   * `integer` - Number of decimal points to show
 *   * `string` (optional) - Prefix.
 *   * `string` (optional) - Postfix (/suffix).
 * * `text` - Escape HTML to help prevent XSS attacks. It has no optional
 *   parameters.
 *
 * @example
 *   // Column definition using the number renderer
 *   {
 *     data: "salary",
 *     render: $.fn.dataTable.render.number( '\'', '.', 0, '$' )
 *   }
 *
 * @namespace
 */
DataTable.render = {
	date: __mlHelper('toLocaleDateString'),
	datetime: __mlHelper('toLocaleString'),
	time: __mlHelper('toLocaleTimeString'),
	number: function ( thousands, decimal, precision, prefix, postfix ) {
		// Auto locale detection
		if (thousands === null || thousands === undefined) {
			thousands = __thousands;
		}

		if (decimal === null || decimal === undefined) {
			decimal = __decimal;
		}

		return {
			display: function ( d ) {
				if ( typeof d !== 'number' && typeof d !== 'string' ) {
					return d;
				}

				if (d === '' || d === null) {
					return d;
				}

				var negative = d < 0 ? '-' : '';
				var flo = parseFloat( d );
				var abs = Math.abs(flo);

				// Scientific notation for large and small numbers
				if (abs >= 100000000000 || (abs < 0.0001 && abs !== 0) ) {
					var exp = flo.toExponential(precision).split(/e\+?/);
					return exp[0] + ' x 10<sup>' + exp[1] + '</sup>';
				}

				// If NaN then there isn't much formatting that we can do - just
				// return immediately, escaping any HTML (this was supposed to
				// be a number after all)
				if ( isNaN( flo ) ) {
					return _escapeHtml( d );
				}

				flo = flo.toFixed( precision );
				d = Math.abs( flo );

				var intPart = parseInt( d, 10 );
				var floatPart = precision ?
					decimal+(d - intPart).toFixed( precision ).substring( 2 ):
					'';

				// If zero, then can't have a negative prefix
				if (intPart === 0 && parseFloat(floatPart) === 0) {
					negative = '';
				}

				return negative + (prefix||'') +
					intPart.toString().replace(
						/\B(?=(\d{3})+(?!\d))/g, thousands
					) +
					floatPart +
					(postfix||'');
			}
		};
	},

	text: function () {
		return {
			display: _escapeHtml,
			filter: _escapeHtml
		};
	}
};


var _extTypes = DataTable.ext.type;

// Get / set type
DataTable.type = function (name, prop, val) {
	if (! prop) {
		return {
			className: _extTypes.className[name],
			detect: _extTypes.detect.find(function (fn) {
				return fn._name === name;
			}),
			order: {
				pre: _extTypes.order[name + '-pre'],
				asc: _extTypes.order[name + '-asc'],
				desc: _extTypes.order[name + '-desc']
			},
			render: _extTypes.render[name],
			search: _extTypes.search[name]
		};
	}

	var setProp = function(prop, propVal) {
		_extTypes[prop][name] = propVal;
	};
	var setDetect = function (detect) {
		// `detect` can be a function or an object - we set a name
		// property for either - that is used for the detection
		Object.defineProperty(detect, "_name", {value: name});

		var idx = _extTypes.detect.findIndex(function (item) {
			return item._name === name;
		});

		if (idx === -1) {
			_extTypes.detect.unshift(detect);
		}
		else {
			_extTypes.detect.splice(idx, 1, detect);
		}
	};
	var setOrder = function (obj) {
		_extTypes.order[name + '-pre'] = obj.pre; // can be undefined
		_extTypes.order[name + '-asc'] = obj.asc; // can be undefined
		_extTypes.order[name + '-desc'] = obj.desc; // can be undefined
	};

	// prop is optional
	if (val === undefined) {
		val = prop;
		prop = null;
	}

	if (prop === 'className') {
		setProp('className', val);
	}
	else if (prop === 'detect') {
		setDetect(val);
	}
	else if (prop === 'order') {
		setOrder(val);
	}
	else if (prop === 'render') {
		setProp('render', val);
	}
	else if (prop === 'search') {
		setProp('search', val);
	}
	else if (! prop) {
		if (val.className) {
			setProp('className', val.className);
		}

		if (val.detect !== undefined) {
			setDetect(val.detect);
		}

		if (val.order) {
			setOrder(val.order);
		}

		if (val.render !== undefined) {
			setProp('render', val.render);
		}

		if (val.search !== undefined) {
			setProp('search', val.search);
		}
	}
}

// Get a list of types
DataTable.types = function () {
	return _extTypes.detect.map(function (fn) {
		return fn._name;
	});
};

var __diacriticSort = function (a, b) {
	a = a !== null && a !== undefined ? a.toString().toLowerCase() : '';
	b = b !== null && b !== undefined ? b.toString().toLowerCase() : '';

	// Checked for `navigator.languages` support in `oneOf` so this code can't execute in old
	// Safari and thus can disable this check
	// eslint-disable-next-line compat/compat
	return a.localeCompare(b, navigator.languages[0] || navigator.language, {
		numeric: true,
		ignorePunctuation: true,
	});
}

var __diacriticHtmlSort = function (a, b) {
	a = _stripHtml(a);
	b = _stripHtml(b);

	return __diacriticSort(a, b);
}

//
// Built in data types
//

DataTable.type('string', {
	detect: function () {
		return 'string';
	},
	order: {
		pre: function ( a ) {
			// This is a little complex, but faster than always calling toString,
			// http://jsperf.com/tostring-v-check
			return _empty(a) && typeof a !== 'boolean' ?
				'' :
				typeof a === 'string' ?
					a.toLowerCase() :
					! a.toString ?
						'' :
						a.toString();
		}
	},
	search: _filterString(false, true)
});

DataTable.type('string-utf8', {
	detect: {
		allOf: function ( d ) {
			return true;
		},
		oneOf: function ( d ) {
			// At least one data point must contain a non-ASCII character
			// This line will also check if navigator.languages is supported or not. If not (Safari 10.0-)
			// this data type won't be supported.
			// eslint-disable-next-line compat/compat
			return ! _empty( d ) && navigator.languages && typeof d === 'string' && d.match(/[^\x00-\x7F]/);
		}
	},
	order: {
		asc: __diacriticSort,
		desc: function (a, b) {
			return __diacriticSort(a, b) * -1;
		}
	},
	search: _filterString(false, true)
});


DataTable.type('html', {
	detect: {
		allOf: function ( d ) {
			return _empty( d ) || (typeof d === 'string' && d.indexOf('<') !== -1);
		},
		oneOf: function ( d ) {
			// At least one data point must contain a `<`
			return ! _empty( d ) && typeof d === 'string' && d.indexOf('<') !== -1;
		}
	},
	order: {
		pre: function ( a ) {
			return _empty(a) ?
				'' :
				a.replace ?
					_stripHtml(a).trim().toLowerCase() :
					a+'';
		}
	},
	search: _filterString(true, true)
});


DataTable.type('html-utf8', {
	detect: {
		allOf: function ( d ) {
			return _empty( d ) || (typeof d === 'string' && d.indexOf('<') !== -1);
		},
		oneOf: function ( d ) {
			// At least one data point must contain a `<` and a non-ASCII character
			// eslint-disable-next-line compat/compat
			return navigator.languages &&
				! _empty( d ) &&
				typeof d === 'string' &&
				d.indexOf('<') !== -1 &&
				typeof d === 'string' && d.match(/[^\x00-\x7F]/);
		}
	},
	order: {
		asc: __diacriticHtmlSort,
		desc: function (a, b) {
			return __diacriticHtmlSort(a, b) * -1;
		}
	},
	search: _filterString(true, true)
});


DataTable.type('date', {
	className: 'dt-type-date',
	detect: {
		allOf: function ( d ) {
			// V8 tries _very_ hard to make a string passed into `Date.parse()`
			// valid, so we need to use a regex to restrict date formats. Use a
			// plug-in for anything other than ISO8601 style strings
			if ( d && !(d instanceof Date) && ! _re_date.test(d) ) {
				return null;
			}
			var parsed = Date.parse(d);
			return (parsed !== null && !isNaN(parsed)) || _empty(d);
		},
		oneOf: function ( d ) {
			// At least one entry must be a date or a string with a date
			return (d instanceof Date) || (typeof d === 'string' && _re_date.test(d));
		}
	},
	order: {
		pre: function ( d ) {
			var ts = Date.parse( d );
			return isNaN(ts) ? -Infinity : ts;
		}
	}
});


DataTable.type('html-num-fmt', {
	className: 'dt-type-numeric',
	detect: {
		allOf: function ( d, settings ) {
			var decimal = settings.oLanguage.sDecimal;
			return _htmlNumeric( d, decimal, true, false );
		},
		oneOf: function (d, settings) {
			// At least one data point must contain a numeric value
			var decimal = settings.oLanguage.sDecimal;
			return _htmlNumeric( d, decimal, true, false );
		}
	},
	order: {
		pre: function ( d, s ) {
			var dp = s.oLanguage.sDecimal;
			return __numericReplace( d, dp, _re_html, _re_formatted_numeric );
		}
	},
	search: _filterString(true, true)
});


DataTable.type('html-num', {
	className: 'dt-type-numeric',
	detect: {
		allOf: function ( d, settings ) {
			var decimal = settings.oLanguage.sDecimal;
			return _htmlNumeric( d, decimal, false, true );
		},
		oneOf: function (d, settings) {
			// At least one data point must contain a numeric value
			var decimal = settings.oLanguage.sDecimal;
			return _htmlNumeric( d, decimal, false, false );
		}
	},
	order: {
		pre: function ( d, s ) {
			var dp = s.oLanguage.sDecimal;
			return __numericReplace( d, dp, _re_html );
		}
	},
	search: _filterString(true, true)
});


DataTable.type('num-fmt', {
	className: 'dt-type-numeric',
	detect: {
		allOf: function ( d, settings ) {
			var decimal = settings.oLanguage.sDecimal;
			return _isNumber( d, decimal, true, true );
		},
		oneOf: function (d, settings) {
			// At least one data point must contain a numeric value
			var decimal = settings.oLanguage.sDecimal;
			return _isNumber( d, decimal, true, false );
		}
	},
	order: {
		pre: function ( d, s ) {
			var dp = s.oLanguage.sDecimal;
			return __numericReplace( d, dp, _re_formatted_numeric );
		}
	}
});


DataTable.type('num', {
	className: 'dt-type-numeric',
	detect: {
		allOf: function ( d, settings ) {
			var decimal = settings.oLanguage.sDecimal;
			return _isNumber( d, decimal, false, true );
		},
		oneOf: function (d, settings) {
			// At least one data point must contain a numeric value
			var decimal = settings.oLanguage.sDecimal;
			return _isNumber( d, decimal, false, false );
		}
	},
	order: {
		pre: function (d, s) {
			var dp = s.oLanguage.sDecimal;
			return __numericReplace( d, dp );
		}
	}
});




var __numericReplace = function ( d, decimalPlace, re1, re2 ) {
	if ( d !== 0 && (!d || d === '-') ) {
		return -Infinity;
	}
	
	var type = typeof d;

	if (type === 'number' || type === 'bigint') {
		return d;
	}

	// If a decimal place other than `.` is used, it needs to be given to the
	// function so we can detect it and replace with a `.` which is the only
	// decimal place Javascript recognises - it is not locale aware.
	if ( decimalPlace ) {
		d = _numToDecimal( d, decimalPlace );
	}

	if ( d.replace ) {
		if ( re1 ) {
			d = d.replace( re1, '' );
		}

		if ( re2 ) {
			d = d.replace( re2, '' );
		}
	}

	return d * 1;
};


$.extend( true, DataTable.ext.renderer, {
	footer: {
		_: function ( settings, cell, classes ) {
			cell.addClass(classes.tfoot.cell);
		}
	},

	header: {
		_: function ( settings, cell, classes ) {
			cell.addClass(classes.thead.cell);

			if (! settings.oFeatures.bSort) {
				cell.addClass(classes.order.none);
			}

			var titleRow = settings.titleRow;
			var headerRows = cell.closest('thead').find('tr');
			var rowIdx = cell.parent().index();

			// Conditions to not apply the ordering icons
			if (
				// Cells and rows which have the attribute to disable the icons
				cell.attr('data-dt-order') === 'disable' ||
				cell.parent().attr('data-dt-order') === 'disable' ||

				// titleRow support, for defining a specific row in the header
				(titleRow === true && rowIdx !== 0) ||
				(titleRow === false && rowIdx !== headerRows.length - 1) ||
				(typeof titleRow === 'number' && rowIdx !== titleRow)
			) {
				return;
			}

			// No additional mark-up required
			// Attach a sort listener to update on sort - note that using the
			// `DT` namespace will allow the event to be removed automatically
			// on destroy, while the `dt` namespaced event is the one we are
			// listening for
			$(settings.nTable).on( 'order.dt.DT column-visibility.dt.DT', function ( e, ctx, column ) {
				if ( settings !== ctx ) { // need to check this this is the host
					return;               // table, not a nested one
				}

				var sorting = ctx.sortDetails;

				if (! sorting) {
					return;
				}

				var orderedColumns = _pluck(sorting, 'col');

				// This handler is only needed on column visibility if the column is part of the
				// ordering. If it isn't, then we can bail out to save performance. It could be a
				// separate event handler, but this is a balance between code reuse / size and performance
				// console.log(e, e.name, column, orderedColumns, orderedColumns.includes(column))
				if (e.type === 'column-visibility' && ! orderedColumns.includes(column)) {
					return;
				}

				var i;
				var orderClasses = classes.order;
				var columns = ctx.api.columns( cell );
				var col = settings.aoColumns[columns.flatten()[0]];
				var orderable = columns.orderable().includes(true);
				var ariaType = '';
				var indexes = columns.indexes();
				var sortDirs = columns.orderable(true).flatten();
				var tabIndex = settings.iTabIndex;
				var canOrder = ctx.orderHandler && orderable;

				cell
					.removeClass(
						orderClasses.isAsc +' '+
						orderClasses.isDesc
					)
					.toggleClass( orderClasses.none, ! orderable )
					.toggleClass( orderClasses.canAsc, canOrder && sortDirs.includes('asc') )
					.toggleClass( orderClasses.canDesc, canOrder && sortDirs.includes('desc') );

				// Determine if all of the columns that this cell covers are included in the
				// current ordering
				var isOrdering = true;
				
				for (i=0; i<indexes.length; i++) {
					if (! orderedColumns.includes(indexes[i])) {
						isOrdering = false;
					}
				}

				if ( isOrdering ) {
					// Get the ordering direction for the columns under this cell
					// Note that it is possible for a cell to be asc and desc sorting
					// (column spanning cells)
					var orderDirs = columns.order();

					cell.addClass(
						orderDirs.includes('asc') ? orderClasses.isAsc : '' +
						orderDirs.includes('desc') ? orderClasses.isDesc : ''
					);
				}

				// Find the first visible column that has ordering applied to it - it get's
				// the aria information, as the ARIA spec says that only one column should
				// be marked with aria-sort
				var firstVis = -1; // column index

				for (i=0; i<orderedColumns.length; i++) {
					if (settings.aoColumns[orderedColumns[i]].bVisible) {
						firstVis = orderedColumns[i];
						break;
					}
				}

				if (indexes[0] == firstVis) {
					var firstSort = sorting[0];
					var sortOrder = col.asSorting;

					cell.attr('aria-sort', firstSort.dir === 'asc' ? 'ascending' : 'descending');

					// Determine if the next click will remove sorting or change the sort
					ariaType = ! sortOrder[firstSort.index + 1] ? 'Remove' : 'Reverse';
				}
				else {
					cell.removeAttr('aria-sort');
				}

				// Make the headers tab-able for keyboard navigation
				if (orderable) {
					var orderSpan = cell.find('.dt-column-order');
					
					orderSpan
						.attr('role', 'button')
						.attr('aria-label', orderable
							? col.ariaTitle + ctx.api.i18n('oAria.orderable' + ariaType)
							: col.ariaTitle
						);

					if (tabIndex !== -1) {
						orderSpan.attr('tabindex', tabIndex);
					}
				}
			} );
		}
	},

	layout: {
		_: function ( settings, container, items ) {
			var classes = settings.oClasses.layout;
			var row = $('<div/>')
				.attr('id', items.id || null)
				.addClass(items.className || classes.row)
				.appendTo( container );

			DataTable.ext.renderer.layout._forLayoutRow(items, function (key, val) {
				if (key === 'id' || key === 'className') {
					return;
				}

				var klass = '';

				if (val.table) {
					row.addClass(classes.tableRow);
					klass += classes.tableCell + ' ';
				}

				if (key === 'start') {
					klass += classes.start;
				}
				else if (key === 'end') {
					klass += classes.end;
				}
				else {
					klass += classes.full;
				}

				$('<div/>')
					.attr({
						id: val.id || null,
						"class": val.className
							? val.className
							: classes.cell + ' ' + klass
					})
					.append( val.contents )
					.appendTo( row );
			});
		},

		// Shared for use by the styling frameworks
		_forLayoutRow: function (items, fn) {
			// As we are inserting dom elements, we need start / end in a
			// specific order, this function is used for sorting the layout
			// keys.
			var layoutEnum = function (x) {
				switch (x) {
					case '': return 0;
					case 'start': return 1;
					case 'end': return 2;
					default: return 3;
				}
			};

			Object
				.keys(items)
				.sort(function (a, b) {
					return layoutEnum(a) - layoutEnum(b);
				})
				.forEach(function (key) {
					fn(key, items[key]);
				});
		}
	}
} );


DataTable.feature = {};

// Third parameter is internal only!
DataTable.feature.register = function ( name, cb, legacy ) {
	DataTable.ext.features[ name ] = cb;

	if (legacy) {
		_ext.feature.push({
			cFeature: legacy,
			fnInit: cb
		});
	}
};

function _divProp(el, prop, val) {
	if (val) {
		el[prop] = val;
	}
}

DataTable.feature.register( 'div', function ( settings, opts ) {
	var n = $('<div>')[0];

	if (opts) {
		_divProp(n, 'className', opts.className);
		_divProp(n, 'id', opts.id);
		_divProp(n, 'innerHTML', opts.html);
		_divProp(n, 'textContent', opts.text);
	}

	return n;
} );

DataTable.feature.register( 'info', function ( settings, opts ) {
	// For compatibility with the legacy `info` top level option
	if (! settings.oFeatures.bInfo) {
		return null;
	}

	var
		lang  = settings.oLanguage,
		tid = settings.sTableId,
		n = $('<div/>', {
			'class': settings.oClasses.info.container,
		} );

	opts = $.extend({
		callback: lang.fnInfoCallback,
		empty: lang.sInfoEmpty,
		postfix: lang.sInfoPostFix,
		search: lang.sInfoFiltered,
		text: lang.sInfo,
	}, opts);


	// Update display on each draw
	settings.aoDrawCallback.push(function (s) {
		_fnUpdateInfo(s, opts, n);
	});

	// For the first info display in the table, we add a callback and aria information.
	if (! settings._infoEl) {
		n.attr({
			'aria-live': 'polite',
			id: tid+'_info',
			role: 'status'
		});

		// Table is described by our info div
		$(settings.nTable).attr( 'aria-describedby', tid+'_info' );

		settings._infoEl = n;
	}

	return n;
}, 'i' );

/**
 * Update the information elements in the display
 *  @param {object} settings dataTables settings object
 *  @memberof DataTable#oApi
 */
function _fnUpdateInfo ( settings, opts, node )
{
	var
		start = settings._iDisplayStart+1,
		end   = settings.fnDisplayEnd(),
		max   = settings.fnRecordsTotal(),
		total = settings.fnRecordsDisplay(),
		out   = total
			? opts.text
			: opts.empty;

	if ( total !== max ) {
		// Record set after filtering
		out += ' ' + opts.search;
	}

	// Convert the macros
	out += opts.postfix;
	out = _fnMacros( settings, out );

	if ( opts.callback ) {
		out = opts.callback.call( settings.oInstance,
			settings, start, end, max, total, out
		);
	}

	node.html( out );

	_fnCallbackFire(settings, null, 'info', [settings, node[0], out]);
}

var __searchCounter = 0;

// opts
// - text
// - placeholder
DataTable.feature.register( 'search', function ( settings, opts ) {
	// Don't show the input if filtering isn't available on the table
	if (! settings.oFeatures.bFilter) {
		return null;
	}

	var classes = settings.oClasses.search;
	var tableId = settings.sTableId;
	var language = settings.oLanguage;
	var previousSearch = settings.oPreviousSearch;
	var input = '<input type="search" class="'+classes.input+'"/>';

	opts = $.extend({
		placeholder: language.sSearchPlaceholder,
		processing: false,
		text: language.sSearch
	}, opts);

	// The _INPUT_ is optional - is appended if not present
	if (opts.text.indexOf('_INPUT_') === -1) {
		opts.text += '_INPUT_';
	}

	opts.text = _fnMacros(settings, opts.text);

	// We can put the <input> outside of the label if it is at the start or end
	// which helps improve accessability (not all screen readers like implicit
	// for elements).
	var end = opts.text.match(/_INPUT_$/);
	var start = opts.text.match(/^_INPUT_/);
	var removed = opts.text.replace(/_INPUT_/, '');
	var str = '<label>' + opts.text + '</label>';

	if (start) {
		str = '_INPUT_<label>' + removed + '</label>';
	}
	else if (end) {
		str = '<label>' + removed + '</label>_INPUT_';
	}

	var filter = $('<div>')
		.addClass(classes.container)
		.append(str.replace(/_INPUT_/, input));

	// add for and id to label and input
	filter.find('label').attr('for', 'dt-search-' + __searchCounter);
	filter.find('input').attr('id', 'dt-search-' + __searchCounter);
	__searchCounter++;

	var searchFn = function(event) {
		var val = this.value;

		if(previousSearch.return && event.key !== "Enter") {
			return;
		}

		/* Now do the filter */
		if ( val != previousSearch.search ) {
			_fnProcessingRun(settings, opts.processing, function () {
				previousSearch.search = val;
		
				_fnFilterComplete( settings, previousSearch );
		
				// Need to redraw, without resorting
				settings._iDisplayStart = 0;
				_fnDraw( settings );
			});
		}
	};

	var searchDelay = settings.searchDelay !== null ?
		settings.searchDelay :
		0;

	var jqFilter = $('input', filter)
		.val( previousSearch.search )
		.attr( 'placeholder', opts.placeholder )
		.on(
			'keyup.DT search.DT input.DT paste.DT cut.DT',
			searchDelay ?
				DataTable.util.debounce( searchFn, searchDelay ) :
				searchFn
		)
		.on( 'mouseup.DT', function(e) {
			// Edge fix! Edge 17 does not trigger anything other than mouse events when clicking
			// on the clear icon (Edge bug 17584515). This is safe in other browsers as `searchFn`
			// checks the value to see if it has changed. In other browsers it won't have.
			setTimeout( function () {
				searchFn.call(jqFilter[0], e);
			}, 10);
		} )
		.on( 'keypress.DT', function(e) {
			/* Prevent form submission */
			if ( e.keyCode == 13 ) {
				return false;
			}
		} )
		.attr('aria-controls', tableId);

	// Update the input elements whenever the table is filtered
	$(settings.nTable).on( 'search.dt.DT', function ( ev, s ) {
		if ( settings === s && jqFilter[0] !== document.activeElement ) {
			jqFilter.val( typeof previousSearch.search !== 'function'
				? previousSearch.search
				: ''
			);
		}
	} );

	return filter;
}, 'f' );

// opts
// - type - button configuration
// - buttons - number of buttons to show - must be odd
DataTable.feature.register( 'paging', function ( settings, opts ) {
	// Don't show the paging input if the table doesn't have paging enabled
	if (! settings.oFeatures.bPaginate) {
		return null;
	}

	opts = $.extend({
		buttons: DataTable.ext.pager.numbers_length,
		type: settings.sPaginationType,
		boundaryNumbers: true,
		firstLast: true,
		previousNext: true,
		numbers: true
	}, opts);

	var host = $('<div/>')
		.addClass(settings.oClasses.paging.container + (opts.type ? ' paging_' + opts.type : ''))
		.append(
			$('<nav>')
				.attr('aria-label', 'pagination')
				.addClass(settings.oClasses.paging.nav)
		);
	var draw = function () {
		_pagingDraw(settings, host.children(), opts);
	};

	settings.aoDrawCallback.push(draw);

	// Responsive redraw of paging control
	$(settings.nTable).on('column-sizing.dt.DT', draw);

	return host;
}, 'p' );

/**
 * Dynamically create the button type array based on the configuration options.
 * This will only happen if the paging type is not defined.
 */
function _pagingDynamic(opts) {
	var out = [];

	if (opts.numbers) {
		out.push('numbers');
	}

	if (opts.previousNext) {
		out.unshift('previous');
		out.push('next');
	}

	if (opts.firstLast) {
		out.unshift('first');
		out.push('last');
	}

	return out;
}

function _pagingDraw(settings, host, opts) {
	if (! settings._bInitComplete) {
		return;
	}

	var
		plugin = opts.type
			? DataTable.ext.pager[ opts.type ]
			: _pagingDynamic,
		aria = settings.oLanguage.oAria.paginate || {},
		start      = settings._iDisplayStart,
		len        = settings._iDisplayLength,
		visRecords = settings.fnRecordsDisplay(),
		all        = len === -1,
		page = all ? 0 : Math.ceil( start / len ),
		pages = all ? 1 : Math.ceil( visRecords / len ),
		buttons = [],
		buttonEls = [],
		buttonsNested = plugin(opts)
			.map(function (val) {
				return val === 'numbers'
					? _pagingNumbers(page, pages, opts.buttons, opts.boundaryNumbers)
					: val;
			});

	// .flat() would be better, but not supported in old Safari
	buttons = buttons.concat.apply(buttons, buttonsNested);

	for (var i=0 ; i<buttons.length ; i++) {
		var button = buttons[i];

		var btnInfo = _pagingButtonInfo(settings, button, page, pages);
		var btn = _fnRenderer( settings, 'pagingButton' )(
			settings,
			button,
			btnInfo.display,
			btnInfo.active,
			btnInfo.disabled
		);

		var ariaLabel = typeof button === 'string'
			? aria[ button ]
			: aria.number
				? aria.number + (button+1)
				: null;

		// Common attributes
		$(btn.clicker).attr({
			'aria-controls': settings.sTableId,
			'aria-disabled': btnInfo.disabled ? 'true' : null,
			'aria-current': btnInfo.active ? 'page' : null,
			'aria-label': ariaLabel,
			'data-dt-idx': button,
			'tabIndex': btnInfo.disabled
				? -1
				: settings.iTabIndex && btn.clicker[0].nodeName.toLowerCase() !== 'span'
					? settings.iTabIndex
					: null, // `0` doesn't need a tabIndex since it is the default
		});

		if (typeof button !== 'number') {
			$(btn.clicker).addClass(button);
		}

		_fnBindAction(
			btn.clicker, {action: button}, function(e) {
				e.preventDefault();

				_fnPageChange( settings, e.data.action, true );
			}
		);

		buttonEls.push(btn.display);
	}

	var wrapped = _fnRenderer(settings, 'pagingContainer')(
		settings, buttonEls
	);

	var activeEl = host.find(document.activeElement).data('dt-idx');

	host.empty().append(wrapped);

	if ( activeEl !== undefined ) {
		host.find( '[data-dt-idx='+activeEl+']' ).trigger('focus');
	}

	// Responsive - check if the buttons are over two lines based on the
	// height of the buttons and the container.
	if (buttonEls.length) {
		var outerHeight = $(buttonEls[0]).outerHeight();
	
		if (
			opts.buttons > 1 && // prevent infinite
			outerHeight > 0 && // will be 0 if hidden
			$(host).height() >= (outerHeight * 2) - 10
		) {
			_pagingDraw(settings, host, $.extend({}, opts, { buttons: opts.buttons - 2 }));
		}
	}
}

/**
 * Get properties for a button based on the current paging state of the table
 *
 * @param {*} settings DT settings object
 * @param {*} button The button type in question
 * @param {*} page Table's current page
 * @param {*} pages Number of pages
 * @returns Info object
 */
function _pagingButtonInfo(settings, button, page, pages) {
	var lang = settings.oLanguage.oPaginate;
	var o = {
		display: '',
		active: false,
		disabled: false
	};

	switch ( button ) {
		case 'ellipsis':
			o.display = '&#x2026;';
			break;

		case 'first':
			o.display = lang.sFirst;

			if (page === 0) {
				o.disabled = true;
			}
			break;

		case 'previous':
			o.display = lang.sPrevious;

			if ( page === 0 ) {
				o.disabled = true;
			}
			break;

		case 'next':
			o.display = lang.sNext;

			if ( pages === 0 || page === pages-1 ) {
				o.disabled = true;
			}
			break;

		case 'last':
			o.display = lang.sLast;

			if ( pages === 0 || page === pages-1 ) {
				o.disabled = true;
			}
			break;

		default:
			if ( typeof button === 'number' ) {
				o.display = settings.fnFormatNumber( button + 1 );
				
				if (page === button) {
					o.active = true;
				}
			}
			break;
	}

	return o;
}

/**
 * Compute what number buttons to show in the paging control
 *
 * @param {*} page Current page
 * @param {*} pages Total number of pages
 * @param {*} buttons Target number of number buttons
 * @param {boolean} addFirstLast Indicate if page 1 and end should be included
 * @returns Buttons to show
 */
function _pagingNumbers ( page, pages, buttons, addFirstLast ) {
	var
		numbers = [],
		half = Math.floor(buttons / 2),
		before = addFirstLast ? 2 : 1,
		after = addFirstLast ? 1 : 0;

	if ( pages <= buttons ) {
		numbers = _range(0, pages);
	}
	else if (buttons === 1) {
		// Single button - current page only
		numbers = [page];
	}
	else if (buttons === 3) {
		// Special logic for just three buttons
		if (page <= 1) {
			numbers = [0, 1, 'ellipsis'];
		}
		else if (page >= pages - 2) {
			numbers = _range(pages-2, pages);
			numbers.unshift('ellipsis');
		}
		else {
			numbers = ['ellipsis', page, 'ellipsis'];
		}
	}
	else if ( page <= half ) {
		numbers = _range(0, buttons-before);
		numbers.push('ellipsis');

		if (addFirstLast) {
			numbers.push(pages-1);
		}
	}
	else if ( page >= pages - 1 - half ) {
		numbers = _range(pages-(buttons-before), pages);
		numbers.unshift('ellipsis');

		if (addFirstLast) {
			numbers.unshift(0);
		}
	}
	else {
		numbers = _range(page-half+before, page+half-after);
		numbers.push('ellipsis');
		numbers.unshift('ellipsis');

		if (addFirstLast) {
			numbers.push(pages-1);
			numbers.unshift(0);
		}
	}

	return numbers;
}

var __lengthCounter = 0;

// opts
// - menu
// - text
DataTable.feature.register( 'pageLength', function ( settings, opts ) {
	var features = settings.oFeatures;

	// For compatibility with the legacy `pageLength` top level option
	if (! features.bPaginate || ! features.bLengthChange) {
		return null;
	}

	opts = $.extend({
		menu: settings.aLengthMenu,
		text: settings.oLanguage.sLengthMenu
	}, opts);

	var
		classes  = settings.oClasses.length,
		tableId  = settings.sTableId,
		menu     = opts.menu,
		lengths  = [],
		language = [],
		i;

	// Options can be given in a number of ways
	if (Array.isArray( menu[0] )) {
		// Old 1.x style - 2D array
		lengths = menu[0];
		language = menu[1];
	}
	else {
		for ( i=0 ; i<menu.length ; i++ ) {
			// An object with different label and value
			if ($.isPlainObject(menu[i])) {
				lengths.push(menu[i].value);
				language.push(menu[i].label);
			}
			else {
				// Or just a number to display and use
				lengths.push(menu[i]);
				language.push(menu[i]);
			}
		}
	}

	// We can put the <select> outside of the label if it is at the start or
	// end which helps improve accessability (not all screen readers like
	// implicit for elements).
	var end = opts.text.match(/_MENU_$/);
	var start = opts.text.match(/^_MENU_/);
	var removed = opts.text.replace(/_MENU_/, '');
	var str = '<label>' + opts.text + '</label>';

	if (start) {
		str = '_MENU_<label>' + removed + '</label>';
	}
	else if (end) {
		str = '<label>' + removed + '</label>_MENU_';
	}

	// Wrapper element - use a span as a holder for where the select will go
	var tmpId = 'tmp-' + (+new Date())
	var div = $('<div/>')
		.addClass( classes.container )
		.append(
			str.replace( '_MENU_', '<span id="'+tmpId+'"></span>' )
		);

	// Save text node content for macro updating
	var textNodes = [];
	Array.prototype.slice.call(div.find('label')[0].childNodes).forEach(function (el) {
		if (el.nodeType === Node.TEXT_NODE) {
			textNodes.push({
				el: el,
				text: el.textContent
			});
		}
	});

	// Update the label text in case it has an entries value
	var updateEntries = function (len) {
		textNodes.forEach(function (node) {
			node.el.textContent = _fnMacros(settings, node.text, len);
		});
	}

	// Next, the select itself, along with the options
	var select = $('<select/>', {
		'aria-controls': tableId,
		'class':         classes.select
	} );

	for ( i=0 ; i<lengths.length ; i++ ) {
		// Attempt to look up the length from the i18n options
		var label = settings.api.i18n('lengthLabels.' + lengths[i], null);

		if (label === null) {
			// If not present, fallback to old style
			label = typeof language[i] === 'number' ?
				settings.fnFormatNumber( language[i] ) :
				language[i];
		}

		select[0][ i ] = new Option(label, lengths[i]);
	}

	// add for and id to label and input
	div.find('label').attr('for', 'dt-length-' + __lengthCounter);
	select.attr('id', 'dt-length-' + __lengthCounter);
	__lengthCounter++;

	// Swap in the select list
	div.find('#' + tmpId).replaceWith(select);

	// Can't use `select` variable as user might provide their own and the
	// reference is broken by the use of outerHTML
	$('select', div)
		.val( settings._iDisplayLength )
		.on( 'change.DT', function() {
			_fnLengthChange( settings, $(this).val() );
			_fnDraw( settings );
		} );

	// Update node value whenever anything changes the table's length
	$(settings.nTable).on( 'length.dt.DT', function (e, s, len) {
		if ( settings === s ) {
			$('select', div).val( len );

			// Resolve plurals in the text for the new length
			updateEntries(len);
		}
	} );

	updateEntries(settings._iDisplayLength);

	return div;
}, 'l' );

// jQuery access
$.fn.dataTable = DataTable;

// Provide access to the host jQuery object (circular reference)
DataTable.$ = $;

// Legacy aliases
$.fn.dataTableSettings = DataTable.settings;
$.fn.dataTableExt = DataTable.ext;

// With a capital `D` we return a DataTables API instance rather than a
// jQuery object
$.fn.DataTable = function ( opts ) {
	return $(this).dataTable( opts ).api();
};

// All properties that are available to $.fn.dataTable should also be
// available on $.fn.DataTable
$.each( DataTable, function ( prop, val ) {
	$.fn.DataTable[ prop ] = val;
} );

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DataTable);


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfY29yZS1qc19tb2R1bGVzX2VzX2FycmF5X2NvbmNhdF9qcy1ub2RlX21vZHVsZXNfZGF0YXRhYmxlc19uZXQtcmVzcG9uc2l2LTUyMzNhNC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBYTtBQUNiLFlBQVksbUJBQU8sQ0FBQyxxRUFBb0I7QUFDeEMsc0JBQXNCLG1CQUFPLENBQUMsNkZBQWdDO0FBQzlELGlCQUFpQixtQkFBTyxDQUFDLHVHQUFxQzs7QUFFOUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7Ozs7Ozs7OztBQ25CYTtBQUNiLGtCQUFrQixtQkFBTyxDQUFDLGlGQUEwQjtBQUNwRCwyQkFBMkIsbUJBQU8sQ0FBQyx1R0FBcUM7QUFDeEUsK0JBQStCLG1CQUFPLENBQUMsK0dBQXlDOztBQUVoRjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNSYTtBQUNiO0FBQ0EseUNBQXlDOztBQUV6QztBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNQYTtBQUNiLFFBQVEsbUJBQU8sQ0FBQyx1RUFBcUI7QUFDckMsWUFBWSxtQkFBTyxDQUFDLHFFQUFvQjtBQUN4QyxjQUFjLG1CQUFPLENBQUMsMkVBQXVCO0FBQzdDLGVBQWUsbUJBQU8sQ0FBQyw2RUFBd0I7QUFDL0MsZUFBZSxtQkFBTyxDQUFDLDZFQUF3QjtBQUMvQyx3QkFBd0IsbUJBQU8sQ0FBQyxtR0FBbUM7QUFDbkUsK0JBQStCLG1CQUFPLENBQUMsbUhBQTJDO0FBQ2xGLHFCQUFxQixtQkFBTyxDQUFDLHlGQUE4QjtBQUMzRCx5QkFBeUIsbUJBQU8sQ0FBQyxtR0FBbUM7QUFDcEUsbUNBQW1DLG1CQUFPLENBQUMsMkhBQStDO0FBQzFGLHNCQUFzQixtQkFBTyxDQUFDLDZGQUFnQztBQUM5RCxpQkFBaUIsbUJBQU8sQ0FBQyx1R0FBcUM7O0FBRTlEOztBQUVBO0FB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Q0Esb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsU0FBUztBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0MsU0FBUztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QyxTQUFTO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyxpQkFBaUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0IsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEMsU0FBUztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7O0FBRTNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUEsa0JBQWtCLDRCQUE0QjtBQUM5QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FB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QTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsc0RBQVM7QUFDWDtBQUNBOztBQUVBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRCxpRUFBZSxzREFBUyxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDM3hEekI7QUFDQTtBQUNBOztBQUU0Qjs7QUFFNUI7QUFDQTtBQUNBLFFBQVEsbUNBQU07OztBQUdkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxTQUFTO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7OztBQUdaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjOzs7QUFHZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOzs7QUFHWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7O0FBR2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxZQUFZLEdBQUc7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsU0FBUztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksR0FBRztBQUNmLFlBQVksR0FBRztBQUNmO0FBQ0E7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LEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0IsU0FBUztBQUN4QztBQUNBOztBQUVBLCtCQUErQixTQUFTO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUIsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE9BQU87QUFDbEI7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IscUJBQXFCO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLG1DQUFtQyxRQUFRO0FBQzNDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQiw0QkFBNEI7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdUJBQXVCO0FBQ3RD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLHNDQUFzQztBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyx3QkFBd0I7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLGFBQWEsMEJBQTBCO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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Q0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQzs7QUFFM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLHdCQUF3QjtBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLFFBQVE7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksS0FBSztBQUNqQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxLQUFLO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQjtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckIsWUFBWSxlQUFlO0FBQzNCO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQjtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDJCQUEyQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLEtBQUs7QUFDMUI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLEtBQUs7QUFDMUI7QUFDQTtBQUNBLFdBQVcsNEJBQTRCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLG1CQUFtQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFrQyxRQUFRO0FBQzFDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDLFFBQVE7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDZCQUE2QixRQUFRO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBO0FB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STtBQUNKO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsYUFBYSxrQkFBa0I7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsSUFBSSxXQUFXO0FBQ2YsSUFBSSxXQUFXO0FBQ2YsSUFBSSxXQUFXO0FBQ2YsSUFBSSxXQUFXO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQyxRQUFRO0FBQzdDLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0MsUUFBUTtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7Ozs7QUFNRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7QUFHRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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OztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRixFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtB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QUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1REFBdUQ7QUFDdkQsR0FBRztBQUNILEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RSxHQUFHO0FBQ0gsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7OztBQUdGO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7OztBQUdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSCxFQUFFOzs7QUFHRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCwyQkFBMkI7QUFDakY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNILEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssZ0NBQWdDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdDQUFnQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDZCQUE2QjtBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEVBQUU7QUFDZjtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxpQ0FBaUM7QUFDdEM7QUFDQSxlQUFlOzs7QUFHZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCOzs7QUFHeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxFQUFFO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDBCQUEwQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdC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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlCQUF5QjtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix5QkFBeUI7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIseUJBQXlCO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLGFBQWE7QUFDYixjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZUFBZTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsRUFBRTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFlBQVk7O0FBRXREO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsNENBQTRDO0FBQzVDLDhDQUE4QztBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsMkJBQTJCO0FBQzNCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrQkFBa0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qjs7QUFFdkIsY0FBYyx5QkFBeUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBLGdCQUFnQixtQkFBbUI7QUFDbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxVQUFVLDJCQUEyQjtBQUMvRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILGFBQWEsbUJBQW1CO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRixpRUFBZSxTQUFTLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWhhcy1zcGVjaWVzLXN1cHBvcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZG9lcy1ub3QtZXhjZWVkLXNhZmUtaW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGF0YXRhYmxlcy5uZXQtYnM1L2pzL2RhdGFUYWJsZXMuYm9vdHN0cmFwNS5tanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RhdGF0YWJsZXMubmV0LXJlc3BvbnNpdmUtYnM1L2pzL3Jlc3BvbnNpdmUuYm9vdHN0cmFwNS5tanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RhdGF0YWJsZXMubmV0LXJlc3BvbnNpdmUvanMvZGF0YVRhYmxlcy5yZXNwb25zaXZlLm1qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGF0YXRhYmxlcy5uZXQvanMvZGF0YVRhYmxlcy5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG52YXIgVjhfVkVSU0lPTiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9lbnZpcm9ubWVudC12OC12ZXJzaW9uJyk7XG5cbnZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE1FVEhPRF9OQU1FKSB7XG4gIC8vIFdlIGNhbid0IHVzZSB0aGlzIGZlYXR1cmUgZGV0ZWN0aW9uIGluIFY4IHNpbmNlIGl0IGNhdXNlc1xuICAvLyBkZW9wdGltaXphdGlvbiBhbmQgc2VyaW91cyBwZXJmb3JtYW5jZSBkZWdyYWRhdGlvblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNjc3XG4gIHJldHVybiBWOF9WRVJTSU9OID49IDUxIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gYXJyYXkuY29uc3RydWN0b3IgPSB7fTtcbiAgICBjb25zdHJ1Y3RvcltTUEVDSUVTXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7IGZvbzogMSB9O1xuICAgIH07XG4gICAgcmV0dXJuIGFycmF5W01FVEhPRF9OQU1FXShCb29sZWFuKS5mb28gIT09IDE7XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIGlmIChERVNDUklQVE9SUykgZGVmaW5lUHJvcGVydHlNb2R1bGUuZihvYmplY3QsIGtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDAsIHZhbHVlKSk7XG4gIGVsc2Ugb2JqZWN0W2tleV0gPSB2YWx1ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gMHgxRkZGRkZGRkZGRkZGRjsgLy8gMiAqKiA1MyAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPiBNQVhfU0FGRV9JTlRFR0VSKSB0aHJvdyAkVHlwZUVycm9yKCdNYXhpbXVtIGFsbG93ZWQgaW5kZXggZXhjZWVkZWQnKTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1hcnJheScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2xlbmd0aC1vZi1hcnJheS1saWtlJyk7XG52YXIgZG9lc05vdEV4Y2VlZFNhZmVJbnRlZ2VyID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RvZXMtbm90LWV4Y2VlZC1zYWZlLWludGVnZXInKTtcbnZhciBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHknKTtcbnZhciBhcnJheVNwZWNpZXNDcmVhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktc3BlY2llcy1jcmVhdGUnKTtcbnZhciBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1oYXMtc3BlY2llcy1zdXBwb3J0Jyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG52YXIgVjhfVkVSU0lPTiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9lbnZpcm9ubWVudC12OC12ZXJzaW9uJyk7XG5cbnZhciBJU19DT05DQVRfU1BSRUFEQUJMRSA9IHdlbGxLbm93blN5bWJvbCgnaXNDb25jYXRTcHJlYWRhYmxlJyk7XG5cbi8vIFdlIGNhbid0IHVzZSB0aGlzIGZlYXR1cmUgZGV0ZWN0aW9uIGluIFY4IHNpbmNlIGl0IGNhdXNlc1xuLy8gZGVvcHRpbWl6YXRpb24gYW5kIHNlcmlvdXMgcGVyZm9ybWFuY2UgZGVncmFkYXRpb25cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy82NzlcbnZhciBJU19DT05DQVRfU1BSRUFEQUJMRV9TVVBQT1JUID0gVjhfVkVSU0lPTiA+PSA1MSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgYXJyYXkgPSBbXTtcbiAgYXJyYXlbSVNfQ09OQ0FUX1NQUkVBREFCTEVdID0gZmFsc2U7XG4gIHJldHVybiBhcnJheS5jb25jYXQoKVswXSAhPT0gYXJyYXk7XG59KTtcblxudmFyIGlzQ29uY2F0U3ByZWFkYWJsZSA9IGZ1bmN0aW9uIChPKSB7XG4gIGlmICghaXNPYmplY3QoTykpIHJldHVybiBmYWxzZTtcbiAgdmFyIHNwcmVhZGFibGUgPSBPW0lTX0NPTkNBVF9TUFJFQURBQkxFXTtcbiAgcmV0dXJuIHNwcmVhZGFibGUgIT09IHVuZGVmaW5lZCA/ICEhc3ByZWFkYWJsZSA6IGlzQXJyYXkoTyk7XG59O1xuXG52YXIgRk9SQ0VEID0gIUlTX0NPTkNBVF9TUFJFQURBQkxFX1NVUFBPUlQgfHwgIWFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQoJ2NvbmNhdCcpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmNvbmNhdGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5jb25jYXRcbi8vIHdpdGggYWRkaW5nIHN1cHBvcnQgb2YgQEBpc0NvbmNhdFNwcmVhZGFibGUgYW5kIEBAc3BlY2llc1xuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGFyaXR5OiAxLCBmb3JjZWQ6IEZPUkNFRCB9LCB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFycyAtLSByZXF1aXJlZCBmb3IgYC5sZW5ndGhgXG4gIGNvbmNhdDogZnVuY3Rpb24gY29uY2F0KGFyZykge1xuICAgIHZhciBPID0gdG9PYmplY3QodGhpcyk7XG4gICAgdmFyIEEgPSBhcnJheVNwZWNpZXNDcmVhdGUoTywgMCk7XG4gICAgdmFyIG4gPSAwO1xuICAgIHZhciBpLCBrLCBsZW5ndGgsIGxlbiwgRTtcbiAgICBmb3IgKGkgPSAtMSwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBFID0gaSA9PT0gLTEgPyBPIDogYXJndW1lbnRzW2ldO1xuICAgICAgaWYgKGlzQ29uY2F0U3ByZWFkYWJsZShFKSkge1xuICAgICAgICBsZW4gPSBsZW5ndGhPZkFycmF5TGlrZShFKTtcbiAgICAgICAgZG9lc05vdEV4Y2VlZFNhZmVJbnRlZ2VyKG4gKyBsZW4pO1xuICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbGVuOyBrKyssIG4rKykgaWYgKGsgaW4gRSkgY3JlYXRlUHJvcGVydHkoQSwgbiwgRVtrXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb2VzTm90RXhjZWVkU2FmZUludGVnZXIobiArIDEpO1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShBLCBuKyssIEUpO1xuICAgICAgfVxuICAgIH1cbiAgICBBLmxlbmd0aCA9IG47XG4gICAgcmV0dXJuIEE7XG4gIH1cbn0pO1xuIiwiLyohIERhdGFUYWJsZXMgQm9vdHN0cmFwIDUgaW50ZWdyYXRpb25cbiAqIMKpIFNwcnlNZWRpYSBMdGQgLSBkYXRhdGFibGVzLm5ldC9saWNlbnNlXG4gKi9cblxuaW1wb3J0IGpRdWVyeSBmcm9tICdqcXVlcnknO1xuaW1wb3J0IERhdGFUYWJsZSBmcm9tICdkYXRhdGFibGVzLm5ldCc7XG5cbi8vIEFsbG93IHJlYXNzaWdubWVudCBvZiB0aGUgJCB2YXJpYWJsZVxubGV0ICQgPSBqUXVlcnk7XG5cblxuLyoqXG4gKiBEYXRhVGFibGVzIGludGVncmF0aW9uIGZvciBCb290c3RyYXAgNS5cbiAqXG4gKiBUaGlzIGZpbGUgc2V0cyB0aGUgZGVmYXVsdHMgYW5kIGFkZHMgb3B0aW9ucyB0byBEYXRhVGFibGVzIHRvIHN0eWxlIGl0c1xuICogY29udHJvbHMgdXNpbmcgQm9vdHN0cmFwLiBTZWUgaHR0cHM6Ly9kYXRhdGFibGVzLm5ldC9tYW51YWwvc3R5bGluZy9ib290c3RyYXBcbiAqIGZvciBmdXJ0aGVyIGluZm9ybWF0aW9uLlxuICovXG5cbi8qIFNldCB0aGUgZGVmYXVsdHMgZm9yIERhdGFUYWJsZXMgaW5pdGlhbGlzYXRpb24gKi9cbiQuZXh0ZW5kKCB0cnVlLCBEYXRhVGFibGUuZGVmYXVsdHMsIHtcblx0cmVuZGVyZXI6ICdib290c3RyYXAnXG59ICk7XG5cblxuLyogRGVmYXVsdCBjbGFzcyBtb2RpZmljYXRpb24gKi9cbiQuZXh0ZW5kKCB0cnVlLCBEYXRhVGFibGUuZXh0LmNsYXNzZXMsIHtcblx0Y29udGFpbmVyOiBcImR0LWNvbnRhaW5lciBkdC1ib290c3RyYXA1XCIsXG5cdHNlYXJjaDoge1xuXHRcdGlucHV0OiBcImZvcm0tY29udHJvbCBmb3JtLWNvbnRyb2wtc21cIlxuXHR9LFxuXHRsZW5ndGg6IHtcblx0XHRzZWxlY3Q6IFwiZm9ybS1zZWxlY3QgZm9ybS1zZWxlY3Qtc21cIlxuXHR9LFxuXHRwcm9jZXNzaW5nOiB7XG5cdFx0Y29udGFpbmVyOiBcImR0LXByb2Nlc3NpbmcgY2FyZFwiXG5cdH0sXG5cdGxheW91dDoge1xuXHRcdHJvdzogJ3JvdyBtdC0yIGp1c3RpZnktY29udGVudC1iZXR3ZWVuJyxcblx0XHRjZWxsOiAnZC1tZC1mbGV4IGp1c3RpZnktY29udGVudC1iZXR3ZWVuIGFsaWduLWl0ZW1zLWNlbnRlcicsXG5cdFx0dGFibGVDZWxsOiAnY29sLTEyJyxcblx0XHRzdGFydDogJ2R0LWxheW91dC1zdGFydCBjb2wtbWQtYXV0byBtZS1hdXRvJyxcblx0XHRlbmQ6ICdkdC1sYXlvdXQtZW5kIGNvbC1tZC1hdXRvIG1zLWF1dG8nLFxuXHRcdGZ1bGw6ICdkdC1sYXlvdXQtZnVsbCBjb2wtbWQnXG5cdH1cbn0gKTtcblxuXG4vKiBCb290c3RyYXAgcGFnaW5nIGJ1dHRvbiByZW5kZXJlciAqL1xuRGF0YVRhYmxlLmV4dC5yZW5kZXJlci5wYWdpbmdCdXR0b24uYm9vdHN0cmFwID0gZnVuY3Rpb24gKHNldHRpbmdzLCBidXR0b25UeXBlLCBjb250ZW50LCBhY3RpdmUsIGRpc2FibGVkKSB7XG5cdHZhciBidG5DbGFzc2VzID0gWydkdC1wYWdpbmctYnV0dG9uJywgJ3BhZ2UtaXRlbSddO1xuXG5cdGlmIChhY3RpdmUpIHtcblx0XHRidG5DbGFzc2VzLnB1c2goJ2FjdGl2ZScpO1xuXHR9XG5cblx0aWYgKGRpc2FibGVkKSB7XG5cdFx0YnRuQ2xhc3Nlcy5wdXNoKCdkaXNhYmxlZCcpXG5cdH1cblxuXHR2YXIgbGkgPSAkKCc8bGk+JykuYWRkQ2xhc3MoYnRuQ2xhc3Nlcy5qb2luKCcgJykpO1xuXHR2YXIgYSA9ICQoJzxidXR0b24+Jywge1xuXHRcdCdjbGFzcyc6ICdwYWdlLWxpbmsnLFxuXHRcdHJvbGU6ICdsaW5rJyxcblx0XHR0eXBlOiAnYnV0dG9uJ1xuXHR9KVxuXHRcdC5odG1sKGNvbnRlbnQpXG5cdFx0LmFwcGVuZFRvKGxpKTtcblxuXHRyZXR1cm4ge1xuXHRcdGRpc3BsYXk6IGxpLFxuXHRcdGNsaWNrZXI6IGFcblx0fTtcbn07XG5cbkRhdGFUYWJsZS5leHQucmVuZGVyZXIucGFnaW5nQ29udGFpbmVyLmJvb3RzdHJhcCA9IGZ1bmN0aW9uIChzZXR0aW5ncywgYnV0dG9uRWxzKSB7XG5cdHJldHVybiAkKCc8dWwvPicpLmFkZENsYXNzKCdwYWdpbmF0aW9uJykuYXBwZW5kKGJ1dHRvbkVscyk7XG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IERhdGFUYWJsZTtcbiIsIi8qISBCb290c3RyYXAgNSBpbnRlZ3JhdGlvbiBmb3IgRGF0YVRhYmxlcycgUmVzcG9uc2l2ZVxuICogwqkgU3ByeU1lZGlhIEx0ZCAtIGRhdGF0YWJsZXMubmV0L2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQgalF1ZXJ5IGZyb20gJ2pxdWVyeSc7XG5pbXBvcnQgRGF0YVRhYmxlIGZyb20gJ2RhdGF0YWJsZXMubmV0LWJzNSc7XG5pbXBvcnQgUmVzcG9uc2l2ZSBmcm9tICdkYXRhdGFibGVzLm5ldC1yZXNwb25zaXZlJztcblxuLy8gQWxsb3cgcmVhc3NpZ25tZW50IG9mIHRoZSAkIHZhcmlhYmxlXG5sZXQgJCA9IGpRdWVyeTtcblxuXG52YXIgX2Rpc3BsYXkgPSBEYXRhVGFibGUuUmVzcG9uc2l2ZS5kaXNwbGF5O1xudmFyIF9vcmlnaW5hbCA9IF9kaXNwbGF5Lm1vZGFsO1xudmFyIF9tb2RhbCA9ICQoXG5cdCc8ZGl2IGNsYXNzPVwibW9kYWwgZmFkZSBkdHItYnMtbW9kYWxcIiByb2xlPVwiZGlhbG9nXCI+JyArXG5cdFx0JzxkaXYgY2xhc3M9XCJtb2RhbC1kaWFsb2dcIiByb2xlPVwiZG9jdW1lbnRcIj4nICtcblx0XHQnPGRpdiBjbGFzcz1cIm1vZGFsLWNvbnRlbnRcIj4nICtcblx0XHQnPGRpdiBjbGFzcz1cIm1vZGFsLWhlYWRlclwiPicgK1xuXHRcdCc8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0bi1jbG9zZVwiIGRhdGEtYnMtZGlzbWlzcz1cIm1vZGFsXCIgYXJpYS1sYWJlbD1cIkNsb3NlXCI+PC9idXR0b24+JyArXG5cdFx0JzwvZGl2PicgK1xuXHRcdCc8ZGl2IGNsYXNzPVwibW9kYWwtYm9keVwiLz4nICtcblx0XHQnPC9kaXY+JyArXG5cdFx0JzwvZGl2PicgK1xuXHRcdCc8L2Rpdj4nXG4pO1xudmFyIG1vZGFsO1xuXG4vLyBOb3RlIHRoaXMgY291bGQgYmUgdW5kZWZpbmVkIGF0IHRoZSB0aW1lIG9mIGluaXRpYWxpc2F0aW9uIC0gdGhlXG4vLyBEYXRhVGFibGUuUmVzcG9uc2l2ZS5ib290c3RyYXAgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gc2V0IGEgZGlmZmVyZW50XG4vLyBib290c3RyYXAgb2JqZWN0XG52YXIgX2JzID0gd2luZG93LmJvb3RzdHJhcDtcblxuRGF0YVRhYmxlLlJlc3BvbnNpdmUuYm9vdHN0cmFwID0gZnVuY3Rpb24gKGJzKSB7XG5cdF9icyA9IGJzO1xufTtcblxuLy8gR2V0IHRoZSBCb290c3RyYXAgbGlicmFyeSBmcm9tIGxvY2FsbHkgc2V0IChsZWdhY3kpIG9yIGZyb20gRFQuXG5mdW5jdGlvbiBnZXRCcygpIHtcblx0bGV0IGR0QnMgPSBEYXRhVGFibGUudXNlKCdib290c3RyYXAnKTtcblxuXHRpZiAoZHRCcykge1xuXHRcdHJldHVybiBkdEJzO1xuXHR9XG5cblx0aWYgKF9icykge1xuXHRcdHJldHVybiBfYnM7XG5cdH1cblxuXHR0aHJvdyBuZXcgRXJyb3IoJ05vIEJvb3RzdHJhcCBsaWJyYXJ5LiBTZXQgaXQgd2l0aCBgRGF0YVRhYmxlLnVzZShib290c3RyYXApO2AnKTtcbn1cblxuX2Rpc3BsYXkubW9kYWwgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRpZiAoIW1vZGFsICYmIF9icy5Nb2RhbCkge1xuXHRcdGxldCBsb2NhbEJzID0gZ2V0QnMoKTtcblx0XHRtb2RhbCA9IG5ldyBsb2NhbEJzLk1vZGFsKF9tb2RhbFswXSk7XG5cdH1cblxuXHRyZXR1cm4gZnVuY3Rpb24gKHJvdywgdXBkYXRlLCByZW5kZXIsIGNsb3NlQ2FsbGJhY2spIHtcblx0XHRpZiAoISBtb2RhbCkge1xuXHRcdFx0cmV0dXJuIF9vcmlnaW5hbChyb3csIHVwZGF0ZSwgcmVuZGVyLCBjbG9zZUNhbGxiYWNrKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHR2YXIgcmVuZGVyZWQgPSByZW5kZXIoKTtcblxuXHRcdFx0aWYgKHJlbmRlcmVkID09PSBmYWxzZSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghdXBkYXRlKSB7XG5cdFx0XHRcdGlmIChvcHRpb25zICYmIG9wdGlvbnMuaGVhZGVyKSB7XG5cdFx0XHRcdFx0dmFyIGhlYWRlciA9IF9tb2RhbC5maW5kKCdkaXYubW9kYWwtaGVhZGVyJyk7XG5cdFx0XHRcdFx0dmFyIGJ1dHRvbiA9IGhlYWRlci5maW5kKCdidXR0b24nKS5kZXRhY2goKTtcblxuXHRcdFx0XHRcdGhlYWRlclxuXHRcdFx0XHRcdFx0LmVtcHR5KClcblx0XHRcdFx0XHRcdC5hcHBlbmQoJzxoNCBjbGFzcz1cIm1vZGFsLXRpdGxlXCI+JyArIG9wdGlvbnMuaGVhZGVyKHJvdykgKyAnPC9oND4nKVxuXHRcdFx0XHRcdFx0LmFwcGVuZChidXR0b24pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0X21vZGFsLmZpbmQoJ2Rpdi5tb2RhbC1ib2R5JykuZW1wdHkoKS5hcHBlbmQocmVuZGVyZWQpO1xuXG5cdFx0XHRcdF9tb2RhbFxuXHRcdFx0XHRcdC5kYXRhKCdkdHItcm93LWlkeCcsIHJvdy5pbmRleCgpKVxuXHRcdFx0XHRcdC5vbmUoJ2hpZGRlbi5icy5tb2RhbCcsIGNsb3NlQ2FsbGJhY2spXG5cdFx0XHRcdFx0LmFwcGVuZFRvKCdib2R5Jyk7XG5cblx0XHRcdFx0bW9kYWwuc2hvdygpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGlmICgkLmNvbnRhaW5zKGRvY3VtZW50LCBfbW9kYWxbMF0pICYmIHJvdy5pbmRleCgpID09PSBfbW9kYWwuZGF0YSgnZHRyLXJvdy1pZHgnKSkge1xuXHRcdFx0XHRcdF9tb2RhbC5maW5kKCdkaXYubW9kYWwtYm9keScpLmVtcHR5KCkuYXBwZW5kKHJlbmRlcmVkKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHQvLyBNb2RhbCBub3Qgc2hvd24gZm9yIHRoaXMgcm93IC0gZG8gbm90aGluZ1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0fTtcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgRGF0YVRhYmxlO1xuIiwiLyohIFJlc3BvbnNpdmUgMy4wLjRcbiAqIMKpIFNwcnlNZWRpYSBMdGQgLSBkYXRhdGFibGVzLm5ldC9saWNlbnNlXG4gKi9cblxuaW1wb3J0IGpRdWVyeSBmcm9tICdqcXVlcnknO1xuaW1wb3J0IERhdGFUYWJsZSBmcm9tICdkYXRhdGFibGVzLm5ldCc7XG5cbi8vIEFsbG93IHJlYXNzaWdubWVudCBvZiB0aGUgJCB2YXJpYWJsZVxubGV0ICQgPSBqUXVlcnk7XG5cblxuLyoqXG4gKiBAc3VtbWFyeSAgICAgUmVzcG9uc2l2ZVxuICogQGRlc2NyaXB0aW9uIFJlc3BvbnNpdmUgdGFibGVzIHBsdWctaW4gZm9yIERhdGFUYWJsZXNcbiAqIEB2ZXJzaW9uICAgICAzLjAuNFxuICogQGF1dGhvciAgICAgIFNwcnlNZWRpYSBMdGRcbiAqIEBjb3B5cmlnaHQgICBTcHJ5TWVkaWEgTHRkLlxuICpcbiAqIFRoaXMgc291cmNlIGZpbGUgaXMgZnJlZSBzb2Z0d2FyZSwgYXZhaWxhYmxlIHVuZGVyIHRoZSBmb2xsb3dpbmcgbGljZW5zZTpcbiAqICAgTUlUIGxpY2Vuc2UgLSBodHRwOi8vZGF0YXRhYmxlcy5uZXQvbGljZW5zZS9taXRcbiAqXG4gKiBUaGlzIHNvdXJjZSBmaWxlIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dFxuICogV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFlcbiAqIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIGxpY2Vuc2UgZmlsZXMgZm9yIGRldGFpbHMuXG4gKlxuICogRm9yIGRldGFpbHMgcGxlYXNlIHJlZmVyIHRvOiBodHRwOi8vd3d3LmRhdGF0YWJsZXMubmV0XG4gKi9cblxuLyoqXG4gKiBSZXNwb25zaXZlIGlzIGEgcGx1Zy1pbiBmb3IgdGhlIERhdGFUYWJsZXMgbGlicmFyeSB0aGF0IG1ha2VzIHVzZSBvZlxuICogRGF0YVRhYmxlcycgYWJpbGl0eSB0byBjaGFuZ2UgdGhlIHZpc2liaWxpdHkgb2YgY29sdW1ucywgY2hhbmdpbmcgdGhlXG4gKiB2aXNpYmlsaXR5IG9mIGNvbHVtbnMgc28gdGhlIGRpc3BsYXllZCBjb2x1bW5zIGZpdCBpbnRvIHRoZSB0YWJsZSBjb250YWluZXIuXG4gKiBUaGUgZW5kIHJlc3VsdCBpcyB0aGF0IGNvbXBsZXggdGFibGVzIHdpbGwgYmUgZHluYW1pY2FsbHkgYWRqdXN0ZWQgdG8gZml0XG4gKiBpbnRvIHRoZSB2aWV3cG9ydCwgYmUgaXQgb24gYSBkZXNrdG9wLCB0YWJsZXQgb3IgbW9iaWxlIGJyb3dzZXIuXG4gKlxuICogUmVzcG9uc2l2ZSBmb3IgRGF0YVRhYmxlcyBoYXMgdHdvIG1vZGVzIG9mIG9wZXJhdGlvbiwgd2hpY2ggY2FuIHVzZWRcbiAqIGluZGl2aWR1YWxseSBvciBjb21iaW5lZDpcbiAqXG4gKiAqIENsYXNzIG5hbWUgYmFzZWQgY29udHJvbCAtIGNvbHVtbnMgYXNzaWduZWQgY2xhc3MgbmFtZXMgdGhhdCBtYXRjaCB0aGVcbiAqICAgYnJlYWtwb2ludCBsb2dpYyBjYW4gYmUgc2hvd24gLyBoaWRkZW4gYXMgcmVxdWlyZWQgZm9yIGVhY2ggYnJlYWtwb2ludC5cbiAqICogQXV0b21hdGljIGNvbnRyb2wgLSBjb2x1bW5zIGFyZSBhdXRvbWF0aWNhbGx5IGhpZGRlbiB3aGVuIHRoZXJlIGlzIG5vXG4gKiAgIHJvb20gbGVmdCB0byBkaXNwbGF5IHRoZW0uIENvbHVtbnMgcmVtb3ZlZCBmcm9tIHRoZSByaWdodC5cbiAqXG4gKiBJbiBhZGRpdGlvbmFsIHRvIGNvbHVtbiB2aXNpYmlsaXR5IGNvbnRyb2wsIFJlc3BvbnNpdmUgYWxzbyBoYXMgYnVpbHQgaW50b1xuICogb3B0aW9ucyB0byB1c2UgRGF0YVRhYmxlcycgY2hpbGQgcm93IGRpc3BsYXkgdG8gc2hvdyAvIGhpZGUgdGhlIGluZm9ybWF0aW9uXG4gKiBmcm9tIHRoZSB0YWJsZSB0aGF0IGhhcyBiZWVuIGhpZGRlbi4gVGhlcmUgYXJlIGFsc28gdHdvIG1vZGVzIG9mIG9wZXJhdGlvblxuICogZm9yIHRoaXMgY2hpbGQgcm93IGRpc3BsYXk6XG4gKlxuICogKiBJbmxpbmUgLSB3aGVuIHRoZSBjb250cm9sIGVsZW1lbnQgdGhhdCB0aGUgdXNlciBjYW4gdXNlIHRvIHNob3cgLyBoaWRlXG4gKiAgIGNoaWxkIHJvd3MgaXMgZGlzcGxheWVkIGluc2lkZSB0aGUgZmlyc3QgY29sdW1uIG9mIHRoZSB0YWJsZS5cbiAqICogQ29sdW1uIC0gd2hlcmUgYSB3aG9sZSBjb2x1bW4gaXMgZGVkaWNhdGVkIHRvIGJlIHRoZSBzaG93IC8gaGlkZSBjb250cm9sLlxuICpcbiAqIEluaXRpYWxpc2F0aW9uIG9mIFJlc3BvbnNpdmUgaXMgcGVyZm9ybWVkIGJ5OlxuICpcbiAqICogQWRkaW5nIHRoZSBjbGFzcyBgcmVzcG9uc2l2ZWAgb3IgYGR0LXJlc3BvbnNpdmVgIHRvIHRoZSB0YWJsZS4gSW4gdGhpcyBjYXNlXG4gKiAgIFJlc3BvbnNpdmUgd2lsbCBhdXRvbWF0aWNhbGx5IGJlIGluaXRpYWxpc2VkIHdpdGggdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvblxuICogICBvcHRpb25zIHdoZW4gdGhlIERhdGFUYWJsZSBpcyBjcmVhdGVkLlxuICogKiBVc2luZyB0aGUgYHJlc3BvbnNpdmVgIG9wdGlvbiBpbiB0aGUgRGF0YVRhYmxlcyBjb25maWd1cmF0aW9uIG9wdGlvbnMuIFRoaXNcbiAqICAgY2FuIGFsc28gYmUgdXNlZCB0byBzcGVjaWZ5IHRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMsIG9yIHNpbXBseSBzZXQgdG9cbiAqICAgYHRydWVgIHRvIHVzZSB0aGUgZGVmYXVsdHMuXG4gKlxuICogIEBjbGFzc1xuICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdCBmb3IgdGhlIGhvc3QgdGFibGVcbiAqICBAcGFyYW0ge29iamVjdH0gW29wdHNdIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICogIEByZXF1aXJlcyBqUXVlcnkgMS43K1xuICogIEByZXF1aXJlcyBEYXRhVGFibGVzIDIuMC4wK1xuICpcbiAqICBAZXhhbXBsZVxuICogICAgICAkKCcjZXhhbXBsZScpLkRhdGFUYWJsZSgge1xuICogICAgICAgIHJlc3BvbnNpdmU6IHRydWVcbiAqICAgICAgfSApO1xuICogICAgfSApO1xuICovXG52YXIgUmVzcG9uc2l2ZSA9IGZ1bmN0aW9uIChzZXR0aW5ncywgb3B0cykge1xuXHQvLyBTYW5pdHkgY2hlY2sgdGhhdCB3ZSBhcmUgdXNpbmcgRGF0YVRhYmxlcyAyLjAuMCBvciBuZXdlclxuXHRpZiAoIURhdGFUYWJsZS52ZXJzaW9uQ2hlY2sgfHwgIURhdGFUYWJsZS52ZXJzaW9uQ2hlY2soJzInKSkge1xuXHRcdHRocm93ICdEYXRhVGFibGVzIFJlc3BvbnNpdmUgcmVxdWlyZXMgRGF0YVRhYmxlcyAyIG9yIG5ld2VyJztcblx0fVxuXG5cdHRoaXMucyA9IHtcblx0XHRjaGlsZE5vZGVTdG9yZToge30sXG5cdFx0Y29sdW1uczogW10sXG5cdFx0Y3VycmVudDogW10sXG5cdFx0ZHQ6IG5ldyBEYXRhVGFibGUuQXBpKHNldHRpbmdzKVxuXHR9O1xuXG5cdC8vIENoZWNrIGlmIHJlc3BvbnNpdmUgaGFzIGFscmVhZHkgYmVlbiBpbml0aWFsaXNlZCBvbiB0aGlzIHRhYmxlXG5cdGlmICh0aGlzLnMuZHQuc2V0dGluZ3MoKVswXS5yZXNwb25zaXZlKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gZGV0YWlscyBpcyBhbiBvYmplY3QsIGJ1dCBmb3Igc2ltcGxpY2l0eSB0aGUgdXNlciBjYW4gZ2l2ZSBpdCBhcyBhIHN0cmluZ1xuXHQvLyBvciBhIGJvb2xlYW5cblx0aWYgKG9wdHMgJiYgdHlwZW9mIG9wdHMuZGV0YWlscyA9PT0gJ3N0cmluZycpIHtcblx0XHRvcHRzLmRldGFpbHMgPSB7IHR5cGU6IG9wdHMuZGV0YWlscyB9O1xuXHR9XG5cdGVsc2UgaWYgKG9wdHMgJiYgb3B0cy5kZXRhaWxzID09PSBmYWxzZSkge1xuXHRcdG9wdHMuZGV0YWlscyA9IHsgdHlwZTogZmFsc2UgfTtcblx0fVxuXHRlbHNlIGlmIChvcHRzICYmIG9wdHMuZGV0YWlscyA9PT0gdHJ1ZSkge1xuXHRcdG9wdHMuZGV0YWlscyA9IHsgdHlwZTogJ2lubGluZScgfTtcblx0fVxuXG5cdHRoaXMuYyA9ICQuZXh0ZW5kKFxuXHRcdHRydWUsXG5cdFx0e30sXG5cdFx0UmVzcG9uc2l2ZS5kZWZhdWx0cyxcblx0XHREYXRhVGFibGUuZGVmYXVsdHMucmVzcG9uc2l2ZSxcblx0XHRvcHRzXG5cdCk7XG5cdHNldHRpbmdzLnJlc3BvbnNpdmUgPSB0aGlzO1xuXHR0aGlzLl9jb25zdHJ1Y3RvcigpO1xufTtcblxuJC5leHRlbmQoUmVzcG9uc2l2ZS5wcm90b3R5cGUsIHtcblx0LyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuXHQgKiBDb25zdHJ1Y3RvclxuXHQgKi9cblxuXHQvKipcblx0ICogSW5pdGlhbGlzZSB0aGUgUmVzcG9uc2l2ZSBpbnN0YW5jZVxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2NvbnN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdHZhciBkdCA9IHRoaXMucy5kdDtcblx0XHR2YXIgb2xkV2luZG93V2lkdGggPSAkKHdpbmRvdykuaW5uZXJXaWR0aCgpO1xuXG5cdFx0ZHQuc2V0dGluZ3MoKVswXS5fcmVzcG9uc2l2ZSA9IHRoaXM7XG5cblx0XHQvLyBVc2UgRGF0YVRhYmxlcycgdGhyb3R0bGUgZnVuY3Rpb24gdG8gYXZvaWQgcHJvY2Vzc29yIHRocmFzaGluZ1xuXHRcdCQod2luZG93KS5vbihcblx0XHRcdCdvcmllbnRhdGlvbmNoYW5nZS5kdHInLFxuXHRcdFx0RGF0YVRhYmxlLnV0aWwudGhyb3R0bGUoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHQvLyBpT1MgaGFzIGEgYnVnIHdoZXJlYnkgcmVzaXplIGNhbiBmaXJlIHdoZW4gb25seSBzY3JvbGxpbmdcblx0XHRcdFx0Ly8gU2VlOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzg4OTg0MTJcblx0XHRcdFx0dmFyIHdpZHRoID0gJCh3aW5kb3cpLmlubmVyV2lkdGgoKTtcblxuXHRcdFx0XHRpZiAod2lkdGggIT09IG9sZFdpbmRvd1dpZHRoKSB7XG5cdFx0XHRcdFx0dGhhdC5fcmVzaXplKCk7XG5cdFx0XHRcdFx0b2xkV2luZG93V2lkdGggPSB3aWR0aDtcblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHQpO1xuXG5cdFx0Ly8gSGFuZGxlIG5ldyByb3dzIGJlaW5nIGR5bmFtaWNhbGx5IGFkZGVkIC0gbmVlZGVkIGFzIHJlc3BvbnNpdmVcblx0XHQvLyB1cGRhdGVzIGFsbCByb3dzIChzaG93biBvciBub3QpIGEgcmVzcG9uc2l2ZSBjaGFuZ2UsIHJhdGhlciB0aGFuXG5cdFx0Ly8gcGVyIGRyYXcuXG5cdFx0ZHQub24oJ3Jvdy1jcmVhdGVkLmR0cicsIGZ1bmN0aW9uIChlLCB0ciwgZGF0YSwgaWR4KSB7XG5cdFx0XHRpZiAoJC5pbkFycmF5KGZhbHNlLCB0aGF0LnMuY3VycmVudCkgIT09IC0xKSB7XG5cdFx0XHRcdCQoJz50ZCwgPnRoJywgdHIpLmVhY2goZnVuY3Rpb24gKGkpIHtcblx0XHRcdFx0XHR2YXIgaWR4ID0gZHQuY29sdW1uLmluZGV4KCd0b0RhdGEnLCBpKTtcblxuXHRcdFx0XHRcdGlmICh0aGF0LnMuY3VycmVudFtpZHhdID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0JCh0aGlzKVxuXHRcdFx0XHRcdFx0XHQuY3NzKCdkaXNwbGF5JywgJ25vbmUnKVxuXHRcdFx0XHRcdFx0XHQuYWRkQ2xhc3MoJ2R0ci1oaWRkZW4nKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gRGVzdHJveSBldmVudCBoYW5kbGVyXG5cdFx0ZHQub24oJ2Rlc3Ryb3kuZHRyJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0ZHQub2ZmKCcuZHRyJyk7XG5cdFx0XHQkKGR0LnRhYmxlKCkuYm9keSgpKS5vZmYoJy5kdHInKTtcblx0XHRcdCQod2luZG93KS5vZmYoJ3Jlc2l6ZS5kdHIgb3JpZW50YXRpb25jaGFuZ2UuZHRyJyk7XG5cdFx0XHRkdC5jZWxscygnLmR0ci1jb250cm9sJykubm9kZXMoKS50byQoKS5yZW1vdmVDbGFzcygnZHRyLWNvbnRyb2wnKTtcblx0XHRcdCQoZHQudGFibGUoKS5ub2RlKCkpLnJlbW92ZUNsYXNzKCdkdHItaW5saW5lIGNvbGxhcHNlZCcpO1xuXG5cdFx0XHQvLyBSZXN0b3JlIHRoZSBjb2x1bW5zIHRoYXQgd2UndmUgaGlkZGVuXG5cdFx0XHQkLmVhY2godGhhdC5zLmN1cnJlbnQsIGZ1bmN0aW9uIChpLCB2YWwpIHtcblx0XHRcdFx0aWYgKHZhbCA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHR0aGF0Ll9zZXRDb2x1bW5WaXMoaSwgdHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0pO1xuXG5cdFx0Ly8gUmVvcmRlciB0aGUgYnJlYWtwb2ludHMgYXJyYXkgaGVyZSBpbiBjYXNlIHRoZXkgaGF2ZSBiZWVuIGFkZGVkIG91dFxuXHRcdC8vIG9mIG9yZGVyXG5cdFx0dGhpcy5jLmJyZWFrcG9pbnRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcblx0XHRcdHJldHVybiBhLndpZHRoIDwgYi53aWR0aCA/IDEgOiBhLndpZHRoID4gYi53aWR0aCA/IC0xIDogMDtcblx0XHR9KTtcblxuXHRcdHRoaXMuX2NsYXNzTG9naWMoKTtcblxuXHRcdC8vIERldGFpbHMgaGFuZGxlclxuXHRcdHZhciBkZXRhaWxzID0gdGhpcy5jLmRldGFpbHM7XG5cblx0XHRpZiAoZGV0YWlscy50eXBlICE9PSBmYWxzZSkge1xuXHRcdFx0dGhhdC5fZGV0YWlsc0luaXQoKTtcblxuXHRcdFx0Ly8gRGF0YVRhYmxlcyB3aWxsIHRyaWdnZXIgdGhpcyBldmVudCBvbiBldmVyeSBjb2x1bW4gaXQgc2hvd3MgYW5kXG5cdFx0XHQvLyBoaWRlcyBpbmRpdmlkdWFsbHlcblx0XHRcdGR0Lm9uKCdjb2x1bW4tdmlzaWJpbGl0eS5kdHInLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdC8vIFVzZSBhIHNtYWxsIGRlYm91bmNlIHRvIGFsbG93IG11bHRpcGxlIGNvbHVtbnMgdG8gYmUgc2V0IHRvZ2V0aGVyXG5cdFx0XHRcdGlmICh0aGF0Ll90aW1lcikge1xuXHRcdFx0XHRcdGNsZWFyVGltZW91dCh0aGF0Ll90aW1lcik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGF0Ll90aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHRoYXQuX3RpbWVyID0gbnVsbDtcblxuXHRcdFx0XHRcdHRoYXQuX2NsYXNzTG9naWMoKTtcblx0XHRcdFx0XHR0aGF0Ll9yZXNpemVBdXRvKCk7XG5cdFx0XHRcdFx0dGhhdC5fcmVzaXplKHRydWUpO1xuXG5cdFx0XHRcdFx0dGhhdC5fcmVkcmF3Q2hpbGRyZW4oKTtcblx0XHRcdFx0fSwgMTAwKTtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBSZWRyYXcgdGhlIGRldGFpbHMgYm94IG9uIGVhY2ggZHJhdyB3aGljaCB3aWxsIGhhcHBlbiBpZiB0aGUgZGF0YVxuXHRcdFx0Ly8gaGFzIGNoYW5nZWQuIFRoaXMgaXMgdXNlZCB1bnRpbCBEYXRhVGFibGVzIGltcGxlbWVudHMgYSBuYXRpdmVcblx0XHRcdC8vIGB1cGRhdGVkYCBldmVudCBmb3Igcm93c1xuXHRcdFx0ZHQub24oJ2RyYXcuZHRyJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0aGF0Ll9yZWRyYXdDaGlsZHJlbigpO1xuXHRcdFx0fSk7XG5cblx0XHRcdCQoZHQudGFibGUoKS5ub2RlKCkpLmFkZENsYXNzKCdkdHItJyArIGRldGFpbHMudHlwZSk7XG5cdFx0fVxuXG5cdFx0Ly8gRFQyIGxldCdzIHVzIHRlbGwgaXQgaWYgd2UgYXJlIGhpZGluZyBjb2x1bW5zXG5cdFx0ZHQub24oJ2NvbHVtbi1jYWxjLmR0JywgZnVuY3Rpb24gKGUsIGQpIHtcblx0XHRcdHZhciBjdXJyID0gdGhhdC5zLmN1cnJlbnQ7XG5cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY3Vyci5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgaWR4ID0gZC52aXNpYmxlLmluZGV4T2YoaSk7XG5cblx0XHRcdFx0aWYgKGN1cnJbaV0gPT09IGZhbHNlICYmIGlkeCA+PSAwKSB7XG5cdFx0XHRcdFx0ZC52aXNpYmxlLnNwbGljZShpZHgsIDEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBPbiBBamF4IHJlbG9hZCB3ZSB3YW50IHRvIHJlb3BlbiBhbnkgY2hpbGQgcm93cyB3aGljaCBhcmUgZGlzcGxheWVkXG5cdFx0Ly8gYnkgcmVzcG9uc2l2ZVxuXHRcdGR0Lm9uKCdwcmVYaHIuZHRyJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHJvd0lkcyA9IFtdO1xuXHRcdFx0ZHQucm93cygpLmV2ZXJ5KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0aWYgKHRoaXMuY2hpbGQuaXNTaG93bigpKSB7XG5cdFx0XHRcdFx0cm93SWRzLnB1c2godGhpcy5pZCh0cnVlKSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRkdC5vbmUoJ2RyYXcuZHRyJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0aGF0Ll9yZXNpemVBdXRvKCk7XG5cdFx0XHRcdHRoYXQuX3Jlc2l6ZSgpO1xuXG5cdFx0XHRcdGR0LnJvd3Mocm93SWRzKS5ldmVyeShmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dGhhdC5fZGV0YWlsc0Rpc3BsYXkodGhpcywgZmFsc2UpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXG5cdFx0Ly8gRmlyc3QgcGFzcyB3aGVuIHRoZSB0YWJsZSBpcyByZWFkeVxuXHRcdGR0XG5cdFx0XHQub24oJ2RyYXcuZHRyJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0aGF0Ll9jb250cm9sQ2xhc3MoKTtcblx0XHRcdH0pXG5cdFx0XHQucmVhZHkoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR0aGF0Ll9yZXNpemVBdXRvKCk7XG5cdFx0XHRcdHRoYXQuX3Jlc2l6ZSgpO1xuXG5cdFx0XHRcdC8vIEF0dGFjaCBsaXN0ZW5lcnMgYWZ0ZXIgZmlyc3QgcGFzc1xuXHRcdFx0XHRkdC5vbignY29sdW1uLXJlb3JkZXIuZHRyJywgZnVuY3Rpb24gKGUsIHNldHRpbmdzLCBkZXRhaWxzKSB7XG5cdFx0XHRcdFx0dGhhdC5fY2xhc3NMb2dpYygpO1xuXHRcdFx0XHRcdHRoYXQuX3Jlc2l6ZUF1dG8oKTtcblx0XHRcdFx0XHR0aGF0Ll9yZXNpemUodHJ1ZSk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdC8vIENoYW5nZSBpbiBjb2x1bW4gc2l6ZXMgbWVhbnMgd2UgbmVlZCB0byBjYWxjXG5cdFx0XHRcdGR0Lm9uKCdjb2x1bW4tc2l6aW5nLmR0cicsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHR0aGF0Ll9yZXNpemVBdXRvKCk7XG5cdFx0XHRcdFx0dGhhdC5fcmVzaXplKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdH0sXG5cblx0LyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuXHQgKiBQcml2YXRlIG1ldGhvZHNcblx0ICovXG5cblx0LyoqXG5cdCAqIEluc2VydCBhIGBjb2xgIHRhZyBpbnRvIHRoZSBjb3JyZWN0IGxvY2F0aW9uIGluIGEgYGNvbGdyb3VwYC5cblx0ICpcblx0ICogQHBhcmFtIHtqUXVlcnl9IGNvbEdyb3VwIFRoZSBgY29sZ3JvdXBgIHRhZ1xuXHQgKiBAcGFyYW0ge2pRdWVyeX0gY29sRWwgVGhlIGBjb2xgIHRhZ1xuXHQgKi9cblx0X2NvbEdyb3VwQXR0YWNoOiBmdW5jdGlvbiAoY29sR3JvdXAsIGNvbEVscywgaWR4KSB7XG5cdFx0dmFyIGZvdW5kID0gbnVsbDtcblxuXHRcdC8vIE5vIG5lZWQgdG8gZG8gYW55dGhpbmcgaWYgYWxyZWFkeSBhdHRhY2hlZFxuXHRcdGlmIChjb2xFbHNbaWR4XS5nZXQoMCkucGFyZW50Tm9kZSA9PT0gY29sR3JvdXBbMF0pIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBGaW5kIHRoZSBmaXJzdCBgY29sYCBhZnRlciBvdXIgb3duIHdoaWNoIGlzIGFscmVhZHkgYXR0YWNoZWRcblx0XHRmb3IgKHZhciBpID0gaWR4KzE7IGkgPCBjb2xFbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChjb2xHcm91cFswXSA9PT0gY29sRWxzW2ldLmdldCgwKS5wYXJlbnROb2RlKSB7XG5cdFx0XHRcdGZvdW5kID0gaTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGZvdW5kICE9PSBudWxsKSB7XG5cdFx0XHQvLyBJbnNlcnQgYmVmb3JlXG5cdFx0XHRjb2xFbHNbaWR4XS5pbnNlcnRCZWZvcmUoY29sRWxzW2ZvdW5kXVswXSk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gSWYgd2Fzbid0IGZvdW5kLCBpbnNlcnQgYXQgdGhlIGVuZFxuXHRcdFx0Y29sR3JvdXAuYXBwZW5kKGNvbEVsc1tpZHhdKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCBhbmQgc3RvcmUgbm9kZXMgZnJvbSBhIGNlbGwgLSB1c2UgZm9yIG5vZGUgbW92aW5nIHJlbmRlcmVyc1xuXHQgKlxuXHQgKiBAcGFyYW0geyp9IGR0IERUIGluc3RhbmNlXG5cdCAqIEBwYXJhbSB7Kn0gcm93IFJvdyBpbmRleFxuXHQgKiBAcGFyYW0geyp9IGNvbCBDb2x1bW4gaW5kZXhcblx0ICovXG5cdF9jaGlsZE5vZGVzOiBmdW5jdGlvbiAoZHQsIHJvdywgY29sKSB7XG5cdFx0dmFyIG5hbWUgPSByb3cgKyAnLScgKyBjb2w7XG5cblx0XHRpZiAodGhpcy5zLmNoaWxkTm9kZVN0b3JlW25hbWVdKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5zLmNoaWxkTm9kZVN0b3JlW25hbWVdO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vanNwZXJmLmNvbS9jaGlsZG5vZGVzLWFycmF5LXNsaWNlLXZzLWxvb3Bcblx0XHR2YXIgbm9kZXMgPSBbXTtcblx0XHR2YXIgY2hpbGRyZW4gPSBkdC5jZWxsKHJvdywgY29sKS5ub2RlKCkuY2hpbGROb2Rlcztcblx0XHRmb3IgKHZhciBpID0gMCwgaWVuID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgaWVuOyBpKyspIHtcblx0XHRcdG5vZGVzLnB1c2goY2hpbGRyZW5baV0pO1xuXHRcdH1cblxuXHRcdHRoaXMucy5jaGlsZE5vZGVTdG9yZVtuYW1lXSA9IG5vZGVzO1xuXG5cdFx0cmV0dXJuIG5vZGVzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXN0b3JlIG5vZGVzIGZyb20gdGhlIGNhY2hlIHRvIGEgdGFibGUgY2VsbFxuXHQgKlxuXHQgKiBAcGFyYW0geyp9IGR0IERUIGluc3RhbmNlXG5cdCAqIEBwYXJhbSB7Kn0gcm93IFJvdyBpbmRleFxuXHQgKiBAcGFyYW0geyp9IGNvbCBDb2x1bW4gaW5kZXhcblx0ICovXG5cdF9jaGlsZE5vZGVzUmVzdG9yZTogZnVuY3Rpb24gKGR0LCByb3csIGNvbCkge1xuXHRcdHZhciBuYW1lID0gcm93ICsgJy0nICsgY29sO1xuXG5cdFx0aWYgKCF0aGlzLnMuY2hpbGROb2RlU3RvcmVbbmFtZV0pIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgbm9kZSA9IGR0LmNlbGwocm93LCBjb2wpLm5vZGUoKTtcblx0XHR2YXIgc3RvcmUgPSB0aGlzLnMuY2hpbGROb2RlU3RvcmVbbmFtZV07XG5cdFx0aWYgKHN0b3JlLmxlbmd0aCA+IDApIHtcblx0XHRcdHZhciBwYXJlbnQgPSBzdG9yZVswXS5wYXJlbnROb2RlO1xuXHRcdFx0dmFyIHBhcmVudENoaWxkcmVuID0gcGFyZW50LmNoaWxkTm9kZXM7XG5cdFx0XHR2YXIgYSA9IFtdO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgaWVuID0gcGFyZW50Q2hpbGRyZW4ubGVuZ3RoOyBpIDwgaWVuOyBpKyspIHtcblx0XHRcdFx0YS5wdXNoKHBhcmVudENoaWxkcmVuW2ldKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yICh2YXIgaiA9IDAsIGplbiA9IGEubGVuZ3RoOyBqIDwgamVuOyBqKyspIHtcblx0XHRcdFx0bm9kZS5hcHBlbmRDaGlsZChhW2pdKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLnMuY2hpbGROb2RlU3RvcmVbbmFtZV0gPSB1bmRlZmluZWQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIENhbGN1bGF0ZSB0aGUgdmlzaWJpbGl0eSBmb3IgdGhlIGNvbHVtbnMgaW4gYSB0YWJsZSBmb3IgYSBnaXZlblxuXHQgKiBicmVha3BvaW50LiBUaGUgcmVzdWx0IGlzIHByZS1kZXRlcm1pbmVkIGJhc2VkIG9uIHRoZSBjbGFzcyBsb2dpYyBpZlxuXHQgKiBjbGFzcyBuYW1lcyBhcmUgdXNlZCB0byBjb250cm9sIGFsbCBjb2x1bW5zLCBidXQgdGhlIHdpZHRoIG9mIHRoZSB0YWJsZVxuXHQgKiBpcyBhbHNvIHVzZWQgaWYgdGhlcmUgYXJlIGNvbHVtbnMgd2hpY2ggYXJlIHRvIGJlIGF1dG9tYXRpY2FsbHkgc2hvd25cblx0ICogYW5kIGhpZGRlbi5cblx0ICpcblx0ICogQHBhcmFtICB7c3RyaW5nfSBicmVha3BvaW50IEJyZWFrcG9pbnQgbmFtZSB0byB1c2UgZm9yIHRoZSBjYWxjdWxhdGlvblxuXHQgKiBAcmV0dXJuIHthcnJheX0gQXJyYXkgb2YgYm9vbGVhbiB2YWx1ZXMgaW5pdGlhdGluZyB0aGUgdmlzaWJpbGl0eSBvZiBlYWNoXG5cdCAqICAgY29sdW1uLlxuXHQgKiAgQHByaXZhdGVcblx0ICovXG5cdF9jb2x1bW5zVmlzaWJsaXR5OiBmdW5jdGlvbiAoYnJlYWtwb2ludCkge1xuXHRcdHZhciBkdCA9IHRoaXMucy5kdDtcblx0XHR2YXIgY29sdW1ucyA9IHRoaXMucy5jb2x1bW5zO1xuXHRcdHZhciBpLCBpZW47XG5cblx0XHQvLyBDcmVhdGUgYW4gYXJyYXkgdGhhdCBkZWZpbmVzIHRoZSBjb2x1bW4gb3JkZXJpbmcgYmFzZWQgZmlyc3Qgb24gdGhlXG5cdFx0Ly8gY29sdW1uJ3MgcHJpb3JpdHksIGFuZCBzZWNvbmRseSB0aGUgY29sdW1uIGluZGV4LiBUaGlzIGFsbG93cyB0aGVcblx0XHQvLyBjb2x1bW5zIHRvIGJlIHJlbW92ZWQgZnJvbSB0aGUgcmlnaHQgaWYgdGhlIHByaW9yaXR5IG1hdGNoZXNcblx0XHR2YXIgb3JkZXIgPSBjb2x1bW5zXG5cdFx0XHQubWFwKGZ1bmN0aW9uIChjb2wsIGlkeCkge1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdGNvbHVtbklkeDogaWR4LFxuXHRcdFx0XHRcdHByaW9yaXR5OiBjb2wucHJpb3JpdHlcblx0XHRcdFx0fTtcblx0XHRcdH0pXG5cdFx0XHQuc29ydChmdW5jdGlvbiAoYSwgYikge1xuXHRcdFx0XHRpZiAoYS5wcmlvcml0eSAhPT0gYi5wcmlvcml0eSkge1xuXHRcdFx0XHRcdHJldHVybiBhLnByaW9yaXR5IC0gYi5wcmlvcml0eTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gYS5jb2x1bW5JZHggLSBiLmNvbHVtbklkeDtcblx0XHRcdH0pO1xuXG5cdFx0Ly8gQ2xhc3MgbG9naWMgLSBkZXRlcm1pbmUgd2hpY2ggY29sdW1ucyBhcmUgaW4gdGhpcyBicmVha3BvaW50IGJhc2VkXG5cdFx0Ly8gb24gdGhlIGNsYXNzZXMuIElmIG5vIGNsYXNzIGNvbnRyb2wgKGkuZS4gYGF1dG9gKSB0aGVuIGAtYCBpcyB1c2VkXG5cdFx0Ly8gdG8gaW5kaWNhdGUgdGhpcyB0byB0aGUgcmVzdCBvZiB0aGUgZnVuY3Rpb25cblx0XHR2YXIgZGlzcGxheSA9ICQubWFwKGNvbHVtbnMsIGZ1bmN0aW9uIChjb2wsIGkpIHtcblx0XHRcdGlmIChkdC5jb2x1bW4oaSkudmlzaWJsZSgpID09PSBmYWxzZSkge1xuXHRcdFx0XHRyZXR1cm4gJ25vdC12aXNpYmxlJztcblx0XHRcdH1cblx0XHRcdHJldHVybiBjb2wuYXV0byAmJiBjb2wubWluV2lkdGggPT09IG51bGxcblx0XHRcdFx0PyBmYWxzZVxuXHRcdFx0XHQ6IGNvbC5hdXRvID09PSB0cnVlXG5cdFx0XHRcdD8gJy0nXG5cdFx0XHRcdDogJC5pbkFycmF5KGJyZWFrcG9pbnQsIGNvbC5pbmNsdWRlSW4pICE9PSAtMTtcblx0XHR9KTtcblxuXHRcdC8vIEF1dG8gY29sdW1uIGNvbnRyb2wgLSBmaXJzdCBwYXNzOiBob3cgbXVjaCB3aWR0aCBpcyB0YWtlbiBieSB0aGVcblx0XHQvLyBvbmVzIHRoYXQgbXVzdCBiZSBpbmNsdWRlZCBmcm9tIHRoZSBub24tYXV0byBjb2x1bW5zXG5cdFx0dmFyIHJlcXVpcmVkV2lkdGggPSAwO1xuXHRcdGZvciAoaSA9IDAsIGllbiA9IGRpc3BsYXkubGVuZ3RoOyBpIDwgaWVuOyBpKyspIHtcblx0XHRcdGlmIChkaXNwbGF5W2ldID09PSB0cnVlKSB7XG5cdFx0XHRcdHJlcXVpcmVkV2lkdGggKz0gY29sdW1uc1tpXS5taW5XaWR0aDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTZWNvbmQgcGFzcywgdXNlIHVwIGFueSByZW1haW5pbmcgd2lkdGggZm9yIG90aGVyIGNvbHVtbnMuIEZvclxuXHRcdC8vIHNjcm9sbGluZyB0YWJsZXMgd2UgbmVlZCB0byBzdWJ0cmFjdCB0aGUgd2lkdGggb2YgdGhlIHNjcm9sbGJhci4gSXRcblx0XHQvLyBtYXkgbm90IGJlIHJlcXVpcmVzIHdoaWNoIG1ha2VzIHRoaXMgc3ViLW9wdGltYWwsIGJ1dCBpdCB3b3VsZFxuXHRcdC8vIHJlcXVpcmUgYW5vdGhlciBmdWxsIHJlZHJhdyB0byBtYWtlIGNvbXBsZXRlIHVzZSBvZiB0aG9zZSBleHRyYSBmZXdcblx0XHQvLyBwaXhlbHNcblx0XHR2YXIgc2Nyb2xsaW5nID0gZHQuc2V0dGluZ3MoKVswXS5vU2Nyb2xsO1xuXHRcdHZhciBiYXIgPSBzY3JvbGxpbmcuc1kgfHwgc2Nyb2xsaW5nLnNYID8gc2Nyb2xsaW5nLmlCYXJXaWR0aCA6IDA7XG5cdFx0dmFyIHdpZHRoQXZhaWxhYmxlID0gZHQudGFibGUoKS5jb250YWluZXIoKS5vZmZzZXRXaWR0aCAtIGJhcjtcblx0XHR2YXIgdXNlZFdpZHRoID0gd2lkdGhBdmFpbGFibGUgLSByZXF1aXJlZFdpZHRoO1xuXG5cdFx0Ly8gQ29udHJvbCBjb2x1bW4gbmVlZHMgdG8gYWx3YXlzIGJlIGluY2x1ZGVkLiBUaGlzIG1ha2VzIGl0IHN1Yi1cblx0XHQvLyBvcHRpbWFsIGluIHRlcm1zIG9mIHVzaW5nIHRoZSBhdmFpbGFibGUgd2l0aCwgYnV0IHRvIHN0b3AgbGF5b3V0XG5cdFx0Ly8gdGhyYXNoaW5nIG9yIG92ZXJmbG93LiBBbHNvIHdlIG5lZWQgdG8gYWNjb3VudCBmb3IgdGhlIGNvbnRyb2wgY29sdW1uXG5cdFx0Ly8gd2lkdGggZmlyc3Qgc28gd2Uga25vdyBob3cgbXVjaCB3aWR0aCBpcyBhdmFpbGFibGUgZm9yIHRoZSBvdGhlclxuXHRcdC8vIGNvbHVtbnMsIHNpbmNlIHRoZSBjb250cm9sIGNvbHVtbiBtaWdodCBub3QgYmUgdGhlIGZpcnN0IG9uZSBzaG93blxuXHRcdGZvciAoaSA9IDAsIGllbiA9IGRpc3BsYXkubGVuZ3RoOyBpIDwgaWVuOyBpKyspIHtcblx0XHRcdGlmIChjb2x1bW5zW2ldLmNvbnRyb2wpIHtcblx0XHRcdFx0dXNlZFdpZHRoIC09IGNvbHVtbnNbaV0ubWluV2lkdGg7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQWxsb3cgY29sdW1ucyB0byBiZSBzaG93biAoY291bnRpbmcgYnkgcHJpb3JpdHkgYW5kIHRoZW4gcmlnaHQgdG9cblx0XHQvLyBsZWZ0KSB1bnRpbCB3ZSBydW4gb3V0IG9mIHJvb21cblx0XHR2YXIgZW1wdHkgPSBmYWxzZTtcblx0XHRmb3IgKGkgPSAwLCBpZW4gPSBvcmRlci5sZW5ndGg7IGkgPCBpZW47IGkrKykge1xuXHRcdFx0dmFyIGNvbElkeCA9IG9yZGVyW2ldLmNvbHVtbklkeDtcblxuXHRcdFx0aWYgKFxuXHRcdFx0XHRkaXNwbGF5W2NvbElkeF0gPT09ICctJyAmJlxuXHRcdFx0XHQhY29sdW1uc1tjb2xJZHhdLmNvbnRyb2wgJiZcblx0XHRcdFx0Y29sdW1uc1tjb2xJZHhdLm1pbldpZHRoXG5cdFx0XHQpIHtcblx0XHRcdFx0Ly8gT25jZSB3ZSd2ZSBmb3VuZCBhIGNvbHVtbiB0aGF0IHdvbid0IGZpdCB3ZSBkb24ndCBsZXQgYW55XG5cdFx0XHRcdC8vIG90aGVycyBkaXNwbGF5IGVpdGhlciwgb3IgY29sdW1ucyBtaWdodCBkaXNhcHBlYXIgaW4gdGhlXG5cdFx0XHRcdC8vIG1pZGRsZSBvZiB0aGUgdGFibGVcblx0XHRcdFx0aWYgKGVtcHR5IHx8IHVzZWRXaWR0aCAtIGNvbHVtbnNbY29sSWR4XS5taW5XaWR0aCA8IDApIHtcblx0XHRcdFx0XHRlbXB0eSA9IHRydWU7XG5cdFx0XHRcdFx0ZGlzcGxheVtjb2xJZHhdID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0ZGlzcGxheVtjb2xJZHhdID0gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHVzZWRXaWR0aCAtPSBjb2x1bW5zW2NvbElkeF0ubWluV2lkdGg7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGlmIHRoZSAnY29udHJvbCcgY29sdW1uIHNob3VsZCBiZSBzaG93biAoaWYgdGhlcmUgaXMgb25lKS5cblx0XHQvLyBUaGlzIGlzIHRoZSBjYXNlIHdoZW4gdGhlcmUgaXMgYSBoaWRkZW4gY29sdW1uICh0aGF0IGlzIG5vdCB0aGVcblx0XHQvLyBjb250cm9sIGNvbHVtbikuIFRoZSB0d28gbG9vcHMgbG9vayBpbmVmZmljaWVudCBoZXJlLCBidXQgdGhleSBhcmVcblx0XHQvLyB0cml2aWFsIGFuZCB3aWxsIGZseSB0aHJvdWdoLiBXZSBuZWVkIHRvIGtub3cgdGhlIG91dGNvbWUgZnJvbSB0aGVcblx0XHQvLyBmaXJzdCAsIGJlZm9yZSB0aGUgYWN0aW9uIGluIHRoZSBzZWNvbmQgY2FuIGJlIHRha2VuXG5cdFx0dmFyIHNob3dDb250cm9sID0gZmFsc2U7XG5cblx0XHRmb3IgKGkgPSAwLCBpZW4gPSBjb2x1bW5zLmxlbmd0aDsgaSA8IGllbjsgaSsrKSB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdCFjb2x1bW5zW2ldLmNvbnRyb2wgJiZcblx0XHRcdFx0IWNvbHVtbnNbaV0ubmV2ZXIgJiZcblx0XHRcdFx0ZGlzcGxheVtpXSA9PT0gZmFsc2Vcblx0XHRcdCkge1xuXHRcdFx0XHRzaG93Q29udHJvbCA9IHRydWU7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGllbiA9IGNvbHVtbnMubGVuZ3RoOyBpIDwgaWVuOyBpKyspIHtcblx0XHRcdGlmIChjb2x1bW5zW2ldLmNvbnRyb2wpIHtcblx0XHRcdFx0ZGlzcGxheVtpXSA9IHNob3dDb250cm9sO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXBsYWNlIG5vdCB2aXNpYmxlIHN0cmluZyB3aXRoIGZhbHNlIGZyb20gdGhlIGNvbnRyb2wgY29sdW1uIGRldGVjdGlvbiBhYm92ZVxuXHRcdFx0aWYgKGRpc3BsYXlbaV0gPT09ICdub3QtdmlzaWJsZScpIHtcblx0XHRcdFx0ZGlzcGxheVtpXSA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZpbmFsbHkgd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhhdCB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgY29sdW1uIHRoYXRcblx0XHQvLyBpcyB2aXNpYmxlXG5cdFx0aWYgKCQuaW5BcnJheSh0cnVlLCBkaXNwbGF5KSA9PT0gLTEpIHtcblx0XHRcdGRpc3BsYXlbMF0gPSB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiBkaXNwbGF5O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDcmVhdGUgdGhlIGludGVybmFsIGBjb2x1bW5zYCBhcnJheSB3aXRoIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjb2x1bW5zXG5cdCAqIGZvciB0aGUgdGFibGUuIFRoaXMgaW5jbHVkZXMgZGV0ZXJtaW5pbmcgd2hpY2ggYnJlYWtwb2ludHMgdGhlIGNvbHVtblxuXHQgKiB3aWxsIGFwcGVhciBpbiwgYmFzZWQgdXBvbiBjbGFzcyBuYW1lcyBpbiB0aGUgY29sdW1uLCB3aGljaCBtYWtlcyB1cCB0aGVcblx0ICogdmFzdCBtYWpvcml0eSBvZiB0aGlzIG1ldGhvZC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9jbGFzc0xvZ2ljOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdHZhciBicmVha3BvaW50cyA9IHRoaXMuYy5icmVha3BvaW50cztcblx0XHR2YXIgZHQgPSB0aGlzLnMuZHQ7XG5cdFx0dmFyIGNvbHVtbnMgPSBkdFxuXHRcdFx0LmNvbHVtbnMoKVxuXHRcdFx0LmVxKDApXG5cdFx0XHQubWFwKGZ1bmN0aW9uIChpKSB7XG5cdFx0XHRcdHZhciBjb2x1bW4gPSB0aGlzLmNvbHVtbihpKTtcblx0XHRcdFx0dmFyIGNsYXNzTmFtZSA9IGNvbHVtbi5oZWFkZXIoKS5jbGFzc05hbWU7XG5cdFx0XHRcdHZhciBwcmlvcml0eSA9IGNvbHVtbi5pbml0KCkucmVzcG9uc2l2ZVByaW9yaXR5O1xuXHRcdFx0XHR2YXIgZGF0YVByaW9yaXR5ID0gY29sdW1uXG5cdFx0XHRcdFx0LmhlYWRlcigpXG5cdFx0XHRcdFx0LmdldEF0dHJpYnV0ZSgnZGF0YS1wcmlvcml0eScpO1xuXG5cdFx0XHRcdGlmIChwcmlvcml0eSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0cHJpb3JpdHkgPVxuXHRcdFx0XHRcdFx0ZGF0YVByaW9yaXR5ID09PSB1bmRlZmluZWQgfHwgZGF0YVByaW9yaXR5ID09PSBudWxsXG5cdFx0XHRcdFx0XHRcdD8gMTAwMDBcblx0XHRcdFx0XHRcdFx0OiBkYXRhUHJpb3JpdHkgKiAxO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRjbGFzc05hbWU6IGNsYXNzTmFtZSxcblx0XHRcdFx0XHRpbmNsdWRlSW46IFtdLFxuXHRcdFx0XHRcdGF1dG86IGZhbHNlLFxuXHRcdFx0XHRcdGNvbnRyb2w6IGZhbHNlLFxuXHRcdFx0XHRcdG5ldmVyOiBjbGFzc05hbWUubWF0Y2goL1xcYihkdHJcXC0pP25ldmVyXFxiLykgPyB0cnVlIDogZmFsc2UsXG5cdFx0XHRcdFx0cHJpb3JpdHk6IHByaW9yaXR5XG5cdFx0XHRcdH07XG5cdFx0XHR9KTtcblxuXHRcdC8vIFNpbXBseSBhZGQgYSBicmVha3BvaW50IHRvIGBpbmNsdWRlSW5gIGFycmF5LCBlbnN1cmluZyB0aGF0IHRoZXJlIGFyZVxuXHRcdC8vIG5vIGR1cGxpY2F0ZXNcblx0XHR2YXIgYWRkID0gZnVuY3Rpb24gKGNvbElkeCwgbmFtZSkge1xuXHRcdFx0dmFyIGluY2x1ZGVJbiA9IGNvbHVtbnNbY29sSWR4XS5pbmNsdWRlSW47XG5cblx0XHRcdGlmICgkLmluQXJyYXkobmFtZSwgaW5jbHVkZUluKSA9PT0gLTEpIHtcblx0XHRcdFx0aW5jbHVkZUluLnB1c2gobmFtZSk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHZhciBjb2x1bW4gPSBmdW5jdGlvbiAoY29sSWR4LCBuYW1lLCBvcGVyYXRvciwgbWF0Y2hlZCkge1xuXHRcdFx0dmFyIHNpemUsIGksIGllbjtcblxuXHRcdFx0aWYgKCFvcGVyYXRvcikge1xuXHRcdFx0XHRjb2x1bW5zW2NvbElkeF0uaW5jbHVkZUluLnB1c2gobmFtZSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChvcGVyYXRvciA9PT0gJ21heC0nKSB7XG5cdFx0XHRcdC8vIEFkZCB0aGlzIGJyZWFrcG9pbnQgYW5kIGFsbCBzbWFsbGVyXG5cdFx0XHRcdHNpemUgPSB0aGF0Ll9maW5kKG5hbWUpLndpZHRoO1xuXG5cdFx0XHRcdGZvciAoaSA9IDAsIGllbiA9IGJyZWFrcG9pbnRzLmxlbmd0aDsgaSA8IGllbjsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKGJyZWFrcG9pbnRzW2ldLndpZHRoIDw9IHNpemUpIHtcblx0XHRcdFx0XHRcdGFkZChjb2xJZHgsIGJyZWFrcG9pbnRzW2ldLm5hbWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAob3BlcmF0b3IgPT09ICdtaW4tJykge1xuXHRcdFx0XHQvLyBBZGQgdGhpcyBicmVha3BvaW50IGFuZCBhbGwgbGFyZ2VyXG5cdFx0XHRcdHNpemUgPSB0aGF0Ll9maW5kKG5hbWUpLndpZHRoO1xuXG5cdFx0XHRcdGZvciAoaSA9IDAsIGllbiA9IGJyZWFrcG9pbnRzLmxlbmd0aDsgaSA8IGllbjsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKGJyZWFrcG9pbnRzW2ldLndpZHRoID49IHNpemUpIHtcblx0XHRcdFx0XHRcdGFkZChjb2xJZHgsIGJyZWFrcG9pbnRzW2ldLm5hbWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAob3BlcmF0b3IgPT09ICdub3QtJykge1xuXHRcdFx0XHQvLyBBZGQgYWxsIGJ1dCB0aGlzIGJyZWFrcG9pbnRcblx0XHRcdFx0Zm9yIChpID0gMCwgaWVuID0gYnJlYWtwb2ludHMubGVuZ3RoOyBpIDwgaWVuOyBpKyspIHtcblx0XHRcdFx0XHRpZiAoYnJlYWtwb2ludHNbaV0ubmFtZS5pbmRleE9mKG1hdGNoZWQpID09PSAtMSkge1xuXHRcdFx0XHRcdFx0YWRkKGNvbElkeCwgYnJlYWtwb2ludHNbaV0ubmFtZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8vIExvb3Agb3ZlciBlYWNoIGNvbHVtbiBhbmQgZGV0ZXJtaW5lIGlmIGl0IGhhcyBhIHJlc3BvbnNpdmUgY29udHJvbFxuXHRcdC8vIGNsYXNzXG5cdFx0Y29sdW1ucy5lYWNoKGZ1bmN0aW9uIChjb2wsIGkpIHtcblx0XHRcdHZhciBjbGFzc05hbWVzID0gY29sLmNsYXNzTmFtZS5zcGxpdCgnICcpO1xuXHRcdFx0dmFyIGhhc0NsYXNzID0gZmFsc2U7XG5cblx0XHRcdC8vIFNwbGl0IHRoZSBjbGFzcyBuYW1lIHVwIHNvIG11bHRpcGxlIHJ1bGVzIGNhbiBiZSBhcHBsaWVkIGlmIG5lZWRlZFxuXHRcdFx0Zm9yICh2YXIgayA9IDAsIGtlbiA9IGNsYXNzTmFtZXMubGVuZ3RoOyBrIDwga2VuOyBrKyspIHtcblx0XHRcdFx0dmFyIGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNba10udHJpbSgpO1xuXG5cdFx0XHRcdGlmIChjbGFzc05hbWUgPT09ICdhbGwnIHx8IGNsYXNzTmFtZSA9PT0gJ2R0ci1hbGwnKSB7XG5cdFx0XHRcdFx0Ly8gSW5jbHVkZSBpbiBhbGxcblx0XHRcdFx0XHRoYXNDbGFzcyA9IHRydWU7XG5cdFx0XHRcdFx0Y29sLmluY2x1ZGVJbiA9ICQubWFwKGJyZWFrcG9pbnRzLCBmdW5jdGlvbiAoYSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGEubmFtZTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoXG5cdFx0XHRcdFx0Y2xhc3NOYW1lID09PSAnbm9uZScgfHxcblx0XHRcdFx0XHRjbGFzc05hbWUgPT09ICdkdHItbm9uZScgfHxcblx0XHRcdFx0XHRjb2wubmV2ZXJcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0Ly8gSW5jbHVkZSBpbiBub25lIChkZWZhdWx0KSBhbmQgbm8gYXV0b1xuXHRcdFx0XHRcdGhhc0NsYXNzID0gdHJ1ZTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoXG5cdFx0XHRcdFx0Y2xhc3NOYW1lID09PSAnY29udHJvbCcgfHxcblx0XHRcdFx0XHRjbGFzc05hbWUgPT09ICdkdHItY29udHJvbCdcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0Ly8gU3BlY2lhbCBjb2x1bW4gdGhhdCBpcyBvbmx5IHZpc2libGUsIHdoZW4gb25lIG9mIHRoZSBvdGhlclxuXHRcdFx0XHRcdC8vIGNvbHVtbnMgaXMgaGlkZGVuLiBUaGlzIGlzIHVzZWQgZm9yIHRoZSBkZXRhaWxzIGNvbnRyb2xcblx0XHRcdFx0XHRoYXNDbGFzcyA9IHRydWU7XG5cdFx0XHRcdFx0Y29sLmNvbnRyb2wgPSB0cnVlO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdCQuZWFjaChicmVha3BvaW50cywgZnVuY3Rpb24gKGosIGJyZWFrcG9pbnQpIHtcblx0XHRcdFx0XHQvLyBEb2VzIHRoaXMgY29sdW1uIGhhdmUgYSBjbGFzcyB0aGF0IG1hdGNoZXMgdGhpcyBicmVha3BvaW50P1xuXHRcdFx0XHRcdHZhciBicm9rZW5Qb2ludCA9IGJyZWFrcG9pbnQubmFtZS5zcGxpdCgnLScpO1xuXHRcdFx0XHRcdHZhciByZSA9IG5ldyBSZWdFeHAoXG5cdFx0XHRcdFx0XHQnKG1pblxcXFwtfG1heFxcXFwtfG5vdFxcXFwtKT8oJyArXG5cdFx0XHRcdFx0XHRcdGJyb2tlblBvaW50WzBdICtcblx0XHRcdFx0XHRcdFx0JykoXFxcXC1bX2EtekEtWjAtOV0pPydcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdHZhciBtYXRjaCA9IGNsYXNzTmFtZS5tYXRjaChyZSk7XG5cblx0XHRcdFx0XHRpZiAobWF0Y2gpIHtcblx0XHRcdFx0XHRcdGhhc0NsYXNzID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0XHRtYXRjaFsyXSA9PT0gYnJva2VuUG9pbnRbMF0gJiZcblx0XHRcdFx0XHRcdFx0bWF0Y2hbM10gPT09ICctJyArIGJyb2tlblBvaW50WzFdXG5cdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0Ly8gQ2xhc3MgbmFtZSBtYXRjaGVzIGJyZWFrcG9pbnQgbmFtZSBmdWxseVxuXHRcdFx0XHRcdFx0XHRjb2x1bW4oXG5cdFx0XHRcdFx0XHRcdFx0aSxcblx0XHRcdFx0XHRcdFx0XHRicmVha3BvaW50Lm5hbWUsXG5cdFx0XHRcdFx0XHRcdFx0bWF0Y2hbMV0sXG5cdFx0XHRcdFx0XHRcdFx0bWF0Y2hbMl0gKyBtYXRjaFszXVxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAobWF0Y2hbMl0gPT09IGJyb2tlblBvaW50WzBdICYmICFtYXRjaFszXSkge1xuXHRcdFx0XHRcdFx0XHQvLyBDbGFzcyBuYW1lIG1hdGNoZWQgcHJpbWFyeSBicmVha3BvaW50IG5hbWUgd2l0aCBubyBxdWFsaWZpZXJcblx0XHRcdFx0XHRcdFx0Y29sdW1uKGksIGJyZWFrcG9pbnQubmFtZSwgbWF0Y2hbMV0sIG1hdGNoWzJdKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGVyZSB3YXMgbm8gY29udHJvbCBjbGFzcywgdGhlbiBhdXRvbWF0aWMgc2l6aW5nIGlzIHVzZWRcblx0XHRcdGlmICghaGFzQ2xhc3MpIHtcblx0XHRcdFx0Y29sLmF1dG8gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dGhpcy5zLmNvbHVtbnMgPSBjb2x1bW5zO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBVcGRhdGUgdGhlIGNlbGxzIHRvIHNob3cgdGhlIGNvcnJlY3QgY29udHJvbCBjbGFzcyAvIGJ1dHRvblxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2NvbnRyb2xDbGFzczogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLmMuZGV0YWlscy50eXBlID09PSAnaW5saW5lJykge1xuXHRcdFx0dmFyIGR0ID0gdGhpcy5zLmR0O1xuXHRcdFx0dmFyIGNvbHVtbnNWaXMgPSB0aGlzLnMuY3VycmVudDtcblx0XHRcdHZhciBmaXJzdFZpc2libGUgPSAkLmluQXJyYXkodHJ1ZSwgY29sdW1uc1Zpcyk7XG5cblx0XHRcdC8vIFJlbW92ZSBmcm9tIGFueSBjZWxscyB3aGljaCBzaG91bGRuJ3QgaGF2ZSBpdFxuXHRcdFx0ZHQuY2VsbHMoXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdGZ1bmN0aW9uIChpZHgpIHtcblx0XHRcdFx0XHRyZXR1cm4gaWR4ICE9PSBmaXJzdFZpc2libGU7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHsgcGFnZTogJ2N1cnJlbnQnIH1cblx0XHRcdClcblx0XHRcdFx0Lm5vZGVzKClcblx0XHRcdFx0LnRvJCgpXG5cdFx0XHRcdC5maWx0ZXIoJy5kdHItY29udHJvbCcpXG5cdFx0XHRcdC5yZW1vdmVDbGFzcygnZHRyLWNvbnRyb2wnKTtcblxuXHRcdFx0aWYgKGZpcnN0VmlzaWJsZSA+PSAwKSB7XG5cdFx0XHRcdGR0LmNlbGxzKG51bGwsIGZpcnN0VmlzaWJsZSwgeyBwYWdlOiAnY3VycmVudCcgfSlcblx0XHRcdFx0XHQubm9kZXMoKVxuXHRcdFx0XHRcdC50byQoKVxuXHRcdFx0XHRcdC5hZGRDbGFzcygnZHRyLWNvbnRyb2wnKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl90YWJJbmRleGVzKCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNob3cgdGhlIGRldGFpbHMgZm9yIHRoZSBjaGlsZCByb3dcblx0ICpcblx0ICogQHBhcmFtICB7RGF0YVRhYmxlcy5BcGl9IHJvdyAgICBBUEkgaW5zdGFuY2UgZm9yIHRoZSByb3dcblx0ICogQHBhcmFtICB7Ym9vbGVhbn0gICAgICAgIHVwZGF0ZSBVcGRhdGUgZmxhZ1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2RldGFpbHNEaXNwbGF5OiBmdW5jdGlvbiAocm93LCB1cGRhdGUpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0dmFyIGR0ID0gdGhpcy5zLmR0O1xuXHRcdHZhciBkZXRhaWxzID0gdGhpcy5jLmRldGFpbHM7XG5cdFx0dmFyIGV2ZW50ID0gZnVuY3Rpb24gKHJlcykge1xuXHRcdFx0JChyb3cubm9kZSgpKS50b2dnbGVDbGFzcygnZHRyLWV4cGFuZGVkJywgcmVzICE9PSBmYWxzZSk7XG5cdFx0XHQkKGR0LnRhYmxlKCkubm9kZSgpKS50cmlnZ2VySGFuZGxlcigncmVzcG9uc2l2ZS1kaXNwbGF5LmR0JywgW1xuXHRcdFx0XHRkdCxcblx0XHRcdFx0cm93LFxuXHRcdFx0XHRyZXMsXG5cdFx0XHRcdHVwZGF0ZVxuXHRcdFx0XSk7XG5cdFx0fTtcblxuXHRcdGlmIChkZXRhaWxzICYmIGRldGFpbHMudHlwZSAhPT0gZmFsc2UpIHtcblx0XHRcdHZhciByZW5kZXJlciA9XG5cdFx0XHRcdHR5cGVvZiBkZXRhaWxzLnJlbmRlcmVyID09PSAnc3RyaW5nJ1xuXHRcdFx0XHRcdD8gUmVzcG9uc2l2ZS5yZW5kZXJlcltkZXRhaWxzLnJlbmRlcmVyXSgpXG5cdFx0XHRcdFx0OiBkZXRhaWxzLnJlbmRlcmVyO1xuXG5cdFx0XHR2YXIgcmVzID0gZGV0YWlscy5kaXNwbGF5KFxuXHRcdFx0XHRyb3csXG5cdFx0XHRcdHVwZGF0ZSxcblx0XHRcdFx0ZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHJldHVybiByZW5kZXJlci5jYWxsKFxuXHRcdFx0XHRcdFx0dGhhdCxcblx0XHRcdFx0XHRcdGR0LFxuXHRcdFx0XHRcdFx0cm93WzBdWzBdLFxuXHRcdFx0XHRcdFx0dGhhdC5fZGV0YWlsc09iaihyb3dbMF0pXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fSxcblx0XHRcdFx0ZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdGV2ZW50KGZhbHNlKTtcblx0XHRcdFx0fVxuXHRcdFx0KTtcblxuXHRcdFx0aWYgKHR5cGVvZiByZXMgPT09ICdib29sZWFuJykge1xuXHRcdFx0XHRldmVudChyZXMpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogSW5pdGlhbGlzYXRpb24gZm9yIHRoZSBkZXRhaWxzIGhhbmRsZXJcblx0ICpcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9kZXRhaWxzSW5pdDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHR2YXIgZHQgPSB0aGlzLnMuZHQ7XG5cdFx0dmFyIGRldGFpbHMgPSB0aGlzLmMuZGV0YWlscztcblxuXHRcdC8vIFRoZSBpbmxpbmUgdHlwZSBhbHdheXMgdXNlcyB0aGUgZmlyc3QgY2hpbGQgYXMgdGhlIHRhcmdldFxuXHRcdGlmIChkZXRhaWxzLnR5cGUgPT09ICdpbmxpbmUnKSB7XG5cdFx0XHRkZXRhaWxzLnRhcmdldCA9ICd0ZC5kdHItY29udHJvbCwgdGguZHRyLWNvbnRyb2wnO1xuXHRcdH1cblxuXHRcdCQoZHQudGFibGUoKS5ib2R5KCkpLm9uKCdrZXl1cC5kdHInLCAndGQsIHRoJywgZnVuY3Rpb24gKGUpIHtcblx0XHRcdGlmIChlLmtleUNvZGUgPT09IDEzICYmICQodGhpcykuZGF0YSgnZHRyLWtleWJvYXJkJykpIHtcblx0XHRcdFx0JCh0aGlzKS5jbGljaygpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gdHlwZS50YXJnZXQgY2FuIGJlIGEgc3RyaW5nIGpRdWVyeSBzZWxlY3RvciBvciBhIGNvbHVtbiBpbmRleFxuXHRcdHZhciB0YXJnZXQgPSBkZXRhaWxzLnRhcmdldDtcblx0XHR2YXIgc2VsZWN0b3IgPSB0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJyA/IHRhcmdldCA6ICd0ZCwgdGgnO1xuXG5cdFx0aWYgKHRhcmdldCAhPT0gdW5kZWZpbmVkIHx8IHRhcmdldCAhPT0gbnVsbCkge1xuXHRcdFx0Ly8gQ2xpY2sgaGFuZGxlciB0byBzaG93IC8gaGlkZSB0aGUgZGV0YWlscyByb3dzIHdoZW4gdGhleSBhcmUgYXZhaWxhYmxlXG5cdFx0XHQkKGR0LnRhYmxlKCkuYm9keSgpKS5vbihcblx0XHRcdFx0J2NsaWNrLmR0ciBtb3VzZWRvd24uZHRyIG1vdXNldXAuZHRyJyxcblx0XHRcdFx0c2VsZWN0b3IsXG5cdFx0XHRcdGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0Ly8gSWYgdGhlIHRhYmxlIGlzIG5vdCBjb2xsYXBzZWQgKGkuZS4gdGhlcmUgaXMgbm8gaGlkZGVuIGNvbHVtbnMpXG5cdFx0XHRcdFx0Ly8gdGhlbiB0YWtlIG5vIGFjdGlvblxuXHRcdFx0XHRcdGlmICghJChkdC50YWJsZSgpLm5vZGUoKSkuaGFzQ2xhc3MoJ2NvbGxhcHNlZCcpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gQ2hlY2sgdGhhdCB0aGUgcm93IGlzIGFjdHVhbGx5IGEgRGF0YVRhYmxlJ3MgY29udHJvbGxlZCBub2RlXG5cdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0JC5pbkFycmF5KFxuXHRcdFx0XHRcdFx0XHQkKHRoaXMpLmNsb3Nlc3QoJ3RyJykuZ2V0KDApLFxuXHRcdFx0XHRcdFx0XHRkdC5yb3dzKCkubm9kZXMoKS50b0FycmF5KClcblx0XHRcdFx0XHRcdCkgPT09IC0xXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRm9yIGNvbHVtbiBpbmRleCwgd2UgZGV0ZXJtaW5lIGlmIHdlIHNob3VsZCBhY3Qgb3Igbm90IGluIHRoZVxuXHRcdFx0XHRcdC8vIGhhbmRsZXIgLSBvdGhlcndpc2UgaXQgaXMgYWxyZWFkeSBva2F5XG5cdFx0XHRcdFx0aWYgKHR5cGVvZiB0YXJnZXQgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdFx0XHR2YXIgdGFyZ2V0SWR4ID1cblx0XHRcdFx0XHRcdFx0dGFyZ2V0IDwgMFxuXHRcdFx0XHRcdFx0XHRcdD8gZHQuY29sdW1ucygpLmVxKDApLmxlbmd0aCArIHRhcmdldFxuXHRcdFx0XHRcdFx0XHRcdDogdGFyZ2V0O1xuXG5cdFx0XHRcdFx0XHRpZiAoZHQuY2VsbCh0aGlzKS5pbmRleCgpLmNvbHVtbiAhPT0gdGFyZ2V0SWR4KSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyAkKCkuY2xvc2VzdCgpIGluY2x1ZGVzIGl0c2VsZiBpbiBpdHMgY2hlY2tcblx0XHRcdFx0XHR2YXIgcm93ID0gZHQucm93KCQodGhpcykuY2xvc2VzdCgndHInKSk7XG5cblx0XHRcdFx0XHQvLyBDaGVjayBldmVudCB0eXBlIHRvIGRvIGFuIGFjdGlvblxuXHRcdFx0XHRcdGlmIChlLnR5cGUgPT09ICdjbGljaycpIHtcblx0XHRcdFx0XHRcdC8vIFRoZSByZW5kZXJlciBpcyBnaXZlbiBhcyBhIGZ1bmN0aW9uIHNvIHRoZSBjYWxsZXIgY2FuIGV4ZWN1dGUgaXRcblx0XHRcdFx0XHRcdC8vIG9ubHkgd2hlbiB0aGV5IG5lZWQgKGkuZS4gaWYgaGlkaW5nIHRoZXJlIGlzIG5vIHBvaW50IGlzIHJ1bm5pbmdcblx0XHRcdFx0XHRcdC8vIHRoZSByZW5kZXJlcilcblx0XHRcdFx0XHRcdHRoYXQuX2RldGFpbHNEaXNwbGF5KHJvdywgZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIGlmIChlLnR5cGUgPT09ICdtb3VzZWRvd24nKSB7XG5cdFx0XHRcdFx0XHQvLyBGb3IgbW91c2UgdXNlcnMsIHByZXZlbnQgdGhlIGZvY3VzIHJpbmcgZnJvbSBzaG93aW5nXG5cdFx0XHRcdFx0XHQkKHRoaXMpLmNzcygnb3V0bGluZScsICdub25lJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgaWYgKGUudHlwZSA9PT0gJ21vdXNldXAnKSB7XG5cdFx0XHRcdFx0XHQvLyBBbmQgdGhlbiByZS1hbGxvdyBhdCB0aGUgZW5kIG9mIHRoZSBjbGlja1xuXHRcdFx0XHRcdFx0JCh0aGlzKS50cmlnZ2VyKCdibHVyJykuY3NzKCdvdXRsaW5lJywgJycpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0KTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCB0aGUgZGV0YWlscyB0byBwYXNzIHRvIGEgcmVuZGVyZXIgZm9yIGEgcm93XG5cdCAqIEBwYXJhbSAge2ludH0gcm93SWR4IFJvdyBpbmRleFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2RldGFpbHNPYmo6IGZ1bmN0aW9uIChyb3dJZHgpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0dmFyIGR0ID0gdGhpcy5zLmR0O1xuXG5cdFx0cmV0dXJuICQubWFwKHRoaXMucy5jb2x1bW5zLCBmdW5jdGlvbiAoY29sLCBpKSB7XG5cdFx0XHQvLyBOZXZlciBhbmQgY29udHJvbCBjb2x1bW5zIHNob3VsZCBub3QgYmUgcGFzc2VkIHRvIHRoZSByZW5kZXJlclxuXHRcdFx0aWYgKGNvbC5uZXZlciB8fCBjb2wuY29udHJvbCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhciBkdENvbCA9IGR0LnNldHRpbmdzKClbMF0uYW9Db2x1bW5zW2ldO1xuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRjbGFzc05hbWU6IGR0Q29sLnNDbGFzcyxcblx0XHRcdFx0Y29sdW1uSW5kZXg6IGksXG5cdFx0XHRcdGRhdGE6IGR0LmNlbGwocm93SWR4LCBpKS5yZW5kZXIodGhhdC5jLm9ydGhvZ29uYWwpLFxuXHRcdFx0XHRoaWRkZW46IGR0LmNvbHVtbihpKS52aXNpYmxlKCkgJiYgIXRoYXQucy5jdXJyZW50W2ldLFxuXHRcdFx0XHRyb3dJbmRleDogcm93SWR4LFxuXHRcdFx0XHR0aXRsZTogZHQuY29sdW1uKGkpLnRpdGxlKClcblx0XHRcdH07XG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEZpbmQgYSBicmVha3BvaW50IG9iamVjdCBmcm9tIGEgbmFtZVxuXHQgKlxuXHQgKiBAcGFyYW0gIHtzdHJpbmd9IG5hbWUgQnJlYWtwb2ludCBuYW1lIHRvIGZpbmRcblx0ICogQHJldHVybiB7b2JqZWN0fSAgICAgIEJyZWFrcG9pbnQgZGVzY3JpcHRpb24gb2JqZWN0XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZmluZDogZnVuY3Rpb24gKG5hbWUpIHtcblx0XHR2YXIgYnJlYWtwb2ludHMgPSB0aGlzLmMuYnJlYWtwb2ludHM7XG5cblx0XHRmb3IgKHZhciBpID0gMCwgaWVuID0gYnJlYWtwb2ludHMubGVuZ3RoOyBpIDwgaWVuOyBpKyspIHtcblx0XHRcdGlmIChicmVha3BvaW50c1tpXS5uYW1lID09PSBuYW1lKSB7XG5cdFx0XHRcdHJldHVybiBicmVha3BvaW50c1tpXTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlLWNyZWF0ZSB0aGUgY29udGVudHMgb2YgdGhlIGNoaWxkIHJvd3MgYXMgdGhlIGRpc3BsYXkgaGFzIGNoYW5nZWQgaW5cblx0ICogc29tZSB3YXkuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfcmVkcmF3Q2hpbGRyZW46IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0dmFyIGR0ID0gdGhpcy5zLmR0O1xuXG5cdFx0ZHQucm93cyh7IHBhZ2U6ICdjdXJyZW50JyB9KS5pdGVyYXRvcigncm93JywgZnVuY3Rpb24gKHNldHRpbmdzLCBpZHgpIHtcblx0XHRcdHRoYXQuX2RldGFpbHNEaXNwbGF5KGR0LnJvdyhpZHgpLCB0cnVlKTtcblx0XHR9KTtcblx0fSxcblxuXHQvKipcblx0ICogQWx0ZXIgdGhlIHRhYmxlIGRpc3BsYXkgZm9yIGEgcmVzaXplZCB2aWV3cG9ydC4gVGhpcyBpbnZvbHZlcyBmaXJzdFxuXHQgKiBkZXRlcm1pbmluZyB3aGF0IGJyZWFrcG9pbnQgdGhlIHdpbmRvdyBjdXJyZW50bHkgaXMgaW4sIGdldHRpbmcgdGhlXG5cdCAqIGNvbHVtbiB2aXNpYmlsaXRpZXMgdG8gYXBwbHkgYW5kIHRoZW4gc2V0dGluZyB0aGVtLlxuXHQgKlxuXHQgKiBAcGFyYW0gIHtib29sZWFufSBmb3JjZVJlZHJhdyBGb3JjZSBhIHJlZHJhd1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3Jlc2l6ZTogZnVuY3Rpb24gKGZvcmNlUmVkcmF3KSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdHZhciBkdCA9IHRoaXMucy5kdDtcblx0XHR2YXIgd2lkdGggPSAkKHdpbmRvdykuaW5uZXJXaWR0aCgpO1xuXHRcdHZhciBicmVha3BvaW50cyA9IHRoaXMuYy5icmVha3BvaW50cztcblx0XHR2YXIgYnJlYWtwb2ludCA9IGJyZWFrcG9pbnRzWzBdLm5hbWU7XG5cdFx0dmFyIGNvbHVtbnMgPSB0aGlzLnMuY29sdW1ucztcblx0XHR2YXIgaSwgaWVuO1xuXHRcdHZhciBvbGRWaXMgPSB0aGlzLnMuY3VycmVudC5zbGljZSgpO1xuXG5cdFx0Ly8gRGV0ZXJtaW5lIHdoYXQgYnJlYWtwb2ludCB3ZSBhcmUgY3VycmVudGx5IGF0XG5cdFx0Zm9yIChpID0gYnJlYWtwb2ludHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdGlmICh3aWR0aCA8PSBicmVha3BvaW50c1tpXS53aWR0aCkge1xuXHRcdFx0XHRicmVha3BvaW50ID0gYnJlYWtwb2ludHNbaV0ubmFtZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU2hvdyB0aGUgY29sdW1ucyBmb3IgdGhhdCBicmVhayBwb2ludFxuXHRcdHZhciBjb2x1bW5zVmlzID0gdGhpcy5fY29sdW1uc1Zpc2libGl0eShicmVha3BvaW50KTtcblx0XHR0aGlzLnMuY3VycmVudCA9IGNvbHVtbnNWaXM7XG5cblx0XHQvLyBTZXQgdGhlIGNsYXNzIGJlZm9yZSB0aGUgY29sdW1uIHZpc2liaWxpdHkgaXMgY2hhbmdlZCBzbyBldmVudFxuXHRcdC8vIGxpc3RlbmVycyBrbm93IHdoYXQgdGhlIHN0YXRlIGlzLiBOZWVkIHRvIGRldGVybWluZSBpZiB0aGVyZSBhcmVcblx0XHQvLyBhbnkgY29sdW1ucyB0aGF0IGFyZSBub3QgdmlzaWJsZSBidXQgY2FuIGJlIHNob3duXG5cdFx0dmFyIGNvbGxhcHNlZENsYXNzID0gZmFsc2U7XG5cblx0XHRmb3IgKGkgPSAwLCBpZW4gPSBjb2x1bW5zLmxlbmd0aDsgaSA8IGllbjsgaSsrKSB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdGNvbHVtbnNWaXNbaV0gPT09IGZhbHNlICYmXG5cdFx0XHRcdCFjb2x1bW5zW2ldLm5ldmVyICYmXG5cdFx0XHRcdCFjb2x1bW5zW2ldLmNvbnRyb2wgJiZcblx0XHRcdFx0IWR0LmNvbHVtbihpKS52aXNpYmxlKCkgPT09IGZhbHNlXG5cdFx0XHQpIHtcblx0XHRcdFx0Y29sbGFwc2VkQ2xhc3MgPSB0cnVlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQkKGR0LnRhYmxlKCkubm9kZSgpKS50b2dnbGVDbGFzcygnY29sbGFwc2VkJywgY29sbGFwc2VkQ2xhc3MpO1xuXG5cdFx0dmFyIGNoYW5nZWQgPSBmYWxzZTtcblx0XHR2YXIgdmlzaWJsZSA9IDA7XG5cdFx0dmFyIGR0U2V0dGluZ3MgPSBkdC5zZXR0aW5ncygpWzBdO1xuXHRcdHZhciBjb2xHcm91cCA9ICQoZHQudGFibGUoKS5ub2RlKCkpLmNoaWxkcmVuKCdjb2xncm91cCcpO1xuXHRcdHZhciBjb2xFbHMgPSBkdFNldHRpbmdzLmFvQ29sdW1ucy5tYXAoZnVuY3Rpb24gKGNvbCkge1xuXHRcdFx0cmV0dXJuIGNvbC5jb2xFbDtcblx0XHR9KTtcblxuXHRcdGR0LmNvbHVtbnMoKVxuXHRcdFx0LmVxKDApXG5cdFx0XHQuZWFjaChmdW5jdGlvbiAoY29sSWR4LCBpKSB7XG5cdFx0XHRcdC8vIERvIG5vdGhpbmcgb24gRGF0YVRhYmxlcycgaGlkZGVuIGNvbHVtbiAtIERUIHJlbW92ZXMgaXQgZnJvbSB0aGUgdGFibGVcblx0XHRcdFx0Ly8gc28gd2UgbmVlZCB0byBzbGlkZSBiYWNrXG5cdFx0XHRcdGlmICghIGR0LmNvbHVtbihjb2xJZHgpLnZpc2libGUoKSkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjb2x1bW5zVmlzW2ldID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0dmlzaWJsZSsrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGZvcmNlUmVkcmF3IHx8IGNvbHVtbnNWaXNbaV0gIT09IG9sZFZpc1tpXSkge1xuXHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHRcdHRoYXQuX3NldENvbHVtblZpcyhjb2xJZHgsIGNvbHVtbnNWaXNbaV0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRGF0YVRhYmxlcyAyIHVzZXMgYGNvbGAgdG8gZGVmaW5lIHRoZSB3aWR0aCBmb3IgYSBjb2x1bW5cblx0XHRcdFx0Ly8gYW5kIHRoaXMgbmVlZHMgdG8gcnVuIGVhY2ggdGltZSwgYXMgRGF0YVRhYmxlcyB3aWxsIGNoYW5nZVxuXHRcdFx0XHQvLyB0aGUgY29sdW1uIHdpZHRoLiBXZSBtYXkgbmVlZCB0byByZWF0dGFjaCBpZiB3ZSd2ZSByZW1vdmVkXG5cdFx0XHRcdC8vIGFuIGVsZW1lbnQgcHJldmlvdXNseS5cblx0XHRcdFx0aWYgKCEgY29sdW1uc1Zpc1tpXSkge1xuXHRcdFx0XHRcdGNvbEVsc1tpXS5kZXRhY2goKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR0aGF0Ll9jb2xHcm91cEF0dGFjaChjb2xHcm91cCwgY29sRWxzLCBpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRpZiAoY2hhbmdlZCkge1xuXHRcdFx0ZHQuY29sdW1ucy5hZGp1c3QoKTtcblxuXHRcdFx0dGhpcy5fcmVkcmF3Q2hpbGRyZW4oKTtcblxuXHRcdFx0Ly8gSW5mb3JtIGxpc3RlbmVycyBvZiB0aGUgY2hhbmdlXG5cdFx0XHQkKGR0LnRhYmxlKCkubm9kZSgpKS50cmlnZ2VyKCdyZXNwb25zaXZlLXJlc2l6ZS5kdCcsIFtcblx0XHRcdFx0ZHQsXG5cdFx0XHRcdHRoaXMuX3Jlc3BvbnNpdmVPbmx5SGlkZGVuKClcblx0XHRcdF0pO1xuXG5cdFx0XHQvLyBJZiBubyByZWNvcmRzLCB1cGRhdGUgdGhlIFwiTm8gcmVjb3Jkc1wiIGRpc3BsYXkgZWxlbWVudFxuXHRcdFx0aWYgKGR0LnBhZ2UuaW5mbygpLnJlY29yZHNEaXNwbGF5ID09PSAwKSB7XG5cdFx0XHRcdCQoJ3RkJywgZHQudGFibGUoKS5ib2R5KCkpLmVxKDApLmF0dHIoJ2NvbHNwYW4nLCB2aXNpYmxlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGF0Ll9jb250cm9sQ2xhc3MoKTtcblx0fSxcblxuXHQvKipcblx0ICogRGV0ZXJtaW5lIHRoZSB3aWR0aCBvZiBlYWNoIGNvbHVtbiBpbiB0aGUgdGFibGUgc28gdGhlIGF1dG8gY29sdW1uIGhpZGluZ1xuXHQgKiBoYXMgdGhhdCBpbmZvcm1hdGlvbiB0byB3b3JrIHdpdGguIFRoaXMgbWV0aG9kIGlzIG5ldmVyIGdvaW5nIHRvIGJlIDEwMCVcblx0ICogcGVyZmVjdCBzaW5jZSBjb2x1bW4gd2lkdGhzIGNhbiBjaGFuZ2Ugc2xpZ2h0bHkgcGVyIHBhZ2UsIGJ1dCB3aXRob3V0XG5cdCAqIHNlcmlvdXNseSBjb21wcm9taXNpbmcgcGVyZm9ybWFuY2UgdGhpcyBpcyBxdWl0ZSBlZmZlY3RpdmUuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfcmVzaXplQXV0bzogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBkdCA9IHRoaXMucy5kdDtcblx0XHR2YXIgY29sdW1ucyA9IHRoaXMucy5jb2x1bW5zO1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHR2YXIgdmlzaWJsZUNvbHVtbnMgPSBkdFxuXHRcdFx0LmNvbHVtbnMoKVxuXHRcdFx0LmluZGV4ZXMoKVxuXHRcdFx0LmZpbHRlcihmdW5jdGlvbiAoaWR4KSB7XG5cdFx0XHRcdHJldHVybiBkdC5jb2x1bW4oaWR4KS52aXNpYmxlKCk7XG5cdFx0XHR9KTtcblxuXHRcdC8vIEFyZSB3ZSBhbGxvd2VkIHRvIGRvIGF1dG8gc2l6aW5nP1xuXHRcdGlmICghdGhpcy5jLmF1dG8pIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBBcmUgdGhlcmUgYW55IGNvbHVtbnMgdGhhdCBhY3R1YWxseSBuZWVkIGF1dG8tc2l6aW5nLCBvciBkbyB0aGV5IGFsbFxuXHRcdC8vIGhhdmUgY2xhc3NlcyBkZWZpbmVkXG5cdFx0aWYgKFxuXHRcdFx0JC5pbkFycmF5KFxuXHRcdFx0XHR0cnVlLFxuXHRcdFx0XHQkLm1hcChjb2x1bW5zLCBmdW5jdGlvbiAoYykge1xuXHRcdFx0XHRcdHJldHVybiBjLmF1dG87XG5cdFx0XHRcdH0pXG5cdFx0XHQpID09PSAtMVxuXHRcdCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIENsb25lIHRoZSB0YWJsZSB3aXRoIHRoZSBjdXJyZW50IGRhdGEgaW4gaXRcblx0XHR2YXIgY2xvbmVkVGFibGUgPSBkdC50YWJsZSgpLm5vZGUoKS5jbG9uZU5vZGUoZmFsc2UpO1xuXHRcdHZhciBjbG9uZWRIZWFkZXIgPSAkKGR0LnRhYmxlKCkuaGVhZGVyKCkuY2xvbmVOb2RlKGZhbHNlKSkuYXBwZW5kVG8oXG5cdFx0XHRjbG9uZWRUYWJsZVxuXHRcdCk7XG5cdFx0dmFyIGNsb25lZEZvb3RlciA9ICQoZHQudGFibGUoKS5mb290ZXIoKS5jbG9uZU5vZGUoZmFsc2UpKS5hcHBlbmRUbyhcblx0XHRcdGNsb25lZFRhYmxlXG5cdFx0KTtcblx0XHR2YXIgY2xvbmVkQm9keSA9ICQoZHQudGFibGUoKS5ib2R5KCkpXG5cdFx0XHQuY2xvbmUoZmFsc2UsIGZhbHNlKVxuXHRcdFx0LmVtcHR5KClcblx0XHRcdC5hcHBlbmRUbyhjbG9uZWRUYWJsZSk7IC8vIHVzZSBqUXVlcnkgYmVjYXVzZSBvZiBJRThcblxuXHRcdGNsb25lZFRhYmxlLnN0eWxlLndpZHRoID0gJ2F1dG8nO1xuXG5cdFx0Ly8gSGVhZGVyXG5cdFx0ZHQudGFibGUoKVxuXHRcdFx0LmhlYWRlci5zdHJ1Y3R1cmUodmlzaWJsZUNvbHVtbnMpXG5cdFx0XHQuZm9yRWFjaCgocm93KSA9PiB7XG5cdFx0XHRcdHZhciBjZWxscyA9IHJvd1xuXHRcdFx0XHRcdC5maWx0ZXIoZnVuY3Rpb24gKGVsKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWwgPyB0cnVlIDogZmFsc2U7XG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHQubWFwKGZ1bmN0aW9uIChlbCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuICQoZWwuY2VsbClcblx0XHRcdFx0XHRcdFx0LmNsb25lKGZhbHNlKVxuXHRcdFx0XHRcdFx0XHQuY3NzKCdkaXNwbGF5JywgJ3RhYmxlLWNlbGwnKVxuXHRcdFx0XHRcdFx0XHQuY3NzKCd3aWR0aCcsICdhdXRvJylcblx0XHRcdFx0XHRcdFx0LmNzcygnbWluLXdpZHRoJywgMCk7XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0JCgnPHRyLz4nKS5hcHBlbmQoY2VsbHMpLmFwcGVuZFRvKGNsb25lZEhlYWRlcik7XG5cdFx0XHR9KTtcblxuXHRcdC8vIEFsd2F5cyBuZWVkIGFuIGVtcHR5IHJvdyB0aGF0IHdlIGNhbiByZWFkIHdpZHRocyBmcm9tXG5cdFx0dmFyIGVtcHR5Um93ID0gJCgnPHRyLz4nKS5hcHBlbmRUbyhjbG9uZWRCb2R5KTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdmlzaWJsZUNvbHVtbnMuY291bnQoKTsgaSsrKSB7XG5cdFx0XHRlbXB0eVJvdy5hcHBlbmQoJzx0ZC8+Jyk7XG5cdFx0fVxuXG5cdFx0Ly8gQm9keSByb3dzXG5cdFx0aWYgKHRoaXMuYy5kZXRhaWxzLnJlbmRlcmVyLl9yZXNwb25zaXZlTW92ZXNOb2Rlcykge1xuXHRcdFx0Ly8gU2xvdyBidXQgaXQgYWxsb3dzIGZvciBtb3ZpbmcgZWxlbWVudHMgYXJvdW5kIHRoZSBkb2N1bWVudFxuXHRcdFx0ZHQucm93cyh7IHBhZ2U6ICdjdXJyZW50JyB9KS5ldmVyeShmdW5jdGlvbiAocm93SWR4KSB7XG5cdFx0XHRcdHZhciBub2RlID0gdGhpcy5ub2RlKCk7XG5cblx0XHRcdFx0aWYgKCEgbm9kZSkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFdlIGNsb25lIHRoZSB0YWJsZSdzIHJvd3MgYW5kIGNlbGxzIHRvIGNyZWF0ZSB0aGUgc2l6aW5nIHRhYmxlXG5cdFx0XHRcdHZhciB0ciA9IG5vZGUuY2xvbmVOb2RlKGZhbHNlKTtcblxuXHRcdFx0XHRkdC5jZWxscyhyb3dJZHgsIHZpc2libGVDb2x1bW5zKS5ldmVyeShmdW5jdGlvbiAocm93SWR4MiwgY29sSWR4KSB7XG5cdFx0XHRcdFx0Ly8gSWYgbm9kZXMgaGF2ZSBiZWVuIG1vdmVkIG91dCAobGlzdEhpZGRlbk5vZGVzKSwgd2UgbmVlZCB0b1xuXHRcdFx0XHRcdC8vIGNsb25lIGZyb20gdGhlIHN0b3JlXG5cdFx0XHRcdFx0dmFyIHN0b3JlID0gdGhhdC5zLmNoaWxkTm9kZVN0b3JlW3Jvd0lkeCArICctJyArIGNvbElkeF07XG5cblx0XHRcdFx0XHRpZiAoc3RvcmUpIHtcblx0XHRcdFx0XHRcdCQodGhpcy5ub2RlKCkuY2xvbmVOb2RlKGZhbHNlKSlcblx0XHRcdFx0XHRcdFx0LmFwcGVuZCgkKHN0b3JlKS5jbG9uZSgpKVxuXHRcdFx0XHRcdFx0XHQuYXBwZW5kVG8odHIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdCQodGhpcy5ub2RlKCkpLmNsb25lKGZhbHNlKS5hcHBlbmRUbyh0cik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRjbG9uZWRCb2R5LmFwcGVuZCh0cik7XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHQvLyBUaGlzIGlzIG11Y2ggZmFzdGVyLCBidXQgaXQgZG9lc24ndCBhY2NvdW50IGZvciBtb3Zpbmcgbm9kZXMgYXJvdW5kXG5cdFx0XHQkKGNsb25lZEJvZHkpXG5cdFx0XHRcdC5hcHBlbmQoICQoZHQucm93cyggeyBwYWdlOiAnY3VycmVudCcgfSApLm5vZGVzKCkpLmNsb25lKCBmYWxzZSApIClcblx0XHRcdFx0LmZpbmQoICd0aCwgdGQnICkuY3NzKCAnZGlzcGxheScsICcnICk7XG5cdFx0fVxuXG5cdFx0Ly8gQW55IGNlbGxzIHdoaWNoIHdlcmUgaGlkZGVuIGJ5IFJlc3BvbnNpdmUgaW4gdGhlIGhvc3QgdGFibGUsIG5lZWQgdG9cblx0XHQvLyBiZSB2aXNpYmxlIGhlcmUgZm9yIHRoZSBjYWxjdWxhdGlvbnNcblx0XHRjbG9uZWRCb2R5LmZpbmQoJ3RoLCB0ZCcpLmNzcygnZGlzcGxheScsICcnKTtcblxuXHRcdC8vIEZvb3RlclxuXHRcdGR0LnRhYmxlKClcblx0XHRcdC5mb290ZXIuc3RydWN0dXJlKHZpc2libGVDb2x1bW5zKVxuXHRcdFx0LmZvckVhY2goKHJvdykgPT4ge1xuXHRcdFx0XHR2YXIgY2VsbHMgPSByb3dcblx0XHRcdFx0XHQuZmlsdGVyKGZ1bmN0aW9uIChlbCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsID8gdHJ1ZSA6IGZhbHNlO1xuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0Lm1hcChmdW5jdGlvbiAoZWwpIHtcblx0XHRcdFx0XHRcdHJldHVybiAkKGVsLmNlbGwpXG5cdFx0XHRcdFx0XHRcdC5jbG9uZShmYWxzZSlcblx0XHRcdFx0XHRcdFx0LmNzcygnZGlzcGxheScsICd0YWJsZS1jZWxsJylcblx0XHRcdFx0XHRcdFx0LmNzcygnd2lkdGgnLCAnYXV0bycpXG5cdFx0XHRcdFx0XHRcdC5jc3MoJ21pbi13aWR0aCcsIDApO1xuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdCQoJzx0ci8+JykuYXBwZW5kKGNlbGxzKS5hcHBlbmRUbyhjbG9uZWRGb290ZXIpO1xuXHRcdFx0fSk7XG5cblx0XHQvLyBJbiB0aGUgaW5saW5lIGNhc2UgZXh0cmEgcGFkZGluZyBpcyBhcHBsaWVkIHRvIHRoZSBmaXJzdCBjb2x1bW4gdG9cblx0XHQvLyBnaXZlIHNwYWNlIGZvciB0aGUgc2hvdyAvIGhpZGUgaWNvbi4gV2UgbmVlZCB0byB1c2UgdGhpcyBpbiB0aGVcblx0XHQvLyBjYWxjdWxhdGlvblxuXHRcdGlmICh0aGlzLmMuZGV0YWlscy50eXBlID09PSAnaW5saW5lJykge1xuXHRcdFx0JChjbG9uZWRUYWJsZSkuYWRkQ2xhc3MoJ2R0ci1pbmxpbmUgY29sbGFwc2VkJyk7XG5cdFx0fVxuXG5cdFx0Ly8gSXQgaXMgdW5zYWZlIHRvIGluc2VydCBlbGVtZW50cyB3aXRoIHRoZSBzYW1lIG5hbWUgaW50byB0aGUgRE9NXG5cdFx0Ly8gbXVsdGlwbGUgdGltZXMuIEZvciBleGFtcGxlLCBjbG9uaW5nIGFuZCBpbnNlcnRpbmcgYSBjaGVja2VkIHJhZGlvXG5cdFx0Ly8gY2xlYXJzIHRoZSBjaGNlY2tlZCBzdGF0ZSBvZiB0aGUgb3JpZ2luYWwgcmFkaW8uXG5cdFx0JChjbG9uZWRUYWJsZSkuZmluZCgnW25hbWVdJykucmVtb3ZlQXR0cignbmFtZScpO1xuXG5cdFx0Ly8gQSBwb3NpdGlvbiBhYnNvbHV0ZSB0YWJsZSB3b3VsZCB0YWtlIHRoZSB0YWJsZSBvdXQgb2YgdGhlIGZsb3cgb2Zcblx0XHQvLyBvdXIgY29udGFpbmVyIGVsZW1lbnQsIGJ5cGFzc2luZyB0aGUgaGVpZ2h0IGFuZCB3aWR0aCAoU2Nyb2xsZXIpXG5cdFx0JChjbG9uZWRUYWJsZSkuY3NzKCdwb3NpdGlvbicsICdyZWxhdGl2ZScpO1xuXG5cdFx0dmFyIGluc2VydGVkID0gJCgnPGRpdi8+Jylcblx0XHRcdC5jc3Moe1xuXHRcdFx0XHR3aWR0aDogMSxcblx0XHRcdFx0aGVpZ2h0OiAxLFxuXHRcdFx0XHRvdmVyZmxvdzogJ2hpZGRlbicsXG5cdFx0XHRcdGNsZWFyOiAnYm90aCdcblx0XHRcdH0pXG5cdFx0XHQuYXBwZW5kKGNsb25lZFRhYmxlKTtcblxuXHRcdGluc2VydGVkLmluc2VydEJlZm9yZShkdC50YWJsZSgpLm5vZGUoKSk7XG5cblx0XHQvLyBUaGUgY2xvbmVkIHRhYmxlIG5vdyBjb250YWlucyB0aGUgc21hbGxlc3QgdGhhdCBlYWNoIGNvbHVtbiBjYW4gYmVcblx0XHRlbXB0eVJvdy5jaGlsZHJlbigpLmVhY2goZnVuY3Rpb24gKGkpIHtcblx0XHRcdHZhciBpZHggPSBkdC5jb2x1bW4uaW5kZXgoJ2Zyb21WaXNpYmxlJywgaSk7XG5cdFx0XHRjb2x1bW5zW2lkeF0ubWluV2lkdGggPSB0aGlzLm9mZnNldFdpZHRoIHx8IDA7XG5cdFx0fSk7XG5cblx0XHRpbnNlcnRlZC5yZW1vdmUoKTtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IHRoZSBzdGF0ZSBvZiB0aGUgY3VycmVudCBoaWRkZW4gY29sdW1ucyAtIGNvbnRyb2xsZWQgYnkgUmVzcG9uc2l2ZSBvbmx5XG5cdCAqL1xuXHRfcmVzcG9uc2l2ZU9ubHlIaWRkZW46IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZHQgPSB0aGlzLnMuZHQ7XG5cblx0XHRyZXR1cm4gJC5tYXAodGhpcy5zLmN1cnJlbnQsIGZ1bmN0aW9uICh2LCBpKSB7XG5cdFx0XHQvLyBJZiB0aGUgY29sdW1uIGlzIGhpZGRlbiBieSBEYXRhVGFibGVzIHRoZW4gaXQgY2FuJ3QgYmUgaGlkZGVuIGJ5XG5cdFx0XHQvLyBSZXNwb25zaXZlIVxuXHRcdFx0aWYgKGR0LmNvbHVtbihpKS52aXNpYmxlKCkgPT09IGZhbHNlKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHY7XG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNldCBhIGNvbHVtbidzIHZpc2liaWxpdHkuXG5cdCAqXG5cdCAqIFdlIGRvbid0IHVzZSBEYXRhVGFibGVzJyBjb2x1bW4gdmlzaWJpbGl0eSBjb250cm9scyBpbiBvcmRlciB0byBlbnN1cmVcblx0ICogdGhhdCBjb2x1bW4gdmlzaWJpbGl0eSBjYW4gUmVzcG9uc2l2ZSBjYW4gbm8tZXhpc3QuIFNpbmNlIG9ubHkgSUU4KyBpc1xuXHQgKiBzdXBwb3J0ZWQgKGFuZCBhbGwgZXZlcmdyZWVuIGJyb3dzZXJzIG9mIGNvdXJzZSkgdGhlIGNvbnRyb2wgb2YgdGhlXG5cdCAqIGRpc3BsYXkgYXR0cmlidXRlIHdvcmtzIHdlbGwuXG5cdCAqXG5cdCAqIEBwYXJhbSB7aW50ZWdlcn0gY29sICAgICAgQ29sdW1uIGluZGV4XG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvd0hpZGUgU2hvdyBvciBoaWRlICh0cnVlIG9yIGZhbHNlKVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3NldENvbHVtblZpczogZnVuY3Rpb24gKGNvbCwgc2hvd0hpZGUpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0dmFyIGR0ID0gdGhpcy5zLmR0O1xuXHRcdHZhciBkaXNwbGF5ID0gc2hvd0hpZGUgPyAnJyA6ICdub25lJzsgLy8gZW1wdHkgc3RyaW5nIHdpbGwgcmVtb3ZlIHRoZSBhdHRyXG5cblx0XHR0aGlzLl9zZXRIZWFkZXJWaXMoY29sLCBzaG93SGlkZSwgZHQudGFibGUoKS5oZWFkZXIuc3RydWN0dXJlKCkpO1xuXHRcdHRoaXMuX3NldEhlYWRlclZpcyhjb2wsIHNob3dIaWRlLCBkdC50YWJsZSgpLmZvb3Rlci5zdHJ1Y3R1cmUoKSk7XG5cblx0XHRkdC5jb2x1bW4oY29sKVxuXHRcdFx0Lm5vZGVzKClcblx0XHRcdC50byQoKVxuXHRcdFx0LmNzcygnZGlzcGxheScsIGRpc3BsYXkpXG5cdFx0XHQudG9nZ2xlQ2xhc3MoJ2R0ci1oaWRkZW4nLCAhc2hvd0hpZGUpO1xuXG5cdFx0Ly8gSWYgdGhlIGFyZSBjaGlsZCBub2RlcyBzdG9yZWQsIHdlIG1pZ2h0IG5lZWQgdG8gcmVpbnNlcnQgdGhlbVxuXHRcdGlmICghJC5pc0VtcHR5T2JqZWN0KHRoaXMucy5jaGlsZE5vZGVTdG9yZSkpIHtcblx0XHRcdGR0LmNlbGxzKG51bGwsIGNvbClcblx0XHRcdFx0LmluZGV4ZXMoKVxuXHRcdFx0XHQuZWFjaChmdW5jdGlvbiAoaWR4KSB7XG5cdFx0XHRcdFx0dGhhdC5fY2hpbGROb2Rlc1Jlc3RvcmUoZHQsIGlkeC5yb3csIGlkeC5jb2x1bW4pO1xuXHRcdFx0XHR9KTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNldCB0aGUgYSBjb2x1bW4ncyB2aXNpYmlsaXR5LCB0YWtpbmcgaW50byBhY2NvdW50IG11bHRpcGxlIHJvd3Ncblx0ICogaW4gYSBoZWFkZXIgLyBmb290ZXIgYW5kIGNvbHNwYW4gYXR0cmlidXRlc1xuXHQgKiBAcGFyYW0geyp9IGNvbFxuXHQgKiBAcGFyYW0geyp9IHNob3dIaWRlXG5cdCAqIEBwYXJhbSB7Kn0gc3RydWN0dXJlXG5cdCAqL1xuXHRfc2V0SGVhZGVyVmlzOiBmdW5jdGlvbiAoY29sLCBzaG93SGlkZSwgc3RydWN0dXJlKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdHZhciBkaXNwbGF5ID0gc2hvd0hpZGUgPyAnJyA6ICdub25lJztcblxuXHRcdC8vIFdlIHVzZSB0aGUgYG51bGxgcyBpbiB0aGUgc3RydWN0dXJlIGFycmF5IHRvIGluZGljYXRlIHRoYXQgYSBjZWxsXG5cdFx0Ly8gc2hvdWxkIGV4cGFuZCBvdmVyIHRoYXQgb25lIGlmIHRoZXJlIGlzIGEgY29sc3BhbiwgYnV0IGl0IG1pZ2h0XG5cdFx0Ly8gYWxzbyBoYXZlIGJlZW4gZmlsbGVkIGJ5IGEgcm93c3Bhbiwgc28gd2UgbmVlZCB0byBleHBhbmQgdGhlXG5cdFx0Ly8gcm93c3BhbiBjZWxscyBkb3duIHRocm91Z2ggdGhlIHN0cnVjdHVyZVxuXHRcdHN0cnVjdHVyZS5mb3JFYWNoKGZ1bmN0aW9uIChyb3csIHJvd0lkeCkge1xuXHRcdFx0Zm9yICh2YXIgY29sID0gMDsgY29sIDwgcm93Lmxlbmd0aDsgY29sKyspIHtcblx0XHRcdFx0aWYgKHJvd1tjb2xdICYmIHJvd1tjb2xdLnJvd3NwYW4gPiAxKSB7XG5cdFx0XHRcdFx0dmFyIHNwYW4gPSByb3dbY29sXS5yb3dzcGFuO1xuXG5cdFx0XHRcdFx0Zm9yICh2YXIgaT0xIDsgaTxzcGFuIDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRzdHJ1Y3R1cmVbcm93SWR4ICsgaV1bY29sXSA9IHt9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0c3RydWN0dXJlLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuXHRcdFx0aWYgKHJvd1tjb2xdICYmIHJvd1tjb2xdLmNlbGwpIHtcblx0XHRcdFx0JChyb3dbY29sXS5jZWxsKVxuXHRcdFx0XHRcdC5jc3MoJ2Rpc3BsYXknLCBkaXNwbGF5KVxuXHRcdFx0XHRcdC50b2dnbGVDbGFzcygnZHRyLWhpZGRlbicsICFzaG93SGlkZSk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Ly8gSW4gYSBjb2xzcGFuIC0gbmVlZCB0byByZXdpbmQgY2FsYyB0aGUgbmV3IHNwYW4gc2luY2Vcblx0XHRcdFx0Ly8gZGlzcGxheTpub25lIGVsZW1lbnRzIGRvIG5vdCBjb3VudCBhcyBiZWluZyBzcGFubmVkIG92ZXJcblx0XHRcdFx0dmFyIHNlYXJjaCA9IGNvbDtcblxuXHRcdFx0XHR3aGlsZSAoc2VhcmNoID49IDApIHtcblx0XHRcdFx0XHRpZiAocm93W3NlYXJjaF0gJiYgcm93W3NlYXJjaF0uY2VsbCkge1xuXHRcdFx0XHRcdFx0cm93W3NlYXJjaF0uY2VsbC5jb2xTcGFuID0gdGhhdC5fY29sc3Bhbihyb3csIHNlYXJjaCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRzZWFyY2gtLTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBIb3cgbWFueSBjb2x1bW5zIHNob3VsZCB0aGlzIGNlbGwgc3BhblxuXHQgKlxuXHQgKiBAcGFyYW0geyp9IHJvdyBIZWFkZXIgc3RydWN0dXJlIHJvd1xuXHQgKiBAcGFyYW0geyp9IGlkeCBUaGUgY29sdW1uIGluZGV4IG9mIHRoZSBjZWxsIHRvIHNwYW5cblx0ICovXG5cdF9jb2xzcGFuOiBmdW5jdGlvbiAocm93LCBpZHgpIHtcblx0XHR2YXIgY29sc3BhbiA9IDE7XG5cblx0XHRmb3IgKHZhciBjb2wgPSBpZHggKyAxOyBjb2wgPCByb3cubGVuZ3RoOyBjb2wrKykge1xuXHRcdFx0aWYgKHJvd1tjb2xdID09PSBudWxsICYmIHRoaXMucy5jdXJyZW50W2NvbF0pIHtcblx0XHRcdFx0Ly8gY29sc3BhbiBhbmQgbm90IGhpZGRlbiBieSBSZXNwb25zaXZlXG5cdFx0XHRcdGNvbHNwYW4rKztcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKHJvd1tjb2xdKSB7XG5cdFx0XHRcdC8vIEdvdCB0aGUgbmV4dCBjZWxsLCBqdW1wIG91dFxuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gY29sc3Bhbjtcblx0fSxcblxuXHQvKipcblx0ICogVXBkYXRlIHRoZSBjZWxsIHRhYiBpbmRleGVzIGZvciBrZXlib2FyZCBhY2Nlc3NpYmlsaXR5LiBUaGlzIGlzIGNhbGxlZCBvblxuXHQgKiBldmVyeSB0YWJsZSBkcmF3IC0gdGhhdCBpcyBwb3RlbnRpYWxseSBpbmVmZmljaWVudCwgYnV0IGFsc28gdGhlIGxlYXN0XG5cdCAqIGNvbXBsZXggb3B0aW9uIGdpdmVuIHRoYXQgY29sdW1uIHZpc2liaWxpdHkgY2FuIGNoYW5nZSBvbiB0aGUgZmx5LiBJdHMgYVxuXHQgKiBzaGFtZSB1c2VyLWZvY3VzIHdhcyByZW1vdmVkIGZyb20gQ1NTIDMgVUksIGFzIGl0IHdvdWxkIGhhdmUgc29sdmVkIHRoaXNcblx0ICogaXNzdWUgd2l0aCBhIHNpbmdsZSBDU1Mgc3RhdGVtZW50LlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3RhYkluZGV4ZXM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZHQgPSB0aGlzLnMuZHQ7XG5cdFx0dmFyIGNlbGxzID0gZHQuY2VsbHMoeyBwYWdlOiAnY3VycmVudCcgfSkubm9kZXMoKS50byQoKTtcblx0XHR2YXIgY3R4ID0gZHQuc2V0dGluZ3MoKVswXTtcblx0XHR2YXIgdGFyZ2V0ID0gdGhpcy5jLmRldGFpbHMudGFyZ2V0O1xuXG5cdFx0Y2VsbHMuZmlsdGVyKCdbZGF0YS1kdHIta2V5Ym9hcmRdJykucmVtb3ZlRGF0YSgnW2RhdGEtZHRyLWtleWJvYXJkXScpO1xuXG5cdFx0aWYgKHR5cGVvZiB0YXJnZXQgPT09ICdudW1iZXInKSB7XG5cdFx0XHRkdC5jZWxscyhudWxsLCB0YXJnZXQsIHsgcGFnZTogJ2N1cnJlbnQnIH0pXG5cdFx0XHRcdC5ub2RlcygpXG5cdFx0XHRcdC50byQoKVxuXHRcdFx0XHQuYXR0cigndGFiSW5kZXgnLCBjdHguaVRhYkluZGV4KVxuXHRcdFx0XHQuZGF0YSgnZHRyLWtleWJvYXJkJywgMSk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gVGhpcyBpcyBhIGJpdCBvZiBhIGhhY2sgLSB3ZSBuZWVkIHRvIGxpbWl0IHRoZSBzZWxlY3RlZCBub2RlcyB0byBqdXN0XG5cdFx0XHQvLyB0aG9zZSBvZiB0aGlzIHRhYmxlXG5cdFx0XHRpZiAodGFyZ2V0ID09PSAndGQ6Zmlyc3QtY2hpbGQsIHRoOmZpcnN0LWNoaWxkJykge1xuXHRcdFx0XHR0YXJnZXQgPSAnPnRkOmZpcnN0LWNoaWxkLCA+dGg6Zmlyc3QtY2hpbGQnO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcm93cyA9IGR0LnJvd3MoeyBwYWdlOiAnY3VycmVudCcgfSkubm9kZXMoKTtcblx0XHRcdHZhciBub2RlcyA9IHRhcmdldCA9PT0gJ3RyJ1xuXHRcdFx0XHQ/ICQocm93cylcblx0XHRcdFx0OiAkKHRhcmdldCwgcm93cyk7XG5cblx0XHRcdG5vZGVzXG5cdFx0XHRcdC5hdHRyKCd0YWJJbmRleCcsIGN0eC5pVGFiSW5kZXgpXG5cdFx0XHRcdC5kYXRhKCdkdHIta2V5Ym9hcmQnLCAxKTtcblx0XHR9XG5cdH1cbn0pO1xuXG4vKipcbiAqIExpc3Qgb2YgZGVmYXVsdCBicmVha3BvaW50cy4gRWFjaCBpdGVtIGluIHRoZSBhcnJheSBpcyBhbiBvYmplY3Qgd2l0aCB0d29cbiAqIHByb3BlcnRpZXM6XG4gKlxuICogKiBgbmFtZWAgLSB0aGUgYnJlYWtwb2ludCBuYW1lLlxuICogKiBgd2lkdGhgIC0gdGhlIGJyZWFrcG9pbnQgd2lkdGhcbiAqXG4gKiBAbmFtZSBSZXNwb25zaXZlLmJyZWFrcG9pbnRzXG4gKiBAc3RhdGljXG4gKi9cblJlc3BvbnNpdmUuYnJlYWtwb2ludHMgPSBbXG5cdHsgbmFtZTogJ2Rlc2t0b3AnLCB3aWR0aDogSW5maW5pdHkgfSxcblx0eyBuYW1lOiAndGFibGV0LWwnLCB3aWR0aDogMTAyNCB9LFxuXHR7IG5hbWU6ICd0YWJsZXQtcCcsIHdpZHRoOiA3NjggfSxcblx0eyBuYW1lOiAnbW9iaWxlLWwnLCB3aWR0aDogNDgwIH0sXG5cdHsgbmFtZTogJ21vYmlsZS1wJywgd2lkdGg6IDMyMCB9XG5dO1xuXG4vKipcbiAqIERpc3BsYXkgbWV0aG9kcyAtIGZ1bmN0aW9ucyB3aGljaCBkZWZpbmUgaG93IHRoZSBoaWRkZW4gZGF0YSBzaG91bGQgYmUgc2hvd25cbiAqIGluIHRoZSB0YWJsZS5cbiAqXG4gKiBAbmFtZXNwYWNlXG4gKiBAbmFtZSBSZXNwb25zaXZlLmRlZmF1bHRzXG4gKiBAc3RhdGljXG4gKi9cblJlc3BvbnNpdmUuZGlzcGxheSA9IHtcblx0Y2hpbGRSb3c6IGZ1bmN0aW9uIChyb3csIHVwZGF0ZSwgcmVuZGVyKSB7XG5cdFx0dmFyIHJvd05vZGUgPSAkKHJvdy5ub2RlKCkpO1xuXG5cdFx0aWYgKHVwZGF0ZSkge1xuXHRcdFx0aWYgKHJvd05vZGUuaGFzQ2xhc3MoJ2R0ci1leHBhbmRlZCcpKSB7XG5cdFx0XHRcdHJvdy5jaGlsZChyZW5kZXIoKSwgJ2NoaWxkJykuc2hvdygpO1xuXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGlmICghcm93Tm9kZS5oYXNDbGFzcygnZHRyLWV4cGFuZGVkJykpIHtcblx0XHRcdFx0dmFyIHJlbmRlcmVkID0gcmVuZGVyKCk7XG5cblx0XHRcdFx0aWYgKHJlbmRlcmVkID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJvdy5jaGlsZChyZW5kZXJlZCwgJ2NoaWxkJykuc2hvdygpO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRyb3cuY2hpbGQoZmFsc2UpO1xuXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Y2hpbGRSb3dJbW1lZGlhdGU6IGZ1bmN0aW9uIChyb3csIHVwZGF0ZSwgcmVuZGVyKSB7XG5cdFx0dmFyIHJvd05vZGUgPSAkKHJvdy5ub2RlKCkpO1xuXG5cdFx0aWYgKFxuXHRcdFx0KCF1cGRhdGUgJiYgcm93Tm9kZS5oYXNDbGFzcygnZHRyLWV4cGFuZGVkJykpIHx8XG5cdFx0XHQhcm93LnJlc3BvbnNpdmUuaGFzSGlkZGVuKClcblx0XHQpIHtcblx0XHRcdC8vIFVzZXIgaW50ZXJhY3Rpb24gYW5kIHRoZSByb3cgaXMgc2hvdywgb3Igbm90aGluZyB0byBzaG93XG5cdFx0XHRyb3cuY2hpbGQoZmFsc2UpO1xuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gRGlzcGxheVxuXHRcdFx0dmFyIHJlbmRlcmVkID0gcmVuZGVyKCk7XG5cblx0XHRcdGlmIChyZW5kZXJlZCA9PT0gZmFsc2UpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRyb3cuY2hpbGQocmVuZGVyZWQsICdjaGlsZCcpLnNob3coKTtcblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIFRoaXMgaXMgYSB3cmFwcGVyIHNvIHRoZSBtb2RhbCBvcHRpb25zIGZvciBCb290c3RyYXAgYW5kIGpRdWVyeSBVSSBjYW5cblx0Ly8gaGF2ZSBvcHRpb25zIHBhc3NlZCBpbnRvIHRoZW0uIFRoaXMgc3BlY2lmaWMgb25lIGRvZXNuJ3QgbmVlZCB0byBiZSBhXG5cdC8vIGZ1bmN0aW9uIGJ1dCBpdCBpcyBmb3IgY29uc2lzdGVuY3kgaW4gdGhlIGBtb2RhbGAgbmFtZVxuXHRtb2RhbDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKHJvdywgdXBkYXRlLCByZW5kZXIsIGNsb3NlQ2FsbGJhY2spIHtcblx0XHRcdHZhciBtb2RhbDtcblx0XHRcdHZhciByZW5kZXJlZCA9IHJlbmRlcigpO1xuXG5cdFx0XHRpZiAocmVuZGVyZWQgPT09IGZhbHNlKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCF1cGRhdGUpIHtcblx0XHRcdFx0Ly8gU2hvdyBhIG1vZGFsXG5cdFx0XHRcdHZhciBjbG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRtb2RhbC5yZW1vdmUoKTsgLy8gd2lsbCB0aWR5IGV2ZW50cyBmb3IgdXNcblx0XHRcdFx0XHQkKGRvY3VtZW50KS5vZmYoJ2tleXByZXNzLmR0cicpO1xuXHRcdFx0XHRcdCQocm93Lm5vZGUoKSkucmVtb3ZlQ2xhc3MoJ2R0ci1leHBhbmRlZCcpO1xuXG5cdFx0XHRcdFx0Y2xvc2VDYWxsYmFjaygpO1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdG1vZGFsID0gJCgnPGRpdiBjbGFzcz1cImR0ci1tb2RhbFwiLz4nKVxuXHRcdFx0XHRcdC5hcHBlbmQoXG5cdFx0XHRcdFx0XHQkKCc8ZGl2IGNsYXNzPVwiZHRyLW1vZGFsLWRpc3BsYXlcIi8+Jylcblx0XHRcdFx0XHRcdFx0LmFwcGVuZChcblx0XHRcdFx0XHRcdFx0XHQkKCc8ZGl2IGNsYXNzPVwiZHRyLW1vZGFsLWNvbnRlbnRcIi8+Jylcblx0XHRcdFx0XHRcdFx0XHRcdC5kYXRhKCdkdHItcm93LWlkeCcsIHJvdy5pbmRleCgpKVxuXHRcdFx0XHRcdFx0XHRcdFx0LmFwcGVuZChyZW5kZXJlZClcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0XHQuYXBwZW5kKFxuXHRcdFx0XHRcdFx0XHRcdCQoXG5cdFx0XHRcdFx0XHRcdFx0XHQnPGRpdiBjbGFzcz1cImR0ci1tb2RhbC1jbG9zZVwiPiZ0aW1lczs8L2Rpdj4nXG5cdFx0XHRcdFx0XHRcdFx0KS5jbGljayhmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjbG9zZSgpO1xuXHRcdFx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0LmFwcGVuZChcblx0XHRcdFx0XHRcdCQoJzxkaXYgY2xhc3M9XCJkdHItbW9kYWwtYmFja2dyb3VuZFwiLz4nKS5jbGljayhcblx0XHRcdFx0XHRcdFx0ZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0XHRcdGNsb3NlKCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0LmFwcGVuZFRvKCdib2R5Jyk7XG5cblx0XHRcdFx0JChyb3cubm9kZSgpKS5hZGRDbGFzcygnZHRyLWV4cGFuZGVkJyk7XG5cblx0XHRcdFx0JChkb2N1bWVudCkub24oJ2tleXVwLmR0cicsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdFx0aWYgKGUua2V5Q29kZSA9PT0gMjcpIHtcblx0XHRcdFx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cblx0XHRcdFx0XHRcdGNsb3NlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRtb2RhbCA9ICQoJ2Rpdi5kdHItbW9kYWwtY29udGVudCcpO1xuXG5cdFx0XHRcdGlmIChtb2RhbC5sZW5ndGggJiYgcm93LmluZGV4KCkgPT09IG1vZGFsLmRhdGEoJ2R0ci1yb3ctaWR4JykpIHtcblx0XHRcdFx0XHRtb2RhbC5lbXB0eSgpLmFwcGVuZChyZW5kZXJlZCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Ly8gTW9kYWwgbm90IHNob3duLCBub3RoaW5nIHRvIHVwZGF0ZVxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvcHRpb25zICYmIG9wdGlvbnMuaGVhZGVyKSB7XG5cdFx0XHRcdCQoJ2Rpdi5kdHItbW9kYWwtY29udGVudCcpLnByZXBlbmQoXG5cdFx0XHRcdFx0JzxoMj4nICsgb3B0aW9ucy5oZWFkZXIocm93KSArICc8L2gyPidcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fTtcblx0fVxufTtcblxuLyoqXG4gKiBEaXNwbGF5IG1ldGhvZHMgLSBmdW5jdGlvbnMgd2hpY2ggZGVmaW5lIGhvdyB0aGUgaGlkZGVuIGRhdGEgc2hvdWxkIGJlIHNob3duXG4gKiBpbiB0aGUgdGFibGUuXG4gKlxuICogQG5hbWVzcGFjZVxuICogQG5hbWUgUmVzcG9uc2l2ZS5kZWZhdWx0c1xuICogQHN0YXRpY1xuICovXG5SZXNwb25zaXZlLnJlbmRlcmVyID0ge1xuXHRsaXN0SGlkZGVuTm9kZXM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZm4gPSBmdW5jdGlvbiAoYXBpLCByb3dJZHgsIGNvbHVtbnMpIHtcblx0XHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHRcdHZhciB1bCA9ICQoXG5cdFx0XHRcdCc8dWwgZGF0YS1kdHItaW5kZXg9XCInICsgcm93SWR4ICsgJ1wiIGNsYXNzPVwiZHRyLWRldGFpbHNcIi8+J1xuXHRcdFx0KTtcblx0XHRcdHZhciBmb3VuZCA9IGZhbHNlO1xuXG5cdFx0XHQkLmVhY2goY29sdW1ucywgZnVuY3Rpb24gKGksIGNvbCkge1xuXHRcdFx0XHRpZiAoY29sLmhpZGRlbikge1xuXHRcdFx0XHRcdHZhciBrbGFzcyA9IGNvbC5jbGFzc05hbWVcblx0XHRcdFx0XHRcdD8gJ2NsYXNzPVwiJyArIGNvbC5jbGFzc05hbWUgKyAnXCInXG5cdFx0XHRcdFx0XHQ6ICcnO1xuXG5cdFx0XHRcdFx0JChcblx0XHRcdFx0XHRcdCc8bGkgJyArXG5cdFx0XHRcdFx0XHRcdGtsYXNzICtcblx0XHRcdFx0XHRcdFx0JyBkYXRhLWR0ci1pbmRleD1cIicgK1xuXHRcdFx0XHRcdFx0XHRjb2wuY29sdW1uSW5kZXggK1xuXHRcdFx0XHRcdFx0XHQnXCIgZGF0YS1kdC1yb3c9XCInICtcblx0XHRcdFx0XHRcdFx0Y29sLnJvd0luZGV4ICtcblx0XHRcdFx0XHRcdFx0J1wiIGRhdGEtZHQtY29sdW1uPVwiJyArXG5cdFx0XHRcdFx0XHRcdGNvbC5jb2x1bW5JbmRleCArXG5cdFx0XHRcdFx0XHRcdCdcIj4nICtcblx0XHRcdFx0XHRcdFx0JzxzcGFuIGNsYXNzPVwiZHRyLXRpdGxlXCI+JyArXG5cdFx0XHRcdFx0XHRcdGNvbC50aXRsZSArXG5cdFx0XHRcdFx0XHRcdCc8L3NwYW4+ICcgK1xuXHRcdFx0XHRcdFx0XHQnPC9saT4nXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0LmFwcGVuZChcblx0XHRcdFx0XHRcdFx0JCgnPHNwYW4gY2xhc3M9XCJkdHItZGF0YVwiLz4nKS5hcHBlbmQoXG5cdFx0XHRcdFx0XHRcdFx0dGhhdC5fY2hpbGROb2Rlcyhcblx0XHRcdFx0XHRcdFx0XHRcdGFwaSxcblx0XHRcdFx0XHRcdFx0XHRcdGNvbC5yb3dJbmRleCxcblx0XHRcdFx0XHRcdFx0XHRcdGNvbC5jb2x1bW5JbmRleFxuXHRcdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KSAvLyBhcGkuY2VsbCggY29sLnJvd0luZGV4LCBjb2wuY29sdW1uSW5kZXggKS5ub2RlKCkuY2hpbGROb2RlcyApIClcblx0XHRcdFx0XHRcdC5hcHBlbmRUbyh1bCk7XG5cblx0XHRcdFx0XHRmb3VuZCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRyZXR1cm4gZm91bmQgPyB1bCA6IGZhbHNlO1xuXHRcdH07XG5cblx0XHRmbi5fcmVzcG9uc2l2ZU1vdmVzTm9kZXMgPSB0cnVlO1xuXG5cdFx0cmV0dXJuIGZuO1xuXHR9LFxuXG5cdGxpc3RIaWRkZW46IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKGFwaSwgcm93SWR4LCBjb2x1bW5zKSB7XG5cdFx0XHR2YXIgZGF0YSA9ICQubWFwKGNvbHVtbnMsIGZ1bmN0aW9uIChjb2wpIHtcblx0XHRcdFx0dmFyIGtsYXNzID0gY29sLmNsYXNzTmFtZVxuXHRcdFx0XHRcdD8gJ2NsYXNzPVwiJyArIGNvbC5jbGFzc05hbWUgKyAnXCInXG5cdFx0XHRcdFx0OiAnJztcblxuXHRcdFx0XHRyZXR1cm4gY29sLmhpZGRlblxuXHRcdFx0XHRcdD8gJzxsaSAnICtcblx0XHRcdFx0XHRcdFx0a2xhc3MgK1xuXHRcdFx0XHRcdFx0XHQnIGRhdGEtZHRyLWluZGV4PVwiJyArXG5cdFx0XHRcdFx0XHRcdGNvbC5jb2x1bW5JbmRleCArXG5cdFx0XHRcdFx0XHRcdCdcIiBkYXRhLWR0LXJvdz1cIicgK1xuXHRcdFx0XHRcdFx0XHRjb2wucm93SW5kZXggK1xuXHRcdFx0XHRcdFx0XHQnXCIgZGF0YS1kdC1jb2x1bW49XCInICtcblx0XHRcdFx0XHRcdFx0Y29sLmNvbHVtbkluZGV4ICtcblx0XHRcdFx0XHRcdFx0J1wiPicgK1xuXHRcdFx0XHRcdFx0XHQnPHNwYW4gY2xhc3M9XCJkdHItdGl0bGVcIj4nICtcblx0XHRcdFx0XHRcdFx0Y29sLnRpdGxlICtcblx0XHRcdFx0XHRcdFx0Jzwvc3Bhbj4gJyArXG5cdFx0XHRcdFx0XHRcdCc8c3BhbiBjbGFzcz1cImR0ci1kYXRhXCI+JyArXG5cdFx0XHRcdFx0XHRcdGNvbC5kYXRhICtcblx0XHRcdFx0XHRcdFx0Jzwvc3Bhbj4nICtcblx0XHRcdFx0XHRcdFx0JzwvbGk+J1xuXHRcdFx0XHRcdDogJyc7XG5cdFx0XHR9KS5qb2luKCcnKTtcblxuXHRcdFx0cmV0dXJuIGRhdGFcblx0XHRcdFx0PyAkKFxuXHRcdFx0XHRcdFx0Jzx1bCBkYXRhLWR0ci1pbmRleD1cIicgK1xuXHRcdFx0XHRcdFx0XHRyb3dJZHggK1xuXHRcdFx0XHRcdFx0XHQnXCIgY2xhc3M9XCJkdHItZGV0YWlsc1wiLz4nXG5cdFx0XHRcdCkuYXBwZW5kKGRhdGEpXG5cdFx0XHRcdDogZmFsc2U7XG5cdFx0fTtcblx0fSxcblxuXHR0YWJsZUFsbDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHRvcHRpb25zID0gJC5leHRlbmQoXG5cdFx0XHR7XG5cdFx0XHRcdHRhYmxlQ2xhc3M6ICcnXG5cdFx0XHR9LFxuXHRcdFx0b3B0aW9uc1xuXHRcdCk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKGFwaSwgcm93SWR4LCBjb2x1bW5zKSB7XG5cdFx0XHR2YXIgZGF0YSA9ICQubWFwKGNvbHVtbnMsIGZ1bmN0aW9uIChjb2wpIHtcblx0XHRcdFx0dmFyIGtsYXNzID0gY29sLmNsYXNzTmFtZVxuXHRcdFx0XHRcdD8gJ2NsYXNzPVwiJyArIGNvbC5jbGFzc05hbWUgKyAnXCInXG5cdFx0XHRcdFx0OiAnJztcblxuXHRcdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRcdCc8dHIgJyArXG5cdFx0XHRcdFx0a2xhc3MgK1xuXHRcdFx0XHRcdCcgZGF0YS1kdC1yb3c9XCInICtcblx0XHRcdFx0XHRjb2wucm93SW5kZXggK1xuXHRcdFx0XHRcdCdcIiBkYXRhLWR0LWNvbHVtbj1cIicgK1xuXHRcdFx0XHRcdGNvbC5jb2x1bW5JbmRleCArXG5cdFx0XHRcdFx0J1wiPicgK1xuXHRcdFx0XHRcdCc8dGQ+JyArXG5cdFx0XHRcdFx0KCAnJyAhPT0gY29sLnRpdGxlXG5cdFx0XHRcdFx0XHQ/IGNvbC50aXRsZSArICc6J1xuXHRcdFx0XHRcdFx0OiAnJ1xuXHRcdFx0XHRcdCkgK1xuXHRcdFx0XHRcdCc8L3RkPiAnICtcblx0XHRcdFx0XHQnPHRkPicgK1xuXHRcdFx0XHRcdGNvbC5kYXRhICtcblx0XHRcdFx0XHQnPC90ZD4nICtcblx0XHRcdFx0XHQnPC90cj4nXG5cdFx0XHRcdCk7XG5cdFx0XHR9KS5qb2luKCcnKTtcblxuXHRcdFx0cmV0dXJuICQoXG5cdFx0XHRcdCc8dGFibGUgY2xhc3M9XCInICtcblx0XHRcdFx0XHRvcHRpb25zLnRhYmxlQ2xhc3MgK1xuXHRcdFx0XHRcdCcgZHRyLWRldGFpbHNcIiB3aWR0aD1cIjEwMCVcIi8+J1xuXHRcdFx0KS5hcHBlbmQoZGF0YSk7XG5cdFx0fTtcblx0fVxufTtcblxuLyoqXG4gKiBSZXNwb25zaXZlIGRlZmF1bHQgc2V0dGluZ3MgZm9yIGluaXRpYWxpc2F0aW9uXG4gKlxuICogQG5hbWVzcGFjZVxuICogQG5hbWUgUmVzcG9uc2l2ZS5kZWZhdWx0c1xuICogQHN0YXRpY1xuICovXG5SZXNwb25zaXZlLmRlZmF1bHRzID0ge1xuXHQvKipcblx0ICogTGlzdCBvZiBicmVha3BvaW50cyBmb3IgdGhlIGluc3RhbmNlLiBOb3RlIHRoYXQgdGhpcyBtZWFucyB0aGF0IGVhY2hcblx0ICogaW5zdGFuY2UgY2FuIGhhdmUgaXRzIG93biBicmVha3BvaW50cy4gQWRkaXRpb25hbGx5LCB0aGUgYnJlYWtwb2ludHNcblx0ICogY2Fubm90IGJlIGNoYW5nZWQgb25jZSBhbiBpbnN0YW5jZSBoYXMgYmVlbiBjcmVhc2VkLlxuXHQgKlxuXHQgKiBAdHlwZSB7QXJyYXl9XG5cdCAqIEBkZWZhdWx0IFRha2VzIHRoZSB2YWx1ZSBvZiBgUmVzcG9uc2l2ZS5icmVha3BvaW50c2Bcblx0ICovXG5cdGJyZWFrcG9pbnRzOiBSZXNwb25zaXZlLmJyZWFrcG9pbnRzLFxuXG5cdC8qKlxuXHQgKiBFbmFibGUgLyBkaXNhYmxlIGF1dG8gaGlkaW5nIGNhbGN1bGF0aW9ucy4gSXQgY2FuIGhlbHAgdG8gaW5jcmVhc2Vcblx0ICogcGVyZm9ybWFuY2Ugc2xpZ2h0bHkgaWYgeW91IGRpc2FibGUgdGhpcyBvcHRpb24sIGJ1dCBhbGwgY29sdW1ucyB3b3VsZFxuXHQgKiBuZWVkIHRvIGhhdmUgYnJlYWtwb2ludCBjbGFzc2VzIGFzc2lnbmVkIHRvIHRoZW1cblx0ICpcblx0ICogQHR5cGUge0Jvb2xlYW59XG5cdCAqIEBkZWZhdWx0ICBgdHJ1ZWBcblx0ICovXG5cdGF1dG86IHRydWUsXG5cblx0LyoqXG5cdCAqIERldGFpbHMgY29udHJvbC4gSWYgZ2l2ZW4gYXMgYSBzdHJpbmcgdmFsdWUsIHRoZSBgdHlwZWAgcHJvcGVydHkgb2YgdGhlXG5cdCAqIGRlZmF1bHQgb2JqZWN0IGlzIHNldCB0byB0aGF0IHZhbHVlLCBhbmQgdGhlIGRlZmF1bHRzIHVzZWQgZm9yIHRoZSByZXN0XG5cdCAqIG9mIHRoZSBvYmplY3QgLSB0aGlzIGlzIGZvciBlYXNlIG9mIGltcGxlbWVudGF0aW9uLlxuXHQgKlxuXHQgKiBUaGUgb2JqZWN0IGNvbnNpc3RzIG9mIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcblx0ICpcblx0ICogKiBgZGlzcGxheWAgLSBBIGZ1bmN0aW9uIHRoYXQgaXMgdXNlZCB0byBzaG93IGFuZCBoaWRlIHRoZSBoaWRkZW4gZGV0YWlsc1xuXHQgKiAqIGByZW5kZXJlcmAgLSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCBmb3IgZGlzcGxheSBvZiB0aGUgY2hpbGQgcm93IGRhdGEuXG5cdCAqICAgVGhlIGRlZmF1bHQgZnVuY3Rpb24gd2lsbCBzaG93IHRoZSBkYXRhIGZyb20gdGhlIGhpZGRlbiBjb2x1bW5zXG5cdCAqICogYHRhcmdldGAgLSBVc2VkIGFzIHRoZSBzZWxlY3RvciBmb3Igd2hhdCBvYmplY3RzIHRvIGF0dGFjaCB0aGUgY2hpbGRcblx0ICogICBvcGVuIC8gY2xvc2UgdG9cblx0ICogKiBgdHlwZWAgLSBgZmFsc2VgIHRvIGRpc2FibGUgdGhlIGRldGFpbHMgZGlzcGxheSwgYGlubGluZWAgb3IgYGNvbHVtbmBcblx0ICogICBmb3IgdGhlIHR3byBjb250cm9sIHR5cGVzXG5cdCAqXG5cdCAqIEB0eXBlIHtPYmplY3R8c3RyaW5nfVxuXHQgKi9cblx0ZGV0YWlsczoge1xuXHRcdGRpc3BsYXk6IFJlc3BvbnNpdmUuZGlzcGxheS5jaGlsZFJvdyxcblxuXHRcdHJlbmRlcmVyOiBSZXNwb25zaXZlLnJlbmRlcmVyLmxpc3RIaWRkZW4oKSxcblxuXHRcdHRhcmdldDogMCxcblxuXHRcdHR5cGU6ICdpbmxpbmUnXG5cdH0sXG5cblx0LyoqXG5cdCAqIE9ydGhvZ29uYWwgZGF0YSByZXF1ZXN0IG9wdGlvbi4gVGhpcyBpcyB1c2VkIHRvIGRlZmluZSB0aGUgZGF0YSB0eXBlXG5cdCAqIHJlcXVlc3RlZCB3aGVuIFJlc3BvbnNpdmUgZ2V0cyB0aGUgZGF0YSB0byBzaG93IGluIHRoZSBjaGlsZCByb3cuXG5cdCAqXG5cdCAqIEB0eXBlIHtTdHJpbmd9XG5cdCAqL1xuXHRvcnRob2dvbmFsOiAnZGlzcGxheSdcbn07XG5cbi8qXG4gKiBBUElcbiAqL1xudmFyIEFwaSA9ICQuZm4uZGF0YVRhYmxlLkFwaTtcblxuLy8gRG9lc24ndCBkbyBhbnl0aGluZyAtIHdvcmsgYXJvdW5kIGZvciBhIGJ1ZyBpbiBEVC4uLiBOb3QgZG9jdW1lbnRlZFxuQXBpLnJlZ2lzdGVyKCdyZXNwb25zaXZlKCknLCBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzO1xufSk7XG5cbkFwaS5yZWdpc3RlcigncmVzcG9uc2l2ZS5pbmRleCgpJywgZnVuY3Rpb24gKGxpKSB7XG5cdGxpID0gJChsaSk7XG5cblx0cmV0dXJuIHtcblx0XHRjb2x1bW46IGxpLmRhdGEoJ2R0ci1pbmRleCcpLFxuXHRcdHJvdzogbGkucGFyZW50KCkuZGF0YSgnZHRyLWluZGV4Jylcblx0fTtcbn0pO1xuXG5BcGkucmVnaXN0ZXIoJ3Jlc3BvbnNpdmUucmVidWlsZCgpJywgZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvcigndGFibGUnLCBmdW5jdGlvbiAoY3R4KSB7XG5cdFx0aWYgKGN0eC5fcmVzcG9uc2l2ZSkge1xuXHRcdFx0Y3R4Ll9yZXNwb25zaXZlLl9jbGFzc0xvZ2ljKCk7XG5cdFx0fVxuXHR9KTtcbn0pO1xuXG5BcGkucmVnaXN0ZXIoJ3Jlc3BvbnNpdmUucmVjYWxjKCknLCBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCd0YWJsZScsIGZ1bmN0aW9uIChjdHgpIHtcblx0XHRpZiAoY3R4Ll9yZXNwb25zaXZlKSB7XG5cdFx0XHRjdHguX3Jlc3BvbnNpdmUuX3Jlc2l6ZUF1dG8oKTtcblx0XHRcdGN0eC5fcmVzcG9uc2l2ZS5fcmVzaXplKCk7XG5cdFx0fVxuXHR9KTtcbn0pO1xuXG5BcGkucmVnaXN0ZXIoJ3Jlc3BvbnNpdmUuaGFzSGlkZGVuKCknLCBmdW5jdGlvbiAoKSB7XG5cdHZhciBjdHggPSB0aGlzLmNvbnRleHRbMF07XG5cblx0cmV0dXJuIGN0eC5fcmVzcG9uc2l2ZVxuXHRcdD8gJC5pbkFycmF5KGZhbHNlLCBjdHguX3Jlc3BvbnNpdmUuX3Jlc3BvbnNpdmVPbmx5SGlkZGVuKCkpICE9PSAtMVxuXHRcdDogZmFsc2U7XG59KTtcblxuQXBpLnJlZ2lzdGVyUGx1cmFsKFxuXHQnY29sdW1ucygpLnJlc3BvbnNpdmVIaWRkZW4oKScsXG5cdCdjb2x1bW4oKS5yZXNwb25zaXZlSGlkZGVuKCknLFxuXHRmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoXG5cdFx0XHQnY29sdW1uJyxcblx0XHRcdGZ1bmN0aW9uIChzZXR0aW5ncywgY29sdW1uKSB7XG5cdFx0XHRcdHJldHVybiBzZXR0aW5ncy5fcmVzcG9uc2l2ZVxuXHRcdFx0XHRcdD8gc2V0dGluZ3MuX3Jlc3BvbnNpdmUuX3Jlc3BvbnNpdmVPbmx5SGlkZGVuKClbY29sdW1uXVxuXHRcdFx0XHRcdDogZmFsc2U7XG5cdFx0XHR9LFxuXHRcdFx0MVxuXHRcdCk7XG5cdH1cbik7XG5cbi8qKlxuICogVmVyc2lvbiBpbmZvcm1hdGlvblxuICpcbiAqIEBuYW1lIFJlc3BvbnNpdmUudmVyc2lvblxuICogQHN0YXRpY1xuICovXG5SZXNwb25zaXZlLnZlcnNpb24gPSAnMy4wLjQnO1xuXG4kLmZuLmRhdGFUYWJsZS5SZXNwb25zaXZlID0gUmVzcG9uc2l2ZTtcbiQuZm4uRGF0YVRhYmxlLlJlc3BvbnNpdmUgPSBSZXNwb25zaXZlO1xuXG4vLyBBdHRhY2ggYSBsaXN0ZW5lciB0byB0aGUgZG9jdW1lbnQgd2hpY2ggbGlzdGVucyBmb3IgRGF0YVRhYmxlcyBpbml0aWFsaXNhdGlvblxuLy8gZXZlbnRzIHNvIHdlIGNhbiBhdXRvbWF0aWNhbGx5IGluaXRpYWxpc2VcbiQoZG9jdW1lbnQpLm9uKCdwcmVJbml0LmR0LmR0cicsIGZ1bmN0aW9uIChlLCBzZXR0aW5ncywganNvbikge1xuXHRpZiAoZS5uYW1lc3BhY2UgIT09ICdkdCcpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRpZiAoXG5cdFx0JChzZXR0aW5ncy5uVGFibGUpLmhhc0NsYXNzKCdyZXNwb25zaXZlJykgfHxcblx0XHQkKHNldHRpbmdzLm5UYWJsZSkuaGFzQ2xhc3MoJ2R0LXJlc3BvbnNpdmUnKSB8fFxuXHRcdHNldHRpbmdzLm9Jbml0LnJlc3BvbnNpdmUgfHxcblx0XHREYXRhVGFibGUuZGVmYXVsdHMucmVzcG9uc2l2ZVxuXHQpIHtcblx0XHR2YXIgaW5pdCA9IHNldHRpbmdzLm9Jbml0LnJlc3BvbnNpdmU7XG5cblx0XHRpZiAoaW5pdCAhPT0gZmFsc2UpIHtcblx0XHRcdG5ldyBSZXNwb25zaXZlKHNldHRpbmdzLCAkLmlzUGxhaW5PYmplY3QoaW5pdCkgPyBpbml0IDoge30pO1xuXHRcdH1cblx0fVxufSk7XG5cblxuZXhwb3J0IGRlZmF1bHQgRGF0YVRhYmxlO1xuIiwiLyohIERhdGFUYWJsZXMgMi4zLjFcbiAqIMKpIFNwcnlNZWRpYSBMdGQgLSBkYXRhdGFibGVzLm5ldC9saWNlbnNlXG4gKi9cblxuaW1wb3J0IGpRdWVyeSBmcm9tICdqcXVlcnknO1xuXG4vLyBEYXRhVGFibGVzIGNvZGUgdXNlcyAkIGludGVybmFsbHksIGJ1dCB3ZSB3YW50IHRvIGJlIGFibGUgdG9cbi8vIHJlYXNzaWduICQgd2l0aCB0aGUgYHVzZWAgbWV0aG9kLCBzbyBpdCBpcyBhIHJlZ3VsYXIgdmFyLlxudmFyICQgPSBqUXVlcnk7XG5cblxudmFyIERhdGFUYWJsZSA9IGZ1bmN0aW9uICggc2VsZWN0b3IsIG9wdGlvbnMgKVxue1xuXHQvLyBDaGVjayBpZiBjYWxsZWQgd2l0aCBhIHdpbmRvdyBvciBqUXVlcnkgb2JqZWN0IGZvciBET00gbGVzcyBhcHBsaWNhdGlvbnNcblx0Ly8gVGhpcyBpcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblx0aWYgKERhdGFUYWJsZS5mYWN0b3J5KHNlbGVjdG9yLCBvcHRpb25zKSkge1xuXHRcdHJldHVybiBEYXRhVGFibGU7XG5cdH1cblxuXHQvLyBXaGVuIGNyZWF0aW5nIHdpdGggYG5ld2AsIGNyZWF0ZSBhIG5ldyBEYXRhVGFibGUsIHJldHVybmluZyB0aGUgQVBJIGluc3RhbmNlXG5cdGlmICh0aGlzIGluc3RhbmNlb2YgRGF0YVRhYmxlKSB7XG5cdFx0cmV0dXJuICQoc2VsZWN0b3IpLkRhdGFUYWJsZShvcHRpb25zKTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBBcmd1bWVudCBzd2l0Y2hpbmdcblx0XHRvcHRpb25zID0gc2VsZWN0b3I7XG5cdH1cblxuXHR2YXIgX3RoYXQgPSB0aGlzO1xuXHR2YXIgZW1wdHlJbml0ID0gb3B0aW9ucyA9PT0gdW5kZWZpbmVkO1xuXHR2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG5cblx0aWYgKCBlbXB0eUluaXQgKSB7XG5cdFx0b3B0aW9ucyA9IHt9O1xuXHR9XG5cblx0Ly8gTWV0aG9kIHRvIGdldCBEVCBBUEkgaW5zdGFuY2UgZnJvbSBqUXVlcnkgb2JqZWN0XG5cdHRoaXMuYXBpID0gZnVuY3Rpb24gKClcblx0e1xuXHRcdHJldHVybiBuZXcgX0FwaSggdGhpcyApO1xuXHR9O1xuXG5cdHRoaXMuZWFjaChmdW5jdGlvbigpIHtcblx0XHQvLyBGb3IgZWFjaCBpbml0aWFsaXNhdGlvbiB3ZSB3YW50IHRvIGdpdmUgaXQgYSBjbGVhbiBpbml0aWFsaXNhdGlvblxuXHRcdC8vIG9iamVjdCB0aGF0IGNhbiBiZSBiYXNoZWQgYXJvdW5kXG5cdFx0dmFyIG8gPSB7fTtcblx0XHR2YXIgb0luaXQgPSBsZW4gPiAxID8gLy8gb3B0aW1pc2F0aW9uIGZvciBzaW5nbGUgdGFibGUgY2FzZVxuXHRcdFx0X2ZuRXh0ZW5kKCBvLCBvcHRpb25zLCB0cnVlICkgOlxuXHRcdFx0b3B0aW9ucztcblxuXHRcdFxuXHRcdHZhciBpPTAsIGlMZW47XG5cdFx0dmFyIHNJZCA9IHRoaXMuZ2V0QXR0cmlidXRlKCAnaWQnICk7XG5cdFx0dmFyIGRlZmF1bHRzID0gRGF0YVRhYmxlLmRlZmF1bHRzO1xuXHRcdHZhciAkdGhpcyA9ICQodGhpcyk7XG5cdFx0XG5cdFx0Ly8gU2FuaXR5IGNoZWNrXG5cdFx0aWYgKCB0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT0gJ3RhYmxlJyApXG5cdFx0e1xuXHRcdFx0X2ZuTG9nKCBudWxsLCAwLCAnTm9uLXRhYmxlIG5vZGUgaW5pdGlhbGlzYXRpb24gKCcrdGhpcy5ub2RlTmFtZSsnKScsIDIgKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0XG5cdFx0Ly8gU3BlY2lhbCBjYXNlIGZvciBvcHRpb25zXG5cdFx0aWYgKG9Jbml0Lm9uICYmIG9Jbml0Lm9uLm9wdGlvbnMpIHtcblx0XHRcdF9mbkxpc3RlbmVyKCR0aGlzLCAnb3B0aW9ucycsIG9Jbml0Lm9uLm9wdGlvbnMpO1x0XG5cdFx0fVxuXHRcdFxuXHRcdCR0aGlzLnRyaWdnZXIoICdvcHRpb25zLmR0Jywgb0luaXQgKTtcblx0XHRcblx0XHQvKiBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBmb3IgdGhlIGRlZmF1bHRzICovXG5cdFx0X2ZuQ29tcGF0T3B0cyggZGVmYXVsdHMgKTtcblx0XHRfZm5Db21wYXRDb2xzKCBkZWZhdWx0cy5jb2x1bW4gKTtcblx0XHRcblx0XHQvKiBDb252ZXJ0IHRoZSBjYW1lbC1jYXNlIGRlZmF1bHRzIHRvIEh1bmdhcmlhbiAqL1xuXHRcdF9mbkNhbWVsVG9IdW5nYXJpYW4oIGRlZmF1bHRzLCBkZWZhdWx0cywgdHJ1ZSApO1xuXHRcdF9mbkNhbWVsVG9IdW5nYXJpYW4oIGRlZmF1bHRzLmNvbHVtbiwgZGVmYXVsdHMuY29sdW1uLCB0cnVlICk7XG5cdFx0XG5cdFx0LyogU2V0dGluZyB1cCB0aGUgaW5pdGlhbGlzYXRpb24gb2JqZWN0ICovXG5cdFx0X2ZuQ2FtZWxUb0h1bmdhcmlhbiggZGVmYXVsdHMsICQuZXh0ZW5kKCBvSW5pdCwgJHRoaXMuZGF0YSgpICksIHRydWUgKTtcblx0XHRcblx0XHRcblx0XHRcblx0XHQvKiBDaGVjayB0byBzZWUgaWYgd2UgYXJlIHJlLWluaXRpYWxpc2luZyBhIHRhYmxlICovXG5cdFx0dmFyIGFsbFNldHRpbmdzID0gRGF0YVRhYmxlLnNldHRpbmdzO1xuXHRcdGZvciAoIGk9MCwgaUxlbj1hbGxTZXR0aW5ncy5sZW5ndGggOyBpPGlMZW4gOyBpKysgKVxuXHRcdHtcblx0XHRcdHZhciBzID0gYWxsU2V0dGluZ3NbaV07XG5cdFx0XG5cdFx0XHQvKiBCYXNlIGNoZWNrIG9uIHRhYmxlIG5vZGUgKi9cblx0XHRcdGlmIChcblx0XHRcdFx0cy5uVGFibGUgPT0gdGhpcyB8fFxuXHRcdFx0XHQocy5uVEhlYWQgJiYgcy5uVEhlYWQucGFyZW50Tm9kZSA9PSB0aGlzKSB8fFxuXHRcdFx0XHQocy5uVEZvb3QgJiYgcy5uVEZvb3QucGFyZW50Tm9kZSA9PSB0aGlzKVxuXHRcdFx0KSB7XG5cdFx0XHRcdHZhciBiUmV0cmlldmUgPSBvSW5pdC5iUmV0cmlldmUgIT09IHVuZGVmaW5lZCA/IG9Jbml0LmJSZXRyaWV2ZSA6IGRlZmF1bHRzLmJSZXRyaWV2ZTtcblx0XHRcdFx0dmFyIGJEZXN0cm95ID0gb0luaXQuYkRlc3Ryb3kgIT09IHVuZGVmaW5lZCA/IG9Jbml0LmJEZXN0cm95IDogZGVmYXVsdHMuYkRlc3Ryb3k7XG5cdFx0XG5cdFx0XHRcdGlmICggZW1wdHlJbml0IHx8IGJSZXRyaWV2ZSApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRyZXR1cm4gcy5vSW5zdGFuY2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoIGJEZXN0cm95IClcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG5ldyBEYXRhVGFibGUuQXBpKHMpLmRlc3Ryb3koKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRfZm5Mb2coIHMsIDAsICdDYW5ub3QgcmVpbml0aWFsaXNlIERhdGFUYWJsZScsIDMgKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcblx0XHRcdC8qIElmIHRoZSBlbGVtZW50IHdlIGFyZSBpbml0aWFsaXNpbmcgaGFzIHRoZSBzYW1lIElEIGFzIGEgdGFibGUgd2hpY2ggd2FzIHByZXZpb3VzbHlcblx0XHRcdCAqIGluaXRpYWxpc2VkLCBidXQgdGhlIHRhYmxlIG5vZGVzIGRvbid0IG1hdGNoIChmcm9tIGJlZm9yZSkgdGhlbiB3ZSBkZXN0cm95IHRoZSBvbGRcblx0XHRcdCAqIGluc3RhbmNlIGJ5IHNpbXBseSBkZWxldGluZyBpdC4gVGhpcyBpcyB1bmRlciB0aGUgYXNzdW1wdGlvbiB0aGF0IHRoZSB0YWJsZSBoYXMgYmVlblxuXHRcdFx0ICogZGVzdHJveWVkIGJ5IG90aGVyIG1ldGhvZHMuIEFueW9uZSB1c2luZyBub24taWQgc2VsZWN0b3JzIHdpbGwgbmVlZCB0byBkbyB0aGlzIG1hbnVhbGx5XG5cdFx0XHQgKi9cblx0XHRcdGlmICggcy5zVGFibGVJZCA9PSB0aGlzLmlkIClcblx0XHRcdHtcblx0XHRcdFx0YWxsU2V0dGluZ3Muc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHQvKiBFbnN1cmUgdGhlIHRhYmxlIGhhcyBhbiBJRCAtIHJlcXVpcmVkIGZvciBhY2Nlc3NpYmlsaXR5ICovXG5cdFx0aWYgKCBzSWQgPT09IG51bGwgfHwgc0lkID09PSBcIlwiIClcblx0XHR7XG5cdFx0XHRzSWQgPSBcIkRhdGFUYWJsZXNfVGFibGVfXCIrKERhdGFUYWJsZS5leHQuX3VuaXF1ZSsrKTtcblx0XHRcdHRoaXMuaWQgPSBzSWQ7XG5cdFx0fVxuXHRcdFxuXHRcdC8qIENyZWF0ZSB0aGUgc2V0dGluZ3Mgb2JqZWN0IGZvciB0aGlzIHRhYmxlIGFuZCBzZXQgc29tZSBvZiB0aGUgZGVmYXVsdCBwYXJhbWV0ZXJzICovXG5cdFx0dmFyIG9TZXR0aW5ncyA9ICQuZXh0ZW5kKCB0cnVlLCB7fSwgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3MsIHtcblx0XHRcdFwic0Rlc3Ryb3lXaWR0aFwiOiAkdGhpc1swXS5zdHlsZS53aWR0aCxcblx0XHRcdFwic0luc3RhbmNlXCI6ICAgICBzSWQsXG5cdFx0XHRcInNUYWJsZUlkXCI6ICAgICAgc0lkLFxuXHRcdFx0Y29sZ3JvdXA6ICQoJzxjb2xncm91cD4nKS5wcmVwZW5kVG8odGhpcyksXG5cdFx0XHRmYXN0RGF0YTogZnVuY3Rpb24gKHJvdywgY29sdW1uLCB0eXBlKSB7XG5cdFx0XHRcdHJldHVybiBfZm5HZXRDZWxsRGF0YShvU2V0dGluZ3MsIHJvdywgY29sdW1uLCB0eXBlKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0b1NldHRpbmdzLm5UYWJsZSA9IHRoaXM7XG5cdFx0b1NldHRpbmdzLm9Jbml0ICA9IG9Jbml0O1xuXHRcdFxuXHRcdGFsbFNldHRpbmdzLnB1c2goIG9TZXR0aW5ncyApO1xuXHRcdFxuXHRcdC8vIE1ha2UgYSBzaW5nbGUgQVBJIGluc3RhbmNlIGF2YWlsYWJsZSBmb3IgaW50ZXJuYWwgaGFuZGxpbmdcblx0XHRvU2V0dGluZ3MuYXBpID0gbmV3IF9BcGkoIG9TZXR0aW5ncyApO1xuXHRcdFxuXHRcdC8vIE5lZWQgdG8gYWRkIHRoZSBpbnN0YW5jZSBhZnRlciB0aGUgaW5zdGFuY2UgYWZ0ZXIgdGhlIHNldHRpbmdzIG9iamVjdCBoYXMgYmVlbiBhZGRlZFxuXHRcdC8vIHRvIHRoZSBzZXR0aW5ncyBhcnJheSwgc28gd2UgY2FuIHNlbGYgcmVmZXJlbmNlIHRoZSB0YWJsZSBpbnN0YW5jZSBpZiBtb3JlIHRoYW4gb25lXG5cdFx0b1NldHRpbmdzLm9JbnN0YW5jZSA9IChfdGhhdC5sZW5ndGg9PT0xKSA/IF90aGF0IDogJHRoaXMuZGF0YVRhYmxlKCk7XG5cdFx0XG5cdFx0Ly8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHksIGJlZm9yZSB3ZSBhcHBseSBhbGwgdGhlIGRlZmF1bHRzXG5cdFx0X2ZuQ29tcGF0T3B0cyggb0luaXQgKTtcblx0XHRcblx0XHQvLyBJZiB0aGUgbGVuZ3RoIG1lbnUgaXMgZ2l2ZW4sIGJ1dCB0aGUgaW5pdCBkaXNwbGF5IGxlbmd0aCBpcyBub3QsIHVzZSB0aGUgbGVuZ3RoIG1lbnVcblx0XHRpZiAoIG9Jbml0LmFMZW5ndGhNZW51ICYmICEgb0luaXQuaURpc3BsYXlMZW5ndGggKVxuXHRcdHtcblx0XHRcdG9Jbml0LmlEaXNwbGF5TGVuZ3RoID0gQXJyYXkuaXNBcnJheShvSW5pdC5hTGVuZ3RoTWVudVswXSlcblx0XHRcdFx0PyBvSW5pdC5hTGVuZ3RoTWVudVswXVswXVxuXHRcdFx0XHQ6ICQuaXNQbGFpbk9iamVjdCggb0luaXQuYUxlbmd0aE1lbnVbMF0gKVxuXHRcdFx0XHRcdD8gb0luaXQuYUxlbmd0aE1lbnVbMF0udmFsdWVcblx0XHRcdFx0XHQ6IG9Jbml0LmFMZW5ndGhNZW51WzBdO1xuXHRcdH1cblx0XHRcblx0XHQvLyBBcHBseSB0aGUgZGVmYXVsdHMgYW5kIGluaXQgb3B0aW9ucyB0byBtYWtlIGEgc2luZ2xlIGluaXQgb2JqZWN0IHdpbGwgYWxsXG5cdFx0Ly8gb3B0aW9ucyBkZWZpbmVkIGZyb20gZGVmYXVsdHMgYW5kIGluc3RhbmNlIG9wdGlvbnMuXG5cdFx0b0luaXQgPSBfZm5FeHRlbmQoICQuZXh0ZW5kKCB0cnVlLCB7fSwgZGVmYXVsdHMgKSwgb0luaXQgKTtcblx0XHRcblx0XHRcblx0XHQvLyBNYXAgdGhlIGluaXRpYWxpc2F0aW9uIG9wdGlvbnMgb250byB0aGUgc2V0dGluZ3Mgb2JqZWN0XG5cdFx0X2ZuTWFwKCBvU2V0dGluZ3Mub0ZlYXR1cmVzLCBvSW5pdCwgW1xuXHRcdFx0XCJiUGFnaW5hdGVcIixcblx0XHRcdFwiYkxlbmd0aENoYW5nZVwiLFxuXHRcdFx0XCJiRmlsdGVyXCIsXG5cdFx0XHRcImJTb3J0XCIsXG5cdFx0XHRcImJTb3J0TXVsdGlcIixcblx0XHRcdFwiYkluZm9cIixcblx0XHRcdFwiYlByb2Nlc3NpbmdcIixcblx0XHRcdFwiYkF1dG9XaWR0aFwiLFxuXHRcdFx0XCJiU29ydENsYXNzZXNcIixcblx0XHRcdFwiYlNlcnZlclNpZGVcIixcblx0XHRcdFwiYkRlZmVyUmVuZGVyXCJcblx0XHRdICk7XG5cdFx0X2ZuTWFwKCBvU2V0dGluZ3MsIG9Jbml0LCBbXG5cdFx0XHRcImFqYXhcIixcblx0XHRcdFwiZm5Gb3JtYXROdW1iZXJcIixcblx0XHRcdFwic1NlcnZlck1ldGhvZFwiLFxuXHRcdFx0XCJhYVNvcnRpbmdcIixcblx0XHRcdFwiYWFTb3J0aW5nRml4ZWRcIixcblx0XHRcdFwiYUxlbmd0aE1lbnVcIixcblx0XHRcdFwic1BhZ2luYXRpb25UeXBlXCIsXG5cdFx0XHRcImlTdGF0ZUR1cmF0aW9uXCIsXG5cdFx0XHRcImJTb3J0Q2VsbHNUb3BcIixcblx0XHRcdFwiaVRhYkluZGV4XCIsXG5cdFx0XHRcInNEb21cIixcblx0XHRcdFwiZm5TdGF0ZUxvYWRDYWxsYmFja1wiLFxuXHRcdFx0XCJmblN0YXRlU2F2ZUNhbGxiYWNrXCIsXG5cdFx0XHRcInJlbmRlcmVyXCIsXG5cdFx0XHRcInNlYXJjaERlbGF5XCIsXG5cdFx0XHRcInJvd0lkXCIsXG5cdFx0XHRcImNhcHRpb25cIixcblx0XHRcdFwibGF5b3V0XCIsXG5cdFx0XHRcIm9yZGVyRGVzY1JldmVyc2VcIixcblx0XHRcdFwib3JkZXJJbmRpY2F0b3JzXCIsXG5cdFx0XHRcIm9yZGVySGFuZGxlclwiLFxuXHRcdFx0XCJ0aXRsZVJvd1wiLFxuXHRcdFx0XCJ0eXBlRGV0ZWN0XCIsXG5cdFx0XHRbIFwiaUNvb2tpZUR1cmF0aW9uXCIsIFwiaVN0YXRlRHVyYXRpb25cIiBdLCAvLyBiYWNrd2FyZHMgY29tcGF0XG5cdFx0XHRbIFwib1NlYXJjaFwiLCBcIm9QcmV2aW91c1NlYXJjaFwiIF0sXG5cdFx0XHRbIFwiYW9TZWFyY2hDb2xzXCIsIFwiYW9QcmVTZWFyY2hDb2xzXCIgXSxcblx0XHRcdFsgXCJpRGlzcGxheUxlbmd0aFwiLCBcIl9pRGlzcGxheUxlbmd0aFwiIF1cblx0XHRdICk7XG5cdFx0X2ZuTWFwKCBvU2V0dGluZ3Mub1Njcm9sbCwgb0luaXQsIFtcblx0XHRcdFsgXCJzU2Nyb2xsWFwiLCBcInNYXCIgXSxcblx0XHRcdFsgXCJzU2Nyb2xsWElubmVyXCIsIFwic1hJbm5lclwiIF0sXG5cdFx0XHRbIFwic1Njcm9sbFlcIiwgXCJzWVwiIF0sXG5cdFx0XHRbIFwiYlNjcm9sbENvbGxhcHNlXCIsIFwiYkNvbGxhcHNlXCIgXVxuXHRcdF0gKTtcblx0XHRfZm5NYXAoIG9TZXR0aW5ncy5vTGFuZ3VhZ2UsIG9Jbml0LCBcImZuSW5mb0NhbGxiYWNrXCIgKTtcblx0XHRcblx0XHQvKiBDYWxsYmFjayBmdW5jdGlvbnMgd2hpY2ggYXJlIGFycmF5IGRyaXZlbiAqL1xuXHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb0RyYXdDYWxsYmFjaycsICAgICAgIG9Jbml0LmZuRHJhd0NhbGxiYWNrICk7XG5cdFx0X2ZuQ2FsbGJhY2tSZWcoIG9TZXR0aW5ncywgJ2FvU3RhdGVTYXZlUGFyYW1zJywgICAgb0luaXQuZm5TdGF0ZVNhdmVQYXJhbXMgKTtcblx0XHRfZm5DYWxsYmFja1JlZyggb1NldHRpbmdzLCAnYW9TdGF0ZUxvYWRQYXJhbXMnLCAgICBvSW5pdC5mblN0YXRlTG9hZFBhcmFtcyApO1xuXHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb1N0YXRlTG9hZGVkJywgICAgICAgIG9Jbml0LmZuU3RhdGVMb2FkZWQgKTtcblx0XHRfZm5DYWxsYmFja1JlZyggb1NldHRpbmdzLCAnYW9Sb3dDYWxsYmFjaycsICAgICAgICBvSW5pdC5mblJvd0NhbGxiYWNrICk7XG5cdFx0X2ZuQ2FsbGJhY2tSZWcoIG9TZXR0aW5ncywgJ2FvUm93Q3JlYXRlZENhbGxiYWNrJywgb0luaXQuZm5DcmVhdGVkUm93ICk7XG5cdFx0X2ZuQ2FsbGJhY2tSZWcoIG9TZXR0aW5ncywgJ2FvSGVhZGVyQ2FsbGJhY2snLCAgICAgb0luaXQuZm5IZWFkZXJDYWxsYmFjayApO1xuXHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb0Zvb3RlckNhbGxiYWNrJywgICAgIG9Jbml0LmZuRm9vdGVyQ2FsbGJhY2sgKTtcblx0XHRfZm5DYWxsYmFja1JlZyggb1NldHRpbmdzLCAnYW9Jbml0Q29tcGxldGUnLCAgICAgICBvSW5pdC5mbkluaXRDb21wbGV0ZSApO1xuXHRcdF9mbkNhbGxiYWNrUmVnKCBvU2V0dGluZ3MsICdhb1ByZURyYXdDYWxsYmFjaycsICAgIG9Jbml0LmZuUHJlRHJhd0NhbGxiYWNrICk7XG5cdFx0XG5cdFx0b1NldHRpbmdzLnJvd0lkRm4gPSBfZm5HZXRPYmplY3REYXRhRm4oIG9Jbml0LnJvd0lkICk7XG5cdFx0XG5cdFx0Ly8gQWRkIGV2ZW50IGxpc3RlbmVyc1xuXHRcdGlmIChvSW5pdC5vbikge1xuXHRcdFx0T2JqZWN0LmtleXMob0luaXQub24pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0XHRfZm5MaXN0ZW5lcigkdGhpcywga2V5LCBvSW5pdC5vbltrZXldKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRcblx0XHQvKiBCcm93c2VyIHN1cHBvcnQgZGV0ZWN0aW9uICovXG5cdFx0X2ZuQnJvd3NlckRldGVjdCggb1NldHRpbmdzICk7XG5cdFx0XG5cdFx0dmFyIG9DbGFzc2VzID0gb1NldHRpbmdzLm9DbGFzc2VzO1xuXHRcdFxuXHRcdCQuZXh0ZW5kKCBvQ2xhc3NlcywgRGF0YVRhYmxlLmV4dC5jbGFzc2VzLCBvSW5pdC5vQ2xhc3NlcyApO1xuXHRcdCR0aGlzLmFkZENsYXNzKCBvQ2xhc3Nlcy50YWJsZSApO1xuXHRcdFxuXHRcdGlmICghIG9TZXR0aW5ncy5vRmVhdHVyZXMuYlBhZ2luYXRlKSB7XG5cdFx0XHRvSW5pdC5pRGlzcGxheVN0YXJ0ID0gMDtcblx0XHR9XG5cdFx0XG5cdFx0aWYgKCBvU2V0dGluZ3MuaUluaXREaXNwbGF5U3RhcnQgPT09IHVuZGVmaW5lZCApXG5cdFx0e1xuXHRcdFx0LyogRGlzcGxheSBzdGFydCBwb2ludCwgdGFraW5nIGludG8gYWNjb3VudCB0aGUgc2F2ZSBzYXZpbmcgKi9cblx0XHRcdG9TZXR0aW5ncy5pSW5pdERpc3BsYXlTdGFydCA9IG9Jbml0LmlEaXNwbGF5U3RhcnQ7XG5cdFx0XHRvU2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQgPSBvSW5pdC5pRGlzcGxheVN0YXJ0O1xuXHRcdH1cblx0XHRcblx0XHR2YXIgZGVmZXIgPSBvSW5pdC5pRGVmZXJMb2FkaW5nO1xuXHRcdGlmICggZGVmZXIgIT09IG51bGwgKVxuXHRcdHtcblx0XHRcdG9TZXR0aW5ncy5kZWZlckxvYWRpbmcgPSB0cnVlO1xuXHRcdFxuXHRcdFx0dmFyIHRtcCA9IEFycmF5LmlzQXJyYXkoZGVmZXIpO1xuXHRcdFx0b1NldHRpbmdzLl9pUmVjb3Jkc0Rpc3BsYXkgPSB0bXAgPyBkZWZlclswXSA6IGRlZmVyO1xuXHRcdFx0b1NldHRpbmdzLl9pUmVjb3Jkc1RvdGFsID0gdG1wID8gZGVmZXJbMV0gOiBkZWZlcjtcblx0XHR9XG5cdFx0XG5cdFx0Lypcblx0XHQgKiBDb2x1bW5zXG5cdFx0ICogU2VlIGlmIHdlIHNob3VsZCBsb2FkIGNvbHVtbnMgYXV0b21hdGljYWxseSBvciB1c2UgZGVmaW5lZCBvbmVzXG5cdFx0ICovXG5cdFx0dmFyIGNvbHVtbnNJbml0ID0gW107XG5cdFx0dmFyIHRoZWFkID0gdGhpcy5nZXRFbGVtZW50c0J5VGFnTmFtZSgndGhlYWQnKTtcblx0XHR2YXIgaW5pdEhlYWRlckxheW91dCA9IF9mbkRldGVjdEhlYWRlciggb1NldHRpbmdzLCB0aGVhZFswXSApO1xuXHRcdFxuXHRcdC8vIElmIHdlIGRvbid0IGhhdmUgYSBjb2x1bW5zIGFycmF5LCB0aGVuIGdlbmVyYXRlIG9uZSB3aXRoIG51bGxzXG5cdFx0aWYgKCBvSW5pdC5hb0NvbHVtbnMgKSB7XG5cdFx0XHRjb2x1bW5zSW5pdCA9IG9Jbml0LmFvQ29sdW1ucztcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIGluaXRIZWFkZXJMYXlvdXQubGVuZ3RoICkge1xuXHRcdFx0Zm9yICggaT0wLCBpTGVuPWluaXRIZWFkZXJMYXlvdXRbMF0ubGVuZ3RoIDsgaTxpTGVuIDsgaSsrICkge1xuXHRcdFx0XHRjb2x1bW5zSW5pdC5wdXNoKCBudWxsICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdC8vIEFkZCB0aGUgY29sdW1uc1xuXHRcdGZvciAoIGk9MCwgaUxlbj1jb2x1bW5zSW5pdC5sZW5ndGggOyBpPGlMZW4gOyBpKysgKSB7XG5cdFx0XHRfZm5BZGRDb2x1bW4oIG9TZXR0aW5ncyApO1xuXHRcdH1cblx0XHRcblx0XHQvLyBBcHBseSB0aGUgY29sdW1uIGRlZmluaXRpb25zXG5cdFx0X2ZuQXBwbHlDb2x1bW5EZWZzKCBvU2V0dGluZ3MsIG9Jbml0LmFvQ29sdW1uRGVmcywgY29sdW1uc0luaXQsIGluaXRIZWFkZXJMYXlvdXQsIGZ1bmN0aW9uIChpQ29sLCBvRGVmKSB7XG5cdFx0XHRfZm5Db2x1bW5PcHRpb25zKCBvU2V0dGluZ3MsIGlDb2wsIG9EZWYgKTtcblx0XHR9ICk7XG5cdFx0XG5cdFx0LyogSFRNTDUgYXR0cmlidXRlIGRldGVjdGlvbiAtIGJ1aWxkIGFuIG1EYXRhIG9iamVjdCBhdXRvbWF0aWNhbGx5IGlmIHRoZVxuXHRcdCAqIGF0dHJpYnV0ZXMgYXJlIGZvdW5kXG5cdFx0ICovXG5cdFx0dmFyIHJvd09uZSA9ICR0aGlzLmNoaWxkcmVuKCd0Ym9keScpLmZpbmQoJ3RyOmZpcnN0LWNoaWxkJykuZXEoMCk7XG5cdFx0XG5cdFx0aWYgKCByb3dPbmUubGVuZ3RoICkge1xuXHRcdFx0dmFyIGEgPSBmdW5jdGlvbiAoIGNlbGwsIG5hbWUgKSB7XG5cdFx0XHRcdHJldHVybiBjZWxsLmdldEF0dHJpYnV0ZSggJ2RhdGEtJytuYW1lICkgIT09IG51bGwgPyBuYW1lIDogbnVsbDtcblx0XHRcdH07XG5cdFx0XG5cdFx0XHQkKCByb3dPbmVbMF0gKS5jaGlsZHJlbigndGgsIHRkJykuZWFjaCggZnVuY3Rpb24gKGksIGNlbGwpIHtcblx0XHRcdFx0dmFyIGNvbCA9IG9TZXR0aW5ncy5hb0NvbHVtbnNbaV07XG5cdFx0XG5cdFx0XHRcdGlmICghIGNvbCkge1xuXHRcdFx0XHRcdF9mbkxvZyggb1NldHRpbmdzLCAwLCAnSW5jb3JyZWN0IGNvbHVtbiBjb3VudCcsIDE4ICk7XG5cdFx0XHRcdH1cblx0XHRcblx0XHRcdFx0aWYgKCBjb2wubURhdGEgPT09IGkgKSB7XG5cdFx0XHRcdFx0dmFyIHNvcnQgPSBhKCBjZWxsLCAnc29ydCcgKSB8fCBhKCBjZWxsLCAnb3JkZXInICk7XG5cdFx0XHRcdFx0dmFyIGZpbHRlciA9IGEoIGNlbGwsICdmaWx0ZXInICkgfHwgYSggY2VsbCwgJ3NlYXJjaCcgKTtcblx0XHRcblx0XHRcdFx0XHRpZiAoIHNvcnQgIT09IG51bGwgfHwgZmlsdGVyICE9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0Y29sLm1EYXRhID0ge1xuXHRcdFx0XHRcdFx0XHRfOiAgICAgIGkrJy5kaXNwbGF5Jyxcblx0XHRcdFx0XHRcdFx0c29ydDogICBzb3J0ICE9PSBudWxsICAgPyBpKycuQGRhdGEtJytzb3J0ICAgOiB1bmRlZmluZWQsXG5cdFx0XHRcdFx0XHRcdHR5cGU6ICAgc29ydCAhPT0gbnVsbCAgID8gaSsnLkBkYXRhLScrc29ydCAgIDogdW5kZWZpbmVkLFxuXHRcdFx0XHRcdFx0XHRmaWx0ZXI6IGZpbHRlciAhPT0gbnVsbCA/IGkrJy5AZGF0YS0nK2ZpbHRlciA6IHVuZGVmaW5lZFxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdGNvbC5faXNBcnJheUhvc3QgPSB0cnVlO1xuXHRcdFxuXHRcdFx0XHRcdFx0X2ZuQ29sdW1uT3B0aW9ucyggb1NldHRpbmdzLCBpICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIE11c3QgYmUgZG9uZSBhZnRlciBldmVyeXRoaW5nIHdoaWNoIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHRoZSBzdGF0ZSBzYXZpbmchXG5cdFx0X2ZuQ2FsbGJhY2tSZWcoIG9TZXR0aW5ncywgJ2FvRHJhd0NhbGxiYWNrJywgX2ZuU2F2ZVN0YXRlICk7XG5cdFx0XG5cdFx0dmFyIGZlYXR1cmVzID0gb1NldHRpbmdzLm9GZWF0dXJlcztcblx0XHRpZiAoIG9Jbml0LmJTdGF0ZVNhdmUgKVxuXHRcdHtcblx0XHRcdGZlYXR1cmVzLmJTdGF0ZVNhdmUgPSB0cnVlO1xuXHRcdH1cblx0XHRcblx0XHQvLyBJZiBhYVNvcnRpbmcgaXMgbm90IGRlZmluZWQsIHRoZW4gd2UgdXNlIHRoZSBmaXJzdCBpbmRpY2F0b3IgaW4gYXNTb3J0aW5nXG5cdFx0Ly8gaW4gY2FzZSB0aGF0IGhhcyBiZWVuIGFsdGVyZWQsIHNvIHRoZSBkZWZhdWx0IHNvcnQgcmVmbGVjdHMgdGhhdCBvcHRpb25cblx0XHRpZiAoIG9Jbml0LmFhU29ydGluZyA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dmFyIHNvcnRpbmcgPSBvU2V0dGluZ3MuYWFTb3J0aW5nO1xuXHRcdFx0Zm9yICggaT0wLCBpTGVuPXNvcnRpbmcubGVuZ3RoIDsgaTxpTGVuIDsgaSsrICkge1xuXHRcdFx0XHRzb3J0aW5nW2ldWzFdID0gb1NldHRpbmdzLmFvQ29sdW1uc1sgaSBdLmFzU29ydGluZ1swXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0Ly8gRG8gYSBmaXJzdCBwYXNzIG9uIHRoZSBzb3J0aW5nIGNsYXNzZXMgKGFsbG93cyBhbnkgc2l6ZSBjaGFuZ2VzIHRvIGJlIHRha2VuIGludG9cblx0XHQvLyBhY2NvdW50LCBhbmQgYWxzbyB3aWxsIGFwcGx5IHNvcnRpbmcgZGlzYWJsZWQgY2xhc3NlcyBpZiBkaXNhYmxlZFxuXHRcdF9mblNvcnRpbmdDbGFzc2VzKCBvU2V0dGluZ3MgKTtcblx0XHRcblx0XHRfZm5DYWxsYmFja1JlZyggb1NldHRpbmdzLCAnYW9EcmF3Q2FsbGJhY2snLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAoIG9TZXR0aW5ncy5iU29ydGVkIHx8IF9mbkRhdGFTb3VyY2UoIG9TZXR0aW5ncyApID09PSAnc3NwJyB8fCBmZWF0dXJlcy5iRGVmZXJSZW5kZXIgKSB7XG5cdFx0XHRcdF9mblNvcnRpbmdDbGFzc2VzKCBvU2V0dGluZ3MgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0XG5cdFx0XG5cdFx0Lypcblx0XHQgKiBUYWJsZSBIVE1MIGluaXRcblx0XHQgKiBDYWNoZSB0aGUgaGVhZGVyLCBib2R5IGFuZCBmb290ZXIgYXMgcmVxdWlyZWQsIGNyZWF0aW5nIHRoZW0gaWYgbmVlZGVkXG5cdFx0ICovXG5cdFx0dmFyIGNhcHRpb24gPSAkdGhpcy5jaGlsZHJlbignY2FwdGlvbicpO1xuXHRcdFxuXHRcdGlmICggb1NldHRpbmdzLmNhcHRpb24gKSB7XG5cdFx0XHRpZiAoIGNhcHRpb24ubGVuZ3RoID09PSAwICkge1xuXHRcdFx0XHRjYXB0aW9uID0gJCgnPGNhcHRpb24vPicpLmFwcGVuZFRvKCAkdGhpcyApO1xuXHRcdFx0fVxuXHRcdFxuXHRcdFx0Y2FwdGlvbi5odG1sKCBvU2V0dGluZ3MuY2FwdGlvbiApO1xuXHRcdH1cblx0XHRcblx0XHQvLyBTdG9yZSB0aGUgY2FwdGlvbiBzaWRlLCBzbyB3ZSBjYW4gcmVtb3ZlIHRoZSBlbGVtZW50IGZyb20gdGhlIGRvY3VtZW50XG5cdFx0Ly8gd2hlbiBjcmVhdGluZyB0aGUgZWxlbWVudFxuXHRcdGlmIChjYXB0aW9uLmxlbmd0aCkge1xuXHRcdFx0Y2FwdGlvblswXS5fY2FwdGlvblNpZGUgPSBjYXB0aW9uLmNzcygnY2FwdGlvbi1zaWRlJyk7XG5cdFx0XHRvU2V0dGluZ3MuY2FwdGlvbk5vZGUgPSBjYXB0aW9uWzBdO1xuXHRcdH1cblx0XHRcblx0XHRpZiAoIHRoZWFkLmxlbmd0aCA9PT0gMCApIHtcblx0XHRcdHRoZWFkID0gJCgnPHRoZWFkLz4nKS5hcHBlbmRUbygkdGhpcyk7XG5cdFx0fVxuXHRcdG9TZXR0aW5ncy5uVEhlYWQgPSB0aGVhZFswXTtcblx0XHRcblx0XHR2YXIgdGJvZHkgPSAkdGhpcy5jaGlsZHJlbigndGJvZHknKTtcblx0XHRpZiAoIHRib2R5Lmxlbmd0aCA9PT0gMCApIHtcblx0XHRcdHRib2R5ID0gJCgnPHRib2R5Lz4nKS5pbnNlcnRBZnRlcih0aGVhZCk7XG5cdFx0fVxuXHRcdG9TZXR0aW5ncy5uVEJvZHkgPSB0Ym9keVswXTtcblx0XHRcblx0XHR2YXIgdGZvb3QgPSAkdGhpcy5jaGlsZHJlbigndGZvb3QnKTtcblx0XHRpZiAoIHRmb290Lmxlbmd0aCA9PT0gMCApIHtcblx0XHRcdC8vIElmIHdlIGFyZSBhIHNjcm9sbGluZyB0YWJsZSwgYW5kIG5vIGZvb3RlciBoYXMgYmVlbiBnaXZlbiwgdGhlbiB3ZSBuZWVkIHRvIGNyZWF0ZVxuXHRcdFx0Ly8gYSB0Zm9vdCBlbGVtZW50IGZvciB0aGUgY2FwdGlvbiBlbGVtZW50IHRvIGJlIGFwcGVuZGVkIHRvXG5cdFx0XHR0Zm9vdCA9ICQoJzx0Zm9vdC8+JykuYXBwZW5kVG8oJHRoaXMpO1xuXHRcdH1cblx0XHRvU2V0dGluZ3MublRGb290ID0gdGZvb3RbMF07XG5cdFx0XG5cdFx0Ly8gQ29weSB0aGUgZGF0YSBpbmRleCBhcnJheVxuXHRcdG9TZXR0aW5ncy5haURpc3BsYXkgPSBvU2V0dGluZ3MuYWlEaXNwbGF5TWFzdGVyLnNsaWNlKCk7XG5cdFx0XG5cdFx0Ly8gSW5pdGlhbGlzYXRpb24gY29tcGxldGUgLSB0YWJsZSBjYW4gYmUgZHJhd25cblx0XHRvU2V0dGluZ3MuYkluaXRpYWxpc2VkID0gdHJ1ZTtcblx0XHRcblx0XHQvLyBMYW5ndWFnZSBkZWZpbml0aW9uc1xuXHRcdHZhciBvTGFuZ3VhZ2UgPSBvU2V0dGluZ3Mub0xhbmd1YWdlO1xuXHRcdCQuZXh0ZW5kKCB0cnVlLCBvTGFuZ3VhZ2UsIG9Jbml0Lm9MYW5ndWFnZSApO1xuXHRcdFxuXHRcdGlmICggb0xhbmd1YWdlLnNVcmwgKSB7XG5cdFx0XHQvLyBHZXQgdGhlIGxhbmd1YWdlIGRlZmluaXRpb25zIGZyb20gYSBmaWxlXG5cdFx0XHQkLmFqYXgoIHtcblx0XHRcdFx0ZGF0YVR5cGU6ICdqc29uJyxcblx0XHRcdFx0dXJsOiBvTGFuZ3VhZ2Uuc1VybCxcblx0XHRcdFx0c3VjY2VzczogZnVuY3Rpb24gKCBqc29uICkge1xuXHRcdFx0XHRcdF9mbkNhbWVsVG9IdW5nYXJpYW4oIGRlZmF1bHRzLm9MYW5ndWFnZSwganNvbiApO1xuXHRcdFx0XHRcdCQuZXh0ZW5kKCB0cnVlLCBvTGFuZ3VhZ2UsIGpzb24sIG9TZXR0aW5ncy5vSW5pdC5vTGFuZ3VhZ2UgKTtcblx0XHRcblx0XHRcdFx0XHRfZm5DYWxsYmFja0ZpcmUoIG9TZXR0aW5ncywgbnVsbCwgJ2kxOG4nLCBbb1NldHRpbmdzXSwgdHJ1ZSk7XG5cdFx0XHRcdFx0X2ZuSW5pdGlhbGlzZSggb1NldHRpbmdzICk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGVycm9yOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0Ly8gRXJyb3Igb2NjdXJyZWQgbG9hZGluZyBsYW5ndWFnZSBmaWxlXG5cdFx0XHRcdFx0X2ZuTG9nKCBvU2V0dGluZ3MsIDAsICdpMThuIGZpbGUgbG9hZGluZyBlcnJvcicsIDIxICk7XG5cdFx0XG5cdFx0XHRcdFx0Ly8gQ29udGludWUgb24gYXMgYmVzdCB3ZSBjYW5cblx0XHRcdFx0XHRfZm5Jbml0aWFsaXNlKCBvU2V0dGluZ3MgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdF9mbkNhbGxiYWNrRmlyZSggb1NldHRpbmdzLCBudWxsLCAnaTE4bicsIFtvU2V0dGluZ3NdLCB0cnVlKTtcblx0XHRcdF9mbkluaXRpYWxpc2UoIG9TZXR0aW5ncyApO1xuXHRcdH1cblx0fSApO1xuXHRfdGhhdCA9IG51bGw7XG5cdHJldHVybiB0aGlzO1xufTtcblxuXG5cbi8qKlxuICogRGF0YVRhYmxlcyBleHRlbnNpb25zXG4gKiBcbiAqIFRoaXMgbmFtZXNwYWNlIGFjdHMgYXMgYSBjb2xsZWN0aW9uIGFyZWEgZm9yIHBsdWctaW5zIHRoYXQgY2FuIGJlIHVzZWQgdG9cbiAqIGV4dGVuZCBEYXRhVGFibGVzIGNhcGFiaWxpdGllcy4gSW5kZWVkIG1hbnkgb2YgdGhlIGJ1aWxkIGluIG1ldGhvZHNcbiAqIHVzZSB0aGlzIG1ldGhvZCB0byBwcm92aWRlIHRoZWlyIG93biBjYXBhYmlsaXRpZXMgKHNvcnRpbmcgbWV0aG9kcyBmb3JcbiAqIGV4YW1wbGUpLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIG5hbWVzcGFjZSBpcyBhbGlhc2VkIHRvIGBqUXVlcnkuZm4uZGF0YVRhYmxlRXh0YCBmb3IgbGVnYWN5XG4gKiByZWFzb25zXG4gKlxuICogIEBuYW1lc3BhY2VcbiAqL1xuRGF0YVRhYmxlLmV4dCA9IF9leHQgPSB7XG5cdC8qKlxuXHQgKiBEYXRhVGFibGVzIGJ1aWxkIHR5cGUgKGV4cGFuZGVkIGJ5IHRoZSBkb3dubG9hZCBidWlsZGVyKVxuXHQgKlxuXHQgKiAgQHR5cGUgc3RyaW5nXG5cdCAqL1xuXHRidWlsZGVyOiBcIi1zb3VyY2UtXCIsXG5cblx0LyoqXG5cdCAqIEJ1dHRvbnMuIEZvciB1c2Ugd2l0aCB0aGUgQnV0dG9ucyBleHRlbnNpb24gZm9yIERhdGFUYWJsZXMuIFRoaXMgaXNcblx0ICogZGVmaW5lZCBoZXJlIHNvIG90aGVyIGV4dGVuc2lvbnMgY2FuIGRlZmluZSBidXR0b25zIHJlZ2FyZGxlc3Mgb2YgbG9hZFxuXHQgKiBvcmRlci4gSXQgaXMgX25vdF8gdXNlZCBieSBEYXRhVGFibGVzIGNvcmUuXG5cdCAqXG5cdCAqICBAdHlwZSBvYmplY3Rcblx0ICogIEBkZWZhdWx0IHt9XG5cdCAqL1xuXHRidXR0b25zOiB7fSxcblxuXG5cdC8qKlxuXHQgKiBDb2x1bW5Db250cm9sIGJ1dHRvbnMgYW5kIGNvbnRlbnRcblx0ICpcblx0ICogIEB0eXBlIG9iamVjdFxuXHQgKi9cblx0Y2NDb250ZW50OiB7fSxcblxuXG5cdC8qKlxuXHQgKiBFbGVtZW50IGNsYXNzIG5hbWVzXG5cdCAqXG5cdCAqICBAdHlwZSBvYmplY3Rcblx0ICogIEBkZWZhdWx0IHt9XG5cdCAqL1xuXHRjbGFzc2VzOiB7fSxcblxuXG5cdC8qKlxuXHQgKiBFcnJvciByZXBvcnRpbmcuXG5cdCAqIFxuXHQgKiBIb3cgc2hvdWxkIERhdGFUYWJsZXMgcmVwb3J0IGFuIGVycm9yLiBDYW4gdGFrZSB0aGUgdmFsdWUgJ2FsZXJ0Jyxcblx0ICogJ3Rocm93JywgJ25vbmUnIG9yIGEgZnVuY3Rpb24uXG5cdCAqXG5cdCAqICBAdHlwZSBzdHJpbmd8ZnVuY3Rpb25cblx0ICogIEBkZWZhdWx0IGFsZXJ0XG5cdCAqL1xuXHRlcnJNb2RlOiBcImFsZXJ0XCIsXG5cblxuXHQvKipcblx0ICogTGVnYWN5IHNvIHYxIHBsdWctaW5zIGRvbid0IHRocm93IGpzIGVycm9ycyBvbiBsb2FkXG5cdCAqL1xuXHRmZWF0dXJlOiBbXSxcblxuXHQvKipcblx0ICogRmVhdHVyZSBwbHVnLWlucy5cblx0ICogXG5cdCAqIFRoaXMgaXMgYW4gb2JqZWN0IG9mIGNhbGxiYWNrcyB3aGljaCBwcm92aWRlIHRoZSBmZWF0dXJlcyBmb3IgRGF0YVRhYmxlc1xuXHQgKiB0byBiZSBpbml0aWFsaXNlZCB2aWEgdGhlIGBsYXlvdXRgIG9wdGlvbi5cblx0ICovXG5cdGZlYXR1cmVzOiB7fSxcblxuXG5cdC8qKlxuXHQgKiBSb3cgc2VhcmNoaW5nLlxuXHQgKiBcblx0ICogVGhpcyBtZXRob2Qgb2Ygc2VhcmNoaW5nIGlzIGNvbXBsaW1lbnRhcnkgdG8gdGhlIGRlZmF1bHQgdHlwZSBiYXNlZFxuXHQgKiBzZWFyY2hpbmcsIGFuZCBhIGxvdCBtb3JlIGNvbXByZWhlbnNpdmUgYXMgaXQgYWxsb3dzIHlvdSBjb21wbGV0ZSBjb250cm9sXG5cdCAqIG92ZXIgdGhlIHNlYXJjaGluZyBsb2dpYy4gRWFjaCBlbGVtZW50IGluIHRoaXMgYXJyYXkgaXMgYSBmdW5jdGlvblxuXHQgKiAocGFyYW1ldGVycyBkZXNjcmliZWQgYmVsb3cpIHRoYXQgaXMgY2FsbGVkIGZvciBldmVyeSByb3cgaW4gdGhlIHRhYmxlLFxuXHQgKiBhbmQgeW91ciBsb2dpYyBkZWNpZGVzIGlmIGl0IHNob3VsZCBiZSBpbmNsdWRlZCBpbiB0aGUgc2VhcmNoaW5nIGRhdGEgc2V0XG5cdCAqIG9yIG5vdC5cblx0ICpcblx0ICogU2VhcmNoaW5nIGZ1bmN0aW9ucyBoYXZlIHRoZSBmb2xsb3dpbmcgaW5wdXQgcGFyYW1ldGVyczpcblx0ICpcblx0ICogMS4gYHtvYmplY3R9YCBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdDogc2VlXG5cdCAqICAgIHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc31cblx0ICogMi4gYHthcnJheXxvYmplY3R9YCBEYXRhIGZvciB0aGUgcm93IHRvIGJlIHByb2Nlc3NlZCAoc2FtZSBhcyB0aGVcblx0ICogICAgb3JpZ2luYWwgZm9ybWF0IHRoYXQgd2FzIHBhc3NlZCBpbiBhcyB0aGUgZGF0YSBzb3VyY2UsIG9yIGFuIGFycmF5XG5cdCAqICAgIGZyb20gYSBET00gZGF0YSBzb3VyY2Vcblx0ICogMy4gYHtpbnR9YCBSb3cgaW5kZXggKHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5ncy5hb0RhdGF9KSwgd2hpY2hcblx0ICogICAgY2FuIGJlIHVzZWZ1bCB0byByZXRyaWV2ZSB0aGUgYFRSYCBlbGVtZW50IGlmIHlvdSBuZWVkIERPTSBpbnRlcmFjdGlvbi5cblx0ICpcblx0ICogQW5kIHRoZSBmb2xsb3dpbmcgcmV0dXJuIGlzIGV4cGVjdGVkOlxuXHQgKlxuXHQgKiAqIHtib29sZWFufSBJbmNsdWRlIHRoZSByb3cgaW4gdGhlIHNlYXJjaGVkIHJlc3VsdCBzZXQgKHRydWUpIG9yIG5vdFxuXHQgKiAgIChmYWxzZSlcblx0ICpcblx0ICogTm90ZSB0aGF0IGFzIHdpdGggdGhlIG1haW4gc2VhcmNoIGFiaWxpdHkgaW4gRGF0YVRhYmxlcywgdGVjaG5pY2FsbHkgdGhpc1xuXHQgKiBpcyBcImZpbHRlcmluZ1wiLCBzaW5jZSBpdCBpcyBzdWJ0cmFjdGl2ZS4gSG93ZXZlciwgZm9yIGNvbnNpc3RlbmN5IGluXG5cdCAqIG5hbWluZyB3ZSBjYWxsIGl0IHNlYXJjaGluZyBoZXJlLlxuXHQgKlxuXHQgKiAgQHR5cGUgYXJyYXlcblx0ICogIEBkZWZhdWx0IFtdXG5cdCAqXG5cdCAqICBAZXhhbXBsZVxuXHQgKiAgICAvLyBUaGUgZm9sbG93aW5nIGV4YW1wbGUgc2hvd3MgY3VzdG9tIHNlYXJjaCBiZWluZyBhcHBsaWVkIHRvIHRoZVxuXHQgKiAgICAvLyBmb3VydGggY29sdW1uIChpLmUuIHRoZSBkYXRhWzNdIGluZGV4KSBiYXNlZCBvbiB0d28gaW5wdXQgdmFsdWVzXG5cdCAqICAgIC8vIGZyb20gdGhlIGVuZC11c2VyLCBtYXRjaGluZyB0aGUgZGF0YSBpbiBhIGNlcnRhaW4gcmFuZ2UuXG5cdCAqICAgICQuZm4uZGF0YVRhYmxlLmV4dC5zZWFyY2gucHVzaChcblx0ICogICAgICBmdW5jdGlvbiggc2V0dGluZ3MsIGRhdGEsIGRhdGFJbmRleCApIHtcblx0ICogICAgICAgIHZhciBtaW4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWluJykudmFsdWUgKiAxO1xuXHQgKiAgICAgICAgdmFyIG1heCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtYXgnKS52YWx1ZSAqIDE7XG5cdCAqICAgICAgICB2YXIgdmVyc2lvbiA9IGRhdGFbM10gPT0gXCItXCIgPyAwIDogZGF0YVszXSoxO1xuXHQgKlxuXHQgKiAgICAgICAgaWYgKCBtaW4gPT0gXCJcIiAmJiBtYXggPT0gXCJcIiApIHtcblx0ICogICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAqICAgICAgICB9XG5cdCAqICAgICAgICBlbHNlIGlmICggbWluID09IFwiXCIgJiYgdmVyc2lvbiA8IG1heCApIHtcblx0ICogICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAqICAgICAgICB9XG5cdCAqICAgICAgICBlbHNlIGlmICggbWluIDwgdmVyc2lvbiAmJiBcIlwiID09IG1heCApIHtcblx0ICogICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAqICAgICAgICB9XG5cdCAqICAgICAgICBlbHNlIGlmICggbWluIDwgdmVyc2lvbiAmJiB2ZXJzaW9uIDwgbWF4ICkge1xuXHQgKiAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICogICAgICAgIH1cblx0ICogICAgICAgIHJldHVybiBmYWxzZTtcblx0ICogICAgICB9XG5cdCAqICAgICk7XG5cdCAqL1xuXHRzZWFyY2g6IFtdLFxuXG5cblx0LyoqXG5cdCAqIFNlbGVjdG9yIGV4dGVuc2lvbnNcblx0ICpcblx0ICogVGhlIGBzZWxlY3RvcmAgb3B0aW9uIGNhbiBiZSB1c2VkIHRvIGV4dGVuZCB0aGUgb3B0aW9ucyBhdmFpbGFibGUgZm9yIHRoZVxuXHQgKiBzZWxlY3RvciBtb2RpZmllciBvcHRpb25zIChgc2VsZWN0b3ItbW9kaWZpZXJgIG9iamVjdCBkYXRhIHR5cGUpIHRoYXRcblx0ICogZWFjaCBvZiB0aGUgdGhyZWUgYnVpbHQgaW4gc2VsZWN0b3IgdHlwZXMgb2ZmZXIgKHJvdywgY29sdW1uIGFuZCBjZWxsICtcblx0ICogdGhlaXIgcGx1cmFsIGNvdW50ZXJwYXJ0cykuIEZvciBleGFtcGxlIHRoZSBTZWxlY3QgZXh0ZW5zaW9uIHVzZXMgdGhpc1xuXHQgKiBtZWNoYW5pc20gdG8gcHJvdmlkZSBhbiBvcHRpb24gdG8gc2VsZWN0IG9ubHkgcm93cywgY29sdW1ucyBhbmQgY2VsbHNcblx0ICogdGhhdCBoYXZlIGJlZW4gbWFya2VkIGFzIHNlbGVjdGVkIGJ5IHRoZSBlbmQgdXNlciAoYHtzZWxlY3RlZDogdHJ1ZX1gKSxcblx0ICogd2hpY2ggY2FuIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgZXhpc3RpbmcgYnVpbHQgaW4gc2VsZWN0b3Jcblx0ICogb3B0aW9ucy5cblx0ICpcblx0ICogRWFjaCBwcm9wZXJ0eSBpcyBhbiBhcnJheSB0byB3aGljaCBmdW5jdGlvbnMgY2FuIGJlIHB1c2hlZC4gVGhlIGZ1bmN0aW9uc1xuXHQgKiB0YWtlIHRocmVlIGF0dHJpYnV0ZXM6XG5cdCAqXG5cdCAqICogU2V0dGluZ3Mgb2JqZWN0IGZvciB0aGUgaG9zdCB0YWJsZVxuXHQgKiAqIE9wdGlvbnMgb2JqZWN0IChgc2VsZWN0b3ItbW9kaWZpZXJgIG9iamVjdCB0eXBlKVxuXHQgKiAqIEFycmF5IG9mIHNlbGVjdGVkIGl0ZW0gaW5kZXhlc1xuXHQgKlxuXHQgKiBUaGUgcmV0dXJuIGlzIGFuIGFycmF5IG9mIHRoZSByZXN1bHRpbmcgaXRlbSBpbmRleGVzIGFmdGVyIHRoZSBjdXN0b21cblx0ICogc2VsZWN0b3IgaGFzIGJlZW4gYXBwbGllZC5cblx0ICpcblx0ICogIEB0eXBlIG9iamVjdFxuXHQgKi9cblx0c2VsZWN0b3I6IHtcblx0XHRjZWxsOiBbXSxcblx0XHRjb2x1bW46IFtdLFxuXHRcdHJvdzogW11cblx0fSxcblxuXG5cdC8qKlxuXHQgKiBMZWdhY3kgY29uZmlndXJhdGlvbiBvcHRpb25zLiBFbmFibGUgYW5kIGRpc2FibGUgbGVnYWN5IG9wdGlvbnMgdGhhdFxuXHQgKiBhcmUgYXZhaWxhYmxlIGluIERhdGFUYWJsZXMuXG5cdCAqXG5cdCAqICBAdHlwZSBvYmplY3Rcblx0ICovXG5cdGxlZ2FjeToge1xuXHRcdC8qKlxuXHRcdCAqIEVuYWJsZSAvIGRpc2FibGUgRGF0YVRhYmxlcyAxLjkgY29tcGF0aWJsZSBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nXG5cdFx0ICogcmVxdWVzdHNcblx0XHQgKlxuXHRcdCAqICBAdHlwZSBib29sZWFuXG5cdFx0ICogIEBkZWZhdWx0IG51bGxcblx0XHQgKi9cblx0XHRhamF4OiBudWxsXG5cdH0sXG5cblxuXHQvKipcblx0ICogUGFnaW5hdGlvbiBwbHVnLWluIG1ldGhvZHMuXG5cdCAqIFxuXHQgKiBFYWNoIGVudHJ5IGluIHRoaXMgb2JqZWN0IGlzIGEgZnVuY3Rpb24gYW5kIGRlZmluZXMgd2hpY2ggYnV0dG9ucyBzaG91bGRcblx0ICogYmUgc2hvd24gYnkgdGhlIHBhZ2luYXRpb24gcmVuZGVyaW5nIG1ldGhvZCB0aGF0IGlzIHVzZWQgZm9yIHRoZSB0YWJsZTpcblx0ICoge0BsaW5rIERhdGFUYWJsZS5leHQucmVuZGVyZXIucGFnZUJ1dHRvbn0uIFRoZSByZW5kZXJlciBhZGRyZXNzZXMgaG93IHRoZVxuXHQgKiBidXR0b25zIGFyZSBkaXNwbGF5ZWQgaW4gdGhlIGRvY3VtZW50LCB3aGlsZSB0aGUgZnVuY3Rpb25zIGhlcmUgdGVsbCBpdFxuXHQgKiB3aGF0IGJ1dHRvbnMgdG8gZGlzcGxheS4gVGhpcyBpcyBkb25lIGJ5IHJldHVybmluZyBhbiBhcnJheSBvZiBidXR0b25cblx0ICogZGVzY3JpcHRpb25zICh3aGF0IGVhY2ggYnV0dG9uIHdpbGwgZG8pLlxuXHQgKlxuXHQgKiBQYWdpbmF0aW9uIHR5cGVzICh0aGUgZm91ciBidWlsdCBpbiBvcHRpb25zIGFuZCBhbnkgYWRkaXRpb25hbCBwbHVnLWluXG5cdCAqIG9wdGlvbnMgZGVmaW5lZCBoZXJlKSBjYW4gYmUgdXNlZCB0aHJvdWdoIHRoZSBgcGFnaW5hdGlvblR5cGVgXG5cdCAqIGluaXRpYWxpc2F0aW9uIHBhcmFtZXRlci5cblx0ICpcblx0ICogVGhlIGZ1bmN0aW9ucyBkZWZpbmVkIHRha2UgdHdvIHBhcmFtZXRlcnM6XG5cdCAqXG5cdCAqIDEuIGB7aW50fSBwYWdlYCBUaGUgY3VycmVudCBwYWdlIGluZGV4XG5cdCAqIDIuIGB7aW50fSBwYWdlc2AgVGhlIG51bWJlciBvZiBwYWdlcyBpbiB0aGUgdGFibGVcblx0ICpcblx0ICogRWFjaCBmdW5jdGlvbiBpcyBleHBlY3RlZCB0byByZXR1cm4gYW4gYXJyYXkgd2hlcmUgZWFjaCBlbGVtZW50IG9mIHRoZVxuXHQgKiBhcnJheSBjYW4gYmUgb25lIG9mOlxuXHQgKlxuXHQgKiAqIGBmaXJzdGAgLSBKdW1wIHRvIGZpcnN0IHBhZ2Ugd2hlbiBhY3RpdmF0ZWRcblx0ICogKiBgbGFzdGAgLSBKdW1wIHRvIGxhc3QgcGFnZSB3aGVuIGFjdGl2YXRlZFxuXHQgKiAqIGBwcmV2aW91c2AgLSBTaG93IHByZXZpb3VzIHBhZ2Ugd2hlbiBhY3RpdmF0ZWRcblx0ICogKiBgbmV4dGAgLSBTaG93IG5leHQgcGFnZSB3aGVuIGFjdGl2YXRlZFxuXHQgKiAqIGB7aW50fWAgLSBTaG93IHBhZ2Ugb2YgdGhlIGluZGV4IGdpdmVuXG5cdCAqICogYHthcnJheX1gIC0gQSBuZXN0ZWQgYXJyYXkgY29udGFpbmluZyB0aGUgYWJvdmUgZWxlbWVudHMgdG8gYWRkIGFcblx0ICogICBjb250YWluaW5nICdESVYnIGVsZW1lbnQgKG1pZ2h0IGJlIHVzZWZ1bCBmb3Igc3R5bGluZykuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCBEYXRhVGFibGVzIHYxLjktIHVzZWQgdGhpcyBvYmplY3Qgc2xpZ2h0bHkgZGlmZmVyZW50bHkgd2hlcmVieVxuXHQgKiBhbiBvYmplY3Qgd2l0aCB0d28gZnVuY3Rpb25zIHdvdWxkIGJlIGRlZmluZWQgZm9yIGVhY2ggcGx1Zy1pbi4gVGhhdFxuXHQgKiBhYmlsaXR5IGlzIHN0aWxsIHN1cHBvcnRlZCBieSBEYXRhVGFibGVzIDEuMTArIHRvIHByb3ZpZGUgYmFja3dhcmRzXG5cdCAqIGNvbXBhdGliaWxpdHksIGJ1dCB0aGlzIG9wdGlvbiBvZiB1c2UgaXMgbm93IGRlY3JlbWVudGVkIGFuZCBubyBsb25nZXJcblx0ICogZG9jdW1lbnRlZCBpbiBEYXRhVGFibGVzIDEuMTArLlxuXHQgKlxuXHQgKiAgQHR5cGUgb2JqZWN0XG5cdCAqICBAZGVmYXVsdCB7fVxuXHQgKlxuXHQgKiAgQGV4YW1wbGVcblx0ICogICAgLy8gU2hvdyBwcmV2aW91cywgbmV4dCBhbmQgY3VycmVudCBwYWdlIGJ1dHRvbnMgb25seVxuXHQgKiAgICAkLmZuLmRhdGFUYWJsZUV4dC5vUGFnaW5hdGlvbi5jdXJyZW50ID0gZnVuY3Rpb24gKCBwYWdlLCBwYWdlcyApIHtcblx0ICogICAgICByZXR1cm4gWyAncHJldmlvdXMnLCBwYWdlLCAnbmV4dCcgXTtcblx0ICogICAgfTtcblx0ICovXG5cdHBhZ2VyOiB7fSxcblxuXG5cdHJlbmRlcmVyOiB7XG5cdFx0cGFnZUJ1dHRvbjoge30sXG5cdFx0aGVhZGVyOiB7fVxuXHR9LFxuXG5cblx0LyoqXG5cdCAqIE9yZGVyaW5nIHBsdWctaW5zIC0gY3VzdG9tIGRhdGEgc291cmNlXG5cdCAqIFxuXHQgKiBUaGUgZXh0ZW5zaW9uIG9wdGlvbnMgZm9yIG9yZGVyaW5nIG9mIGRhdGEgYXZhaWxhYmxlIGhlcmUgaXMgY29tcGxpbWVudGFyeVxuXHQgKiB0byB0aGUgZGVmYXVsdCB0eXBlIGJhc2VkIG9yZGVyaW5nIHRoYXQgRGF0YVRhYmxlcyB0eXBpY2FsbHkgdXNlcy4gSXRcblx0ICogYWxsb3dzIG11Y2ggZ3JlYXRlciBjb250cm9sIG92ZXIgdGhlIHRoZSBkYXRhIHRoYXQgaXMgYmVpbmcgdXNlZCB0b1xuXHQgKiBvcmRlciBhIGNvbHVtbiwgYnV0IGlzIG5lY2Vzc2FyaWx5IHRoZXJlZm9yZSBtb3JlIGNvbXBsZXguXG5cdCAqIFxuXHQgKiBUaGlzIHR5cGUgb2Ygb3JkZXJpbmcgaXMgdXNlZnVsIGlmIHlvdSB3YW50IHRvIGRvIG9yZGVyaW5nIGJhc2VkIG9uIGRhdGFcblx0ICogbGl2ZSBmcm9tIHRoZSBET00gKGZvciBleGFtcGxlIHRoZSBjb250ZW50cyBvZiBhbiAnaW5wdXQnIGVsZW1lbnQpIHJhdGhlclxuXHQgKiB0aGFuIGp1c3QgdGhlIHN0YXRpYyBzdHJpbmcgdGhhdCBEYXRhVGFibGVzIGtub3dzIG9mLlxuXHQgKiBcblx0ICogVGhlIHdheSB0aGVzZSBwbHVnLWlucyB3b3JrIGlzIHRoYXQgeW91IGNyZWF0ZSBhbiBhcnJheSBvZiB0aGUgdmFsdWVzIHlvdVxuXHQgKiB3aXNoIHRvIGJlIG9yZGVyaW5nIGZvciB0aGUgY29sdW1uIGluIHF1ZXN0aW9uIGFuZCB0aGVuIHJldHVybiB0aGF0XG5cdCAqIGFycmF5LiBUaGUgZGF0YSBpbiB0aGUgYXJyYXkgbXVjaCBiZSBpbiB0aGUgaW5kZXggb3JkZXIgb2YgdGhlIHJvd3MgaW5cblx0ICogdGhlIHRhYmxlIChub3QgdGhlIGN1cnJlbnRseSBvcmRlcmluZyBvcmRlciEpLiBXaGljaCBvcmRlciBkYXRhIGdhdGhlcmluZ1xuXHQgKiBmdW5jdGlvbiBpcyBydW4gaGVyZSBkZXBlbmRzIG9uIHRoZSBgZHQtaW5pdCBjb2x1bW5zLm9yZGVyRGF0YVR5cGVgXG5cdCAqIHBhcmFtZXRlciB0aGF0IGlzIHVzZWQgZm9yIHRoZSBjb2x1bW4gKGlmIGFueSkuXG5cdCAqXG5cdCAqIFRoZSBmdW5jdGlvbnMgZGVmaW5lZCB0YWtlIHR3byBwYXJhbWV0ZXJzOlxuXHQgKlxuXHQgKiAxLiBge29iamVjdH1gIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0OiBzZWVcblx0ICogICAge0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzfVxuXHQgKiAyLiBge2ludH1gIFRhcmdldCBjb2x1bW4gaW5kZXhcblx0ICpcblx0ICogRWFjaCBmdW5jdGlvbiBpcyBleHBlY3RlZCB0byByZXR1cm4gYW4gYXJyYXk6XG5cdCAqXG5cdCAqICogYHthcnJheX1gIERhdGEgZm9yIHRoZSBjb2x1bW4gdG8gYmUgb3JkZXJpbmcgdXBvblxuXHQgKlxuXHQgKiAgQHR5cGUgYXJyYXlcblx0ICpcblx0ICogIEBleGFtcGxlXG5cdCAqICAgIC8vIE9yZGVyaW5nIHVzaW5nIGBpbnB1dGAgbm9kZSB2YWx1ZXNcblx0ICogICAgJC5mbi5kYXRhVGFibGUuZXh0Lm9yZGVyWydkb20tdGV4dCddID0gZnVuY3Rpb24gICggc2V0dGluZ3MsIGNvbCApXG5cdCAqICAgIHtcblx0ICogICAgICByZXR1cm4gdGhpcy5hcGkoKS5jb2x1bW4oIGNvbCwge29yZGVyOidpbmRleCd9ICkubm9kZXMoKS5tYXAoIGZ1bmN0aW9uICggdGQsIGkgKSB7XG5cdCAqICAgICAgICByZXR1cm4gJCgnaW5wdXQnLCB0ZCkudmFsKCk7XG5cdCAqICAgICAgfSApO1xuXHQgKiAgICB9XG5cdCAqL1xuXHRvcmRlcjoge30sXG5cblxuXHQvKipcblx0ICogVHlwZSBiYXNlZCBwbHVnLWlucy5cblx0ICpcblx0ICogRWFjaCBjb2x1bW4gaW4gRGF0YVRhYmxlcyBoYXMgYSB0eXBlIGFzc2lnbmVkIHRvIGl0LCBlaXRoZXIgYnkgYXV0b21hdGljXG5cdCAqIGRldGVjdGlvbiBvciBieSBkaXJlY3QgYXNzaWdubWVudCB1c2luZyB0aGUgYHR5cGVgIG9wdGlvbiBmb3IgdGhlIGNvbHVtbi5cblx0ICogVGhlIHR5cGUgb2YgYSBjb2x1bW4gd2lsbCBlZmZlY3QgaG93IGl0IGlzIG9yZGVyaW5nIGFuZCBzZWFyY2ggKHBsdWctaW5zXG5cdCAqIGNhbiBhbHNvIG1ha2UgdXNlIG9mIHRoZSBjb2x1bW4gdHlwZSBpZiByZXF1aXJlZCkuXG5cdCAqXG5cdCAqIEBuYW1lc3BhY2Vcblx0ICovXG5cdHR5cGU6IHtcblx0XHQvKipcblx0XHQgKiBBdXRvbWF0aWMgY29sdW1uIGNsYXNzIGFzc2lnbm1lbnRcblx0XHQgKi9cblx0XHRjbGFzc05hbWU6IHt9LFxuXG5cdFx0LyoqXG5cdFx0ICogVHlwZSBkZXRlY3Rpb24gZnVuY3Rpb25zLlxuXHRcdCAqXG5cdFx0ICogVGhlIGZ1bmN0aW9ucyBkZWZpbmVkIGluIHRoaXMgb2JqZWN0IGFyZSB1c2VkIHRvIGF1dG9tYXRpY2FsbHkgZGV0ZWN0XG5cdFx0ICogYSBjb2x1bW4ncyB0eXBlLCBtYWtpbmcgaW5pdGlhbGlzYXRpb24gb2YgRGF0YVRhYmxlcyBzdXBlciBlYXN5LCBldmVuXG5cdFx0ICogd2hlbiBjb21wbGV4IGRhdGEgaXMgaW4gdGhlIHRhYmxlLlxuXHRcdCAqXG5cdFx0ICogVGhlIGZ1bmN0aW9ucyBkZWZpbmVkIHRha2UgdHdvIHBhcmFtZXRlcnM6XG5cdFx0ICpcblx0ICAgICAqICAxLiBgeyp9YCBEYXRhIGZyb20gdGhlIGNvbHVtbiBjZWxsIHRvIGJlIGFuYWx5c2VkXG5cdCAgICAgKiAgMi4gYHtzZXR0aW5nc31gIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VkIHRvXG5cdCAgICAgKiAgICAgcGVyZm9ybSBjb250ZXh0IHNwZWNpZmljIHR5cGUgZGV0ZWN0aW9uIC0gZm9yIGV4YW1wbGUgZGV0ZWN0aW9uXG5cdCAgICAgKiAgICAgYmFzZWQgb24gbGFuZ3VhZ2Ugc2V0dGluZ3Mgc3VjaCBhcyB1c2luZyBhIGNvbW1hIGZvciBhIGRlY2ltYWxcblx0ICAgICAqICAgICBwbGFjZS4gR2VuZXJhbGx5IHNwZWFraW5nIHRoZSBvcHRpb25zIGZyb20gdGhlIHNldHRpbmdzIHdpbGwgbm90XG5cdCAgICAgKiAgICAgYmUgcmVxdWlyZWRcblx0XHQgKlxuXHRcdCAqIEVhY2ggZnVuY3Rpb24gaXMgZXhwZWN0ZWQgdG8gcmV0dXJuOlxuXHRcdCAqXG5cdFx0ICogKiBge3N0cmluZ3xudWxsfWAgRGF0YSB0eXBlIGRldGVjdGVkLCBvciBudWxsIGlmIHVua25vd24gKGFuZCB0aHVzXG5cdFx0ICogICBwYXNzIGl0IG9uIHRvIHRoZSBvdGhlciB0eXBlIGRldGVjdGlvbiBmdW5jdGlvbnMuXG5cdFx0ICpcblx0XHQgKiAgQHR5cGUgYXJyYXlcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIEN1cnJlbmN5IHR5cGUgZGV0ZWN0aW9uIHBsdWctaW46XG5cdFx0ICogICAgJC5mbi5kYXRhVGFibGUuZXh0LnR5cGUuZGV0ZWN0LnB1c2goXG5cdFx0ICogICAgICBmdW5jdGlvbiAoIGRhdGEsIHNldHRpbmdzICkge1xuXHRcdCAqICAgICAgICAvLyBDaGVjayB0aGUgbnVtZXJpYyBwYXJ0XG5cdFx0ICogICAgICAgIGlmICggISBkYXRhLnN1YnN0cmluZygxKS5tYXRjaCgvWzAtOV0vKSApIHtcblx0XHQgKiAgICAgICAgICByZXR1cm4gbnVsbDtcblx0XHQgKiAgICAgICAgfVxuXHRcdCAqXG5cdFx0ICogICAgICAgIC8vIENoZWNrIHByZWZpeGVkIGJ5IGN1cnJlbmN5XG5cdFx0ICogICAgICAgIGlmICggZGF0YS5jaGFyQXQoMCkgPT0gJyQnIHx8IGRhdGEuY2hhckF0KDApID09ICcmcG91bmQ7JyApIHtcblx0XHQgKiAgICAgICAgICByZXR1cm4gJ2N1cnJlbmN5Jztcblx0XHQgKiAgICAgICAgfVxuXHRcdCAqICAgICAgICByZXR1cm4gbnVsbDtcblx0XHQgKiAgICAgIH1cblx0XHQgKiAgICApO1xuXHRcdCAqL1xuXHRcdGRldGVjdDogW10sXG5cblx0XHQvKipcblx0XHQgKiBBdXRvbWF0aWMgcmVuZGVyZXIgYXNzaWdubWVudFxuXHRcdCAqL1xuXHRcdHJlbmRlcjoge30sXG5cblxuXHRcdC8qKlxuXHRcdCAqIFR5cGUgYmFzZWQgc2VhcmNoIGZvcm1hdHRpbmcuXG5cdFx0ICpcblx0XHQgKiBUaGUgdHlwZSBiYXNlZCBzZWFyY2hpbmcgZnVuY3Rpb25zIGNhbiBiZSB1c2VkIHRvIHByZS1mb3JtYXQgdGhlXG5cdFx0ICogZGF0YSB0byBiZSBzZWFyY2ggb24uIEZvciBleGFtcGxlLCBpdCBjYW4gYmUgdXNlZCB0byBzdHJpcCBIVE1MXG5cdFx0ICogdGFncyBvciB0byBkZS1mb3JtYXQgdGVsZXBob25lIG51bWJlcnMgZm9yIG51bWVyaWMgb25seSBzZWFyY2hpbmcuXG5cdFx0ICpcblx0XHQgKiBOb3RlIHRoYXQgaXMgYSBzZWFyY2ggaXMgbm90IGRlZmluZWQgZm9yIGEgY29sdW1uIG9mIGEgZ2l2ZW4gdHlwZSxcblx0XHQgKiBubyBzZWFyY2ggZm9ybWF0dGluZyB3aWxsIGJlIHBlcmZvcm1lZC5cblx0XHQgKiBcblx0XHQgKiBQcmUtcHJvY2Vzc2luZyBvZiBzZWFyY2hpbmcgZGF0YSBwbHVnLWlucyAtIFdoZW4geW91IGFzc2lnbiB0aGUgc1R5cGVcblx0XHQgKiBmb3IgYSBjb2x1bW4gKG9yIGhhdmUgaXQgYXV0b21hdGljYWxseSBkZXRlY3RlZCBmb3IgeW91IGJ5IERhdGFUYWJsZXNcblx0XHQgKiBvciBhIHR5cGUgZGV0ZWN0aW9uIHBsdWctaW4pLCB5b3Ugd2lsbCB0eXBpY2FsbHkgYmUgdXNpbmcgdGhpcyBmb3Jcblx0XHQgKiBjdXN0b20gc29ydGluZywgYnV0IGl0IGNhbiBhbHNvIGJlIHVzZWQgdG8gcHJvdmlkZSBjdXN0b20gc2VhcmNoaW5nXG5cdFx0ICogYnkgYWxsb3dpbmcgeW91IHRvIHByZS1wcm9jZXNzaW5nIHRoZSBkYXRhIGFuZCByZXR1cm5pbmcgdGhlIGRhdGEgaW5cblx0XHQgKiB0aGUgZm9ybWF0IHRoYXQgc2hvdWxkIGJlIHNlYXJjaGVkIHVwb24uIFRoaXMgaXMgZG9uZSBieSBhZGRpbmdcblx0XHQgKiBmdW5jdGlvbnMgdGhpcyBvYmplY3Qgd2l0aCBhIHBhcmFtZXRlciBuYW1lIHdoaWNoIG1hdGNoZXMgdGhlIHNUeXBlXG5cdFx0ICogZm9yIHRoYXQgdGFyZ2V0IGNvbHVtbi4gVGhpcyBpcyB0aGUgY29yb2xsYXJ5IG9mIDxpPmFmblNvcnREYXRhPC9pPlxuXHRcdCAqIGZvciBzZWFyY2hpbmcgZGF0YS5cblx0XHQgKlxuXHRcdCAqIFRoZSBmdW5jdGlvbnMgZGVmaW5lZCB0YWtlIGEgc2luZ2xlIHBhcmFtZXRlcjpcblx0XHQgKlxuXHQgICAgICogIDEuIGB7Kn1gIERhdGEgZnJvbSB0aGUgY29sdW1uIGNlbGwgdG8gYmUgcHJlcGFyZWQgZm9yIHNlYXJjaGluZ1xuXHRcdCAqXG5cdFx0ICogRWFjaCBmdW5jdGlvbiBpcyBleHBlY3RlZCB0byByZXR1cm46XG5cdFx0ICpcblx0XHQgKiAqIGB7c3RyaW5nfG51bGx9YCBGb3JtYXR0ZWQgc3RyaW5nIHRoYXQgd2lsbCBiZSB1c2VkIGZvciB0aGUgc2VhcmNoaW5nLlxuXHRcdCAqXG5cdFx0ICogIEB0eXBlIG9iamVjdFxuXHRcdCAqICBAZGVmYXVsdCB7fVxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgJC5mbi5kYXRhVGFibGUuZXh0LnR5cGUuc2VhcmNoWyd0aXRsZS1udW1lcmljJ10gPSBmdW5jdGlvbiAoIGQgKSB7XG5cdFx0ICogICAgICByZXR1cm4gZC5yZXBsYWNlKC9cXG4vZyxcIiBcIikucmVwbGFjZSggLzwuKj8+L2csIFwiXCIgKTtcblx0XHQgKiAgICB9XG5cdFx0ICovXG5cdFx0c2VhcmNoOiB7fSxcblxuXG5cdFx0LyoqXG5cdFx0ICogVHlwZSBiYXNlZCBvcmRlcmluZy5cblx0XHQgKlxuXHRcdCAqIFRoZSBjb2x1bW4gdHlwZSB0ZWxscyBEYXRhVGFibGVzIHdoYXQgb3JkZXJpbmcgdG8gYXBwbHkgdG8gdGhlIHRhYmxlXG5cdFx0ICogd2hlbiBhIGNvbHVtbiBpcyBzb3J0ZWQgdXBvbi4gVGhlIG9yZGVyIGZvciBlYWNoIHR5cGUgdGhhdCBpcyBkZWZpbmVkLFxuXHRcdCAqIGlzIGRlZmluZWQgYnkgdGhlIGZ1bmN0aW9ucyBhdmFpbGFibGUgaW4gdGhpcyBvYmplY3QuXG5cdFx0ICpcblx0XHQgKiBFYWNoIG9yZGVyaW5nIG9wdGlvbiBjYW4gYmUgZGVzY3JpYmVkIGJ5IHRocmVlIHByb3BlcnRpZXMgYWRkZWQgdG9cblx0XHQgKiB0aGlzIG9iamVjdDpcblx0XHQgKlxuXHRcdCAqICogYHt0eXBlfS1wcmVgIC0gUHJlLWZvcm1hdHRpbmcgZnVuY3Rpb25cblx0XHQgKiAqIGB7dHlwZX0tYXNjYCAtIEFzY2VuZGluZyBvcmRlciBmdW5jdGlvblxuXHRcdCAqICogYHt0eXBlfS1kZXNjYCAtIERlc2NlbmRpbmcgb3JkZXIgZnVuY3Rpb25cblx0XHQgKlxuXHRcdCAqIEFsbCB0aHJlZSBjYW4gYmUgdXNlZCB0b2dldGhlciwgb25seSBge3R5cGV9LXByZWAgb3Igb25seVxuXHRcdCAqIGB7dHlwZX0tYXNjYCBhbmQgYHt0eXBlfS1kZXNjYCB0b2dldGhlci4gSXQgaXMgZ2VuZXJhbGx5IHJlY29tbWVuZGVkXG5cdFx0ICogdGhhdCBvbmx5IGB7dHlwZX0tcHJlYCBpcyB1c2VkLCBhcyB0aGlzIHByb3ZpZGVzIHRoZSBvcHRpbWFsXG5cdFx0ICogaW1wbGVtZW50YXRpb24gaW4gdGVybXMgb2Ygc3BlZWQsIGFsdGhvdWdoIHRoZSBvdGhlcnMgYXJlIHByb3ZpZGVkXG5cdFx0ICogZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBleGlzdGluZyBKYXZhc2NyaXB0IHNvcnQgZnVuY3Rpb25zLlxuXHRcdCAqXG5cdFx0ICogYHt0eXBlfS1wcmVgOiBGdW5jdGlvbnMgZGVmaW5lZCB0YWtlIGEgc2luZ2xlIHBhcmFtZXRlcjpcblx0XHQgKlxuXHQgICAgICogIDEuIGB7Kn1gIERhdGEgZnJvbSB0aGUgY29sdW1uIGNlbGwgdG8gYmUgcHJlcGFyZWQgZm9yIG9yZGVyaW5nXG5cdFx0ICpcblx0XHQgKiBBbmQgcmV0dXJuOlxuXHRcdCAqXG5cdFx0ICogKiBgeyp9YCBEYXRhIHRvIGJlIHNvcnRlZCB1cG9uXG5cdFx0ICpcblx0XHQgKiBge3R5cGV9LWFzY2AgYW5kIGB7dHlwZX0tZGVzY2A6IEZ1bmN0aW9ucyBhcmUgdHlwaWNhbCBKYXZhc2NyaXB0IHNvcnRcblx0XHQgKiBmdW5jdGlvbnMsIHRha2luZyB0d28gcGFyYW1ldGVyczpcblx0XHQgKlxuXHQgICAgICogIDEuIGB7Kn1gIERhdGEgdG8gY29tcGFyZSB0byB0aGUgc2Vjb25kIHBhcmFtZXRlclxuXHQgICAgICogIDIuIGB7Kn1gIERhdGEgdG8gY29tcGFyZSB0byB0aGUgZmlyc3QgcGFyYW1ldGVyXG5cdFx0ICpcblx0XHQgKiBBbmQgcmV0dXJuaW5nOlxuXHRcdCAqXG5cdFx0ICogKiBgeyp9YCBPcmRlcmluZyBtYXRjaDogPDAgaWYgZmlyc3QgcGFyYW1ldGVyIHNob3VsZCBiZSBzb3J0ZWQgbG93ZXJcblx0XHQgKiAgIHRoYW4gdGhlIHNlY29uZCBwYXJhbWV0ZXIsID09PTAgaWYgdGhlIHR3byBwYXJhbWV0ZXJzIGFyZSBlcXVhbCBhbmRcblx0XHQgKiAgID4wIGlmIHRoZSBmaXJzdCBwYXJhbWV0ZXIgc2hvdWxkIGJlIHNvcnRlZCBoZWlnaHQgdGhhbiB0aGUgc2Vjb25kXG5cdFx0ICogICBwYXJhbWV0ZXIuXG5cdFx0ICogXG5cdFx0ICogIEB0eXBlIG9iamVjdFxuXHRcdCAqICBAZGVmYXVsdCB7fVxuXHRcdCAqXG5cdFx0ICogIEBleGFtcGxlXG5cdFx0ICogICAgLy8gTnVtZXJpYyBvcmRlcmluZyBvZiBmb3JtYXR0ZWQgbnVtYmVycyB3aXRoIGEgcHJlLWZvcm1hdHRlclxuXHRcdCAqICAgICQuZXh0ZW5kKCAkLmZuLmRhdGFUYWJsZS5leHQudHlwZS5vcmRlciwge1xuXHRcdCAqICAgICAgXCJzdHJpbmctcHJlXCI6IGZ1bmN0aW9uKHgpIHtcblx0XHQgKiAgICAgICAgYSA9IChhID09PSBcIi1cIiB8fCBhID09PSBcIlwiKSA/IDAgOiBhLnJlcGxhY2UoIC9bXlxcZFxcLVxcLl0vZywgXCJcIiApO1xuXHRcdCAqICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCggYSApO1xuXHRcdCAqICAgICAgfVxuXHRcdCAqICAgIH0gKTtcblx0XHQgKlxuXHRcdCAqICBAZXhhbXBsZVxuXHRcdCAqICAgIC8vIENhc2Utc2Vuc2l0aXZlIHN0cmluZyBvcmRlcmluZywgd2l0aCBubyBwcmUtZm9ybWF0dGluZyBtZXRob2Rcblx0XHQgKiAgICAkLmV4dGVuZCggJC5mbi5kYXRhVGFibGUuZXh0Lm9yZGVyLCB7XG5cdFx0ICogICAgICBcInN0cmluZy1jYXNlLWFzY1wiOiBmdW5jdGlvbih4LHkpIHtcblx0XHQgKiAgICAgICAgcmV0dXJuICgoeCA8IHkpID8gLTEgOiAoKHggPiB5KSA/IDEgOiAwKSk7XG5cdFx0ICogICAgICB9LFxuXHRcdCAqICAgICAgXCJzdHJpbmctY2FzZS1kZXNjXCI6IGZ1bmN0aW9uKHgseSkge1xuXHRcdCAqICAgICAgICByZXR1cm4gKCh4IDwgeSkgPyAxIDogKCh4ID4geSkgPyAtMSA6IDApKTtcblx0XHQgKiAgICAgIH1cblx0XHQgKiAgICB9ICk7XG5cdFx0ICovXG5cdFx0b3JkZXI6IHt9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFVuaXF1ZSBEYXRhVGFibGVzIGluc3RhbmNlIGNvdW50ZXJcblx0ICpcblx0ICogQHR5cGUgaW50XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfdW5pcXVlOiAwLFxuXG5cblx0Ly9cblx0Ly8gRGVwcmVjaWF0ZWRcblx0Ly8gVGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGFyZSByZXRhaW5lZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgb25seS5cblx0Ly8gVGhlIHNob3VsZCBub3QgYmUgdXNlZCBpbiBuZXcgcHJvamVjdHMgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZVxuXHQvLyB2ZXJzaW9uXG5cdC8vXG5cblx0LyoqXG5cdCAqIFZlcnNpb24gY2hlY2sgZnVuY3Rpb24uXG5cdCAqICBAdHlwZSBmdW5jdGlvblxuXHQgKiAgQGRlcHJlY2lhdGVkIFNpbmNlIDEuMTBcblx0ICovXG5cdGZuVmVyc2lvbkNoZWNrOiBEYXRhVGFibGUuZm5WZXJzaW9uQ2hlY2ssXG5cblxuXHQvKipcblx0ICogSW5kZXggZm9yIHdoYXQgJ3RoaXMnIGluZGV4IEFQSSBmdW5jdGlvbnMgc2hvdWxkIHVzZVxuXHQgKiAgQHR5cGUgaW50XG5cdCAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuXHQgKi9cblx0aUFwaUluZGV4OiAwLFxuXG5cblx0LyoqXG5cdCAqIFNvZnR3YXJlIHZlcnNpb25cblx0ICogIEB0eXBlIHN0cmluZ1xuXHQgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcblx0ICovXG5cdHNWZXJzaW9uOiBEYXRhVGFibGUudmVyc2lvblxufTtcblxuXG4vL1xuLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIEFsaWFzIHRvIHByZSAxLjEwIEh1bmdhcmlhbiBub3RhdGlvbiBjb3VudGVyIHBhcnRzXG4vL1xuJC5leHRlbmQoIF9leHQsIHtcblx0YWZuRmlsdGVyaW5nOiBfZXh0LnNlYXJjaCxcblx0YVR5cGVzOiAgICAgICBfZXh0LnR5cGUuZGV0ZWN0LFxuXHRvZm5TZWFyY2g6ICAgIF9leHQudHlwZS5zZWFyY2gsXG5cdG9Tb3J0OiAgICAgICAgX2V4dC50eXBlLm9yZGVyLFxuXHRhZm5Tb3J0RGF0YTogIF9leHQub3JkZXIsXG5cdGFvRmVhdHVyZXM6ICAgX2V4dC5mZWF0dXJlLFxuXHRvU3RkQ2xhc3NlczogIF9leHQuY2xhc3Nlcyxcblx0b1BhZ2luYXRpb246ICBfZXh0LnBhZ2VyXG59ICk7XG5cblxuJC5leHRlbmQoIERhdGFUYWJsZS5leHQuY2xhc3Nlcywge1xuXHRjb250YWluZXI6ICdkdC1jb250YWluZXInLFxuXHRlbXB0eToge1xuXHRcdHJvdzogJ2R0LWVtcHR5J1xuXHR9LFxuXHRpbmZvOiB7XG5cdFx0Y29udGFpbmVyOiAnZHQtaW5mbydcblx0fSxcblx0bGF5b3V0OiB7XG5cdFx0cm93OiAnZHQtbGF5b3V0LXJvdycsXG5cdFx0Y2VsbDogJ2R0LWxheW91dC1jZWxsJyxcblx0XHR0YWJsZVJvdzogJ2R0LWxheW91dC10YWJsZScsXG5cdFx0dGFibGVDZWxsOiAnJyxcblx0XHRzdGFydDogJ2R0LWxheW91dC1zdGFydCcsXG5cdFx0ZW5kOiAnZHQtbGF5b3V0LWVuZCcsXG5cdFx0ZnVsbDogJ2R0LWxheW91dC1mdWxsJ1xuXHR9LFxuXHRsZW5ndGg6IHtcblx0XHRjb250YWluZXI6ICdkdC1sZW5ndGgnLFxuXHRcdHNlbGVjdDogJ2R0LWlucHV0J1xuXHR9LFxuXHRvcmRlcjoge1xuXHRcdGNhbkFzYzogJ2R0LW9yZGVyYWJsZS1hc2MnLFxuXHRcdGNhbkRlc2M6ICdkdC1vcmRlcmFibGUtZGVzYycsXG5cdFx0aXNBc2M6ICdkdC1vcmRlcmluZy1hc2MnLFxuXHRcdGlzRGVzYzogJ2R0LW9yZGVyaW5nLWRlc2MnLFxuXHRcdG5vbmU6ICdkdC1vcmRlcmFibGUtbm9uZScsXG5cdFx0cG9zaXRpb246ICdzb3J0aW5nXydcblx0fSxcblx0cHJvY2Vzc2luZzoge1xuXHRcdGNvbnRhaW5lcjogJ2R0LXByb2Nlc3NpbmcnXG5cdH0sXG5cdHNjcm9sbGluZzoge1xuXHRcdGJvZHk6ICdkdC1zY3JvbGwtYm9keScsXG5cdFx0Y29udGFpbmVyOiAnZHQtc2Nyb2xsJyxcblx0XHRmb290ZXI6IHtcblx0XHRcdHNlbGY6ICdkdC1zY3JvbGwtZm9vdCcsXG5cdFx0XHRpbm5lcjogJ2R0LXNjcm9sbC1mb290SW5uZXInXG5cdFx0fSxcblx0XHRoZWFkZXI6IHtcblx0XHRcdHNlbGY6ICdkdC1zY3JvbGwtaGVhZCcsXG5cdFx0XHRpbm5lcjogJ2R0LXNjcm9sbC1oZWFkSW5uZXInXG5cdFx0fVxuXHR9LFxuXHRzZWFyY2g6IHtcblx0XHRjb250YWluZXI6ICdkdC1zZWFyY2gnLFxuXHRcdGlucHV0OiAnZHQtaW5wdXQnXG5cdH0sXG5cdHRhYmxlOiAnZGF0YVRhYmxlJyxcdFxuXHR0Ym9keToge1xuXHRcdGNlbGw6ICcnLFxuXHRcdHJvdzogJydcblx0fSxcblx0dGhlYWQ6IHtcblx0XHRjZWxsOiAnJyxcblx0XHRyb3c6ICcnXG5cdH0sXG5cdHRmb290OiB7XG5cdFx0Y2VsbDogJycsXG5cdFx0cm93OiAnJ1xuXHR9LFxuXHRwYWdpbmc6IHtcblx0XHRhY3RpdmU6ICdjdXJyZW50Jyxcblx0XHRidXR0b246ICdkdC1wYWdpbmctYnV0dG9uJyxcblx0XHRjb250YWluZXI6ICdkdC1wYWdpbmcnLFxuXHRcdGRpc2FibGVkOiAnZGlzYWJsZWQnLFxuXHRcdG5hdjogJydcblx0fVxufSApO1xuXG5cbi8qXG4gKiBJdCBpcyB1c2VmdWwgdG8gaGF2ZSB2YXJpYWJsZXMgd2hpY2ggYXJlIHNjb3BlZCBsb2NhbGx5IHNvIG9ubHkgdGhlXG4gKiBEYXRhVGFibGVzIGZ1bmN0aW9ucyBjYW4gYWNjZXNzIHRoZW0gYW5kIHRoZXkgZG9uJ3QgbGVhayBpbnRvIGdsb2JhbCBzcGFjZS5cbiAqIEF0IHRoZSBzYW1lIHRpbWUgdGhlc2UgZnVuY3Rpb25zIGFyZSBvZnRlbiB1c2VmdWwgb3ZlciBtdWx0aXBsZSBmaWxlcyBpbiB0aGVcbiAqIGNvcmUgYW5kIEFQSSwgc28gd2UgbGlzdCwgb3IgYXQgbGVhc3QgZG9jdW1lbnQsIGFsbCB2YXJpYWJsZXMgd2hpY2ggYXJlIHVzZWRcbiAqIGJ5IERhdGFUYWJsZXMgYXMgcHJpdmF0ZSB2YXJpYWJsZXMgaGVyZS4gVGhpcyBhbHNvIGVuc3VyZXMgdGhhdCB0aGVyZSBpcyBub1xuICogY2xhc2hpbmcgb2YgdmFyaWFibGUgbmFtZXMgYW5kIHRoYXQgdGhleSBjYW4gZWFzaWx5IHJlZmVyZW5jZWQgZm9yIHJldXNlLlxuICovXG5cblxuLy8gRGVmaW5lZCBlbHNlIHdoZXJlXG4vLyAgX3NlbGVjdG9yX3J1blxuLy8gIF9zZWxlY3Rvcl9vcHRzXG4vLyAgX3NlbGVjdG9yX3Jvd19pbmRleGVzXG5cbnZhciBfZXh0OyAvLyBEYXRhVGFibGUuZXh0XG52YXIgX0FwaTsgLy8gRGF0YVRhYmxlLkFwaVxudmFyIF9hcGlfcmVnaXN0ZXI7IC8vIERhdGFUYWJsZS5BcGkucmVnaXN0ZXJcbnZhciBfYXBpX3JlZ2lzdGVyUGx1cmFsOyAvLyBEYXRhVGFibGUuQXBpLnJlZ2lzdGVyUGx1cmFsXG5cbnZhciBfcmVfZGljID0ge307XG52YXIgX3JlX25ld19saW5lcyA9IC9bXFxyXFxuXFx1MjAyOF0vZztcbnZhciBfcmVfaHRtbCA9IC88KFtePl0qPikvZztcbnZhciBfbWF4X3N0cl9sZW4gPSBNYXRoLnBvdygyLCAyOCk7XG5cbi8vIFRoaXMgaXMgbm90IHN0cmljdCBJU084NjAxIC0gRGF0ZS5wYXJzZSgpIGlzIHF1aXRlIGxheCwgYWx0aG91Z2hcbi8vIGltcGxlbWVudGF0aW9ucyBkaWZmZXIgYmV0d2VlbiBicm93c2Vycy5cbnZhciBfcmVfZGF0ZSA9IC9eXFxkezIsNH1bLi8tXVxcZHsxLDJ9Wy4vLV1cXGR7MSwyfShbVCBdezF9XFxkezEsMn1bOi5dXFxkezJ9KFsuOl1cXGR7Mn0pPyk/JC87XG5cbi8vIEVzY2FwZSByZWd1bGFyIGV4cHJlc3Npb24gc3BlY2lhbCBjaGFyYWN0ZXJzXG52YXIgX3JlX2VzY2FwZV9yZWdleCA9IG5ldyBSZWdFeHAoICcoXFxcXCcgKyBbICcvJywgJy4nLCAnKicsICcrJywgJz8nLCAnfCcsICcoJywgJyknLCAnWycsICddJywgJ3snLCAnfScsICdcXFxcJywgJyQnLCAnXicsICctJyBdLmpvaW4oJ3xcXFxcJykgKyAnKScsICdnJyApO1xuXG4vLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Gb3JlaWduX2V4Y2hhbmdlX21hcmtldFxuLy8gLSBcXHUyMEJEIC0gUnVzc2lhbiBydWJsZS5cbi8vIC0gXFx1MjBhOSAtIFNvdXRoIEtvcmVhbiBXb25cbi8vIC0gXFx1MjBCQSAtIFR1cmtpc2ggTGlyYVxuLy8gLSBcXHUyMEI5IC0gSW5kaWFuIFJ1cGVlXG4vLyAtIFIgLSBCcmF6aWwgKFIkKSBhbmQgU291dGggQWZyaWNhXG4vLyAtIGZyIC0gU3dpc3MgRnJhbmNcbi8vIC0ga3IgLSBTd2VkaXNoIGtyb25hLCBOb3J3ZWdpYW4ga3JvbmUgYW5kIERhbmlzaCBrcm9uZVxuLy8gLSBcXHUyMDA5IGlzIHRoaW4gc3BhY2UgYW5kIFxcdTIwMkYgaXMgbmFycm93IG5vLWJyZWFrIHNwYWNlLCBib3RoIHVzZWQgaW4gbWFueVxuLy8gLSDJgyAtIEJpdGNvaW5cbi8vIC0gzp4gLSBFdGhlcmV1bVxuLy8gICBzdGFuZGFyZHMgYXMgdGhvdXNhbmRzIHNlcGFyYXRvcnMuXG52YXIgX3JlX2Zvcm1hdHRlZF9udW1lcmljID0gL1snXFx1MDBBMCwkwqPigqzCpSVcXHUyMDA5XFx1MjAyRlxcdTIwQkRcXHUyMGE5XFx1MjBCQXJma8mDzp5dL2dpO1xuXG5cbnZhciBfZW1wdHkgPSBmdW5jdGlvbiAoIGQgKSB7XG5cdHJldHVybiAhZCB8fCBkID09PSB0cnVlIHx8IGQgPT09ICctJyA/IHRydWUgOiBmYWxzZTtcbn07XG5cblxudmFyIF9pbnRWYWwgPSBmdW5jdGlvbiAoIHMgKSB7XG5cdHZhciBpbnRlZ2VyID0gcGFyc2VJbnQoIHMsIDEwICk7XG5cdHJldHVybiAhaXNOYU4oaW50ZWdlcikgJiYgaXNGaW5pdGUocykgPyBpbnRlZ2VyIDogbnVsbDtcbn07XG5cbi8vIENvbnZlcnQgZnJvbSBhIGZvcm1hdHRlZCBudW1iZXIgd2l0aCBjaGFyYWN0ZXJzIG90aGVyIHRoYW4gYC5gIGFzIHRoZVxuLy8gZGVjaW1hbCBwbGFjZSwgdG8gYSBKYXZhc2NyaXB0IG51bWJlclxudmFyIF9udW1Ub0RlY2ltYWwgPSBmdW5jdGlvbiAoIG51bSwgZGVjaW1hbFBvaW50ICkge1xuXHQvLyBDYWNoZSBjcmVhdGVkIHJlZ3VsYXIgZXhwcmVzc2lvbnMgZm9yIHNwZWVkIGFzIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG9mdGVuXG5cdGlmICggISBfcmVfZGljWyBkZWNpbWFsUG9pbnQgXSApIHtcblx0XHRfcmVfZGljWyBkZWNpbWFsUG9pbnQgXSA9IG5ldyBSZWdFeHAoIF9mbkVzY2FwZVJlZ2V4KCBkZWNpbWFsUG9pbnQgKSwgJ2cnICk7XG5cdH1cblx0cmV0dXJuIHR5cGVvZiBudW0gPT09ICdzdHJpbmcnICYmIGRlY2ltYWxQb2ludCAhPT0gJy4nID9cblx0XHRudW0ucmVwbGFjZSggL1xcLi9nLCAnJyApLnJlcGxhY2UoIF9yZV9kaWNbIGRlY2ltYWxQb2ludCBdLCAnLicgKSA6XG5cdFx0bnVtO1xufTtcblxuXG52YXIgX2lzTnVtYmVyID0gZnVuY3Rpb24gKCBkLCBkZWNpbWFsUG9pbnQsIGZvcm1hdHRlZCwgYWxsb3dFbXB0eSApIHtcblx0dmFyIHR5cGUgPSB0eXBlb2YgZDtcblx0dmFyIHN0clR5cGUgPSB0eXBlID09PSAnc3RyaW5nJztcblxuXHRpZiAoIHR5cGUgPT09ICdudW1iZXInIHx8IHR5cGUgPT09ICdiaWdpbnQnKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvLyBJZiBlbXB0eSByZXR1cm4gaW1tZWRpYXRlbHkgc28gdGhlcmUgbXVzdCBiZSBhIG51bWJlciBpZiBpdCBpcyBhXG5cdC8vIGZvcm1hdHRlZCBzdHJpbmcgKHRoaXMgc3RvcHMgdGhlIHN0cmluZyBcImtcIiwgb3IgXCJrclwiLCBldGMgYmVpbmcgZGV0ZWN0ZWRcblx0Ly8gYXMgYSBmb3JtYXR0ZWQgbnVtYmVyIGZvciBjdXJyZW5jeVxuXHRpZiAoIGFsbG93RW1wdHkgJiYgX2VtcHR5KCBkICkgKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRpZiAoIGRlY2ltYWxQb2ludCAmJiBzdHJUeXBlICkge1xuXHRcdGQgPSBfbnVtVG9EZWNpbWFsKCBkLCBkZWNpbWFsUG9pbnQgKTtcblx0fVxuXG5cdGlmICggZm9ybWF0dGVkICYmIHN0clR5cGUgKSB7XG5cdFx0ZCA9IGQucmVwbGFjZSggX3JlX2Zvcm1hdHRlZF9udW1lcmljLCAnJyApO1xuXHR9XG5cblx0cmV0dXJuICFpc05hTiggcGFyc2VGbG9hdChkKSApICYmIGlzRmluaXRlKCBkICk7XG59O1xuXG5cbi8vIEEgc3RyaW5nIHdpdGhvdXQgSFRNTCBpbiBpdCBjYW4gYmUgY29uc2lkZXJlZCB0byBiZSBIVE1MIHN0aWxsXG52YXIgX2lzSHRtbCA9IGZ1bmN0aW9uICggZCApIHtcblx0cmV0dXJuIF9lbXB0eSggZCApIHx8IHR5cGVvZiBkID09PSAnc3RyaW5nJztcbn07XG5cbi8vIElzIGEgc3RyaW5nIGEgbnVtYmVyIHN1cnJvdW5kZWQgYnkgSFRNTD9cbnZhciBfaHRtbE51bWVyaWMgPSBmdW5jdGlvbiAoIGQsIGRlY2ltYWxQb2ludCwgZm9ybWF0dGVkLCBhbGxvd0VtcHR5ICkge1xuXHRpZiAoIGFsbG93RW1wdHkgJiYgX2VtcHR5KCBkICkgKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvLyBpbnB1dCBhbmQgc2VsZWN0IHN0cmluZ3MgbWVhbiB0aGF0IHRoaXMgaXNuJ3QganVzdCBhIG51bWJlclxuXHRpZiAodHlwZW9mIGQgPT09ICdzdHJpbmcnICYmIGQubWF0Y2goLzwoaW5wdXR8c2VsZWN0KS9pKSkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0dmFyIGh0bWwgPSBfaXNIdG1sKCBkICk7XG5cdHJldHVybiAhIGh0bWwgP1xuXHRcdG51bGwgOlxuXHRcdF9pc051bWJlciggX3N0cmlwSHRtbCggZCApLCBkZWNpbWFsUG9pbnQsIGZvcm1hdHRlZCwgYWxsb3dFbXB0eSApID9cblx0XHRcdHRydWUgOlxuXHRcdFx0bnVsbDtcbn07XG5cblxudmFyIF9wbHVjayA9IGZ1bmN0aW9uICggYSwgcHJvcCwgcHJvcDIgKSB7XG5cdHZhciBvdXQgPSBbXTtcblx0dmFyIGk9MCwgaWVuPWEubGVuZ3RoO1xuXG5cdC8vIENvdWxkIGhhdmUgdGhlIHRlc3QgaW4gdGhlIGxvb3AgZm9yIHNsaWdodGx5IHNtYWxsZXIgY29kZSwgYnV0IHNwZWVkXG5cdC8vIGlzIGVzc2VudGlhbCBoZXJlXG5cdGlmICggcHJvcDIgIT09IHVuZGVmaW5lZCApIHtcblx0XHRmb3IgKCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0aWYgKCBhW2ldICYmIGFbaV1bIHByb3AgXSApIHtcblx0XHRcdFx0b3V0LnB1c2goIGFbaV1bIHByb3AgXVsgcHJvcDIgXSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRlbHNlIHtcblx0XHRmb3IgKCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0aWYgKCBhW2ldICkge1xuXHRcdFx0XHRvdXQucHVzaCggYVtpXVsgcHJvcCBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG91dDtcbn07XG5cblxuLy8gQmFzaWNhbGx5IHRoZSBzYW1lIGFzIF9wbHVjaywgYnV0IHJhdGhlciB0aGFuIGxvb3Bpbmcgb3ZlciBgYWAgd2UgdXNlIGBvcmRlcmBcbi8vIGFzIHRoZSBpbmRleGVzIHRvIHBpY2sgZnJvbSBgYWBcbnZhciBfcGx1Y2tfb3JkZXIgPSBmdW5jdGlvbiAoIGEsIG9yZGVyLCBwcm9wLCBwcm9wMiApXG57XG5cdHZhciBvdXQgPSBbXTtcblx0dmFyIGk9MCwgaWVuPW9yZGVyLmxlbmd0aDtcblxuXHQvLyBDb3VsZCBoYXZlIHRoZSB0ZXN0IGluIHRoZSBsb29wIGZvciBzbGlnaHRseSBzbWFsbGVyIGNvZGUsIGJ1dCBzcGVlZFxuXHQvLyBpcyBlc3NlbnRpYWwgaGVyZVxuXHRpZiAoIHByb3AyICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0Zm9yICggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdGlmICggYVsgb3JkZXJbaV0gXSAmJiBhWyBvcmRlcltpXSBdWyBwcm9wIF0gKSB7XG5cdFx0XHRcdG91dC5wdXNoKCBhWyBvcmRlcltpXSBdWyBwcm9wIF1bIHByb3AyIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZWxzZSB7XG5cdFx0Zm9yICggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdGlmICggYVsgb3JkZXJbaV0gXSApIHtcblx0XHRcdFx0b3V0LnB1c2goIGFbIG9yZGVyW2ldIF1bIHByb3AgXSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBvdXQ7XG59O1xuXG5cbnZhciBfcmFuZ2UgPSBmdW5jdGlvbiAoIGxlbiwgc3RhcnQgKVxue1xuXHR2YXIgb3V0ID0gW107XG5cdHZhciBlbmQ7XG5cblx0aWYgKCBzdGFydCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHN0YXJ0ID0gMDtcblx0XHRlbmQgPSBsZW47XG5cdH1cblx0ZWxzZSB7XG5cdFx0ZW5kID0gc3RhcnQ7XG5cdFx0c3RhcnQgPSBsZW47XG5cdH1cblxuXHRmb3IgKCB2YXIgaT1zdGFydCA7IGk8ZW5kIDsgaSsrICkge1xuXHRcdG91dC5wdXNoKCBpICk7XG5cdH1cblxuXHRyZXR1cm4gb3V0O1xufTtcblxuXG52YXIgX3JlbW92ZUVtcHR5ID0gZnVuY3Rpb24gKCBhIClcbntcblx0dmFyIG91dCA9IFtdO1xuXG5cdGZvciAoIHZhciBpPTAsIGllbj1hLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdGlmICggYVtpXSApIHsgLy8gY2FyZWZ1bCAtIHdpbGwgcmVtb3ZlIGFsbCBmYWxzeSB2YWx1ZXMhXG5cdFx0XHRvdXQucHVzaCggYVtpXSApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBvdXQ7XG59O1xuXG4vLyBSZXBsYWNlYWJsZSBmdW5jdGlvbiBpbiBhcGkudXRpbFxudmFyIF9zdHJpcEh0bWwgPSBmdW5jdGlvbiAoaW5wdXQpIHtcblx0aWYgKCEgaW5wdXQgfHwgdHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuXHRcdHJldHVybiBpbnB1dDtcblx0fVxuXG5cdC8vIElycmVsZXZhbnQgY2hlY2sgdG8gd29ya2Fyb3VuZCBDb2RlUUwncyBmYWxzZSBwb3NpdGl2ZSBvbiB0aGUgcmVnZXhcblx0aWYgKGlucHV0Lmxlbmd0aCA+IF9tYXhfc3RyX2xlbikge1xuXHRcdHRocm93IG5ldyBFcnJvcignRXhjZWVkZWQgbWF4IHN0ciBsZW4nKTtcblx0fVxuXG5cdHZhciBwcmV2aW91cztcblxuXHRpbnB1dCA9IGlucHV0LnJlcGxhY2UoX3JlX2h0bWwsICcnKTsgLy8gQ29tcGxldGUgdGFnc1xuXG5cdC8vIFNhZmV0eSBmb3IgaW5jb21wbGV0ZSBzY3JpcHQgdGFnIC0gdXNlIGRvIC8gd2hpbGUgdG8gZW5zdXJlIHRoYXRcblx0Ly8gd2UgZ2V0IGFsbCBpbnN0YW5jZXNcblx0ZG8ge1xuXHRcdHByZXZpb3VzID0gaW5wdXQ7XG5cdFx0aW5wdXQgPSBpbnB1dC5yZXBsYWNlKC88c2NyaXB0L2ksICcnKTtcblx0fSB3aGlsZSAoaW5wdXQgIT09IHByZXZpb3VzKTtcblxuXHRyZXR1cm4gcHJldmlvdXM7XG59O1xuXG4vLyBSZXBsYWNlYWJsZSBmdW5jdGlvbiBpbiBhcGkudXRpbFxudmFyIF9lc2NhcGVIdG1sID0gZnVuY3Rpb24gKCBkICkge1xuXHRpZiAoQXJyYXkuaXNBcnJheShkKSkge1xuXHRcdGQgPSBkLmpvaW4oJywnKTtcblx0fVxuXG5cdHJldHVybiB0eXBlb2YgZCA9PT0gJ3N0cmluZycgP1xuXHRcdGRcblx0XHRcdC5yZXBsYWNlKC8mL2csICcmYW1wOycpXG5cdFx0XHQucmVwbGFjZSgvPC9nLCAnJmx0OycpXG5cdFx0XHQucmVwbGFjZSgvPi9nLCAnJmd0OycpXG5cdFx0XHQucmVwbGFjZSgvXCIvZywgJyZxdW90OycpIDpcblx0XHRkO1xufTtcblxuLy8gUmVtb3ZlIGRpYWNyaXRpY3MgZnJvbSBhIHN0cmluZyBieSBkZWNvbXBvc2luZyBpdCBhbmQgdGhlbiByZW1vdmluZ1xuLy8gbm9uLWFzY2lpIGNoYXJhY3RlcnNcbnZhciBfbm9ybWFsaXplID0gZnVuY3Rpb24gKHN0ciwgYm90aCkge1xuXHRpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcblx0XHRyZXR1cm4gc3RyO1xuXHR9XG5cblx0Ly8gSXQgaXMgZmFzdGVyIHRvIGp1c3QgcnVuIGBub3JtYWxpemVgIHRoYW4gaXQgaXMgdG8gY2hlY2sgaWZcblx0Ly8gd2UgbmVlZCB0byB3aXRoIGEgcmVnZXghIChDaGVjayBhcyBpdCBpc24ndCBhdmFpbGFibGUgaW4gb2xkXG5cdC8vIFNhZmFyaSlcblx0dmFyIHJlcyA9IHN0ci5ub3JtYWxpemVcblx0XHQ/IHN0ci5ub3JtYWxpemUoXCJORkRcIilcblx0XHQ6IHN0cjtcblxuXHQvLyBFcXVhbGx5LCBoZXJlIHdlIGNoZWNrIGlmIGEgcmVnZXggaXMgbmVlZGVkIG9yIG5vdFxuXHRyZXR1cm4gcmVzLmxlbmd0aCAhPT0gc3RyLmxlbmd0aFxuXHRcdD8gKGJvdGggPT09IHRydWUgPyBzdHIgKyAnICcgOiAnJyApICsgcmVzLnJlcGxhY2UoL1tcXHUwMzAwLVxcdTAzNmZdL2csIFwiXCIpXG5cdFx0OiByZXM7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGFsbCB2YWx1ZXMgaW4gdGhlIGFycmF5IGFyZSB1bmlxdWUuIFRoaXMgbWVhbnMgd2UgY2FuIHNob3J0XG4gKiBjdXQgdGhlIF91bmlxdWUgbWV0aG9kIGF0IHRoZSBjb3N0IG9mIGEgc2luZ2xlIGxvb3AuIEEgc29ydGVkIGFycmF5IGlzIHVzZWRcbiAqIHRvIGVhc2lseSBjaGVjayB0aGUgdmFsdWVzLlxuICpcbiAqIEBwYXJhbSAge2FycmF5fSBzcmMgU291cmNlIGFycmF5XG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIGFsbCB1bmlxdWUsIGZhbHNlIG90aGVyd2lzZVxuICogQGlnbm9yZVxuICovXG52YXIgX2FyZUFsbFVuaXF1ZSA9IGZ1bmN0aW9uICggc3JjICkge1xuXHRpZiAoIHNyYy5sZW5ndGggPCAyICkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0dmFyIHNvcnRlZCA9IHNyYy5zbGljZSgpLnNvcnQoKTtcblx0dmFyIGxhc3QgPSBzb3J0ZWRbMF07XG5cblx0Zm9yICggdmFyIGk9MSwgaWVuPXNvcnRlZC5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRpZiAoIHNvcnRlZFtpXSA9PT0gbGFzdCApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRsYXN0ID0gc29ydGVkW2ldO1xuXHR9XG5cblx0cmV0dXJuIHRydWU7XG59O1xuXG5cbi8qKlxuICogRmluZCB0aGUgdW5pcXVlIGVsZW1lbnRzIGluIGEgc291cmNlIGFycmF5LlxuICpcbiAqIEBwYXJhbSAge2FycmF5fSBzcmMgU291cmNlIGFycmF5XG4gKiBAcmV0dXJuIHthcnJheX0gQXJyYXkgb2YgdW5pcXVlIGl0ZW1zXG4gKiBAaWdub3JlXG4gKi9cbnZhciBfdW5pcXVlID0gZnVuY3Rpb24gKCBzcmMgKVxue1xuXHRpZiAoQXJyYXkuZnJvbSAmJiBTZXQpIHtcblx0XHRyZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KHNyYykpO1xuXHR9XG5cblx0aWYgKCBfYXJlQWxsVW5pcXVlKCBzcmMgKSApIHtcblx0XHRyZXR1cm4gc3JjLnNsaWNlKCk7XG5cdH1cblxuXHQvLyBBIGZhc3RlciB1bmlxdWUgbWV0aG9kIGlzIHRvIHVzZSBvYmplY3Qga2V5cyB0byBpZGVudGlmeSB1c2VkIHZhbHVlcyxcblx0Ly8gYnV0IHRoaXMgZG9lc24ndCB3b3JrIHdpdGggYXJyYXlzIG9yIG9iamVjdHMsIHdoaWNoIHdlIG11c3QgYWxzb1xuXHQvLyBjb25zaWRlci4gU2VlIGpzcGVyZi5hcHAvY29tcGFyZS1hcnJheS11bmlxdWUtdmVyc2lvbnMvNCBmb3IgbW9yZVxuXHQvLyBpbmZvcm1hdGlvbi5cblx0dmFyXG5cdFx0b3V0ID0gW10sXG5cdFx0dmFsLFxuXHRcdGksIGllbj1zcmMubGVuZ3RoLFxuXHRcdGosIGs9MDtcblxuXHRhZ2FpbjogZm9yICggaT0wIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0dmFsID0gc3JjW2ldO1xuXG5cdFx0Zm9yICggaj0wIDsgajxrIDsgaisrICkge1xuXHRcdFx0aWYgKCBvdXRbal0gPT09IHZhbCApIHtcblx0XHRcdFx0Y29udGludWUgYWdhaW47XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0b3V0LnB1c2goIHZhbCApO1xuXHRcdGsrKztcblx0fVxuXG5cdHJldHVybiBvdXQ7XG59O1xuXG4vLyBTdXJwcmlzaW5nbHkgdGhpcyBpcyBmYXN0ZXIgdGhhbiBbXS5jb25jYXQuYXBwbHlcbi8vIGh0dHBzOi8vanNwZXJmLmNvbS9mbGF0dGVuLWFuLWFycmF5LWxvb3AtdnMtcmVkdWNlLzJcbnZhciBfZmxhdHRlbiA9IGZ1bmN0aW9uIChvdXQsIHZhbCkge1xuXHRpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG5cdFx0Zm9yICh2YXIgaT0wIDsgaTx2YWwubGVuZ3RoIDsgaSsrKSB7XG5cdFx0XHRfZmxhdHRlbihvdXQsIHZhbFtpXSk7XG5cdFx0fVxuXHR9XG5cdGVsc2Uge1xuXHRcdG91dC5wdXNoKHZhbCk7XG5cdH1cblxuXHRyZXR1cm4gb3V0O1xufVxuXG4vLyBTaW1pbGFyIHRvIGpRdWVyeSdzIGFkZENsYXNzLCBidXQgdXNlIGNsYXNzTGlzdC5hZGRcbmZ1bmN0aW9uIF9hZGRDbGFzcyhlbCwgbmFtZSkge1xuXHRpZiAobmFtZSkge1xuXHRcdG5hbWUuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRpZiAobikge1xuXHRcdFx0XHQvLyBgYWRkYCBkb2VzIGRlZHVwbGljYXRpb24sIHNvIG5vIG5lZWQgdG8gY2hlY2sgYGNvbnRhaW5zYFxuXHRcdFx0XHRlbC5jbGFzc0xpc3QuYWRkKG4pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG59XG5cbi8qKlxuICogRGF0YVRhYmxlcyB1dGlsaXR5IG1ldGhvZHNcbiAqIFxuICogVGhpcyBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIG1ldGhvZHMgdGhhdCBEYXRhVGFibGVzIHVzZXMgaW50ZXJuYWxseSB0b1xuICogY3JlYXRlIGEgRGF0YVRhYmxlLCBidXQgd2hpY2ggYXJlIG5vdCBleGNsdXNpdmVseSB1c2VkIG9ubHkgZm9yIERhdGFUYWJsZXMuXG4gKiBUaGVzZSBtZXRob2RzIGNhbiBiZSB1c2VkIGJ5IGV4dGVuc2lvbiBhdXRob3JzIHRvIHNhdmUgdGhlIGR1cGxpY2F0aW9uIG9mXG4gKiBjb2RlLlxuICpcbiAqICBAbmFtZXNwYWNlXG4gKi9cbkRhdGFUYWJsZS51dGlsID0ge1xuXHQvKipcblx0ICogUmV0dXJuIGEgc3RyaW5nIHdpdGggZGlhY3JpdGljIGNoYXJhY3RlcnMgZGVjb21wb3NlZFxuXHQgKiBAcGFyYW0geyp9IG1peGVkIEZ1bmN0aW9uIG9yIHN0cmluZyB0byBub3JtYWxpemVcblx0ICogQHBhcmFtIHsqfSBib3RoIFJldHVybiBvcmlnaW5hbCBzdHJpbmcgYW5kIHRoZSBub3JtYWxpemVkIHN0cmluZ1xuXHQgKiBAcmV0dXJucyBTdHJpbmcgb3IgdW5kZWZpbmVkXG5cdCAqL1xuXHRkaWFjcml0aWNzOiBmdW5jdGlvbiAobWl4ZWQsIGJvdGgpIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiBtaXhlZDtcblxuXHRcdGlmICh0eXBlICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRyZXR1cm4gX25vcm1hbGl6ZShtaXhlZCwgYm90aCk7XG5cdFx0fVxuXHRcdF9ub3JtYWxpemUgPSBtaXhlZDtcblx0fSxcblxuXHQvKipcblx0ICogRGVib3VuY2UgYSBmdW5jdGlvblxuXHQgKlxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBiZSBjYWxsZWRcblx0ICogQHBhcmFtIHtpbnRlZ2VyfSBmcmVxIENhbGwgZnJlcXVlbmN5IGluIG1TXG5cdCAqIEByZXR1cm4ge2Z1bmN0aW9ufSBXcmFwcGVkIGZ1bmN0aW9uXG5cdCAqL1xuXHRkZWJvdW5jZTogZnVuY3Rpb24gKCBmbiwgdGltZW91dCApIHtcblx0XHR2YXIgdGltZXI7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdFx0dmFyIGFyZ3MgPSBhcmd1bWVudHM7XG5cblx0XHRcdGNsZWFyVGltZW91dCh0aW1lcik7XG5cblx0XHRcdHRpbWVyID0gc2V0VGltZW91dCggZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRmbi5hcHBseSh0aGF0LCBhcmdzKTtcblx0XHRcdH0sIHRpbWVvdXQgfHwgMjUwICk7XG5cdFx0fTtcblx0fSxcblxuXHQvKipcblx0ICogVGhyb3R0bGUgdGhlIGNhbGxzIHRvIGEgZnVuY3Rpb24uIEFyZ3VtZW50cyBhbmQgY29udGV4dCBhcmUgbWFpbnRhaW5lZFxuXHQgKiBmb3IgdGhlIHRocm90dGxlZCBmdW5jdGlvbi5cblx0ICpcblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gYmUgY2FsbGVkXG5cdCAqIEBwYXJhbSB7aW50ZWdlcn0gZnJlcSBDYWxsIGZyZXF1ZW5jeSBpbiBtU1xuXHQgKiBAcmV0dXJuIHtmdW5jdGlvbn0gV3JhcHBlZCBmdW5jdGlvblxuXHQgKi9cblx0dGhyb3R0bGU6IGZ1bmN0aW9uICggZm4sIGZyZXEgKSB7XG5cdFx0dmFyXG5cdFx0XHRmcmVxdWVuY3kgPSBmcmVxICE9PSB1bmRlZmluZWQgPyBmcmVxIDogMjAwLFxuXHRcdFx0bGFzdCxcblx0XHRcdHRpbWVyO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhclxuXHRcdFx0XHR0aGF0ID0gdGhpcyxcblx0XHRcdFx0bm93ICA9ICtuZXcgRGF0ZSgpLFxuXHRcdFx0XHRhcmdzID0gYXJndW1lbnRzO1xuXG5cdFx0XHRpZiAoIGxhc3QgJiYgbm93IDwgbGFzdCArIGZyZXF1ZW5jeSApIHtcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KCB0aW1lciApO1xuXG5cdFx0XHRcdHRpbWVyID0gc2V0VGltZW91dCggZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdGxhc3QgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0Zm4uYXBwbHkoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0fSwgZnJlcXVlbmN5ICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0bGFzdCA9IG5vdztcblx0XHRcdFx0Zm4uYXBwbHkoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBFc2NhcGUgYSBzdHJpbmcgc3VjaCB0aGF0IGl0IGNhbiBiZSB1c2VkIGluIGEgcmVndWxhciBleHByZXNzaW9uXG5cdCAqXG5cdCAqICBAcGFyYW0ge3N0cmluZ30gdmFsIHN0cmluZyB0byBlc2NhcGVcblx0ICogIEByZXR1cm5zIHtzdHJpbmd9IGVzY2FwZWQgc3RyaW5nXG5cdCAqL1xuXHRlc2NhcGVSZWdleDogZnVuY3Rpb24gKCB2YWwgKSB7XG5cdFx0cmV0dXJuIHZhbC5yZXBsYWNlKCBfcmVfZXNjYXBlX3JlZ2V4LCAnXFxcXCQxJyApO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYSBmdW5jdGlvbiB0aGF0IHdpbGwgd3JpdGUgdG8gYSBuZXN0ZWQgb2JqZWN0IG9yIGFycmF5XG5cdCAqIEBwYXJhbSB7Kn0gc291cmNlIEpTT04gbm90YXRpb24gc3RyaW5nXG5cdCAqIEByZXR1cm5zIFdyaXRlIGZ1bmN0aW9uXG5cdCAqL1xuXHRzZXQ6IGZ1bmN0aW9uICggc291cmNlICkge1xuXHRcdGlmICggJC5pc1BsYWluT2JqZWN0KCBzb3VyY2UgKSApIHtcblx0XHRcdC8qIFVubGlrZSBnZXQsIG9ubHkgdGhlIHVuZGVyc2NvcmUgKGdsb2JhbCkgb3B0aW9uIGlzIHVzZWQgZm9yIGZvclxuXHRcdFx0ICogc2V0dGluZyBkYXRhIHNpbmNlIHdlIGRvbid0IGtub3cgdGhlIHR5cGUgaGVyZS4gVGhpcyBpcyB3aHkgYW4gb2JqZWN0XG5cdFx0XHQgKiBvcHRpb24gaXMgbm90IGRvY3VtZW50ZWQgZm9yIGBtRGF0YWAgKHdoaWNoIGlzIHJlYWQvd3JpdGUpLCBidXQgaXQgaXNcblx0XHRcdCAqIGZvciBgbVJlbmRlcmAgd2hpY2ggaXMgcmVhZCBvbmx5LlxuXHRcdFx0ICovXG5cdFx0XHRyZXR1cm4gRGF0YVRhYmxlLnV0aWwuc2V0KCBzb3VyY2UuXyApO1xuXHRcdH1cblx0XHRlbHNlIGlmICggc291cmNlID09PSBudWxsICkge1xuXHRcdFx0Ly8gTm90aGluZyB0byBkbyB3aGVuIHRoZSBkYXRhIHNvdXJjZSBpcyBudWxsXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge307XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCB0eXBlb2Ygc291cmNlID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIChkYXRhLCB2YWwsIG1ldGEpIHtcblx0XHRcdFx0c291cmNlKCBkYXRhLCAnc2V0JywgdmFsLCBtZXRhICk7XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRlbHNlIGlmIChcblx0XHRcdHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnICYmIChzb3VyY2UuaW5kZXhPZignLicpICE9PSAtMSB8fFxuXHRcdFx0c291cmNlLmluZGV4T2YoJ1snKSAhPT0gLTEgfHwgc291cmNlLmluZGV4T2YoJygnKSAhPT0gLTEpXG5cdFx0KSB7XG5cdFx0XHQvLyBMaWtlIHRoZSBnZXQsIHdlIG5lZWQgdG8gZ2V0IGRhdGEgZnJvbSBhIG5lc3RlZCBvYmplY3Rcblx0XHRcdHZhciBzZXREYXRhID0gZnVuY3Rpb24gKGRhdGEsIHZhbCwgc3JjKSB7XG5cdFx0XHRcdHZhciBhID0gX2ZuU3BsaXRPYmpOb3RhdGlvbiggc3JjICksIGI7XG5cdFx0XHRcdHZhciBhTGFzdCA9IGFbYS5sZW5ndGgtMV07XG5cdFx0XHRcdHZhciBhcnJheU5vdGF0aW9uLCBmdW5jTm90YXRpb24sIG8sIGlubmVyU3JjO1xuXHRcblx0XHRcdFx0Zm9yICggdmFyIGk9MCwgaUxlbj1hLmxlbmd0aC0xIDsgaTxpTGVuIDsgaSsrICkge1xuXHRcdFx0XHRcdC8vIFByb3RlY3QgYWdhaW5zdCBwcm90b3R5cGUgcG9sbHV0aW9uXG5cdFx0XHRcdFx0aWYgKGFbaV0gPT09ICdfX3Byb3RvX18nIHx8IGFbaV0gPT09ICdjb25zdHJ1Y3RvcicpIHtcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignQ2Fubm90IHNldCBwcm90b3R5cGUgdmFsdWVzJyk7XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHQvLyBDaGVjayBpZiB3ZSBhcmUgZGVhbGluZyB3aXRoIGFuIGFycmF5IG5vdGF0aW9uIHJlcXVlc3Rcblx0XHRcdFx0XHRhcnJheU5vdGF0aW9uID0gYVtpXS5tYXRjaChfX3JlQXJyYXkpO1xuXHRcdFx0XHRcdGZ1bmNOb3RhdGlvbiA9IGFbaV0ubWF0Y2goX19yZUZuKTtcblx0XG5cdFx0XHRcdFx0aWYgKCBhcnJheU5vdGF0aW9uICkge1xuXHRcdFx0XHRcdFx0YVtpXSA9IGFbaV0ucmVwbGFjZShfX3JlQXJyYXksICcnKTtcblx0XHRcdFx0XHRcdGRhdGFbIGFbaV0gXSA9IFtdO1xuXHRcblx0XHRcdFx0XHRcdC8vIEdldCB0aGUgcmVtYWluZGVyIG9mIHRoZSBuZXN0ZWQgb2JqZWN0IHRvIHNldCBzbyB3ZSBjYW4gcmVjdXJzZVxuXHRcdFx0XHRcdFx0YiA9IGEuc2xpY2UoKTtcblx0XHRcdFx0XHRcdGIuc3BsaWNlKCAwLCBpKzEgKTtcblx0XHRcdFx0XHRcdGlubmVyU3JjID0gYi5qb2luKCcuJyk7XG5cdFxuXHRcdFx0XHRcdFx0Ly8gVHJhdmVyc2UgZWFjaCBlbnRyeSBpbiB0aGUgYXJyYXkgc2V0dGluZyB0aGUgcHJvcGVydGllcyByZXF1ZXN0ZWRcblx0XHRcdFx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsICkgKSB7XG5cdFx0XHRcdFx0XHRcdGZvciAoIHZhciBqPTAsIGpMZW49dmFsLmxlbmd0aCA7IGo8akxlbiA7IGorKyApIHtcblx0XHRcdFx0XHRcdFx0XHRvID0ge307XG5cdFx0XHRcdFx0XHRcdFx0c2V0RGF0YSggbywgdmFsW2pdLCBpbm5lclNyYyApO1xuXHRcdFx0XHRcdFx0XHRcdGRhdGFbIGFbaV0gXS5wdXNoKCBvICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBXZSd2ZSBiZWVuIGFza2VkIHRvIHNhdmUgZGF0YSB0byBhbiBhcnJheSwgYnV0IGl0XG5cdFx0XHRcdFx0XHRcdC8vIGlzbid0IGFycmF5IGRhdGEgdG8gYmUgc2F2ZWQuIEJlc3QgdGhhdCBjYW4gYmUgZG9uZVxuXHRcdFx0XHRcdFx0XHQvLyBpcyB0byBqdXN0IHNhdmUgdGhlIHZhbHVlLlxuXHRcdFx0XHRcdFx0XHRkYXRhWyBhW2ldIF0gPSB2YWw7XG5cdFx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdFx0Ly8gVGhlIGlubmVyIGNhbGwgdG8gc2V0RGF0YSBoYXMgYWxyZWFkeSB0cmF2ZXJzZWQgdGhyb3VnaCB0aGUgcmVtYWluZGVyXG5cdFx0XHRcdFx0XHQvLyBvZiB0aGUgc291cmNlIGFuZCBoYXMgc2V0IHRoZSBkYXRhLCB0aHVzIHdlIGNhbiBleGl0IGhlcmVcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBpZiAoIGZ1bmNOb3RhdGlvbiApIHtcblx0XHRcdFx0XHRcdC8vIEZ1bmN0aW9uIGNhbGxcblx0XHRcdFx0XHRcdGFbaV0gPSBhW2ldLnJlcGxhY2UoX19yZUZuLCAnJyk7XG5cdFx0XHRcdFx0XHRkYXRhID0gZGF0YVsgYVtpXSBdKCB2YWwgKTtcblx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdC8vIElmIHRoZSBuZXN0ZWQgb2JqZWN0IGRvZXNuJ3QgY3VycmVudGx5IGV4aXN0IC0gc2luY2Ugd2UgYXJlXG5cdFx0XHRcdFx0Ly8gdHJ5aW5nIHRvIHNldCB0aGUgdmFsdWUgLSBjcmVhdGUgaXRcblx0XHRcdFx0XHRpZiAoIGRhdGFbIGFbaV0gXSA9PT0gbnVsbCB8fCBkYXRhWyBhW2ldIF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGRhdGFbIGFbaV0gXSA9IHt9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRhID0gZGF0YVsgYVtpXSBdO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHQvLyBMYXN0IGl0ZW0gaW4gdGhlIGlucHV0IC0gaS5lLCB0aGUgYWN0dWFsIHNldFxuXHRcdFx0XHRpZiAoIGFMYXN0Lm1hdGNoKF9fcmVGbiApICkge1xuXHRcdFx0XHRcdC8vIEZ1bmN0aW9uIGNhbGxcblx0XHRcdFx0XHRkYXRhID0gZGF0YVsgYUxhc3QucmVwbGFjZShfX3JlRm4sICcnKSBdKCB2YWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHQvLyBJZiBhcnJheSBub3RhdGlvbiBpcyB1c2VkLCB3ZSBqdXN0IHdhbnQgdG8gc3RyaXAgaXQgYW5kIHVzZSB0aGUgcHJvcGVydHkgbmFtZVxuXHRcdFx0XHRcdC8vIGFuZCBhc3NpZ24gdGhlIHZhbHVlLiBJZiBpdCBpc24ndCB1c2VkLCB0aGVuIHdlIGdldCB0aGUgcmVzdWx0IHdlIHdhbnQgYW55d2F5XG5cdFx0XHRcdFx0ZGF0YVsgYUxhc3QucmVwbGFjZShfX3JlQXJyYXksICcnKSBdID0gdmFsO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcblx0XHRcdHJldHVybiBmdW5jdGlvbiAoZGF0YSwgdmFsKSB7IC8vIG1ldGEgaXMgYWxzbyBwYXNzZWQgaW4sIGJ1dCBub3QgdXNlZFxuXHRcdFx0XHRyZXR1cm4gc2V0RGF0YSggZGF0YSwgdmFsLCBzb3VyY2UgKTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gQXJyYXkgb3IgZmxhdCBvYmplY3QgbWFwcGluZ1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIChkYXRhLCB2YWwpIHsgLy8gbWV0YSBpcyBhbHNvIHBhc3NlZCBpbiwgYnV0IG5vdCB1c2VkXG5cdFx0XHRcdGRhdGFbc291cmNlXSA9IHZhbDtcblx0XHRcdH07XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYSBmdW5jdGlvbiB0aGF0IHdpbGwgcmVhZCBuZXN0ZWQgb2JqZWN0cyBmcm9tIGFycmF5cywgYmFzZWQgb24gSlNPTiBub3RhdGlvblxuXHQgKiBAcGFyYW0geyp9IHNvdXJjZSBKU09OIG5vdGF0aW9uIHN0cmluZ1xuXHQgKiBAcmV0dXJucyBWYWx1ZSByZWFkXG5cdCAqL1xuXHRnZXQ6IGZ1bmN0aW9uICggc291cmNlICkge1xuXHRcdGlmICggJC5pc1BsYWluT2JqZWN0KCBzb3VyY2UgKSApIHtcblx0XHRcdC8vIEJ1aWxkIGFuIG9iamVjdCBvZiBnZXQgZnVuY3Rpb25zLCBhbmQgd3JhcCB0aGVtIGluIGEgc2luZ2xlIGNhbGxcblx0XHRcdHZhciBvID0ge307XG5cdFx0XHQkLmVhY2goIHNvdXJjZSwgZnVuY3Rpb24gKGtleSwgdmFsKSB7XG5cdFx0XHRcdGlmICggdmFsICkge1xuXHRcdFx0XHRcdG9ba2V5XSA9IERhdGFUYWJsZS51dGlsLmdldCggdmFsICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKGRhdGEsIHR5cGUsIHJvdywgbWV0YSkge1xuXHRcdFx0XHR2YXIgdCA9IG9bdHlwZV0gfHwgby5fO1xuXHRcdFx0XHRyZXR1cm4gdCAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0XHR0KGRhdGEsIHR5cGUsIHJvdywgbWV0YSkgOlxuXHRcdFx0XHRcdGRhdGE7XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRlbHNlIGlmICggc291cmNlID09PSBudWxsICkge1xuXHRcdFx0Ly8gR2l2ZSBhbiBlbXB0eSBzdHJpbmcgZm9yIHJlbmRlcmluZyAvIHNvcnRpbmcgZXRjXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHsgLy8gdHlwZSwgcm93IGFuZCBtZXRhIGFsc28gcGFzc2VkLCBidXQgbm90IHVzZWRcblx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRlbHNlIGlmICggdHlwZW9mIHNvdXJjZSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiAoZGF0YSwgdHlwZSwgcm93LCBtZXRhKSB7XG5cdFx0XHRcdHJldHVybiBzb3VyY2UoIGRhdGEsIHR5cGUsIHJvdywgbWV0YSApO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoXG5cdFx0XHR0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJyAmJiAoc291cmNlLmluZGV4T2YoJy4nKSAhPT0gLTEgfHxcblx0XHRcdHNvdXJjZS5pbmRleE9mKCdbJykgIT09IC0xIHx8IHNvdXJjZS5pbmRleE9mKCcoJykgIT09IC0xKVxuXHRcdCkge1xuXHRcdFx0LyogSWYgdGhlcmUgaXMgYSAuIGluIHRoZSBzb3VyY2Ugc3RyaW5nIHRoZW4gdGhlIGRhdGEgc291cmNlIGlzIGluIGFcblx0XHRcdCAqIG5lc3RlZCBvYmplY3Qgc28gd2UgbG9vcCBvdmVyIHRoZSBkYXRhIGZvciBlYWNoIGxldmVsIHRvIGdldCB0aGUgbmV4dFxuXHRcdFx0ICogbGV2ZWwgZG93bi4gT24gZWFjaCBsb29wIHdlIHRlc3QgZm9yIHVuZGVmaW5lZCwgYW5kIGlmIGZvdW5kIGltbWVkaWF0ZWx5XG5cdFx0XHQgKiByZXR1cm4uIFRoaXMgYWxsb3dzIGVudGlyZSBvYmplY3RzIHRvIGJlIG1pc3NpbmcgYW5kIHNEZWZhdWx0Q29udGVudCB0b1xuXHRcdFx0ICogYmUgdXNlZCBpZiBkZWZpbmVkLCByYXRoZXIgdGhhbiB0aHJvd2luZyBhbiBlcnJvclxuXHRcdFx0ICovXG5cdFx0XHR2YXIgZmV0Y2hEYXRhID0gZnVuY3Rpb24gKGRhdGEsIHR5cGUsIHNyYykge1xuXHRcdFx0XHR2YXIgYXJyYXlOb3RhdGlvbiwgZnVuY05vdGF0aW9uLCBvdXQsIGlubmVyU3JjO1xuXHRcblx0XHRcdFx0aWYgKCBzcmMgIT09IFwiXCIgKSB7XG5cdFx0XHRcdFx0dmFyIGEgPSBfZm5TcGxpdE9iak5vdGF0aW9uKCBzcmMgKTtcblx0XG5cdFx0XHRcdFx0Zm9yICggdmFyIGk9MCwgaUxlbj1hLmxlbmd0aCA7IGk8aUxlbiA7IGkrKyApIHtcblx0XHRcdFx0XHRcdC8vIENoZWNrIGlmIHdlIGFyZSBkZWFsaW5nIHdpdGggc3BlY2lhbCBub3RhdGlvblxuXHRcdFx0XHRcdFx0YXJyYXlOb3RhdGlvbiA9IGFbaV0ubWF0Y2goX19yZUFycmF5KTtcblx0XHRcdFx0XHRcdGZ1bmNOb3RhdGlvbiA9IGFbaV0ubWF0Y2goX19yZUZuKTtcblx0XG5cdFx0XHRcdFx0XHRpZiAoIGFycmF5Tm90YXRpb24gKSB7XG5cdFx0XHRcdFx0XHRcdC8vIEFycmF5IG5vdGF0aW9uXG5cdFx0XHRcdFx0XHRcdGFbaV0gPSBhW2ldLnJlcGxhY2UoX19yZUFycmF5LCAnJyk7XG5cdFxuXHRcdFx0XHRcdFx0XHQvLyBDb25kaXRpb24gYWxsb3dzIHNpbXBseSBbXSB0byBiZSBwYXNzZWQgaW5cblx0XHRcdFx0XHRcdFx0aWYgKCBhW2ldICE9PSBcIlwiICkge1xuXHRcdFx0XHRcdFx0XHRcdGRhdGEgPSBkYXRhWyBhW2ldIF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0b3V0ID0gW107XG5cdFxuXHRcdFx0XHRcdFx0XHQvLyBHZXQgdGhlIHJlbWFpbmRlciBvZiB0aGUgbmVzdGVkIG9iamVjdCB0byBnZXRcblx0XHRcdFx0XHRcdFx0YS5zcGxpY2UoIDAsIGkrMSApO1xuXHRcdFx0XHRcdFx0XHRpbm5lclNyYyA9IGEuam9pbignLicpO1xuXHRcblx0XHRcdFx0XHRcdFx0Ly8gVHJhdmVyc2UgZWFjaCBlbnRyeSBpbiB0aGUgYXJyYXkgZ2V0dGluZyB0aGUgcHJvcGVydGllcyByZXF1ZXN0ZWRcblx0XHRcdFx0XHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBkYXRhICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Zm9yICggdmFyIGo9MCwgakxlbj1kYXRhLmxlbmd0aCA7IGo8akxlbiA7IGorKyApIHtcblx0XHRcdFx0XHRcdFx0XHRcdG91dC5wdXNoKCBmZXRjaERhdGEoIGRhdGFbal0sIHR5cGUsIGlubmVyU3JjICkgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0XHRcdC8vIElmIGEgc3RyaW5nIGlzIGdpdmVuIGluIGJldHdlZW4gdGhlIGFycmF5IG5vdGF0aW9uIGluZGljYXRvcnMsIHRoYXRcblx0XHRcdFx0XHRcdFx0Ly8gaXMgdXNlZCB0byBqb2luIHRoZSBzdHJpbmdzIHRvZ2V0aGVyLCBvdGhlcndpc2UgYW4gYXJyYXkgaXMgcmV0dXJuZWRcblx0XHRcdFx0XHRcdFx0dmFyIGpvaW4gPSBhcnJheU5vdGF0aW9uWzBdLnN1YnN0cmluZygxLCBhcnJheU5vdGF0aW9uWzBdLmxlbmd0aC0xKTtcblx0XHRcdFx0XHRcdFx0ZGF0YSA9IChqb2luPT09XCJcIikgPyBvdXQgOiBvdXQuam9pbihqb2luKTtcblx0XG5cdFx0XHRcdFx0XHRcdC8vIFRoZSBpbm5lciBjYWxsIHRvIGZldGNoRGF0YSBoYXMgYWxyZWFkeSB0cmF2ZXJzZWQgdGhyb3VnaCB0aGUgcmVtYWluZGVyXG5cdFx0XHRcdFx0XHRcdC8vIG9mIHRoZSBzb3VyY2UgcmVxdWVzdGVkLCBzbyB3ZSBleGl0IGZyb20gdGhlIGxvb3Bcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIGlmICggZnVuY05vdGF0aW9uICkge1xuXHRcdFx0XHRcdFx0XHQvLyBGdW5jdGlvbiBjYWxsXG5cdFx0XHRcdFx0XHRcdGFbaV0gPSBhW2ldLnJlcGxhY2UoX19yZUZuLCAnJyk7XG5cdFx0XHRcdFx0XHRcdGRhdGEgPSBkYXRhWyBhW2ldIF0oKTtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdFx0aWYgKGRhdGEgPT09IG51bGwgfHwgZGF0YVsgYVtpXSBdID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCB8fCBkYXRhWyBhW2ldIF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0ZGF0YSA9IGRhdGFbIGFbaV0gXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0fTtcblx0XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKGRhdGEsIHR5cGUpIHsgLy8gcm93IGFuZCBtZXRhIGFsc28gcGFzc2VkLCBidXQgbm90IHVzZWRcblx0XHRcdFx0cmV0dXJuIGZldGNoRGF0YSggZGF0YSwgdHlwZSwgc291cmNlICk7XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIEFycmF5IG9yIGZsYXQgb2JqZWN0IG1hcHBpbmdcblx0XHRcdHJldHVybiBmdW5jdGlvbiAoZGF0YSkgeyAvLyByb3cgYW5kIG1ldGEgYWxzbyBwYXNzZWQsIGJ1dCBub3QgdXNlZFxuXHRcdFx0XHRyZXR1cm4gZGF0YVtzb3VyY2VdO1xuXHRcdFx0fTtcblx0XHR9XG5cdH0sXG5cblx0c3RyaXBIdG1sOiBmdW5jdGlvbiAobWl4ZWQpIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiBtaXhlZDtcblxuXHRcdGlmICh0eXBlID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRfc3RyaXBIdG1sID0gbWl4ZWQ7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRyZXR1cm4gX3N0cmlwSHRtbChtaXhlZCk7XG5cdFx0fVxuXHRcdHJldHVybiBtaXhlZDtcblx0fSxcblxuXHRlc2NhcGVIdG1sOiBmdW5jdGlvbiAobWl4ZWQpIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiBtaXhlZDtcblxuXHRcdGlmICh0eXBlID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRfZXNjYXBlSHRtbCA9IG1peGVkO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJyB8fCBBcnJheS5pc0FycmF5KG1peGVkKSkge1xuXHRcdFx0cmV0dXJuIF9lc2NhcGVIdG1sKG1peGVkKTtcblx0XHR9XG5cdFx0cmV0dXJuIG1peGVkO1xuXHR9LFxuXG5cdHVuaXF1ZTogX3VuaXF1ZVxufTtcblxuXG5cbi8qKlxuICogQ3JlYXRlIGEgbWFwcGluZyBvYmplY3QgdGhhdCBhbGxvd3MgY2FtZWwgY2FzZSBwYXJhbWV0ZXJzIHRvIGJlIGxvb2tlZCB1cFxuICogZm9yIHRoZWlyIEh1bmdhcmlhbiBjb3VudGVycGFydHMuIFRoZSBtYXBwaW5nIGlzIHN0b3JlZCBpbiBhIHByaXZhdGVcbiAqIHBhcmFtZXRlciBjYWxsZWQgYF9odW5nYXJpYW5NYXBgIHdoaWNoIGNhbiBiZSBhY2Nlc3NlZCBvbiB0aGUgc291cmNlIG9iamVjdC5cbiAqICBAcGFyYW0ge29iamVjdH0gb1xuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5IdW5nYXJpYW5NYXAgKCBvIClcbntcblx0dmFyXG5cdFx0aHVuZ2FyaWFuID0gJ2EgYWEgYWkgYW8gYXMgYiBmbiBpIG0gbyBzICcsXG5cdFx0bWF0Y2gsXG5cdFx0bmV3S2V5LFxuXHRcdG1hcCA9IHt9O1xuXG5cdCQuZWFjaCggbywgZnVuY3Rpb24gKGtleSkge1xuXHRcdG1hdGNoID0ga2V5Lm1hdGNoKC9eKFteQS1aXSs/KShbQS1aXSkvKTtcblxuXHRcdGlmICggbWF0Y2ggJiYgaHVuZ2FyaWFuLmluZGV4T2YobWF0Y2hbMV0rJyAnKSAhPT0gLTEgKVxuXHRcdHtcblx0XHRcdG5ld0tleSA9IGtleS5yZXBsYWNlKCBtYXRjaFswXSwgbWF0Y2hbMl0udG9Mb3dlckNhc2UoKSApO1xuXHRcdFx0bWFwWyBuZXdLZXkgXSA9IGtleTtcblxuXHRcdFx0aWYgKCBtYXRjaFsxXSA9PT0gJ28nIClcblx0XHRcdHtcblx0XHRcdFx0X2ZuSHVuZ2FyaWFuTWFwKCBvW2tleV0gKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gKTtcblxuXHRvLl9odW5nYXJpYW5NYXAgPSBtYXA7XG59XG5cblxuLyoqXG4gKiBDb252ZXJ0IGZyb20gY2FtZWwgY2FzZSBwYXJhbWV0ZXJzIHRvIEh1bmdhcmlhbiwgYmFzZWQgb24gYSBIdW5nYXJpYW4gbWFwXG4gKiBjcmVhdGVkIGJ5IF9mbkh1bmdhcmlhbk1hcC5cbiAqICBAcGFyYW0ge29iamVjdH0gc3JjIFRoZSBtb2RlbCBvYmplY3Qgd2hpY2ggaG9sZHMgYWxsIHBhcmFtZXRlcnMgdGhhdCBjYW4gYmVcbiAqICAgIG1hcHBlZC5cbiAqICBAcGFyYW0ge29iamVjdH0gdXNlciBUaGUgb2JqZWN0IHRvIGNvbnZlcnQgZnJvbSBjYW1lbCBjYXNlIHRvIEh1bmdhcmlhbi5cbiAqICBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlIFdoZW4gc2V0IHRvIGB0cnVlYCwgcHJvcGVydGllcyB3aGljaCBhbHJlYWR5IGhhdmUgYVxuICogICAgSHVuZ2FyaWFuIHZhbHVlIGluIHRoZSBgdXNlcmAgb2JqZWN0IHdpbGwgYmUgb3ZlcndyaXR0ZW4uIE90aGVyd2lzZSB0aGV5XG4gKiAgICB3b24ndCBiZS5cbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuQ2FtZWxUb0h1bmdhcmlhbiAoIHNyYywgdXNlciwgZm9yY2UgKVxue1xuXHRpZiAoICEgc3JjLl9odW5nYXJpYW5NYXAgKSB7XG5cdFx0X2ZuSHVuZ2FyaWFuTWFwKCBzcmMgKTtcblx0fVxuXG5cdHZhciBodW5nYXJpYW5LZXk7XG5cblx0JC5lYWNoKCB1c2VyLCBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0aHVuZ2FyaWFuS2V5ID0gc3JjLl9odW5nYXJpYW5NYXBbIGtleSBdO1xuXG5cdFx0aWYgKCBodW5nYXJpYW5LZXkgIT09IHVuZGVmaW5lZCAmJiAoZm9yY2UgfHwgdXNlcltodW5nYXJpYW5LZXldID09PSB1bmRlZmluZWQpIClcblx0XHR7XG5cdFx0XHQvLyBGb3Igb2JqZWN0cywgd2UgbmVlZCB0byBidXp6IGRvd24gaW50byB0aGUgb2JqZWN0IHRvIGNvcHkgcGFyYW1ldGVyc1xuXHRcdFx0aWYgKCBodW5nYXJpYW5LZXkuY2hhckF0KDApID09PSAnbycgKVxuXHRcdFx0e1xuXHRcdFx0XHQvLyBDb3B5IHRoZSBjYW1lbENhc2Ugb3B0aW9ucyBvdmVyIHRvIHRoZSBodW5nYXJpYW5cblx0XHRcdFx0aWYgKCAhIHVzZXJbIGh1bmdhcmlhbktleSBdICkge1xuXHRcdFx0XHRcdHVzZXJbIGh1bmdhcmlhbktleSBdID0ge307XG5cdFx0XHRcdH1cblx0XHRcdFx0JC5leHRlbmQoIHRydWUsIHVzZXJbaHVuZ2FyaWFuS2V5XSwgdXNlcltrZXldICk7XG5cblx0XHRcdFx0X2ZuQ2FtZWxUb0h1bmdhcmlhbiggc3JjW2h1bmdhcmlhbktleV0sIHVzZXJbaHVuZ2FyaWFuS2V5XSwgZm9yY2UgKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR1c2VyW2h1bmdhcmlhbktleV0gPSB1c2VyWyBrZXkgXTtcblx0XHRcdH1cblx0XHR9XG5cdH0gKTtcbn1cblxuLyoqXG4gKiBNYXAgb25lIHBhcmFtZXRlciBvbnRvIGFub3RoZXJcbiAqICBAcGFyYW0ge29iamVjdH0gbyBPYmplY3QgdG8gbWFwXG4gKiAgQHBhcmFtIHsqfSBrbmV3IFRoZSBuZXcgcGFyYW1ldGVyIG5hbWVcbiAqICBAcGFyYW0geyp9IG9sZCBUaGUgb2xkIHBhcmFtZXRlciBuYW1lXG4gKi9cbnZhciBfZm5Db21wYXRNYXAgPSBmdW5jdGlvbiAoIG8sIGtuZXcsIG9sZCApIHtcblx0aWYgKCBvWyBrbmV3IF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRvWyBvbGQgXSA9IG9bIGtuZXcgXTtcblx0fVxufTtcblxuXG4vKipcbiAqIFByb3ZpZGUgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgZm9yIHRoZSBtYWluIERUIG9wdGlvbnMuIE5vdGUgdGhhdCB0aGUgbmV3XG4gKiBvcHRpb25zIGFyZSBtYXBwZWQgb250byB0aGUgb2xkIHBhcmFtZXRlcnMsIHNvIHRoaXMgaXMgYW4gZXh0ZXJuYWwgaW50ZXJmYWNlXG4gKiBjaGFuZ2Ugb25seS5cbiAqICBAcGFyYW0ge29iamVjdH0gaW5pdCBPYmplY3QgdG8gbWFwXG4gKi9cbmZ1bmN0aW9uIF9mbkNvbXBhdE9wdHMgKCBpbml0IClcbntcblx0X2ZuQ29tcGF0TWFwKCBpbml0LCAnb3JkZXJpbmcnLCAgICAgICdiU29ydCcgKTtcblx0X2ZuQ29tcGF0TWFwKCBpbml0LCAnb3JkZXJNdWx0aScsICAgICdiU29ydE11bHRpJyApO1xuXHRfZm5Db21wYXRNYXAoIGluaXQsICdvcmRlckNsYXNzZXMnLCAgJ2JTb3J0Q2xhc3NlcycgKTtcblx0X2ZuQ29tcGF0TWFwKCBpbml0LCAnb3JkZXJDZWxsc1RvcCcsICdiU29ydENlbGxzVG9wJyApO1xuXHRfZm5Db21wYXRNYXAoIGluaXQsICdvcmRlcicsICAgICAgICAgJ2FhU29ydGluZycgKTtcblx0X2ZuQ29tcGF0TWFwKCBpbml0LCAnb3JkZXJGaXhlZCcsICAgICdhYVNvcnRpbmdGaXhlZCcgKTtcblx0X2ZuQ29tcGF0TWFwKCBpbml0LCAncGFnaW5nJywgICAgICAgICdiUGFnaW5hdGUnICk7XG5cdF9mbkNvbXBhdE1hcCggaW5pdCwgJ3BhZ2luZ1R5cGUnLCAgICAnc1BhZ2luYXRpb25UeXBlJyApO1xuXHRfZm5Db21wYXRNYXAoIGluaXQsICdwYWdlTGVuZ3RoJywgICAgJ2lEaXNwbGF5TGVuZ3RoJyApO1xuXHRfZm5Db21wYXRNYXAoIGluaXQsICdzZWFyY2hpbmcnLCAgICAgJ2JGaWx0ZXInICk7XG5cblx0Ly8gQm9vbGVhbiBpbml0aWFsaXNhdGlvbiBvZiB4LXNjcm9sbGluZ1xuXHRpZiAoIHR5cGVvZiBpbml0LnNTY3JvbGxYID09PSAnYm9vbGVhbicgKSB7XG5cdFx0aW5pdC5zU2Nyb2xsWCA9IGluaXQuc1Njcm9sbFggPyAnMTAwJScgOiAnJztcblx0fVxuXHRpZiAoIHR5cGVvZiBpbml0LnNjcm9sbFggPT09ICdib29sZWFuJyApIHtcblx0XHRpbml0LnNjcm9sbFggPSBpbml0LnNjcm9sbFggPyAnMTAwJScgOiAnJztcblx0fVxuXG5cdC8vIE9iamVjdHMgZm9yIG9yZGVyaW5nXG5cdGlmICggdHlwZW9mIGluaXQuYlNvcnQgPT09ICdvYmplY3QnICkge1xuXHRcdGluaXQub3JkZXJJbmRpY2F0b3JzID0gaW5pdC5iU29ydC5pbmRpY2F0b3JzICE9PSB1bmRlZmluZWQgPyBpbml0LmJTb3J0LmluZGljYXRvcnMgOiB0cnVlO1xuXHRcdGluaXQub3JkZXJIYW5kbGVyID0gaW5pdC5iU29ydC5oYW5kbGVyICE9PSB1bmRlZmluZWQgPyBpbml0LmJTb3J0LmhhbmRsZXIgOiB0cnVlO1xuXHRcdGluaXQuYlNvcnQgPSB0cnVlO1xuXHR9XG5cdGVsc2UgaWYgKGluaXQuYlNvcnQgPT09IGZhbHNlKSB7XG5cdFx0aW5pdC5vcmRlckluZGljYXRvcnMgPSBmYWxzZTtcblx0XHRpbml0Lm9yZGVySGFuZGxlciA9IGZhbHNlO1xuXHR9XG5cdGVsc2UgaWYgKGluaXQuYlNvcnQgPT09IHRydWUpIHtcblx0XHRpbml0Lm9yZGVySW5kaWNhdG9ycyA9IHRydWU7XG5cdFx0aW5pdC5vcmRlckhhbmRsZXIgPSB0cnVlO1xuXHR9XG5cblx0Ly8gV2hpY2ggY2VsbHMgYXJlIHRoZSB0aXRsZSBjZWxscz9cblx0aWYgKHR5cGVvZiBpbml0LmJTb3J0Q2VsbHNUb3AgPT09ICdib29sZWFuJykge1xuXHRcdGluaXQudGl0bGVSb3cgPSBpbml0LmJTb3J0Q2VsbHNUb3A7XG5cdH1cblxuXHQvLyBDb2x1bW4gc2VhcmNoIG9iamVjdHMgYXJlIGluIGFuIGFycmF5LCBzbyBpdCBuZWVkcyB0byBiZSBjb252ZXJ0ZWRcblx0Ly8gZWxlbWVudCBieSBlbGVtZW50XG5cdHZhciBzZWFyY2hDb2xzID0gaW5pdC5hb1NlYXJjaENvbHM7XG5cblx0aWYgKCBzZWFyY2hDb2xzICkge1xuXHRcdGZvciAoIHZhciBpPTAsIGllbj1zZWFyY2hDb2xzLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0aWYgKCBzZWFyY2hDb2xzW2ldICkge1xuXHRcdFx0XHRfZm5DYW1lbFRvSHVuZ2FyaWFuKCBEYXRhVGFibGUubW9kZWxzLm9TZWFyY2gsIHNlYXJjaENvbHNbaV0gKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBFbmFibGUgc2VhcmNoIGRlbGF5IGlmIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcgaXMgZW5hYmxlZFxuXHRpZiAoaW5pdC5zZXJ2ZXJTaWRlICYmICEgaW5pdC5zZWFyY2hEZWxheSkge1xuXHRcdGluaXQuc2VhcmNoRGVsYXkgPSA0MDA7XG5cdH1cbn1cblxuXG4vKipcbiAqIFByb3ZpZGUgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgZm9yIGNvbHVtbiBvcHRpb25zLiBOb3RlIHRoYXQgdGhlIG5ldyBvcHRpb25zXG4gKiBhcmUgbWFwcGVkIG9udG8gdGhlIG9sZCBwYXJhbWV0ZXJzLCBzbyB0aGlzIGlzIGFuIGV4dGVybmFsIGludGVyZmFjZSBjaGFuZ2VcbiAqIG9ubHkuXG4gKiAgQHBhcmFtIHtvYmplY3R9IGluaXQgT2JqZWN0IHRvIG1hcFxuICovXG5mdW5jdGlvbiBfZm5Db21wYXRDb2xzICggaW5pdCApXG57XG5cdF9mbkNvbXBhdE1hcCggaW5pdCwgJ29yZGVyYWJsZScsICAgICAnYlNvcnRhYmxlJyApO1xuXHRfZm5Db21wYXRNYXAoIGluaXQsICdvcmRlckRhdGEnLCAgICAgJ2FEYXRhU29ydCcgKTtcblx0X2ZuQ29tcGF0TWFwKCBpbml0LCAnb3JkZXJTZXF1ZW5jZScsICdhc1NvcnRpbmcnICk7XG5cdF9mbkNvbXBhdE1hcCggaW5pdCwgJ29yZGVyRGF0YVR5cGUnLCAnc29ydERhdGFUeXBlJyApO1xuXG5cdC8vIG9yZGVyRGF0YSBjYW4gYmUgZ2l2ZW4gYXMgYW4gaW50ZWdlclxuXHR2YXIgZGF0YVNvcnQgPSBpbml0LmFEYXRhU29ydDtcblx0aWYgKCB0eXBlb2YgZGF0YVNvcnQgPT09ICdudW1iZXInICYmICEgQXJyYXkuaXNBcnJheSggZGF0YVNvcnQgKSApIHtcblx0XHRpbml0LmFEYXRhU29ydCA9IFsgZGF0YVNvcnQgXTtcblx0fVxufVxuXG5cbi8qKlxuICogQnJvd3NlciBmZWF0dXJlIGRldGVjdGlvbiBmb3IgY2FwYWJpbGl0aWVzLCBxdWlya3NcbiAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuQnJvd3NlckRldGVjdCggc2V0dGluZ3MgKVxue1xuXHQvLyBXZSBkb24ndCBuZWVkIHRvIGRvIHRoaXMgZXZlcnkgdGltZSBEYXRhVGFibGVzIGlzIGNvbnN0cnVjdGVkLCB0aGUgdmFsdWVzXG5cdC8vIGNhbGN1bGF0ZWQgYXJlIHNwZWNpZmljIHRvIHRoZSBicm93c2VyIGFuZCBPUyBjb25maWd1cmF0aW9uIHdoaWNoIHdlXG5cdC8vIGRvbid0IGV4cGVjdCB0byBjaGFuZ2UgYmV0d2VlbiBpbml0aWFsaXNhdGlvbnNcblx0aWYgKCAhIERhdGFUYWJsZS5fX2Jyb3dzZXIgKSB7XG5cdFx0dmFyIGJyb3dzZXIgPSB7fTtcblx0XHREYXRhVGFibGUuX19icm93c2VyID0gYnJvd3NlcjtcblxuXHRcdC8vIFNjcm9sbGluZyBmZWF0dXJlIC8gcXVpcmtzIGRldGVjdGlvblxuXHRcdHZhciBuID0gJCgnPGRpdi8+Jylcblx0XHRcdC5jc3MoIHtcblx0XHRcdFx0cG9zaXRpb246ICdmaXhlZCcsXG5cdFx0XHRcdHRvcDogMCxcblx0XHRcdFx0bGVmdDogLTEgKiB3aW5kb3cucGFnZVhPZmZzZXQsIC8vIGFsbG93IGZvciBzY3JvbGxpbmdcblx0XHRcdFx0aGVpZ2h0OiAxLFxuXHRcdFx0XHR3aWR0aDogMSxcblx0XHRcdFx0b3ZlcmZsb3c6ICdoaWRkZW4nXG5cdFx0XHR9IClcblx0XHRcdC5hcHBlbmQoXG5cdFx0XHRcdCQoJzxkaXYvPicpXG5cdFx0XHRcdFx0LmNzcygge1xuXHRcdFx0XHRcdFx0cG9zaXRpb246ICdhYnNvbHV0ZScsXG5cdFx0XHRcdFx0XHR0b3A6IDEsXG5cdFx0XHRcdFx0XHRsZWZ0OiAxLFxuXHRcdFx0XHRcdFx0d2lkdGg6IDEwMCxcblx0XHRcdFx0XHRcdG92ZXJmbG93OiAnc2Nyb2xsJ1xuXHRcdFx0XHRcdH0gKVxuXHRcdFx0XHRcdC5hcHBlbmQoXG5cdFx0XHRcdFx0XHQkKCc8ZGl2Lz4nKVxuXHRcdFx0XHRcdFx0XHQuY3NzKCB7XG5cdFx0XHRcdFx0XHRcdFx0d2lkdGg6ICcxMDAlJyxcblx0XHRcdFx0XHRcdFx0XHRoZWlnaHQ6IDEwXG5cdFx0XHRcdFx0XHRcdH0gKVxuXHRcdFx0XHRcdClcblx0XHRcdClcblx0XHRcdC5hcHBlbmRUbyggJ2JvZHknICk7XG5cblx0XHR2YXIgb3V0ZXIgPSBuLmNoaWxkcmVuKCk7XG5cdFx0dmFyIGlubmVyID0gb3V0ZXIuY2hpbGRyZW4oKTtcblxuXHRcdC8vIEdldCBzY3JvbGxiYXIgd2lkdGhcblx0XHRicm93c2VyLmJhcldpZHRoID0gb3V0ZXJbMF0ub2Zmc2V0V2lkdGggLSBvdXRlclswXS5jbGllbnRXaWR0aDtcblxuXHRcdC8vIEluIHJ0bCB0ZXh0IGxheW91dCwgc29tZSBicm93c2VycyAobW9zdCwgYnV0IG5vdCBhbGwpIHdpbGwgcGxhY2UgdGhlXG5cdFx0Ly8gc2Nyb2xsYmFyIG9uIHRoZSBsZWZ0LCByYXRoZXIgdGhhbiB0aGUgcmlnaHQuXG5cdFx0YnJvd3Nlci5iU2Nyb2xsYmFyTGVmdCA9IE1hdGgucm91bmQoIGlubmVyLm9mZnNldCgpLmxlZnQgKSAhPT0gMTtcblxuXHRcdG4ucmVtb3ZlKCk7XG5cdH1cblxuXHQkLmV4dGVuZCggc2V0dGluZ3Mub0Jyb3dzZXIsIERhdGFUYWJsZS5fX2Jyb3dzZXIgKTtcblx0c2V0dGluZ3Mub1Njcm9sbC5pQmFyV2lkdGggPSBEYXRhVGFibGUuX19icm93c2VyLmJhcldpZHRoO1xufVxuXG4vKipcbiAqIEFkZCBhIGNvbHVtbiB0byB0aGUgbGlzdCB1c2VkIGZvciB0aGUgdGFibGUgd2l0aCBkZWZhdWx0IHZhbHVlc1xuICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuQWRkQ29sdW1uKCBvU2V0dGluZ3MgKVxue1xuXHQvLyBBZGQgY29sdW1uIHRvIGFvQ29sdW1ucyBhcnJheVxuXHR2YXIgb0RlZmF1bHRzID0gRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbjtcblx0dmFyIGlDb2wgPSBvU2V0dGluZ3MuYW9Db2x1bW5zLmxlbmd0aDtcblx0dmFyIG9Db2wgPSAkLmV4dGVuZCgge30sIERhdGFUYWJsZS5tb2RlbHMub0NvbHVtbiwgb0RlZmF1bHRzLCB7XG5cdFx0XCJhRGF0YVNvcnRcIjogb0RlZmF1bHRzLmFEYXRhU29ydCA/IG9EZWZhdWx0cy5hRGF0YVNvcnQgOiBbaUNvbF0sXG5cdFx0XCJtRGF0YVwiOiBvRGVmYXVsdHMubURhdGEgPyBvRGVmYXVsdHMubURhdGEgOiBpQ29sLFxuXHRcdGlkeDogaUNvbCxcblx0XHRzZWFyY2hGaXhlZDoge30sXG5cdFx0Y29sRWw6ICQoJzxjb2w+JykuYXR0cignZGF0YS1kdC1jb2x1bW4nLCBpQ29sKVxuXHR9ICk7XG5cdG9TZXR0aW5ncy5hb0NvbHVtbnMucHVzaCggb0NvbCApO1xuXG5cdC8vIEFkZCBzZWFyY2ggb2JqZWN0IGZvciBjb2x1bW4gc3BlY2lmaWMgc2VhcmNoLiBOb3RlIHRoYXQgdGhlIGBzZWFyY2hDb2xzWyBpQ29sIF1gXG5cdC8vIHBhc3NlZCBpbnRvIGV4dGVuZCBjYW4gYmUgdW5kZWZpbmVkLiBUaGlzIGFsbG93cyB0aGUgdXNlciB0byBnaXZlIGEgZGVmYXVsdFxuXHQvLyB3aXRoIG9ubHkgc29tZSBvZiB0aGUgcGFyYW1ldGVycyBkZWZpbmVkLCBhbmQgYWxzbyBub3QgZ2l2ZSBhIGRlZmF1bHRcblx0dmFyIHNlYXJjaENvbHMgPSBvU2V0dGluZ3MuYW9QcmVTZWFyY2hDb2xzO1xuXHRzZWFyY2hDb2xzWyBpQ29sIF0gPSAkLmV4dGVuZCgge30sIERhdGFUYWJsZS5tb2RlbHMub1NlYXJjaCwgc2VhcmNoQ29sc1sgaUNvbCBdICk7XG59XG5cblxuLyoqXG4gKiBBcHBseSBvcHRpb25zIGZvciBhIGNvbHVtblxuICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAcGFyYW0ge2ludH0gaUNvbCBjb2x1bW4gaW5kZXggdG8gY29uc2lkZXJcbiAqICBAcGFyYW0ge29iamVjdH0gb09wdGlvbnMgb2JqZWN0IHdpdGggc1R5cGUsIGJWaXNpYmxlIGFuZCBiU2VhcmNoYWJsZSBldGNcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuQ29sdW1uT3B0aW9ucyggb1NldHRpbmdzLCBpQ29sLCBvT3B0aW9ucyApXG57XG5cdHZhciBvQ29sID0gb1NldHRpbmdzLmFvQ29sdW1uc1sgaUNvbCBdO1xuXG5cdC8qIFVzZXIgc3BlY2lmaWVkIGNvbHVtbiBvcHRpb25zICovXG5cdGlmICggb09wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBvT3B0aW9ucyAhPT0gbnVsbCApXG5cdHtcblx0XHQvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXHRcdF9mbkNvbXBhdENvbHMoIG9PcHRpb25zICk7XG5cblx0XHQvLyBNYXAgY2FtZWwgY2FzZSBwYXJhbWV0ZXJzIHRvIHRoZWlyIEh1bmdhcmlhbiBjb3VudGVycGFydHNcblx0XHRfZm5DYW1lbFRvSHVuZ2FyaWFuKCBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLCBvT3B0aW9ucywgdHJ1ZSApO1xuXG5cdFx0LyogQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgZm9yIG1EYXRhUHJvcCAqL1xuXHRcdGlmICggb09wdGlvbnMubURhdGFQcm9wICE9PSB1bmRlZmluZWQgJiYgIW9PcHRpb25zLm1EYXRhIClcblx0XHR7XG5cdFx0XHRvT3B0aW9ucy5tRGF0YSA9IG9PcHRpb25zLm1EYXRhUHJvcDtcblx0XHR9XG5cblx0XHRpZiAoIG9PcHRpb25zLnNUeXBlIClcblx0XHR7XG5cdFx0XHRvQ29sLl9zTWFudWFsVHlwZSA9IG9PcHRpb25zLnNUeXBlO1xuXHRcdH1cblx0XG5cdFx0Ly8gYGNsYXNzYCBpcyBhIHJlc2VydmVkIHdvcmQgaW4gSmF2YXNjcmlwdCwgc28gd2UgbmVlZCB0byBwcm92aWRlXG5cdFx0Ly8gdGhlIGFiaWxpdHkgdG8gdXNlIGEgdmFsaWQgbmFtZSBmb3IgdGhlIGNhbWVsIGNhc2UgaW5wdXRcblx0XHRpZiAoIG9PcHRpb25zLmNsYXNzTmFtZSAmJiAhIG9PcHRpb25zLnNDbGFzcyApXG5cdFx0e1xuXHRcdFx0b09wdGlvbnMuc0NsYXNzID0gb09wdGlvbnMuY2xhc3NOYW1lO1xuXHRcdH1cblxuXHRcdHZhciBvcmlnQ2xhc3MgPSBvQ29sLnNDbGFzcztcblxuXHRcdCQuZXh0ZW5kKCBvQ29sLCBvT3B0aW9ucyApO1xuXHRcdF9mbk1hcCggb0NvbCwgb09wdGlvbnMsIFwic1dpZHRoXCIsIFwic1dpZHRoT3JpZ1wiICk7XG5cblx0XHQvLyBNZXJnZSBjbGFzcyBmcm9tIHByZXZpb3VzbHkgZGVmaW5lZCBjbGFzc2VzIHdpdGggdGhpcyBvbmUsIHJhdGhlciB0aGFuIGp1c3Rcblx0XHQvLyBvdmVyd3JpdGluZyBpdCBpbiB0aGUgZXh0ZW5kIGFib3ZlXG5cdFx0aWYgKG9yaWdDbGFzcyAhPT0gb0NvbC5zQ2xhc3MpIHtcblx0XHRcdG9Db2wuc0NsYXNzID0gb3JpZ0NsYXNzICsgJyAnICsgb0NvbC5zQ2xhc3M7XG5cdFx0fVxuXG5cdFx0LyogaURhdGFTb3J0IHRvIGJlIGFwcGxpZWQgKGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5KSwgYnV0IGFEYXRhU29ydCB3aWxsIHRha2Vcblx0XHQgKiBwcmlvcml0eSBpZiBkZWZpbmVkXG5cdFx0ICovXG5cdFx0aWYgKCBvT3B0aW9ucy5pRGF0YVNvcnQgIT09IHVuZGVmaW5lZCApXG5cdFx0e1xuXHRcdFx0b0NvbC5hRGF0YVNvcnQgPSBbIG9PcHRpb25zLmlEYXRhU29ydCBdO1xuXHRcdH1cblx0XHRfZm5NYXAoIG9Db2wsIG9PcHRpb25zLCBcImFEYXRhU29ydFwiICk7XG5cdH1cblxuXHQvKiBDYWNoZSB0aGUgZGF0YSBnZXQgYW5kIHNldCBmdW5jdGlvbnMgZm9yIHNwZWVkICovXG5cdHZhciBtRGF0YVNyYyA9IG9Db2wubURhdGE7XG5cdHZhciBtRGF0YSA9IF9mbkdldE9iamVjdERhdGFGbiggbURhdGFTcmMgKTtcblxuXHQvLyBUaGUgYHJlbmRlcmAgb3B0aW9uIGNhbiBiZSBnaXZlbiBhcyBhbiBhcnJheSB0byBhY2Nlc3MgdGhlIGhlbHBlciByZW5kZXJpbmcgbWV0aG9kcy5cblx0Ly8gVGhlIGZpcnN0IGVsZW1lbnQgaXMgdGhlIHJlbmRlcmluZyBtZXRob2QgdG8gdXNlLCB0aGUgcmVzdCBhcmUgdGhlIHBhcmFtZXRlcnMgdG8gcGFzc1xuXHRpZiAoIG9Db2wubVJlbmRlciAmJiBBcnJheS5pc0FycmF5KCBvQ29sLm1SZW5kZXIgKSApIHtcblx0XHR2YXIgY29weSA9IG9Db2wubVJlbmRlci5zbGljZSgpO1xuXHRcdHZhciBuYW1lID0gY29weS5zaGlmdCgpO1xuXG5cdFx0b0NvbC5tUmVuZGVyID0gRGF0YVRhYmxlLnJlbmRlcltuYW1lXS5hcHBseSh3aW5kb3csIGNvcHkpO1xuXHR9XG5cblx0b0NvbC5fcmVuZGVyID0gb0NvbC5tUmVuZGVyID8gX2ZuR2V0T2JqZWN0RGF0YUZuKCBvQ29sLm1SZW5kZXIgKSA6IG51bGw7XG5cblx0dmFyIGF0dHJUZXN0ID0gZnVuY3Rpb24oIHNyYyApIHtcblx0XHRyZXR1cm4gdHlwZW9mIHNyYyA9PT0gJ3N0cmluZycgJiYgc3JjLmluZGV4T2YoJ0AnKSAhPT0gLTE7XG5cdH07XG5cdG9Db2wuX2JBdHRyU3JjID0gJC5pc1BsYWluT2JqZWN0KCBtRGF0YVNyYyApICYmIChcblx0XHRhdHRyVGVzdChtRGF0YVNyYy5zb3J0KSB8fCBhdHRyVGVzdChtRGF0YVNyYy50eXBlKSB8fCBhdHRyVGVzdChtRGF0YVNyYy5maWx0ZXIpXG5cdCk7XG5cdG9Db2wuX3NldHRlciA9IG51bGw7XG5cblx0b0NvbC5mbkdldERhdGEgPSBmdW5jdGlvbiAocm93RGF0YSwgdHlwZSwgbWV0YSkge1xuXHRcdHZhciBpbm5lckRhdGEgPSBtRGF0YSggcm93RGF0YSwgdHlwZSwgdW5kZWZpbmVkLCBtZXRhICk7XG5cblx0XHRyZXR1cm4gb0NvbC5fcmVuZGVyICYmIHR5cGUgP1xuXHRcdFx0b0NvbC5fcmVuZGVyKCBpbm5lckRhdGEsIHR5cGUsIHJvd0RhdGEsIG1ldGEgKSA6XG5cdFx0XHRpbm5lckRhdGE7XG5cdH07XG5cdG9Db2wuZm5TZXREYXRhID0gZnVuY3Rpb24gKCByb3dEYXRhLCB2YWwsIG1ldGEgKSB7XG5cdFx0cmV0dXJuIF9mblNldE9iamVjdERhdGFGbiggbURhdGFTcmMgKSggcm93RGF0YSwgdmFsLCBtZXRhICk7XG5cdH07XG5cblx0Ly8gSW5kaWNhdGUgaWYgRGF0YVRhYmxlcyBzaG91bGQgcmVhZCBET00gZGF0YSBhcyBhbiBvYmplY3Qgb3IgYXJyYXlcblx0Ly8gVXNlZCBpbiBfZm5HZXRSb3dFbGVtZW50c1xuXHRpZiAoIHR5cGVvZiBtRGF0YVNyYyAhPT0gJ251bWJlcicgJiYgISBvQ29sLl9pc0FycmF5SG9zdCApIHtcblx0XHRvU2V0dGluZ3MuX3Jvd1JlYWRPYmplY3QgPSB0cnVlO1xuXHR9XG5cblx0LyogRmVhdHVyZSBzb3J0aW5nIG92ZXJyaWRlcyBjb2x1bW4gc3BlY2lmaWMgd2hlbiBvZmYgKi9cblx0aWYgKCAhb1NldHRpbmdzLm9GZWF0dXJlcy5iU29ydCApXG5cdHtcblx0XHRvQ29sLmJTb3J0YWJsZSA9IGZhbHNlO1xuXHR9XG59XG5cblxuLyoqXG4gKiBBZGp1c3QgdGhlIHRhYmxlIGNvbHVtbiB3aWR0aHMgZm9yIG5ldyBkYXRhLiBOb3RlOiB5b3Ugd291bGQgcHJvYmFibHkgd2FudCB0b1xuICogZG8gYSByZWRyYXcgYWZ0ZXIgY2FsbGluZyB0aGlzIGZ1bmN0aW9uIVxuICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5BZGp1c3RDb2x1bW5TaXppbmcgKCBzZXR0aW5ncyApXG57XG5cdF9mbkNhbGN1bGF0ZUNvbHVtbldpZHRocyggc2V0dGluZ3MgKTtcblx0X2ZuQ29sdW1uU2l6ZXMoIHNldHRpbmdzICk7XG5cblx0dmFyIHNjcm9sbCA9IHNldHRpbmdzLm9TY3JvbGw7XG5cdGlmICggc2Nyb2xsLnNZICE9PSAnJyB8fCBzY3JvbGwuc1ggIT09ICcnKSB7XG5cdFx0X2ZuU2Nyb2xsRHJhdyggc2V0dGluZ3MgKTtcblx0fVxuXG5cdF9mbkNhbGxiYWNrRmlyZSggc2V0dGluZ3MsIG51bGwsICdjb2x1bW4tc2l6aW5nJywgW3NldHRpbmdzXSApO1xufVxuXG4vKipcbiAqIEFwcGx5IGNvbHVtbiBzaXplc1xuICpcbiAqIEBwYXJhbSB7Kn0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqL1xuZnVuY3Rpb24gX2ZuQ29sdW1uU2l6ZXMgKCBzZXR0aW5ncyApXG57XG5cdHZhciBjb2xzID0gc2V0dGluZ3MuYW9Db2x1bW5zO1xuXG5cdGZvciAodmFyIGk9MCA7IGk8Y29scy5sZW5ndGggOyBpKyspIHtcblx0XHR2YXIgd2lkdGggPSBfZm5Db2x1bW5zU3VtV2lkdGgoc2V0dGluZ3MsIFtpXSwgZmFsc2UsIGZhbHNlKTtcblxuXHRcdGNvbHNbaV0uY29sRWwuY3NzKCd3aWR0aCcsIHdpZHRoKTtcblxuXHRcdGlmIChzZXR0aW5ncy5vU2Nyb2xsLnNYKSB7XG5cdFx0XHRjb2xzW2ldLmNvbEVsLmNzcygnbWluLXdpZHRoJywgd2lkdGgpO1xuXHRcdH1cblx0fVxufVxuXG5cbi8qKlxuICogQ29udmVydCB0aGUgaW5kZXggb2YgYSB2aXNpYmxlIGNvbHVtbiB0byB0aGUgaW5kZXggaW4gdGhlIGRhdGEgYXJyYXkgKHRha2UgYWNjb3VudFxuICogb2YgaGlkZGVuIGNvbHVtbnMpXG4gKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBwYXJhbSB7aW50fSBpTWF0Y2ggVmlzaWJsZSBjb2x1bW4gaW5kZXggdG8gbG9va3VwXG4gKiAgQHJldHVybnMge2ludH0gaSB0aGUgZGF0YSBpbmRleFxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5WaXNpYmxlVG9Db2x1bW5JbmRleCggb1NldHRpbmdzLCBpTWF0Y2ggKVxue1xuXHR2YXIgYWlWaXMgPSBfZm5HZXRDb2x1bW5zKCBvU2V0dGluZ3MsICdiVmlzaWJsZScgKTtcblxuXHRyZXR1cm4gdHlwZW9mIGFpVmlzW2lNYXRjaF0gPT09ICdudW1iZXInID9cblx0XHRhaVZpc1tpTWF0Y2hdIDpcblx0XHRudWxsO1xufVxuXG5cbi8qKlxuICogQ29udmVydCB0aGUgaW5kZXggb2YgYW4gaW5kZXggaW4gdGhlIGRhdGEgYXJyYXkgYW5kIGNvbnZlcnQgaXQgdG8gdGhlIHZpc2libGVcbiAqICAgY29sdW1uIGluZGV4ICh0YWtlIGFjY291bnQgb2YgaGlkZGVuIGNvbHVtbnMpXG4gKiAgQHBhcmFtIHtpbnR9IGlNYXRjaCBDb2x1bW4gaW5kZXggdG8gbG9va3VwXG4gKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEByZXR1cm5zIHtpbnR9IGkgdGhlIGRhdGEgaW5kZXhcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuQ29sdW1uSW5kZXhUb1Zpc2libGUoIG9TZXR0aW5ncywgaU1hdGNoIClcbntcblx0dmFyIGFpVmlzID0gX2ZuR2V0Q29sdW1ucyggb1NldHRpbmdzLCAnYlZpc2libGUnICk7XG5cdHZhciBpUG9zID0gYWlWaXMuaW5kZXhPZihpTWF0Y2gpO1xuXG5cdHJldHVybiBpUG9zICE9PSAtMSA/IGlQb3MgOiBudWxsO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSBudW1iZXIgb2YgdmlzaWJsZSBjb2x1bW5zXG4gKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEByZXR1cm5zIHtpbnR9IGkgdGhlIG51bWJlciBvZiB2aXNpYmxlIGNvbHVtbnNcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuVmlzYmxlQ29sdW1ucyggc2V0dGluZ3MgKVxue1xuXHR2YXIgbGF5b3V0ID0gc2V0dGluZ3MuYW9IZWFkZXI7XG5cdHZhciBjb2x1bW5zID0gc2V0dGluZ3MuYW9Db2x1bW5zO1xuXHR2YXIgdmlzID0gMDtcblxuXHRpZiAoIGxheW91dC5sZW5ndGggKSB7XG5cdFx0Zm9yICggdmFyIGk9MCwgaWVuPWxheW91dFswXS5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdGlmICggY29sdW1uc1tpXS5iVmlzaWJsZSAmJiAkKGxheW91dFswXVtpXS5jZWxsKS5jc3MoJ2Rpc3BsYXknKSAhPT0gJ25vbmUnICkge1xuXHRcdFx0XHR2aXMrKztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdmlzO1xufVxuXG5cbi8qKlxuICogR2V0IGFuIGFycmF5IG9mIGNvbHVtbiBpbmRleGVzIHRoYXQgbWF0Y2ggYSBnaXZlbiBwcm9wZXJ0eVxuICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAcGFyYW0ge3N0cmluZ30gc1BhcmFtIFBhcmFtZXRlciBpbiBhb0NvbHVtbnMgdG8gbG9vayBmb3IgLSB0eXBpY2FsbHlcbiAqICAgIGJWaXNpYmxlIG9yIGJTZWFyY2hhYmxlXG4gKiAgQHJldHVybnMge2FycmF5fSBBcnJheSBvZiBpbmRleGVzIHdpdGggbWF0Y2hlZCBwcm9wZXJ0aWVzXG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkdldENvbHVtbnMoIG9TZXR0aW5ncywgc1BhcmFtIClcbntcblx0dmFyIGEgPSBbXTtcblxuXHRvU2V0dGluZ3MuYW9Db2x1bW5zLm1hcCggZnVuY3Rpb24odmFsLCBpKSB7XG5cdFx0aWYgKCB2YWxbc1BhcmFtXSApIHtcblx0XHRcdGEucHVzaCggaSApO1xuXHRcdH1cblx0fSApO1xuXG5cdHJldHVybiBhO1xufVxuXG4vKipcbiAqIEFsbG93IHRoZSByZXN1bHQgZnJvbSBhIHR5cGUgZGV0ZWN0aW9uIGZ1bmN0aW9uIHRvIGJlIGB0cnVlYCB3aGlsZVxuICogdHJhbnNsYXRpbmcgdGhhdCBpbnRvIGEgc3RyaW5nLiBPbGQgdHlwZSBkZXRlY3Rpb24gZnVuY3Rpb25zIHdpbGxcbiAqIHJldHVybiB0aGUgdHlwZSBuYW1lIGlmIGl0IHBhc3Nlcy4gQW4gb2JlY3Qgc3RvcmUgd291bGQgYmUgYmV0dGVyLFxuICogYnV0IG5vdCBiYWNrd2FyZHMgY29tcGF0aWJsZS5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVEZXRlY3QgT2JqZWN0IG9yIGZ1bmN0aW9uIGZvciB0eXBlIGRldGVjdGlvblxuICogQHBhcmFtIHsqfSByZXMgUmVzdWx0IGZyb20gdGhlIHR5cGUgZGV0ZWN0aW9uIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyBUeXBlIG5hbWUgb3IgZmFsc2VcbiAqL1xuZnVuY3Rpb24gX3R5cGVSZXN1bHQgKHR5cGVEZXRlY3QsIHJlcykge1xuXHRyZXR1cm4gcmVzID09PSB0cnVlXG5cdFx0PyB0eXBlRGV0ZWN0Ll9uYW1lXG5cdFx0OiByZXM7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSAndHlwZScgb2YgYSBjb2x1bW5cbiAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuQ29sdW1uVHlwZXMgKCBzZXR0aW5ncyApXG57XG5cdHZhciBjb2x1bW5zID0gc2V0dGluZ3MuYW9Db2x1bW5zO1xuXHR2YXIgZGF0YSA9IHNldHRpbmdzLmFvRGF0YTtcblx0dmFyIHR5cGVzID0gRGF0YVRhYmxlLmV4dC50eXBlLmRldGVjdDtcblx0dmFyIGksIGllbiwgaiwgamVuLCBrLCBrZW47XG5cdHZhciBjb2wsIGRldGVjdGVkVHlwZSwgY2FjaGU7XG5cblx0Ly8gRm9yIGVhY2ggY29sdW1uLCBzcGluIG92ZXIgdGhlIGRhdGEgdHlwZSBkZXRlY3Rpb24gZnVuY3Rpb25zLCBzZWVpbmcgaWYgb25lIG1hdGNoZXNcblx0Zm9yICggaT0wLCBpZW49Y29sdW1ucy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRjb2wgPSBjb2x1bW5zW2ldO1xuXHRcdGNhY2hlID0gW107XG5cblx0XHRpZiAoICEgY29sLnNUeXBlICYmIGNvbC5fc01hbnVhbFR5cGUgKSB7XG5cdFx0XHRjb2wuc1R5cGUgPSBjb2wuX3NNYW51YWxUeXBlO1xuXHRcdH1cblx0XHRlbHNlIGlmICggISBjb2wuc1R5cGUgKSB7XG5cdFx0XHQvLyBXaXRoIFNTUCB0eXBlIGRldGVjdGlvbiBjYW4gYmUgdW5yZWxpYWJsZSBhbmQgZXJyb3IgcHJvbmUsIHNvIHdlIHByb3ZpZGUgYSB3YXlcblx0XHRcdC8vIHRvIHR1cm4gaXQgb2ZmLlxuXHRcdFx0aWYgKCEgc2V0dGluZ3MudHlwZURldGVjdCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGo9MCwgamVuPXR5cGVzLmxlbmd0aCA7IGo8amVuIDsgaisrICkge1xuXHRcdFx0XHR2YXIgdHlwZURldGVjdCA9IHR5cGVzW2pdO1xuXG5cdFx0XHRcdC8vIFRoZXJlIGNhbiBiZSBlaXRoZXIgb25lLCBvciB0aHJlZSB0eXBlIGRldGVjdGlvbiBmdW5jdGlvbnNcblx0XHRcdFx0dmFyIG9uZU9mID0gdHlwZURldGVjdC5vbmVPZjtcblx0XHRcdFx0dmFyIGFsbE9mID0gdHlwZURldGVjdC5hbGxPZiB8fCB0eXBlRGV0ZWN0O1xuXHRcdFx0XHR2YXIgaW5pdCA9IHR5cGVEZXRlY3QuaW5pdDtcblx0XHRcdFx0dmFyIG9uZSA9IGZhbHNlO1xuXG5cdFx0XHRcdGRldGVjdGVkVHlwZSA9IG51bGw7XG5cblx0XHRcdFx0Ly8gRmFzdCBkZXRlY3QgYmFzZWQgb24gY29sdW1uIGFzc2lnbm1lbnRcblx0XHRcdFx0aWYgKGluaXQpIHtcblx0XHRcdFx0XHRkZXRlY3RlZFR5cGUgPSBfdHlwZVJlc3VsdCh0eXBlRGV0ZWN0LCBpbml0KHNldHRpbmdzLCBjb2wsIGkpKTtcblxuXHRcdFx0XHRcdGlmIChkZXRlY3RlZFR5cGUpIHtcblx0XHRcdFx0XHRcdGNvbC5zVHlwZSA9IGRldGVjdGVkVHlwZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAoIGs9MCwga2VuPWRhdGEubGVuZ3RoIDsgazxrZW4gOyBrKysgKSB7XG5cdFx0XHRcdFx0aWYgKCEgZGF0YVtrXSkge1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gVXNlIGEgY2FjaGUgYXJyYXkgc28gd2Ugb25seSBuZWVkIHRvIGdldCB0aGUgdHlwZSBkYXRhXG5cdFx0XHRcdFx0Ly8gZnJvbSB0aGUgZm9ybWF0dGVyIG9uY2UgKHdoZW4gdXNpbmcgbXVsdGlwbGUgZGV0ZWN0b3JzKVxuXHRcdFx0XHRcdGlmICggY2FjaGVba10gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGNhY2hlW2tdID0gX2ZuR2V0Q2VsbERhdGEoIHNldHRpbmdzLCBrLCBpLCAndHlwZScgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IG9uZSBkYXRhIHBvaW50IGluIHRoZSBjb2x1bW4gbmVlZHMgdG8gbWF0Y2ggdGhpcyBmdW5jdGlvblxuXHRcdFx0XHRcdGlmIChvbmVPZiAmJiAhIG9uZSkge1xuXHRcdFx0XHRcdFx0b25lID0gX3R5cGVSZXN1bHQodHlwZURldGVjdCwgb25lT2YoIGNhY2hlW2tdLCBzZXR0aW5ncyApKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBBbGwgZGF0YSBwb2ludHMgbmVlZCB0byBtYXRjaCB0aGlzIGZ1bmN0aW9uXG5cdFx0XHRcdFx0ZGV0ZWN0ZWRUeXBlID0gX3R5cGVSZXN1bHQodHlwZURldGVjdCwgYWxsT2YoIGNhY2hlW2tdLCBzZXR0aW5ncyApKTtcblxuXHRcdFx0XHRcdC8vIElmIG51bGwsIHRoZW4gdGhpcyB0eXBlIGNhbid0IGFwcGx5IHRvIHRoaXMgY29sdW1uLCBzb1xuXHRcdFx0XHRcdC8vIHJhdGhlciB0aGFuIHRlc3RpbmcgYWxsIGNlbGxzLCBicmVhayBvdXQuIFRoZXJlIGlzIGFuXG5cdFx0XHRcdFx0Ly8gZXhjZXB0aW9uIGZvciB0aGUgbGFzdCB0eXBlIHdoaWNoIGlzIGBodG1sYC4gV2UgbmVlZCB0b1xuXHRcdFx0XHRcdC8vIHNjYW4gYWxsIHJvd3Mgc2luY2UgaXQgaXMgcG9zc2libGUgdG8gbWl4IHN0cmluZyBhbmQgSFRNTFxuXHRcdFx0XHRcdC8vIHR5cGVzXG5cdFx0XHRcdFx0aWYgKCAhIGRldGVjdGVkVHlwZSAmJiBqICE9PSB0eXBlcy5sZW5ndGgtMyApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYSBzaW5nbGUgbWF0Y2ggaXMgbmVlZGVkIGZvciBodG1sIHR5cGUgc2luY2UgaXQgaXNcblx0XHRcdFx0XHQvLyBib3R0b20gb2YgdGhlIHBpbGUgYW5kIHZlcnkgc2ltaWxhciB0byBzdHJpbmcgLSBidXQgaXRcblx0XHRcdFx0XHQvLyBtdXN0IG5vdCBiZSBlbXB0eVxuXHRcdFx0XHRcdGlmICggZGV0ZWN0ZWRUeXBlID09PSAnaHRtbCcgJiYgISBfZW1wdHkoY2FjaGVba10pICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVHlwZSBpcyB2YWxpZCBmb3IgYWxsIGRhdGEgcG9pbnRzIGluIHRoZSBjb2x1bW4gLSB1c2UgdGhpc1xuXHRcdFx0XHQvLyB0eXBlXG5cdFx0XHRcdGlmICggKG9uZU9mICYmIG9uZSAmJiBkZXRlY3RlZFR5cGUpIHx8ICghb25lT2YgJiYgZGV0ZWN0ZWRUeXBlKSApIHtcblx0XHRcdFx0XHRjb2wuc1R5cGUgPSBkZXRlY3RlZFR5cGU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gRmFsbCBiYWNrIC0gaWYgbm8gdHlwZSB3YXMgZGV0ZWN0ZWQsIGFsd2F5cyB1c2Ugc3RyaW5nXG5cdFx0XHRpZiAoICEgY29sLnNUeXBlICkge1xuXHRcdFx0XHRjb2wuc1R5cGUgPSAnc3RyaW5nJztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTZXQgY2xhc3MgbmFtZXMgZm9yIGhlYWRlciAvIGZvb3RlciBmb3IgYXV0byB0eXBlIGNsYXNzZXNcblx0XHR2YXIgYXV0b0NsYXNzID0gX2V4dC50eXBlLmNsYXNzTmFtZVtjb2wuc1R5cGVdO1xuXG5cdFx0aWYgKGF1dG9DbGFzcykge1xuXHRcdFx0X2NvbHVtbkF1dG9DbGFzcyhzZXR0aW5ncy5hb0hlYWRlciwgaSwgYXV0b0NsYXNzKTtcblx0XHRcdF9jb2x1bW5BdXRvQ2xhc3Moc2V0dGluZ3MuYW9Gb290ZXIsIGksIGF1dG9DbGFzcyk7XG5cdFx0fVxuXG5cdFx0dmFyIHJlbmRlcmVyID0gX2V4dC50eXBlLnJlbmRlcltjb2wuc1R5cGVdO1xuXG5cdFx0Ly8gVGhpcyBjYW4gb25seSBoYXBwZW4gb25jZSEgVGhlcmUgaXMgbm8gd2F5IHRvIHJlbW92ZVxuXHRcdC8vIGEgcmVuZGVyZXIuIEFmdGVyIHRoZSBmaXJzdCB0aW1lIHRoZSByZW5kZXJlciBoYXNcblx0XHQvLyBhbHJlYWR5IGJlZW4gc2V0IHNvIGNyZWF0ZVRyIHdpbGwgcnVuIHRoZSByZW5kZXJlciBpdHNlbGYuXG5cdFx0aWYgKHJlbmRlcmVyICYmICEgY29sLl9yZW5kZXIpIHtcblx0XHRcdGNvbC5fcmVuZGVyID0gRGF0YVRhYmxlLnV0aWwuZ2V0KHJlbmRlcmVyKTtcblxuXHRcdFx0X2NvbHVtbkF1dG9SZW5kZXIoc2V0dGluZ3MsIGkpO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEFwcGx5IGFuIGF1dG8gZGV0ZWN0ZWQgcmVuZGVyZXIgdG8gZGF0YSB3aGljaCBkb2Vzbid0IHlldCBoYXZlXG4gKiBhIHJlbmRlcmVyXG4gKi9cbmZ1bmN0aW9uIF9jb2x1bW5BdXRvUmVuZGVyKHNldHRpbmdzLCBjb2xJZHgpIHtcblx0dmFyIGRhdGEgPSBzZXR0aW5ncy5hb0RhdGE7XG5cblx0Zm9yICh2YXIgaT0wIDsgaTxkYXRhLmxlbmd0aCA7IGkrKykge1xuXHRcdGlmIChkYXRhW2ldLm5Ucikge1xuXHRcdFx0Ly8gV2UgaGF2ZSB0byB1cGRhdGUgdGhlIGRpc3BsYXkgaGVyZSBzaW5jZSB0aGVyZSBpcyBub1xuXHRcdFx0Ly8gaW52YWxpZGF0aW9uIGNoZWNrIGZvciB0aGUgZGF0YVxuXHRcdFx0dmFyIGRpc3BsYXkgPSBfZm5HZXRDZWxsRGF0YSggc2V0dGluZ3MsIGksIGNvbElkeCwgJ2Rpc3BsYXknICk7XG5cblx0XHRcdGRhdGFbaV0uZGlzcGxheURhdGFbY29sSWR4XSA9IGRpc3BsYXk7XG5cdFx0XHRfZm5Xcml0ZUNlbGwoZGF0YVtpXS5hbkNlbGxzW2NvbElkeF0sIGRpc3BsYXkpO1xuXG5cdFx0XHQvLyBObyBuZWVkIHRvIHVwZGF0ZSBzb3J0IC8gZmlsdGVyIGRhdGEgc2luY2UgaXQgaGFzXG5cdFx0XHQvLyBiZWVuIGludmFsaWRhdGVkIGFuZCB3aWxsIGJlIHJlLXJlYWQgd2l0aCB0aGVcblx0XHRcdC8vIHJlbmRlcmVyIG5vdyBhcHBsaWVkXG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQXBwbHkgYSBjbGFzcyBuYW1lIHRvIGEgY29sdW1uJ3MgaGVhZGVyIGNlbGxzXG4gKi9cbmZ1bmN0aW9uIF9jb2x1bW5BdXRvQ2xhc3MoY29udGFpbmVyLCBjb2xJZHgsIGNsYXNzTmFtZSkge1xuXHRjb250YWluZXIuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7XG5cdFx0aWYgKHJvd1tjb2xJZHhdICYmIHJvd1tjb2xJZHhdLnVuaXF1ZSkge1xuXHRcdFx0X2FkZENsYXNzKHJvd1tjb2xJZHhdLmNlbGwsIGNsYXNzTmFtZSk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLyoqXG4gKiBUYWtlIHRoZSBjb2x1bW4gZGVmaW5pdGlvbnMgYW5kIHN0YXRpYyBjb2x1bW5zIGFycmF5cyBhbmQgY2FsY3VsYXRlIGhvd1xuICogdGhleSByZWxhdGUgdG8gY29sdW1uIGluZGV4ZXMuIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aWxsIHRoZW4gYXBwbHkgdGhlXG4gKiBkZWZpbml0aW9uIGZvdW5kIGZvciBhIGNvbHVtbiB0byBhIHN1aXRhYmxlIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAcGFyYW0ge2FycmF5fSBhb0NvbERlZnMgVGhlIGFvQ29sdW1uRGVmcyBhcnJheSB0aGF0IGlzIHRvIGJlIGFwcGxpZWRcbiAqICBAcGFyYW0ge2FycmF5fSBhb0NvbHMgVGhlIGFvQ29sdW1ucyBhcnJheSB0aGF0IGRlZmluZXMgY29sdW1ucyBpbmRpdmlkdWFsbHlcbiAqICBAcGFyYW0ge2FycmF5fSBoZWFkZXJMYXlvdXQgTGF5b3V0IGZvciBoZWFkZXIgYXMgaXQgd2FzIGxvYWRlZFxuICogIEBwYXJhbSB7ZnVuY3Rpb259IGZuIENhbGxiYWNrIGZ1bmN0aW9uIC0gdGFrZXMgdHdvIHBhcmFtZXRlcnMsIHRoZSBjYWxjdWxhdGVkXG4gKiAgICBjb2x1bW4gaW5kZXggYW5kIHRoZSBkZWZpbml0aW9uIGZvciB0aGF0IGNvbHVtbi5cbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuQXBwbHlDb2x1bW5EZWZzKCBvU2V0dGluZ3MsIGFvQ29sRGVmcywgYW9Db2xzLCBoZWFkZXJMYXlvdXQsIGZuIClcbntcblx0dmFyIGksIGlMZW4sIGosIGpMZW4sIGssIGtMZW4sIGRlZjtcblx0dmFyIGNvbHVtbnMgPSBvU2V0dGluZ3MuYW9Db2x1bW5zO1xuXG5cdGlmICggYW9Db2xzICkge1xuXHRcdGZvciAoIGk9MCwgaUxlbj1hb0NvbHMubGVuZ3RoIDsgaTxpTGVuIDsgaSsrICkge1xuXHRcdFx0aWYgKGFvQ29sc1tpXSAmJiBhb0NvbHNbaV0ubmFtZSkge1xuXHRcdFx0XHRjb2x1bW5zW2ldLnNOYW1lID0gYW9Db2xzW2ldLm5hbWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ29sdW1uIGRlZmluaXRpb25zIHdpdGggYVRhcmdldHNcblx0aWYgKCBhb0NvbERlZnMgKVxuXHR7XG5cdFx0LyogTG9vcCBvdmVyIHRoZSBkZWZpbml0aW9ucyBhcnJheSAtIGxvb3AgaW4gcmV2ZXJzZSBzbyBmaXJzdCBpbnN0YW5jZSBoYXMgcHJpb3JpdHkgKi9cblx0XHRmb3IgKCBpPWFvQ29sRGVmcy5sZW5ndGgtMSA7IGk+PTAgOyBpLS0gKVxuXHRcdHtcblx0XHRcdGRlZiA9IGFvQ29sRGVmc1tpXTtcblxuXHRcdFx0LyogRWFjaCBkZWZpbml0aW9uIGNhbiB0YXJnZXQgbXVsdGlwbGUgY29sdW1ucywgYXMgaXQgaXMgYW4gYXJyYXkgKi9cblx0XHRcdHZhciBhVGFyZ2V0cyA9IGRlZi50YXJnZXQgIT09IHVuZGVmaW5lZFxuXHRcdFx0XHQ/IGRlZi50YXJnZXRcblx0XHRcdFx0OiBkZWYudGFyZ2V0cyAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdFx0PyBkZWYudGFyZ2V0c1xuXHRcdFx0XHRcdDogZGVmLmFUYXJnZXRzO1xuXG5cdFx0XHRpZiAoICEgQXJyYXkuaXNBcnJheSggYVRhcmdldHMgKSApXG5cdFx0XHR7XG5cdFx0XHRcdGFUYXJnZXRzID0gWyBhVGFyZ2V0cyBdO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKCBqPTAsIGpMZW49YVRhcmdldHMubGVuZ3RoIDsgajxqTGVuIDsgaisrIClcblx0XHRcdHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IGFUYXJnZXRzW2pdO1xuXG5cdFx0XHRcdGlmICggdHlwZW9mIHRhcmdldCA9PT0gJ251bWJlcicgJiYgdGFyZ2V0ID49IDAgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0LyogQWRkIGNvbHVtbnMgdGhhdCB3ZSBkb24ndCB5ZXQga25vdyBhYm91dCAqL1xuXHRcdFx0XHRcdHdoaWxlKCBjb2x1bW5zLmxlbmd0aCA8PSB0YXJnZXQgKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdF9mbkFkZENvbHVtbiggb1NldHRpbmdzICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0LyogSW50ZWdlciwgYmFzaWMgaW5kZXggKi9cblx0XHRcdFx0XHRmbiggdGFyZ2V0LCBkZWYgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICggdHlwZW9mIHRhcmdldCA9PT0gJ251bWJlcicgJiYgdGFyZ2V0IDwgMCApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHQvKiBOZWdhdGl2ZSBpbnRlZ2VyLCByaWdodCB0byBsZWZ0IGNvbHVtbiBjb3VudGluZyAqL1xuXHRcdFx0XHRcdGZuKCBjb2x1bW5zLmxlbmd0aCt0YXJnZXQsIGRlZiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKCB0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJyApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRmb3IgKCBrPTAsIGtMZW49Y29sdW1ucy5sZW5ndGggOyBrPGtMZW4gOyBrKysgKSB7XG5cdFx0XHRcdFx0XHRpZiAodGFyZ2V0ID09PSAnX2FsbCcpIHtcblx0XHRcdFx0XHRcdFx0Ly8gQXBwbHkgdG8gYWxsIGNvbHVtbnNcblx0XHRcdFx0XHRcdFx0Zm4oIGssIGRlZiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZWxzZSBpZiAodGFyZ2V0LmluZGV4T2YoJzpuYW1lJykgIT09IC0xKSB7XG5cdFx0XHRcdFx0XHRcdC8vIENvbHVtbiBzZWxlY3RvclxuXHRcdFx0XHRcdFx0XHRpZiAoY29sdW1uc1trXS5zTmFtZSA9PT0gdGFyZ2V0LnJlcGxhY2UoJzpuYW1lJywgJycpKSB7XG5cdFx0XHRcdFx0XHRcdFx0Zm4oIGssIGRlZiApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gQ2VsbCBzZWxlY3RvclxuXHRcdFx0XHRcdFx0XHRoZWFkZXJMYXlvdXQuZm9yRWFjaChmdW5jdGlvbiAocm93KSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHJvd1trXSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIGNlbGwgPSAkKHJvd1trXS5jZWxsKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gTGVnYWN5IHN1cHBvcnQuIE5vdGUgdGhhdCBpdCBtZWFucyB0aGF0IHdlIGRvbid0IHN1cHBvcnRcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuIGVsZW1lbnQgbmFtZSBzZWxlY3RvciBvbmx5LCBzaW5jZSB0aGV5IGFyZSB0cmVhdGVkIGFzXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBjbGFzcyBuYW1lcyBmb3IgMS54IGNvbXBhdC5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICh0YXJnZXQubWF0Y2goL15bYS16XVtcXHctXSokL2kpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRhcmdldCA9ICcuJyArIHRhcmdldDtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKGNlbGwuaXMoIHRhcmdldCApKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZuKCBrLCBkZWYgKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFN0YXRpY2FsbHkgZGVmaW5lZCBjb2x1bW5zIGFycmF5XG5cdGlmICggYW9Db2xzICkge1xuXHRcdGZvciAoIGk9MCwgaUxlbj1hb0NvbHMubGVuZ3RoIDsgaTxpTGVuIDsgaSsrICkge1xuXHRcdFx0Zm4oIGksIGFvQ29sc1tpXSApO1xuXHRcdH1cblx0fVxufVxuXG5cbi8qKlxuICogR2V0IHRoZSB3aWR0aCBmb3IgYSBnaXZlbiBzZXQgb2YgY29sdW1uc1xuICpcbiAqIEBwYXJhbSB7Kn0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0cyBDb2x1bW5zIC0gY29tbWEgc2VwYXJhdGVkIHN0cmluZyBvciBhcnJheSBvZiBudW1iZXJzXG4gKiBAcGFyYW0geyp9IG9yaWdpbmFsIFVzZSB0aGUgb3JpZ2luYWwgd2lkdGggKHRydWUpIG9yIGNhbGN1bGF0ZWQgKGZhbHNlKVxuICogQHBhcmFtIHsqfSBpbmNWaXNpYmxlIEluY2x1ZGUgdmlzaWJsZSBjb2x1bW5zICh0cnVlKSBvciBub3QgKGZhbHNlKVxuICogQHJldHVybnMgQ29tYmluZWQgQ1NTIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIF9mbkNvbHVtbnNTdW1XaWR0aCggc2V0dGluZ3MsIHRhcmdldHMsIG9yaWdpbmFsLCBpbmNWaXNpYmxlICkge1xuXHRpZiAoICEgQXJyYXkuaXNBcnJheSggdGFyZ2V0cyApICkge1xuXHRcdHRhcmdldHMgPSBfZm5Db2x1bW5zRnJvbUhlYWRlciggdGFyZ2V0cyApO1xuXHR9XG5cblx0dmFyIHN1bSA9IDA7XG5cdHZhciB1bml0O1xuXHR2YXIgY29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucztcblx0XG5cdGZvciAoIHZhciBpPTAsIGllbj10YXJnZXRzLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdHZhciBjb2x1bW4gPSBjb2x1bW5zWyB0YXJnZXRzW2ldIF07XG5cdFx0dmFyIGRlZmluZWRXaWR0aCA9IG9yaWdpbmFsID9cblx0XHRcdGNvbHVtbi5zV2lkdGhPcmlnIDpcblx0XHRcdGNvbHVtbi5zV2lkdGg7XG5cblx0XHRpZiAoICEgaW5jVmlzaWJsZSAmJiBjb2x1bW4uYlZpc2libGUgPT09IGZhbHNlICkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBkZWZpbmVkV2lkdGggPT09IG51bGwgfHwgZGVmaW5lZFdpZHRoID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDsgLy8gY2FuJ3QgZGV0ZXJtaW5lIGEgZGVmaW5lZCB3aWR0aCAtIGJyb3dzZXIgZGVmaW5lZFxuXHRcdH1cblx0XHRlbHNlIGlmICggdHlwZW9mIGRlZmluZWRXaWR0aCA9PT0gJ251bWJlcicgKSB7XG5cdFx0XHR1bml0ID0gJ3B4Jztcblx0XHRcdHN1bSArPSBkZWZpbmVkV2lkdGg7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dmFyIG1hdGNoZWQgPSBkZWZpbmVkV2lkdGgubWF0Y2goLyhbXFxkXFwuXSspKFteXFxkXSopLyk7XG5cblx0XHRcdGlmICggbWF0Y2hlZCApIHtcblx0XHRcdFx0c3VtICs9IG1hdGNoZWRbMV0gKiAxO1xuXHRcdFx0XHR1bml0ID0gbWF0Y2hlZC5sZW5ndGggPT09IDMgP1xuXHRcdFx0XHRcdG1hdGNoZWRbMl0gOlxuXHRcdFx0XHRcdCdweCc7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHN1bSArIHVuaXQ7XG59XG5cbmZ1bmN0aW9uIF9mbkNvbHVtbnNGcm9tSGVhZGVyKCBjZWxsIClcbntcblx0dmFyIGF0dHIgPSAkKGNlbGwpLmNsb3Nlc3QoJ1tkYXRhLWR0LWNvbHVtbl0nKS5hdHRyKCdkYXRhLWR0LWNvbHVtbicpO1xuXG5cdGlmICggISBhdHRyICkge1xuXHRcdHJldHVybiBbXTtcblx0fVxuXG5cdHJldHVybiBhdHRyLnNwbGl0KCcsJykubWFwKCBmdW5jdGlvbiAodmFsKSB7XG5cdFx0cmV0dXJuIHZhbCAqIDE7XG5cdH0gKTtcbn1cbi8qKlxuICogQWRkIGEgZGF0YSBhcnJheSB0byB0aGUgdGFibGUsIGNyZWF0aW5nIERPTSBub2RlIGV0Yy4gVGhpcyBpcyB0aGUgcGFyYWxsZWwgdG9cbiAqIF9mbkdhdGhlckRhdGEsIGJ1dCBmb3IgYWRkaW5nIHJvd3MgZnJvbSBhIEphdmFzY3JpcHQgc291cmNlLCByYXRoZXIgdGhhbiBhXG4gKiBET00gc291cmNlLlxuICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBwYXJhbSB7YXJyYXl9IGRhdGEgZGF0YSBhcnJheSB0byBiZSBhZGRlZFxuICogIEBwYXJhbSB7bm9kZX0gW3RyXSBUUiBlbGVtZW50IHRvIGFkZCB0byB0aGUgdGFibGUgLSBvcHRpb25hbC4gSWYgbm90IGdpdmVuLFxuICogICAgRGF0YVRhYmxlcyB3aWxsIGNyZWF0ZSBhIHJvdyBhdXRvbWF0aWNhbGx5XG4gKiAgQHBhcmFtIHthcnJheX0gW3Rkc10gQXJyYXkgb2YgVER8VEggZWxlbWVudHMgZm9yIHRoZSByb3cgLSBtdXN0IGJlIGdpdmVuXG4gKiAgICBpZiBuVHIgaXMuXG4gKiAgQHJldHVybnMge2ludH0gPj0wIGlmIHN1Y2Nlc3NmdWwgKGluZGV4IG9mIG5ldyBhb0RhdGEgZW50cnkpLCAtMSBpZiBmYWlsZWRcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuQWRkRGF0YSAoIHNldHRpbmdzLCBkYXRhSW4sIHRyLCB0ZHMgKVxue1xuXHQvKiBDcmVhdGUgdGhlIG9iamVjdCBmb3Igc3RvcmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGlzIG5ldyByb3cgKi9cblx0dmFyIHJvd0lkeCA9IHNldHRpbmdzLmFvRGF0YS5sZW5ndGg7XG5cdHZhciByb3dNb2RlbCA9ICQuZXh0ZW5kKCB0cnVlLCB7fSwgRGF0YVRhYmxlLm1vZGVscy5vUm93LCB7XG5cdFx0c3JjOiB0ciA/ICdkb20nIDogJ2RhdGEnLFxuXHRcdGlkeDogcm93SWR4XG5cdH0gKTtcblxuXHRyb3dNb2RlbC5fYURhdGEgPSBkYXRhSW47XG5cdHNldHRpbmdzLmFvRGF0YS5wdXNoKCByb3dNb2RlbCApO1xuXG5cdHZhciBjb2x1bW5zID0gc2V0dGluZ3MuYW9Db2x1bW5zO1xuXG5cdGZvciAoIHZhciBpPTAsIGlMZW49Y29sdW1ucy5sZW5ndGggOyBpPGlMZW4gOyBpKysgKVxuXHR7XG5cdFx0Ly8gSW52YWxpZGF0ZSB0aGUgY29sdW1uIHR5cGVzIGFzIHRoZSBuZXcgZGF0YSBuZWVkcyB0byBiZSByZXZhbGlkYXRlZFxuXHRcdGNvbHVtbnNbaV0uc1R5cGUgPSBudWxsO1xuXHR9XG5cblx0LyogQWRkIHRvIHRoZSBkaXNwbGF5IGFycmF5ICovXG5cdHNldHRpbmdzLmFpRGlzcGxheU1hc3Rlci5wdXNoKCByb3dJZHggKTtcblxuXHR2YXIgaWQgPSBzZXR0aW5ncy5yb3dJZEZuKCBkYXRhSW4gKTtcblx0aWYgKCBpZCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdHNldHRpbmdzLmFJZHNbIGlkIF0gPSByb3dNb2RlbDtcblx0fVxuXG5cdC8qIENyZWF0ZSB0aGUgRE9NIGluZm9ybWF0aW9uLCBvciByZWdpc3RlciBpdCBpZiBhbHJlYWR5IHByZXNlbnQgKi9cblx0aWYgKCB0ciB8fCAhIHNldHRpbmdzLm9GZWF0dXJlcy5iRGVmZXJSZW5kZXIgKVxuXHR7XG5cdFx0X2ZuQ3JlYXRlVHIoIHNldHRpbmdzLCByb3dJZHgsIHRyLCB0ZHMgKTtcblx0fVxuXG5cdHJldHVybiByb3dJZHg7XG59XG5cblxuLyoqXG4gKiBBZGQgb25lIG9yIG1vcmUgVFIgZWxlbWVudHMgdG8gdGhlIHRhYmxlLiBHZW5lcmFsbHkgd2UnZCBleHBlY3QgdG9cbiAqIHVzZSB0aGlzIGZvciByZWFkaW5nIGRhdGEgZnJvbSBhIERPTSBzb3VyY2VkIHRhYmxlLCBidXQgaXQgY291bGQgYmVcbiAqIHVzZWQgZm9yIGFuIFRSIGVsZW1lbnQuIE5vdGUgdGhhdCBpZiBhIFRSIGlzIGdpdmVuLCBpdCBpcyB1c2VkIChpLmUuXG4gKiBpdCBpcyBub3QgY2xvbmVkKS5cbiAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAcGFyYW0ge2FycmF5fG5vZGV8alF1ZXJ5fSB0cnMgVGhlIFRSIGVsZW1lbnQocykgdG8gYWRkIHRvIHRoZSB0YWJsZVxuICogIEByZXR1cm5zIHthcnJheX0gQXJyYXkgb2YgaW5kZXhlcyBmb3IgdGhlIGFkZGVkIHJvd3NcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuQWRkVHIoIHNldHRpbmdzLCB0cnMgKVxue1xuXHR2YXIgcm93O1xuXG5cdC8vIEFsbG93IGFuIGluZGl2aWR1YWwgbm9kZSB0byBiZSBwYXNzZWQgaW5cblx0aWYgKCAhICh0cnMgaW5zdGFuY2VvZiAkKSApIHtcblx0XHR0cnMgPSAkKHRycyk7XG5cdH1cblxuXHRyZXR1cm4gdHJzLm1hcCggZnVuY3Rpb24gKGksIGVsKSB7XG5cdFx0cm93ID0gX2ZuR2V0Um93RWxlbWVudHMoIHNldHRpbmdzLCBlbCApO1xuXHRcdHJldHVybiBfZm5BZGREYXRhKCBzZXR0aW5ncywgcm93LmRhdGEsIGVsLCByb3cuY2VsbHMgKTtcblx0fSApO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSBkYXRhIGZvciBhIGdpdmVuIGNlbGwgZnJvbSB0aGUgaW50ZXJuYWwgY2FjaGUsIHRha2luZyBpbnRvIGFjY291bnQgZGF0YSBtYXBwaW5nXG4gKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQHBhcmFtIHtpbnR9IHJvd0lkeCBhb0RhdGEgcm93IGlkXG4gKiAgQHBhcmFtIHtpbnR9IGNvbElkeCBDb2x1bW4gaW5kZXhcbiAqICBAcGFyYW0ge3N0cmluZ30gdHlwZSBkYXRhIGdldCB0eXBlICgnZGlzcGxheScsICd0eXBlJyAnZmlsdGVyfHNlYXJjaCcgJ3NvcnR8b3JkZXInKVxuICogIEByZXR1cm5zIHsqfSBDZWxsIGRhdGFcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuR2V0Q2VsbERhdGEoIHNldHRpbmdzLCByb3dJZHgsIGNvbElkeCwgdHlwZSApXG57XG5cdGlmICh0eXBlID09PSAnc2VhcmNoJykge1xuXHRcdHR5cGUgPSAnZmlsdGVyJztcblx0fVxuXHRlbHNlIGlmICh0eXBlID09PSAnb3JkZXInKSB7XG5cdFx0dHlwZSA9ICdzb3J0Jztcblx0fVxuXG5cdHZhciByb3cgPSBzZXR0aW5ncy5hb0RhdGFbcm93SWR4XTtcblxuXHRpZiAoISByb3cpIHtcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHR9XG5cblx0dmFyIGRyYXcgICAgICAgICAgID0gc2V0dGluZ3MuaURyYXc7XG5cdHZhciBjb2wgICAgICAgICAgICA9IHNldHRpbmdzLmFvQ29sdW1uc1tjb2xJZHhdO1xuXHR2YXIgcm93RGF0YSAgICAgICAgPSByb3cuX2FEYXRhO1xuXHR2YXIgZGVmYXVsdENvbnRlbnQgPSBjb2wuc0RlZmF1bHRDb250ZW50O1xuXHR2YXIgY2VsbERhdGEgICAgICAgPSBjb2wuZm5HZXREYXRhKCByb3dEYXRhLCB0eXBlLCB7XG5cdFx0c2V0dGluZ3M6IHNldHRpbmdzLFxuXHRcdHJvdzogICAgICByb3dJZHgsXG5cdFx0Y29sOiAgICAgIGNvbElkeFxuXHR9ICk7XG5cblx0Ly8gQWxsb3cgZm9yIGEgbm9kZSBiZWluZyByZXR1cm5lZCBmb3Igbm9uLWRpc3BsYXkgdHlwZXNcblx0aWYgKHR5cGUgIT09ICdkaXNwbGF5JyAmJiBjZWxsRGF0YSAmJiB0eXBlb2YgY2VsbERhdGEgPT09ICdvYmplY3QnICYmIGNlbGxEYXRhLm5vZGVOYW1lKSB7XG5cdFx0Y2VsbERhdGEgPSBjZWxsRGF0YS5pbm5lckhUTUw7XG5cdH1cblxuXHRpZiAoIGNlbGxEYXRhID09PSB1bmRlZmluZWQgKSB7XG5cdFx0aWYgKCBzZXR0aW5ncy5pRHJhd0Vycm9yICE9IGRyYXcgJiYgZGVmYXVsdENvbnRlbnQgPT09IG51bGwgKSB7XG5cdFx0XHRfZm5Mb2coIHNldHRpbmdzLCAwLCBcIlJlcXVlc3RlZCB1bmtub3duIHBhcmFtZXRlciBcIitcblx0XHRcdFx0KHR5cGVvZiBjb2wubURhdGE9PSdmdW5jdGlvbicgPyAne2Z1bmN0aW9ufScgOiBcIidcIitjb2wubURhdGErXCInXCIpK1xuXHRcdFx0XHRcIiBmb3Igcm93IFwiK3Jvd0lkeCtcIiwgY29sdW1uIFwiK2NvbElkeCwgNCApO1xuXHRcdFx0c2V0dGluZ3MuaURyYXdFcnJvciA9IGRyYXc7XG5cdFx0fVxuXHRcdHJldHVybiBkZWZhdWx0Q29udGVudDtcblx0fVxuXG5cdC8vIFdoZW4gdGhlIGRhdGEgc291cmNlIGlzIG51bGwgYW5kIGEgc3BlY2lmaWMgZGF0YSB0eXBlIGlzIHJlcXVlc3RlZCAoaS5lLlxuXHQvLyBub3QgdGhlIG9yaWdpbmFsIGRhdGEpLCB3ZSBjYW4gdXNlIGRlZmF1bHQgY29sdW1uIGRhdGFcblx0aWYgKCAoY2VsbERhdGEgPT09IHJvd0RhdGEgfHwgY2VsbERhdGEgPT09IG51bGwpICYmIGRlZmF1bHRDb250ZW50ICE9PSBudWxsICYmIHR5cGUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRjZWxsRGF0YSA9IGRlZmF1bHRDb250ZW50O1xuXHR9XG5cdGVsc2UgaWYgKCB0eXBlb2YgY2VsbERhdGEgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0Ly8gSWYgdGhlIGRhdGEgc291cmNlIGlzIGEgZnVuY3Rpb24sIHRoZW4gd2UgcnVuIGl0IGFuZCB1c2UgdGhlIHJldHVybixcblx0XHQvLyBleGVjdXRpbmcgaW4gdGhlIHNjb3BlIG9mIHRoZSBkYXRhIG9iamVjdCAoZm9yIGluc3RhbmNlcylcblx0XHRyZXR1cm4gY2VsbERhdGEuY2FsbCggcm93RGF0YSApO1xuXHR9XG5cblx0aWYgKCBjZWxsRGF0YSA9PT0gbnVsbCAmJiB0eXBlID09PSAnZGlzcGxheScgKSB7XG5cdFx0cmV0dXJuICcnO1xuXHR9XG5cblx0aWYgKCB0eXBlID09PSAnZmlsdGVyJyApIHtcblx0XHR2YXIgZm9tYXR0ZXJzID0gRGF0YVRhYmxlLmV4dC50eXBlLnNlYXJjaDtcblxuXHRcdGlmICggZm9tYXR0ZXJzWyBjb2wuc1R5cGUgXSApIHtcblx0XHRcdGNlbGxEYXRhID0gZm9tYXR0ZXJzWyBjb2wuc1R5cGUgXSggY2VsbERhdGEgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY2VsbERhdGE7XG59XG5cblxuLyoqXG4gKiBTZXQgdGhlIHZhbHVlIGZvciBhIHNwZWNpZmljIGNlbGwsIGludG8gdGhlIGludGVybmFsIGRhdGEgY2FjaGVcbiAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAcGFyYW0ge2ludH0gcm93SWR4IGFvRGF0YSByb3cgaWRcbiAqICBAcGFyYW0ge2ludH0gY29sSWR4IENvbHVtbiBpbmRleFxuICogIEBwYXJhbSB7Kn0gdmFsIFZhbHVlIHRvIHNldFxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5TZXRDZWxsRGF0YSggc2V0dGluZ3MsIHJvd0lkeCwgY29sSWR4LCB2YWwgKVxue1xuXHR2YXIgY29sICAgICA9IHNldHRpbmdzLmFvQ29sdW1uc1tjb2xJZHhdO1xuXHR2YXIgcm93RGF0YSA9IHNldHRpbmdzLmFvRGF0YVtyb3dJZHhdLl9hRGF0YTtcblxuXHRjb2wuZm5TZXREYXRhKCByb3dEYXRhLCB2YWwsIHtcblx0XHRzZXR0aW5nczogc2V0dGluZ3MsXG5cdFx0cm93OiAgICAgIHJvd0lkeCxcblx0XHRjb2w6ICAgICAgY29sSWR4XG5cdH0gICk7XG59XG5cbi8qKlxuICogV3JpdGUgYSB2YWx1ZSB0byBhIGNlbGxcbiAqIEBwYXJhbSB7Kn0gdGQgQ2VsbFxuICogQHBhcmFtIHsqfSB2YWwgVmFsdWVcbiAqL1xuZnVuY3Rpb24gX2ZuV3JpdGVDZWxsKHRkLCB2YWwpXG57XG5cdGlmICh2YWwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgdmFsLm5vZGVOYW1lKSB7XG5cdFx0JCh0ZClcblx0XHRcdC5lbXB0eSgpXG5cdFx0XHQuYXBwZW5kKHZhbCk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0dGQuaW5uZXJIVE1MID0gdmFsO1xuXHR9XG59XG5cblxuLy8gUHJpdmF0ZSB2YXJpYWJsZSB0aGF0IGlzIHVzZWQgdG8gbWF0Y2ggYWN0aW9uIHN5bnRheCBpbiB0aGUgZGF0YSBwcm9wZXJ0eSBvYmplY3RcbnZhciBfX3JlQXJyYXkgPSAvXFxbLio/XFxdJC87XG52YXIgX19yZUZuID0gL1xcKFxcKSQvO1xuXG4vKipcbiAqIFNwbGl0IHN0cmluZyBvbiBwZXJpb2RzLCB0YWtpbmcgaW50byBhY2NvdW50IGVzY2FwZWQgcGVyaW9kc1xuICogQHBhcmFtICB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIHNwbGl0XG4gKiBAcmV0dXJuIHthcnJheX0gU3BsaXQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIF9mblNwbGl0T2JqTm90YXRpb24oIHN0ciApXG57XG5cdHZhciBwYXJ0cyA9IHN0ci5tYXRjaCgvKFxcXFwufFteLl0pKy9nKSB8fCBbJyddO1xuXG5cdHJldHVybiBwYXJ0cy5tYXAoIGZ1bmN0aW9uICggcyApIHtcblx0XHRyZXR1cm4gcy5yZXBsYWNlKC9cXFxcXFwuL2csICcuJyk7XG5cdH0gKTtcbn1cblxuXG4vKipcbiAqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gZ2V0IGRhdGEgZnJvbSBhIHNvdXJjZSBvYmplY3QsIHRha2luZ1xuICogaW50byBhY2NvdW50IHRoZSBhYmlsaXR5IHRvIHVzZSBuZXN0ZWQgb2JqZWN0cyBhcyBhIHNvdXJjZVxuICogIEBwYXJhbSB7c3RyaW5nfGludHxmdW5jdGlvbn0gbVNvdXJjZSBUaGUgZGF0YSBzb3VyY2UgZm9yIHRoZSBvYmplY3RcbiAqICBAcmV0dXJucyB7ZnVuY3Rpb259IERhdGEgZ2V0IGZ1bmN0aW9uXG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbnZhciBfZm5HZXRPYmplY3REYXRhRm4gPSBEYXRhVGFibGUudXRpbC5nZXQ7XG5cblxuLyoqXG4gKiBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIHNldCBkYXRhIGZyb20gYSBzb3VyY2Ugb2JqZWN0LCB0YWtpbmdcbiAqIGludG8gYWNjb3VudCB0aGUgYWJpbGl0eSB0byB1c2UgbmVzdGVkIG9iamVjdHMgYXMgYSBzb3VyY2VcbiAqICBAcGFyYW0ge3N0cmluZ3xpbnR8ZnVuY3Rpb259IG1Tb3VyY2UgVGhlIGRhdGEgc291cmNlIGZvciB0aGUgb2JqZWN0XG4gKiAgQHJldHVybnMge2Z1bmN0aW9ufSBEYXRhIHNldCBmdW5jdGlvblxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG52YXIgX2ZuU2V0T2JqZWN0RGF0YUZuID0gRGF0YVRhYmxlLnV0aWwuc2V0O1xuXG5cbi8qKlxuICogUmV0dXJuIGFuIGFycmF5IHdpdGggdGhlIGZ1bGwgdGFibGUgZGF0YVxuICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAcmV0dXJucyBhcnJheSB7YXJyYXl9IGFEYXRhIE1hc3RlciBkYXRhIGFycmF5XG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkdldERhdGFNYXN0ZXIgKCBzZXR0aW5ncyApXG57XG5cdHJldHVybiBfcGx1Y2soIHNldHRpbmdzLmFvRGF0YSwgJ19hRGF0YScgKTtcbn1cblxuXG4vKipcbiAqIE51a2UgdGhlIHRhYmxlXG4gKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5DbGVhclRhYmxlKCBzZXR0aW5ncyApXG57XG5cdHNldHRpbmdzLmFvRGF0YS5sZW5ndGggPSAwO1xuXHRzZXR0aW5ncy5haURpc3BsYXlNYXN0ZXIubGVuZ3RoID0gMDtcblx0c2V0dGluZ3MuYWlEaXNwbGF5Lmxlbmd0aCA9IDA7XG5cdHNldHRpbmdzLmFJZHMgPSB7fTtcbn1cblxuXG4vKipcbiAqIE1hcmsgY2FjaGVkIGRhdGEgYXMgaW52YWxpZCBzdWNoIHRoYXQgYSByZS1yZWFkIG9mIHRoZSBkYXRhIHdpbGwgb2NjdXIgd2hlblxuICogdGhlIGNhY2hlZCBkYXRhIGlzIG5leHQgcmVxdWVzdGVkLiBBbHNvIHVwZGF0ZSBmcm9tIHRoZSBkYXRhIHNvdXJjZSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiBAcGFyYW0ge2ludH0gICAgcm93SWR4ICAgUm93IGluZGV4IHRvIGludmFsaWRhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3JjXSAgICBTb3VyY2UgdG8gaW52YWxpZGF0ZSBmcm9tOiB1bmRlZmluZWQsICdhdXRvJywgJ2RvbSdcbiAqICAgICBvciAnZGF0YSdcbiAqIEBwYXJhbSB7aW50fSAgICBbY29sSWR4XSBDb2x1bW4gaW5kZXggdG8gaW52YWxpZGF0ZS4gSWYgdW5kZWZpbmVkIHRoZSB3aG9sZVxuICogICAgIHJvdyB3aWxsIGJlIGludmFsaWRhdGVkXG4gKiBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqXG4gKiBAdG9kbyBGb3IgdGhlIG1vZHVsYXJpc2F0aW9uIG9mIHYxLjExIHRoaXMgd2lsbCBuZWVkIHRvIGJlY29tZSBhIGNhbGxiYWNrLCBzb1xuICogICB0aGUgc29ydCBhbmQgZmlsdGVyIG1ldGhvZHMgY2FuIHN1YnNjcmliZSB0byBpdC4gVGhhdCB3aWxsIHJlcXVpcmVkXG4gKiAgIGluaXRpYWxpc2F0aW9uIG9wdGlvbnMgZm9yIHNvcnRpbmcsIHdoaWNoIGlzIHdoeSBpdCBpcyBub3QgYWxyZWFkeSBiYWtlZCBpblxuICovXG5mdW5jdGlvbiBfZm5JbnZhbGlkYXRlKCBzZXR0aW5ncywgcm93SWR4LCBzcmMsIGNvbElkeCApXG57XG5cdHZhciByb3cgPSBzZXR0aW5ncy5hb0RhdGFbIHJvd0lkeCBdO1xuXHR2YXIgaSwgaWVuO1xuXG5cdC8vIFJlbW92ZSB0aGUgY2FjaGVkIGRhdGEgZm9yIHRoZSByb3dcblx0cm93Ll9hU29ydERhdGEgPSBudWxsO1xuXHRyb3cuX2FGaWx0ZXJEYXRhID0gbnVsbDtcblx0cm93LmRpc3BsYXlEYXRhID0gbnVsbDtcblxuXHQvLyBBcmUgd2UgcmVhZGluZyBsYXN0IGRhdGEgZnJvbSBET00gb3IgdGhlIGRhdGEgb2JqZWN0P1xuXHRpZiAoIHNyYyA9PT0gJ2RvbScgfHwgKCghIHNyYyB8fCBzcmMgPT09ICdhdXRvJykgJiYgcm93LnNyYyA9PT0gJ2RvbScpICkge1xuXHRcdC8vIFJlYWQgdGhlIGRhdGEgZnJvbSB0aGUgRE9NXG5cdFx0cm93Ll9hRGF0YSA9IF9mbkdldFJvd0VsZW1lbnRzKFxuXHRcdFx0XHRzZXR0aW5ncywgcm93LCBjb2xJZHgsIGNvbElkeCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogcm93Ll9hRGF0YVxuXHRcdFx0KVxuXHRcdFx0LmRhdGE7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gUmVhZGluZyBmcm9tIGRhdGEgb2JqZWN0LCB1cGRhdGUgdGhlIERPTVxuXHRcdHZhciBjZWxscyA9IHJvdy5hbkNlbGxzO1xuXHRcdHZhciBkaXNwbGF5ID0gX2ZuR2V0Um93RGlzcGxheShzZXR0aW5ncywgcm93SWR4KTtcblxuXHRcdGlmICggY2VsbHMgKSB7XG5cdFx0XHRpZiAoIGNvbElkeCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRfZm5Xcml0ZUNlbGwoY2VsbHNbY29sSWR4XSwgZGlzcGxheVtjb2xJZHhdKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRmb3IgKCBpPTAsIGllbj1jZWxscy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0XHRfZm5Xcml0ZUNlbGwoY2VsbHNbaV0sIGRpc3BsYXlbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ29sdW1uIHNwZWNpZmljIGludmFsaWRhdGlvblxuXHR2YXIgY29scyA9IHNldHRpbmdzLmFvQ29sdW1ucztcblx0aWYgKCBjb2xJZHggIT09IHVuZGVmaW5lZCApIHtcblx0XHQvLyBUeXBlIC0gdGhlIGRhdGEgbWlnaHQgaGF2ZSBjaGFuZ2VkXG5cdFx0Y29sc1sgY29sSWR4IF0uc1R5cGUgPSBudWxsO1xuXG5cdFx0Ly8gTWF4IGxlbmd0aCBzdHJpbmcuIEl0cyBhIGZhaXJseSBjaGVlcCByZWNhbGN1bGF0aW9uLCBzbyBub3Qgd29ydGhcblx0XHQvLyBzb21ldGhpbmcgbW9yZSBjb21wbGljYXRlZFxuXHRcdGNvbHNbIGNvbElkeCBdLm1heExlblN0cmluZyA9IG51bGw7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Zm9yICggaT0wLCBpZW49Y29scy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdGNvbHNbaV0uc1R5cGUgPSBudWxsO1xuXHRcdFx0Y29sc1tpXS5tYXhMZW5TdHJpbmcgPSBudWxsO1xuXHRcdH1cblxuXHRcdC8vIFVwZGF0ZSBEYXRhVGFibGVzIHNwZWNpYWwgYERUXypgIGF0dHJpYnV0ZXMgZm9yIHRoZSByb3dcblx0XHRfZm5Sb3dBdHRyaWJ1dGVzKCBzZXR0aW5ncywgcm93ICk7XG5cdH1cbn1cblxuXG4vKipcbiAqIEJ1aWxkIGEgZGF0YSBzb3VyY2Ugb2JqZWN0IGZyb20gYW4gSFRNTCByb3csIHJlYWRpbmcgdGhlIGNvbnRlbnRzIG9mIHRoZVxuICogY2VsbHMgdGhhdCBhcmUgaW4gdGhlIHJvdy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqIEBwYXJhbSB7bm9kZXxvYmplY3R9IFRSIGVsZW1lbnQgZnJvbSB3aGljaCB0byByZWFkIGRhdGEgb3IgZXhpc3Rpbmcgcm93XG4gKiAgIG9iamVjdCBmcm9tIHdoaWNoIHRvIHJlLXJlYWQgdGhlIGRhdGEgZnJvbSB0aGUgY2VsbHNcbiAqIEBwYXJhbSB7aW50fSBbY29sSWR4XSBPcHRpb25hbCBjb2x1bW4gaW5kZXhcbiAqIEBwYXJhbSB7YXJyYXl8b2JqZWN0fSBbZF0gRGF0YSBzb3VyY2Ugb2JqZWN0LiBJZiBgY29sSWR4YCBpcyBnaXZlbiB0aGVuIHRoaXNcbiAqICAgcGFyYW1ldGVyIHNob3VsZCBhbHNvIGJlIGdpdmVuIGFuZCB3aWxsIGJlIHVzZWQgdG8gd3JpdGUgdGhlIGRhdGEgaW50by5cbiAqICAgT25seSB0aGUgY29sdW1uIGluIHF1ZXN0aW9uIHdpbGwgYmUgd3JpdHRlblxuICogQHJldHVybnMge29iamVjdH0gT2JqZWN0IHdpdGggdHdvIHBhcmFtZXRlcnM6IGBkYXRhYCB0aGUgZGF0YSByZWFkLCBpblxuICogICBkb2N1bWVudCBvcmRlciwgYW5kIGBjZWxsc2AgYW5kIGFycmF5IG9mIG5vZGVzICh0aGV5IGNhbiBiZSB1c2VmdWwgdG8gdGhlXG4gKiAgIGNhbGxlciwgc28gcmF0aGVyIHRoYW4gbmVlZGluZyBhIHNlY29uZCB0cmF2ZXJzYWwgdG8gZ2V0IHRoZW0sIGp1c3QgcmV0dXJuXG4gKiAgIHRoZW0gZnJvbSBoZXJlKS5cbiAqIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5HZXRSb3dFbGVtZW50cyggc2V0dGluZ3MsIHJvdywgY29sSWR4LCBkIClcbntcblx0dmFyXG5cdFx0dGRzID0gW10sXG5cdFx0dGQgPSByb3cuZmlyc3RDaGlsZCxcblx0XHRuYW1lLCBjb2wsIGk9MCwgY29udGVudHMsXG5cdFx0Y29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucyxcblx0XHRvYmplY3RSZWFkID0gc2V0dGluZ3MuX3Jvd1JlYWRPYmplY3Q7XG5cblx0Ly8gQWxsb3cgdGhlIGRhdGEgb2JqZWN0IHRvIGJlIHBhc3NlZCBpbiwgb3IgY29uc3RydWN0XG5cdGQgPSBkICE9PSB1bmRlZmluZWQgP1xuXHRcdGQgOlxuXHRcdG9iamVjdFJlYWQgP1xuXHRcdFx0e30gOlxuXHRcdFx0W107XG5cblx0dmFyIGF0dHIgPSBmdW5jdGlvbiAoIHN0ciwgdGQgICkge1xuXHRcdGlmICggdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHR2YXIgaWR4ID0gc3RyLmluZGV4T2YoJ0AnKTtcblxuXHRcdFx0aWYgKCBpZHggIT09IC0xICkge1xuXHRcdFx0XHR2YXIgYXR0ciA9IHN0ci5zdWJzdHJpbmcoIGlkeCsxICk7XG5cdFx0XHRcdHZhciBzZXR0ZXIgPSBfZm5TZXRPYmplY3REYXRhRm4oIHN0ciApO1xuXHRcdFx0XHRzZXR0ZXIoIGQsIHRkLmdldEF0dHJpYnV0ZSggYXR0ciApICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8vIFJlYWQgZGF0YSBmcm9tIGEgY2VsbCBhbmQgc3RvcmUgaW50byB0aGUgZGF0YSBvYmplY3Rcblx0dmFyIGNlbGxQcm9jZXNzID0gZnVuY3Rpb24gKCBjZWxsICkge1xuXHRcdGlmICggY29sSWR4ID09PSB1bmRlZmluZWQgfHwgY29sSWR4ID09PSBpICkge1xuXHRcdFx0Y29sID0gY29sdW1uc1tpXTtcblx0XHRcdGNvbnRlbnRzID0gKGNlbGwuaW5uZXJIVE1MKS50cmltKCk7XG5cblx0XHRcdGlmICggY29sICYmIGNvbC5fYkF0dHJTcmMgKSB7XG5cdFx0XHRcdHZhciBzZXR0ZXIgPSBfZm5TZXRPYmplY3REYXRhRm4oIGNvbC5tRGF0YS5fICk7XG5cdFx0XHRcdHNldHRlciggZCwgY29udGVudHMgKTtcblxuXHRcdFx0XHRhdHRyKCBjb2wubURhdGEuc29ydCwgY2VsbCApO1xuXHRcdFx0XHRhdHRyKCBjb2wubURhdGEudHlwZSwgY2VsbCApO1xuXHRcdFx0XHRhdHRyKCBjb2wubURhdGEuZmlsdGVyLCBjZWxsICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Ly8gRGVwZW5kaW5nIG9uIHRoZSBgZGF0YWAgb3B0aW9uIGZvciB0aGUgY29sdW1ucyB0aGUgZGF0YSBjYW5cblx0XHRcdFx0Ly8gYmUgcmVhZCB0byBlaXRoZXIgYW4gb2JqZWN0IG9yIGFuIGFycmF5LlxuXHRcdFx0XHRpZiAoIG9iamVjdFJlYWQgKSB7XG5cdFx0XHRcdFx0aWYgKCAhIGNvbC5fc2V0dGVyICkge1xuXHRcdFx0XHRcdFx0Ly8gQ2FjaGUgdGhlIHNldHRlciBmdW5jdGlvblxuXHRcdFx0XHRcdFx0Y29sLl9zZXR0ZXIgPSBfZm5TZXRPYmplY3REYXRhRm4oIGNvbC5tRGF0YSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb2wuX3NldHRlciggZCwgY29udGVudHMgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRkW2ldID0gY29udGVudHM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpKys7XG5cdH07XG5cblx0aWYgKCB0ZCApIHtcblx0XHQvLyBgdHJgIGVsZW1lbnQgd2FzIHBhc3NlZCBpblxuXHRcdHdoaWxlICggdGQgKSB7XG5cdFx0XHRuYW1lID0gdGQubm9kZU5hbWUudG9VcHBlckNhc2UoKTtcblxuXHRcdFx0aWYgKCBuYW1lID09IFwiVERcIiB8fCBuYW1lID09IFwiVEhcIiApIHtcblx0XHRcdFx0Y2VsbFByb2Nlc3MoIHRkICk7XG5cdFx0XHRcdHRkcy5wdXNoKCB0ZCApO1xuXHRcdFx0fVxuXG5cdFx0XHR0ZCA9IHRkLm5leHRTaWJsaW5nO1xuXHRcdH1cblx0fVxuXHRlbHNlIHtcblx0XHQvLyBFeGlzdGluZyByb3cgb2JqZWN0IHBhc3NlZCBpblxuXHRcdHRkcyA9IHJvdy5hbkNlbGxzO1xuXG5cdFx0Zm9yICggdmFyIGo9MCwgamVuPXRkcy5sZW5ndGggOyBqPGplbiA7IGorKyApIHtcblx0XHRcdGNlbGxQcm9jZXNzKCB0ZHNbal0gKTtcblx0XHR9XG5cdH1cblxuXHQvLyBSZWFkIHRoZSBJRCBmcm9tIHRoZSBET00gaWYgcHJlc2VudFxuXHR2YXIgcm93Tm9kZSA9IHJvdy5maXJzdENoaWxkID8gcm93IDogcm93Lm5UcjtcblxuXHRpZiAoIHJvd05vZGUgKSB7XG5cdFx0dmFyIGlkID0gcm93Tm9kZS5nZXRBdHRyaWJ1dGUoICdpZCcgKTtcblxuXHRcdGlmICggaWQgKSB7XG5cdFx0XHRfZm5TZXRPYmplY3REYXRhRm4oIHNldHRpbmdzLnJvd0lkICkoIGQsIGlkICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRkYXRhOiBkLFxuXHRcdGNlbGxzOiB0ZHNcblx0fTtcbn1cblxuLyoqXG4gKiBSZW5kZXIgYW5kIGNhY2hlIGEgcm93J3MgZGlzcGxheSBkYXRhIGZvciB0aGUgY29sdW1ucywgaWYgcmVxdWlyZWRcbiAqIEByZXR1cm5zIFxuICovXG5mdW5jdGlvbiBfZm5HZXRSb3dEaXNwbGF5IChzZXR0aW5ncywgcm93SWR4KSB7XG5cdHZhciByb3dNb2RhbCA9IHNldHRpbmdzLmFvRGF0YVtyb3dJZHhdO1xuXHR2YXIgY29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucztcblxuXHRpZiAoISByb3dNb2RhbC5kaXNwbGF5RGF0YSkge1xuXHRcdC8vIE5lZWQgdG8gcmVuZGVyIGFuZCBjYWNoZVxuXHRcdHJvd01vZGFsLmRpc3BsYXlEYXRhID0gW107XG5cdFxuXHRcdGZvciAoIHZhciBjb2xJZHg9MCwgbGVuPWNvbHVtbnMubGVuZ3RoIDsgY29sSWR4PGxlbiA7IGNvbElkeCsrICkge1xuXHRcdFx0cm93TW9kYWwuZGlzcGxheURhdGEucHVzaChcblx0XHRcdFx0X2ZuR2V0Q2VsbERhdGEoIHNldHRpbmdzLCByb3dJZHgsIGNvbElkeCwgJ2Rpc3BsYXknIClcblx0XHRcdCk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHJvd01vZGFsLmRpc3BsYXlEYXRhO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBUUiBlbGVtZW50IChhbmQgaXQncyBURCBjaGlsZHJlbikgZm9yIGEgcm93XG4gKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBwYXJhbSB7aW50fSBpUm93IFJvdyB0byBjb25zaWRlclxuICogIEBwYXJhbSB7bm9kZX0gW25UckluXSBUUiBlbGVtZW50IHRvIGFkZCB0byB0aGUgdGFibGUgLSBvcHRpb25hbC4gSWYgbm90IGdpdmVuLFxuICogICAgRGF0YVRhYmxlcyB3aWxsIGNyZWF0ZSBhIHJvdyBhdXRvbWF0aWNhbGx5XG4gKiAgQHBhcmFtIHthcnJheX0gW2FuVGRzXSBBcnJheSBvZiBURHxUSCBlbGVtZW50cyBmb3IgdGhlIHJvdyAtIG11c3QgYmUgZ2l2ZW5cbiAqICAgIGlmIG5UciBpcy5cbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuQ3JlYXRlVHIgKCBvU2V0dGluZ3MsIGlSb3csIG5UckluLCBhblRkcyApXG57XG5cdHZhclxuXHRcdHJvdyA9IG9TZXR0aW5ncy5hb0RhdGFbaVJvd10sXG5cdFx0cm93RGF0YSA9IHJvdy5fYURhdGEsXG5cdFx0Y2VsbHMgPSBbXSxcblx0XHRuVHIsIG5UZCwgb0NvbCxcblx0XHRpLCBpTGVuLCBjcmVhdGUsXG5cdFx0dHJDbGFzcyA9IG9TZXR0aW5ncy5vQ2xhc3Nlcy50Ym9keS5yb3c7XG5cblx0aWYgKCByb3cublRyID09PSBudWxsIClcblx0e1xuXHRcdG5UciA9IG5UckluIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyJyk7XG5cblx0XHRyb3cublRyID0gblRyO1xuXHRcdHJvdy5hbkNlbGxzID0gY2VsbHM7XG5cblx0XHRfYWRkQ2xhc3MoblRyLCB0ckNsYXNzKTtcblxuXHRcdC8qIFVzZSBhIHByaXZhdGUgcHJvcGVydHkgb24gdGhlIG5vZGUgdG8gYWxsb3cgcmVzZXJ2ZSBtYXBwaW5nIGZyb20gdGhlIG5vZGVcblx0XHQgKiB0byB0aGUgYW9EYXRhIGFycmF5IGZvciBmYXN0IGxvb2sgdXBcblx0XHQgKi9cblx0XHRuVHIuX0RUX1Jvd0luZGV4ID0gaVJvdztcblxuXHRcdC8qIFNwZWNpYWwgcGFyYW1ldGVycyBjYW4gYmUgZ2l2ZW4gYnkgdGhlIGRhdGEgc291cmNlIHRvIGJlIHVzZWQgb24gdGhlIHJvdyAqL1xuXHRcdF9mblJvd0F0dHJpYnV0ZXMoIG9TZXR0aW5ncywgcm93ICk7XG5cblx0XHQvKiBQcm9jZXNzIGVhY2ggY29sdW1uICovXG5cdFx0Zm9yICggaT0wLCBpTGVuPW9TZXR0aW5ncy5hb0NvbHVtbnMubGVuZ3RoIDsgaTxpTGVuIDsgaSsrIClcblx0XHR7XG5cdFx0XHRvQ29sID0gb1NldHRpbmdzLmFvQ29sdW1uc1tpXTtcblx0XHRcdGNyZWF0ZSA9IG5UckluICYmIGFuVGRzW2ldID8gZmFsc2UgOiB0cnVlO1xuXG5cdFx0XHRuVGQgPSBjcmVhdGUgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBvQ29sLnNDZWxsVHlwZSApIDogYW5UZHNbaV07XG5cblx0XHRcdGlmICghIG5UZCkge1xuXHRcdFx0XHRfZm5Mb2coIG9TZXR0aW5ncywgMCwgJ0luY29ycmVjdCBjb2x1bW4gY291bnQnLCAxOCApO1xuXHRcdFx0fVxuXG5cdFx0XHRuVGQuX0RUX0NlbGxJbmRleCA9IHtcblx0XHRcdFx0cm93OiBpUm93LFxuXHRcdFx0XHRjb2x1bW46IGlcblx0XHRcdH07XG5cdFx0XHRcblx0XHRcdGNlbGxzLnB1c2goIG5UZCApO1xuXHRcdFx0XG5cdFx0XHR2YXIgZGlzcGxheSA9IF9mbkdldFJvd0Rpc3BsYXkob1NldHRpbmdzLCBpUm93KTtcblxuXHRcdFx0Ly8gTmVlZCB0byBjcmVhdGUgdGhlIEhUTUwgaWYgbmV3LCBvciBpZiBhIHJlbmRlcmluZyBmdW5jdGlvbiBpcyBkZWZpbmVkXG5cdFx0XHRpZiAoXG5cdFx0XHRcdGNyZWF0ZSB8fFxuXHRcdFx0XHQoXG5cdFx0XHRcdFx0KG9Db2wubVJlbmRlciB8fCBvQ29sLm1EYXRhICE9PSBpKSAmJlxuXHRcdFx0XHRcdCghJC5pc1BsYWluT2JqZWN0KG9Db2wubURhdGEpIHx8IG9Db2wubURhdGEuXyAhPT0gaSsnLmRpc3BsYXknKVxuXHRcdFx0XHQpXG5cdFx0XHQpIHtcblx0XHRcdFx0X2ZuV3JpdGVDZWxsKG5UZCwgZGlzcGxheVtpXSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNvbHVtbiBjbGFzc1xuXHRcdFx0X2FkZENsYXNzKG5UZCwgb0NvbC5zQ2xhc3MpO1xuXG5cdFx0XHQvLyBWaXNpYmlsaXR5IC0gYWRkIG9yIHJlbW92ZSBhcyByZXF1aXJlZFxuXHRcdFx0aWYgKCBvQ29sLmJWaXNpYmxlICYmIGNyZWF0ZSApXG5cdFx0XHR7XG5cdFx0XHRcdG5Uci5hcHBlbmRDaGlsZCggblRkICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggISBvQ29sLmJWaXNpYmxlICYmICEgY3JlYXRlIClcblx0XHRcdHtcblx0XHRcdFx0blRkLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIG5UZCApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG9Db2wuZm5DcmVhdGVkQ2VsbCApXG5cdFx0XHR7XG5cdFx0XHRcdG9Db2wuZm5DcmVhdGVkQ2VsbC5jYWxsKCBvU2V0dGluZ3Mub0luc3RhbmNlLFxuXHRcdFx0XHRcdG5UZCwgX2ZuR2V0Q2VsbERhdGEoIG9TZXR0aW5ncywgaVJvdywgaSApLCByb3dEYXRhLCBpUm93LCBpXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0X2ZuQ2FsbGJhY2tGaXJlKCBvU2V0dGluZ3MsICdhb1Jvd0NyZWF0ZWRDYWxsYmFjaycsICdyb3ctY3JlYXRlZCcsIFtuVHIsIHJvd0RhdGEsIGlSb3csIGNlbGxzXSApO1xuXHR9XG5cdGVsc2Uge1xuXHRcdF9hZGRDbGFzcyhyb3cublRyLCB0ckNsYXNzKTtcblx0fVxufVxuXG5cbi8qKlxuICogQWRkIGF0dHJpYnV0ZXMgdG8gYSByb3cgYmFzZWQgb24gdGhlIHNwZWNpYWwgYERUXypgIHBhcmFtZXRlcnMgaW4gYSBkYXRhXG4gKiBzb3VyY2Ugb2JqZWN0LlxuICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBwYXJhbSB7b2JqZWN0fSBEYXRhVGFibGVzIHJvdyBvYmplY3QgZm9yIHRoZSByb3cgdG8gYmUgbW9kaWZpZWRcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuUm93QXR0cmlidXRlcyggc2V0dGluZ3MsIHJvdyApXG57XG5cdHZhciB0ciA9IHJvdy5uVHI7XG5cdHZhciBkYXRhID0gcm93Ll9hRGF0YTtcblxuXHRpZiAoIHRyICkge1xuXHRcdHZhciBpZCA9IHNldHRpbmdzLnJvd0lkRm4oIGRhdGEgKTtcblxuXHRcdGlmICggaWQgKSB7XG5cdFx0XHR0ci5pZCA9IGlkO1xuXHRcdH1cblxuXHRcdGlmICggZGF0YS5EVF9Sb3dDbGFzcyApIHtcblx0XHRcdC8vIFJlbW92ZSBhbnkgY2xhc3NlcyBhZGRlZCBieSBEVF9Sb3dDbGFzcyBiZWZvcmVcblx0XHRcdHZhciBhID0gZGF0YS5EVF9Sb3dDbGFzcy5zcGxpdCgnICcpO1xuXHRcdFx0cm93Ll9fcm93YyA9IHJvdy5fX3Jvd2MgP1xuXHRcdFx0XHRfdW5pcXVlKCByb3cuX19yb3djLmNvbmNhdCggYSApICkgOlxuXHRcdFx0XHRhO1xuXG5cdFx0XHQkKHRyKVxuXHRcdFx0XHQucmVtb3ZlQ2xhc3MoIHJvdy5fX3Jvd2Muam9pbignICcpIClcblx0XHRcdFx0LmFkZENsYXNzKCBkYXRhLkRUX1Jvd0NsYXNzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBkYXRhLkRUX1Jvd0F0dHIgKSB7XG5cdFx0XHQkKHRyKS5hdHRyKCBkYXRhLkRUX1Jvd0F0dHIgKTtcblx0XHR9XG5cblx0XHRpZiAoIGRhdGEuRFRfUm93RGF0YSApIHtcblx0XHRcdCQodHIpLmRhdGEoIGRhdGEuRFRfUm93RGF0YSApO1xuXHRcdH1cblx0fVxufVxuXG5cbi8qKlxuICogQ3JlYXRlIHRoZSBIVE1MIGhlYWRlciBmb3IgdGhlIHRhYmxlXG4gKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5CdWlsZEhlYWQoIHNldHRpbmdzLCBzaWRlIClcbntcblx0dmFyIGNsYXNzZXMgPSBzZXR0aW5ncy5vQ2xhc3Nlcztcblx0dmFyIGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnM7XG5cdHZhciBpLCBpZW4sIHJvdztcblx0dmFyIHRhcmdldCA9IHNpZGUgPT09ICdoZWFkZXInXG5cdFx0PyBzZXR0aW5ncy5uVEhlYWRcblx0XHQ6IHNldHRpbmdzLm5URm9vdDtcblx0dmFyIHRpdGxlUHJvcCA9IHNpZGUgPT09ICdoZWFkZXInID8gJ3NUaXRsZScgOiBzaWRlO1xuXG5cdC8vIEZvb3RlciBtaWdodCBiZSBkZWZpbmVkXG5cdGlmICghIHRhcmdldCkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIElmIG5vIGNlbGxzIHlldCBhbmQgd2UgaGF2ZSBjb250ZW50IGZvciB0aGVtLCB0aGVuIGNyZWF0ZVxuXHRpZiAoc2lkZSA9PT0gJ2hlYWRlcicgfHwgX3BsdWNrKHNldHRpbmdzLmFvQ29sdW1ucywgdGl0bGVQcm9wKS5qb2luKCcnKSkge1xuXHRcdHJvdyA9ICQoJ3RyJywgdGFyZ2V0KTtcblxuXHRcdC8vIEFkZCBhIHJvdyBpZiBuZWVkZWRcblx0XHRpZiAoISByb3cubGVuZ3RoKSB7XG5cdFx0XHRyb3cgPSAkKCc8dHIvPicpLmFwcGVuZFRvKHRhcmdldClcblx0XHR9XG5cblx0XHQvLyBBZGQgdGhlIG51bWJlciBvZiBjZWxscyBuZWVkZWQgdG8gbWFrZSB1cCB0byB0aGUgbnVtYmVyIG9mIGNvbHVtbnNcblx0XHRpZiAocm93Lmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0dmFyIGNlbGxDb3VudCA9IDA7XG5cdFx0XHRcblx0XHRcdCQoJ3RkLCB0aCcsIHJvdykuZWFjaChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGNlbGxDb3VudCArPSB0aGlzLmNvbFNwYW47XG5cdFx0XHR9KTtcblxuXHRcdFx0Zm9yICggaT1jZWxsQ291bnQsIGllbj1jb2x1bW5zLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHQkKCc8dGgvPicpXG5cdFx0XHRcdFx0Lmh0bWwoIGNvbHVtbnNbaV1bdGl0bGVQcm9wXSB8fCAnJyApXG5cdFx0XHRcdFx0LmFwcGVuZFRvKCByb3cgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHR2YXIgZGV0ZWN0ZWQgPSBfZm5EZXRlY3RIZWFkZXIoIHNldHRpbmdzLCB0YXJnZXQsIHRydWUgKTtcblxuXHRpZiAoc2lkZSA9PT0gJ2hlYWRlcicpIHtcblx0XHRzZXR0aW5ncy5hb0hlYWRlciA9IGRldGVjdGVkO1xuXHRcdCQoJ3RyJywgdGFyZ2V0KS5hZGRDbGFzcyhjbGFzc2VzLnRoZWFkLnJvdyk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0c2V0dGluZ3MuYW9Gb290ZXIgPSBkZXRlY3RlZDtcblx0XHQkKCd0cicsIHRhcmdldCkuYWRkQ2xhc3MoY2xhc3Nlcy50Zm9vdC5yb3cpO1xuXHR9XG5cblx0Ly8gRXZlcnkgY2VsbCBuZWVkcyB0byBiZSBwYXNzZWQgdGhyb3VnaCB0aGUgcmVuZGVyZXJcblx0JCh0YXJnZXQpLmNoaWxkcmVuKCd0cicpLmNoaWxkcmVuKCd0aCwgdGQnKVxuXHRcdC5lYWNoKCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRfZm5SZW5kZXJlciggc2V0dGluZ3MsIHNpZGUgKShcblx0XHRcdFx0c2V0dGluZ3MsICQodGhpcyksIGNsYXNzZXNcblx0XHRcdCk7XG5cdFx0fSApO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgbGF5b3V0IHN0cnVjdHVyZSBmb3IgYSBoZWFkZXIgb3IgZm9vdGVyXG4gKlxuICogQHBhcmFtIHsqfSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBTb3VyY2UgbGF5b3V0IGFycmF5XG4gKiBAcGFyYW0geyp9IGluY0NvbHVtbnMgV2hhdCBjb2x1bW5zIHNob3VsZCBiZSBpbmNsdWRlZFxuICogQHJldHVybnMgTGF5b3V0IGFycmF5IGluIGNvbHVtbiBpbmRleCBvcmRlclxuICovXG5mdW5jdGlvbiBfZm5IZWFkZXJMYXlvdXQoIHNldHRpbmdzLCBzb3VyY2UsIGluY0NvbHVtbnMgKVxue1xuXHR2YXIgcm93LCBjb2x1bW4sIGNlbGw7XG5cdHZhciBsb2NhbCA9IFtdO1xuXHR2YXIgc3RydWN0dXJlID0gW107XG5cdHZhciBjb2x1bW5zID0gc2V0dGluZ3MuYW9Db2x1bW5zO1xuXHR2YXIgY29sdW1uQ291bnQgPSBjb2x1bW5zLmxlbmd0aDtcblx0dmFyIHJvd3NwYW4sIGNvbHNwYW47XG5cblx0aWYgKCAhIHNvdXJjZSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBEZWZhdWx0IGlzIHRvIHdvcmsgb24gb25seSB2aXNpYmxlIGNvbHVtbnNcblx0aWYgKCAhIGluY0NvbHVtbnMgKSB7XG5cdFx0aW5jQ29sdW1ucyA9IF9yYW5nZShjb2x1bW5Db3VudClcblx0XHRcdC5maWx0ZXIoZnVuY3Rpb24gKGlkeCkge1xuXHRcdFx0XHRyZXR1cm4gY29sdW1uc1tpZHhdLmJWaXNpYmxlO1xuXHRcdFx0fSk7XG5cdH1cblxuXHQvLyBNYWtlIGEgY29weSBvZiB0aGUgbWFzdGVyIGxheW91dCBhcnJheSwgYnV0IHdpdGggb25seSB0aGUgY29sdW1ucyB3ZSB3YW50XG5cdGZvciAoIHJvdz0wIDsgcm93PHNvdXJjZS5sZW5ndGggOyByb3crKyApIHtcblx0XHQvLyBSZW1vdmUgYW55IGNvbHVtbnMgd2UgaGF2ZW4ndCBzZWxlY3RlZFxuXHRcdGxvY2FsW3Jvd10gPSBzb3VyY2Vbcm93XS5zbGljZSgpLmZpbHRlcihmdW5jdGlvbiAoY2VsbCwgaSkge1xuXHRcdFx0cmV0dXJuIGluY0NvbHVtbnMuaW5jbHVkZXMoaSk7XG5cdFx0fSk7XG5cblx0XHQvLyBQcmVwIHRoZSBzdHJ1Y3R1cmUgYXJyYXkgLSBpdCBuZWVkcyBhbiBlbGVtZW50IGZvciBlYWNoIHJvd1xuXHRcdHN0cnVjdHVyZS5wdXNoKCBbXSApO1xuXHR9XG5cblx0Zm9yICggcm93PTAgOyByb3c8bG9jYWwubGVuZ3RoIDsgcm93KysgKSB7XG5cdFx0Zm9yICggY29sdW1uPTAgOyBjb2x1bW48bG9jYWxbcm93XS5sZW5ndGggOyBjb2x1bW4rKyApIHtcblx0XHRcdHJvd3NwYW4gPSAxO1xuXHRcdFx0Y29sc3BhbiA9IDE7XG5cblx0XHRcdC8vIENoZWNrIHRvIHNlZSBpZiB0aGVyZSBpcyBhbHJlYWR5IGEgY2VsbCAocm93L2NvbHNwYW4pIGNvdmVyaW5nIG91ciB0YXJnZXRcblx0XHRcdC8vIGluc2VydCBwb2ludC4gSWYgdGhlcmUgaXMsIHRoZW4gdGhlcmUgaXMgbm90aGluZyB0byBkby5cblx0XHRcdGlmICggc3RydWN0dXJlW3Jvd11bY29sdW1uXSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRjZWxsID0gbG9jYWxbcm93XVtjb2x1bW5dLmNlbGw7XG5cblx0XHRcdFx0Ly8gRXhwYW5kIGZvciByb3dzcGFuXG5cdFx0XHRcdHdoaWxlIChcblx0XHRcdFx0XHRsb2NhbFtyb3crcm93c3Bhbl0gIT09IHVuZGVmaW5lZCAmJlxuXHRcdFx0XHRcdGxvY2FsW3Jvd11bY29sdW1uXS5jZWxsID09IGxvY2FsW3Jvdytyb3dzcGFuXVtjb2x1bW5dLmNlbGxcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0c3RydWN0dXJlW3Jvdytyb3dzcGFuXVtjb2x1bW5dID0gbnVsbDtcblx0XHRcdFx0XHRyb3dzcGFuKys7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBbmQgZm9yIGNvbHNwYW5cblx0XHRcdFx0d2hpbGUgKFxuXHRcdFx0XHRcdGxvY2FsW3Jvd11bY29sdW1uK2NvbHNwYW5dICE9PSB1bmRlZmluZWQgJiZcblx0XHRcdFx0XHRsb2NhbFtyb3ddW2NvbHVtbl0uY2VsbCA9PSBsb2NhbFtyb3ddW2NvbHVtbitjb2xzcGFuXS5jZWxsXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdC8vIFdoaWNoIGFsc28gbmVlZHMgdG8gZ28gb3ZlciByb3dzXG5cdFx0XHRcdFx0Zm9yICggdmFyIGs9MCA7IGs8cm93c3BhbiA7IGsrKyApIHtcblx0XHRcdFx0XHRcdHN0cnVjdHVyZVtyb3cra11bY29sdW1uK2NvbHNwYW5dID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjb2xzcGFuKys7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgdGl0bGVTcGFuID0gJCgnc3Bhbi5kdC1jb2x1bW4tdGl0bGUnLCBjZWxsKTtcblxuXHRcdFx0XHRzdHJ1Y3R1cmVbcm93XVtjb2x1bW5dID0ge1xuXHRcdFx0XHRcdGNlbGw6IGNlbGwsXG5cdFx0XHRcdFx0Y29sc3BhbjogY29sc3Bhbixcblx0XHRcdFx0XHRyb3dzcGFuOiByb3dzcGFuLFxuXHRcdFx0XHRcdHRpdGxlOiB0aXRsZVNwYW4ubGVuZ3RoXG5cdFx0XHRcdFx0XHQ/IHRpdGxlU3Bhbi5odG1sKClcblx0XHRcdFx0XHRcdDogJChjZWxsKS5odG1sKClcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gc3RydWN0dXJlO1xufVxuXG5cbi8qKlxuICogRHJhdyB0aGUgaGVhZGVyIChvciBmb290ZXIpIGVsZW1lbnQgYmFzZWQgb24gdGhlIGNvbHVtbiB2aXNpYmlsaXR5IHN0YXRlcy5cbiAqXG4gKiAgQHBhcmFtIG9iamVjdCBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAcGFyYW0gYXJyYXkgYW9Tb3VyY2UgTGF5b3V0IGFycmF5IGZyb20gX2ZuRGV0ZWN0SGVhZGVyXG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkRyYXdIZWFkKCBzZXR0aW5ncywgc291cmNlIClcbntcblx0dmFyIGxheW91dCA9IF9mbkhlYWRlckxheW91dChzZXR0aW5ncywgc291cmNlKTtcblx0dmFyIHRyLCBuO1xuXG5cdGZvciAoIHZhciByb3c9MCA7IHJvdzxzb3VyY2UubGVuZ3RoIDsgcm93KysgKSB7XG5cdFx0dHIgPSBzb3VyY2Vbcm93XS5yb3c7XG5cblx0XHQvLyBBbGwgY2VsbHMgYXJlIGdvaW5nIHRvIGJlIHJlcGxhY2VkLCBzbyBlbXB0eSBvdXQgdGhlIHJvd1xuXHRcdC8vIENhbid0IHVzZSAkKCkuZW1wdHkoKSBhcyB0aGF0IGtpbGxzIGV2ZW50IGhhbmRsZXJzXG5cdFx0aWYgKHRyKSB7XG5cdFx0XHR3aGlsZSggKG4gPSB0ci5maXJzdENoaWxkKSApIHtcblx0XHRcdFx0dHIucmVtb3ZlQ2hpbGQoIG4gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKCB2YXIgY29sdW1uPTAgOyBjb2x1bW48bGF5b3V0W3Jvd10ubGVuZ3RoIDsgY29sdW1uKysgKSB7XG5cdFx0XHR2YXIgcG9pbnQgPSBsYXlvdXRbcm93XVtjb2x1bW5dO1xuXG5cdFx0XHRpZiAocG9pbnQpIHtcblx0XHRcdFx0JChwb2ludC5jZWxsKVxuXHRcdFx0XHRcdC5hcHBlbmRUbyh0cilcblx0XHRcdFx0XHQuYXR0cigncm93c3BhbicsIHBvaW50LnJvd3NwYW4pXG5cdFx0XHRcdFx0LmF0dHIoJ2NvbHNwYW4nLCBwb2ludC5jb2xzcGFuKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuXG4vKipcbiAqIEluc2VydCB0aGUgcmVxdWlyZWQgVFIgbm9kZXMgaW50byB0aGUgdGFibGUgZm9yIGRpc3BsYXlcbiAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQHBhcmFtIGFqYXhDb21wbGV0ZSB0cnVlIGFmdGVyIGFqYXggY2FsbCB0byBjb21wbGV0ZSByZW5kZXJpbmdcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuRHJhdyggb1NldHRpbmdzLCBhamF4Q29tcGxldGUgKVxue1xuXHQvLyBBbGxvdyBmb3Igc3RhdGUgc2F2aW5nIGFuZCBhIGN1c3RvbSBzdGFydCBwb3NpdGlvblxuXHRfZm5TdGFydCggb1NldHRpbmdzICk7XG5cblx0LyogUHJvdmlkZSBhIHByZS1jYWxsYmFjayBmdW5jdGlvbiB3aGljaCBjYW4gYmUgdXNlZCB0byBjYW5jZWwgdGhlIGRyYXcgaXMgZmFsc2UgaXMgcmV0dXJuZWQgKi9cblx0dmFyIGFQcmVEcmF3ID0gX2ZuQ2FsbGJhY2tGaXJlKCBvU2V0dGluZ3MsICdhb1ByZURyYXdDYWxsYmFjaycsICdwcmVEcmF3JywgW29TZXR0aW5nc10gKTtcblx0aWYgKCBhUHJlRHJhdy5pbmRleE9mKGZhbHNlKSAhPT0gLTEgKVxuXHR7XG5cdFx0X2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoIG9TZXR0aW5ncywgZmFsc2UgKTtcblx0XHRyZXR1cm47XG5cdH1cblxuXHR2YXIgYW5Sb3dzID0gW107XG5cdHZhciBpUm93Q291bnQgPSAwO1xuXHR2YXIgYlNlcnZlclNpZGUgPSBfZm5EYXRhU291cmNlKCBvU2V0dGluZ3MgKSA9PSAnc3NwJztcblx0dmFyIGFpRGlzcGxheSA9IG9TZXR0aW5ncy5haURpc3BsYXk7XG5cdHZhciBpRGlzcGxheVN0YXJ0ID0gb1NldHRpbmdzLl9pRGlzcGxheVN0YXJ0O1xuXHR2YXIgaURpc3BsYXlFbmQgPSBvU2V0dGluZ3MuZm5EaXNwbGF5RW5kKCk7XG5cdHZhciBjb2x1bW5zID0gb1NldHRpbmdzLmFvQ29sdW1ucztcblx0dmFyIGJvZHkgPSAkKG9TZXR0aW5ncy5uVEJvZHkpO1xuXG5cdG9TZXR0aW5ncy5iRHJhd2luZyA9IHRydWU7XG5cblx0LyogU2VydmVyLXNpZGUgcHJvY2Vzc2luZyBkcmF3IGludGVyY2VwdCAqL1xuXHRpZiAoIG9TZXR0aW5ncy5kZWZlckxvYWRpbmcgKVxuXHR7XG5cdFx0b1NldHRpbmdzLmRlZmVyTG9hZGluZyA9IGZhbHNlO1xuXHRcdG9TZXR0aW5ncy5pRHJhdysrO1xuXHRcdF9mblByb2Nlc3NpbmdEaXNwbGF5KCBvU2V0dGluZ3MsIGZhbHNlICk7XG5cdH1cblx0ZWxzZSBpZiAoICFiU2VydmVyU2lkZSApXG5cdHtcblx0XHRvU2V0dGluZ3MuaURyYXcrKztcblx0fVxuXHRlbHNlIGlmICggIW9TZXR0aW5ncy5iRGVzdHJveWluZyAmJiAhYWpheENvbXBsZXRlKVxuXHR7XG5cdFx0Ly8gU2hvdyBsb2FkaW5nIG1lc3NhZ2UgZm9yIHNlcnZlci1zaWRlIHByb2Nlc3Npbmdcblx0XHRpZiAob1NldHRpbmdzLmlEcmF3ID09PSAwKSB7XG5cdFx0XHRib2R5LmVtcHR5KCkuYXBwZW5kKF9lbXB0eVJvdyhvU2V0dGluZ3MpKTtcblx0XHR9XG5cblx0XHRfZm5BamF4VXBkYXRlKCBvU2V0dGluZ3MgKTtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRpZiAoIGFpRGlzcGxheS5sZW5ndGggIT09IDAgKVxuXHR7XG5cdFx0dmFyIGlTdGFydCA9IGJTZXJ2ZXJTaWRlID8gMCA6IGlEaXNwbGF5U3RhcnQ7XG5cdFx0dmFyIGlFbmQgPSBiU2VydmVyU2lkZSA/IG9TZXR0aW5ncy5hb0RhdGEubGVuZ3RoIDogaURpc3BsYXlFbmQ7XG5cblx0XHRmb3IgKCB2YXIgaj1pU3RhcnQgOyBqPGlFbmQgOyBqKysgKVxuXHRcdHtcblx0XHRcdHZhciBpRGF0YUluZGV4ID0gYWlEaXNwbGF5W2pdO1xuXHRcdFx0dmFyIGFvRGF0YSA9IG9TZXR0aW5ncy5hb0RhdGFbIGlEYXRhSW5kZXggXTtcblx0XHRcdGlmICggYW9EYXRhLm5UciA9PT0gbnVsbCApXG5cdFx0XHR7XG5cdFx0XHRcdF9mbkNyZWF0ZVRyKCBvU2V0dGluZ3MsIGlEYXRhSW5kZXggKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIG5Sb3cgPSBhb0RhdGEublRyO1xuXG5cdFx0XHQvLyBBZGQgdmFyaW91cyBjbGFzc2VzIGFzIG5lZWRlZFxuXHRcdFx0Zm9yICh2YXIgaT0wIDsgaTxjb2x1bW5zLmxlbmd0aCA7IGkrKykge1xuXHRcdFx0XHR2YXIgY29sID0gY29sdW1uc1tpXTtcblx0XHRcdFx0dmFyIHRkID0gYW9EYXRhLmFuQ2VsbHNbaV07XG5cblx0XHRcdFx0X2FkZENsYXNzKHRkLCBfZXh0LnR5cGUuY2xhc3NOYW1lW2NvbC5zVHlwZV0pOyAvLyBhdXRvIGNsYXNzXG5cdFx0XHRcdF9hZGRDbGFzcyh0ZCwgb1NldHRpbmdzLm9DbGFzc2VzLnRib2R5LmNlbGwpOyAvLyBhbGwgY2VsbHNcblx0XHRcdH1cblxuXHRcdFx0Ly8gUm93IGNhbGxiYWNrIGZ1bmN0aW9ucyAtIG1pZ2h0IHdhbnQgdG8gbWFuaXB1bGF0ZSB0aGUgcm93XG5cdFx0XHQvLyBpUm93Q291bnQgYW5kIGogYXJlIG5vdCBjdXJyZW50bHkgZG9jdW1lbnRlZC4gQXJlIHRoZXkgYXQgYWxsXG5cdFx0XHQvLyB1c2VmdWw/XG5cdFx0XHRfZm5DYWxsYmFja0ZpcmUoIG9TZXR0aW5ncywgJ2FvUm93Q2FsbGJhY2snLCBudWxsLFxuXHRcdFx0XHRbblJvdywgYW9EYXRhLl9hRGF0YSwgaVJvd0NvdW50LCBqLCBpRGF0YUluZGV4XSApO1xuXG5cdFx0XHRhblJvd3MucHVzaCggblJvdyApO1xuXHRcdFx0aVJvd0NvdW50Kys7XG5cdFx0fVxuXHR9XG5cdGVsc2Vcblx0e1xuXHRcdGFuUm93c1sgMCBdID0gX2VtcHR5Um93KG9TZXR0aW5ncyk7XG5cdH1cblxuXHQvKiBIZWFkZXIgYW5kIGZvb3RlciBjYWxsYmFja3MgKi9cblx0X2ZuQ2FsbGJhY2tGaXJlKCBvU2V0dGluZ3MsICdhb0hlYWRlckNhbGxiYWNrJywgJ2hlYWRlcicsIFsgJChvU2V0dGluZ3MublRIZWFkKS5jaGlsZHJlbigndHInKVswXSxcblx0XHRfZm5HZXREYXRhTWFzdGVyKCBvU2V0dGluZ3MgKSwgaURpc3BsYXlTdGFydCwgaURpc3BsYXlFbmQsIGFpRGlzcGxheSBdICk7XG5cblx0X2ZuQ2FsbGJhY2tGaXJlKCBvU2V0dGluZ3MsICdhb0Zvb3RlckNhbGxiYWNrJywgJ2Zvb3RlcicsIFsgJChvU2V0dGluZ3MublRGb290KS5jaGlsZHJlbigndHInKVswXSxcblx0XHRfZm5HZXREYXRhTWFzdGVyKCBvU2V0dGluZ3MgKSwgaURpc3BsYXlTdGFydCwgaURpc3BsYXlFbmQsIGFpRGlzcGxheSBdICk7XG5cblx0Ly8gcmVwbGFjZUNoaWxkcmVuIGlzIGZhc3RlciwgYnV0IG9ubHkgYmVjYW1lIHdpZGVzcHJlYWQgaW4gMjAyMCxcblx0Ly8gc28gYSBmYWxsIGJhY2sgaW4galF1ZXJ5IGlzIHByb3ZpZGVkIGZvciBvbGRlciBicm93c2Vycy5cblx0aWYgKGJvZHlbMF0ucmVwbGFjZUNoaWxkcmVuKSB7XG5cdFx0Ym9keVswXS5yZXBsYWNlQ2hpbGRyZW4uYXBwbHkoYm9keVswXSwgYW5Sb3dzKTtcblx0fVxuXHRlbHNlIHtcblx0XHRib2R5LmNoaWxkcmVuKCkuZGV0YWNoKCk7XG5cdFx0Ym9keS5hcHBlbmQoICQoYW5Sb3dzKSApO1xuXHR9XG5cblx0Ly8gRW1wdHkgdGFibGUgbmVlZHMgYSBzcGVjaWZpYyBjbGFzc1xuXHQkKG9TZXR0aW5ncy5uVGFibGVXcmFwcGVyKS50b2dnbGVDbGFzcygnZHQtZW1wdHktZm9vdGVyJywgJCgndHInLCBvU2V0dGluZ3MublRGb290KS5sZW5ndGggPT09IDApO1xuXG5cdC8qIENhbGwgYWxsIHJlcXVpcmVkIGNhbGxiYWNrIGZ1bmN0aW9ucyBmb3IgdGhlIGVuZCBvZiBhIGRyYXcgKi9cblx0X2ZuQ2FsbGJhY2tGaXJlKCBvU2V0dGluZ3MsICdhb0RyYXdDYWxsYmFjaycsICdkcmF3JywgW29TZXR0aW5nc10sIHRydWUgKTtcblxuXHQvKiBEcmF3IGlzIGNvbXBsZXRlLCBzb3J0aW5nIGFuZCBmaWx0ZXJpbmcgbXVzdCBiZSBhcyB3ZWxsICovXG5cdG9TZXR0aW5ncy5iU29ydGVkID0gZmFsc2U7XG5cdG9TZXR0aW5ncy5iRmlsdGVyZWQgPSBmYWxzZTtcblx0b1NldHRpbmdzLmJEcmF3aW5nID0gZmFsc2U7XG59XG5cblxuLyoqXG4gKiBSZWRyYXcgdGhlIHRhYmxlIC0gdGFraW5nIGFjY291bnQgb2YgdGhlIHZhcmlvdXMgZmVhdHVyZXMgd2hpY2ggYXJlIGVuYWJsZWRcbiAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQHBhcmFtIHtib29sZWFufSBbaG9sZFBvc2l0aW9uXSBLZWVwIHRoZSBjdXJyZW50IHBhZ2luZyBwb3NpdGlvbi4gQnkgZGVmYXVsdFxuICogICAgdGhlIHBhZ2luZyBpcyByZXNldCB0byB0aGUgZmlyc3QgcGFnZVxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5SZURyYXcoIHNldHRpbmdzLCBob2xkUG9zaXRpb24sIHJlY29tcHV0ZSApXG57XG5cdHZhclxuXHRcdGZlYXR1cmVzID0gc2V0dGluZ3Mub0ZlYXR1cmVzLFxuXHRcdHNvcnQgICAgID0gZmVhdHVyZXMuYlNvcnQsXG5cdFx0ZmlsdGVyICAgPSBmZWF0dXJlcy5iRmlsdGVyO1xuXG5cdGlmIChyZWNvbXB1dGUgPT09IHVuZGVmaW5lZCB8fCByZWNvbXB1dGUgPT09IHRydWUpIHtcblx0XHQvLyBSZXNvbHZlIGFueSBjb2x1bW4gdHlwZXMgdGhhdCBhcmUgdW5rbm93biBkdWUgdG8gYWRkaXRpb24gb3IgaW52YWxpZGF0aW9uXG5cdFx0X2ZuQ29sdW1uVHlwZXMoIHNldHRpbmdzICk7XG5cblx0XHRpZiAoIHNvcnQgKSB7XG5cdFx0XHRfZm5Tb3J0KCBzZXR0aW5ncyApO1xuXHRcdH1cblxuXHRcdGlmICggZmlsdGVyICkge1xuXHRcdFx0X2ZuRmlsdGVyQ29tcGxldGUoIHNldHRpbmdzLCBzZXR0aW5ncy5vUHJldmlvdXNTZWFyY2ggKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHQvLyBObyBmaWx0ZXJpbmcsIHNvIHdlIHdhbnQgdG8ganVzdCB1c2UgdGhlIGRpc3BsYXkgbWFzdGVyXG5cdFx0XHRzZXR0aW5ncy5haURpc3BsYXkgPSBzZXR0aW5ncy5haURpc3BsYXlNYXN0ZXIuc2xpY2UoKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoIGhvbGRQb3NpdGlvbiAhPT0gdHJ1ZSApIHtcblx0XHRzZXR0aW5ncy5faURpc3BsYXlTdGFydCA9IDA7XG5cdH1cblxuXHQvLyBMZXQgYW55IG1vZHVsZXMga25vdyBhYm91dCB0aGUgZHJhdyBob2xkIHBvc2l0aW9uIHN0YXRlICh1c2VkIGJ5XG5cdC8vIHNjcm9sbGluZyBpbnRlcm5hbGx5KVxuXHRzZXR0aW5ncy5fZHJhd0hvbGQgPSBob2xkUG9zaXRpb247XG5cblx0X2ZuRHJhdyggc2V0dGluZ3MgKTtcblxuXHRzZXR0aW5ncy5hcGkub25lKCdkcmF3JywgZnVuY3Rpb24gKCkge1xuXHRcdHNldHRpbmdzLl9kcmF3SG9sZCA9IGZhbHNlO1xuXHR9KTtcbn1cblxuXG4vKlxuICogVGFibGUgaXMgZW1wdHkgLSBjcmVhdGUgYSByb3cgd2l0aCBhbiBlbXB0eSBtZXNzYWdlIGluIGl0XG4gKi9cbmZ1bmN0aW9uIF9lbXB0eVJvdyAoIHNldHRpbmdzICkge1xuXHR2YXIgb0xhbmcgPSBzZXR0aW5ncy5vTGFuZ3VhZ2U7XG5cdHZhciB6ZXJvID0gb0xhbmcuc1plcm9SZWNvcmRzO1xuXHR2YXIgZGF0YVNyYyA9IF9mbkRhdGFTb3VyY2UoIHNldHRpbmdzICk7XG5cblx0Ly8gTWFrZSB1c2Ugb2YgdGhlIGZhY3QgdGhhdCBzZXR0aW5ncy5qc29uIGlzIG9ubHkgc2V0IG9uY2UgdGhlIGluaXRpYWwgZGF0YSBoYXNcblx0Ly8gYmVlbiBsb2FkZWQuIFNob3cgbG9hZGluZyB3aGVuIHRoYXQgaXNuJ3QgdGhlIGNhc2Vcblx0aWYgKChkYXRhU3JjID09PSAnc3NwJyB8fCBkYXRhU3JjID09PSAnYWpheCcpICYmICEgc2V0dGluZ3MuanNvbikge1xuXHRcdHplcm8gPSBvTGFuZy5zTG9hZGluZ1JlY29yZHM7XG5cdH1cblx0ZWxzZSBpZiAoIG9MYW5nLnNFbXB0eVRhYmxlICYmIHNldHRpbmdzLmZuUmVjb3Jkc1RvdGFsKCkgPT09IDAgKVxuXHR7XG5cdFx0emVybyA9IG9MYW5nLnNFbXB0eVRhYmxlO1xuXHR9XG5cblx0cmV0dXJuICQoICc8dHIvPicgKVxuXHRcdC5hcHBlbmQoICQoJzx0ZCAvPicsIHtcblx0XHRcdCdjb2xTcGFuJzogX2ZuVmlzYmxlQ29sdW1ucyggc2V0dGluZ3MgKSxcblx0XHRcdCdjbGFzcyc6ICAgc2V0dGluZ3Mub0NsYXNzZXMuZW1wdHkucm93XG5cdFx0fSApLmh0bWwoIHplcm8gKSApWzBdO1xufVxuXG5cbi8qKlxuICogRXhwYW5kIHRoZSBsYXlvdXQgaXRlbXMgaW50byBhbiBvYmplY3QgZm9yIHRoZSByZW5kZXJpbmcgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gX2xheW91dEl0ZW1zIChyb3csIGFsaWduLCBpdGVtcykge1xuXHRpZiAoIEFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG5cdFx0Zm9yICh2YXIgaT0wIDsgaTxpdGVtcy5sZW5ndGggOyBpKyspIHtcblx0XHRcdF9sYXlvdXRJdGVtcyhyb3csIGFsaWduLCBpdGVtc1tpXSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dmFyIHJvd0NlbGwgPSByb3dbYWxpZ25dO1xuXG5cdC8vIElmIGl0IGlzIGFuIG9iamVjdCwgdGhlbiB0aGVyZSBjYW4gYmUgbXVsdGlwbGUgZmVhdHVyZXMgY29udGFpbmVkIGluIGl0XG5cdGlmICggJC5pc1BsYWluT2JqZWN0KCBpdGVtcyApICkge1xuXHRcdC8vIEEgZmVhdHVyZSBwbHVnaW4gY2Fubm90IGJlIG5hbWVkIFwiZmVhdHVyZXNcIiBkdWUgdG8gdGhpcyBjaGVja1xuXHRcdGlmIChpdGVtcy5mZWF0dXJlcykge1xuXHRcdFx0aWYgKGl0ZW1zLnJvd0lkKSB7XG5cdFx0XHRcdHJvdy5pZCA9IGl0ZW1zLnJvd0lkO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGl0ZW1zLnJvd0NsYXNzKSB7XG5cdFx0XHRcdHJvdy5jbGFzc05hbWUgPSBpdGVtcy5yb3dDbGFzcztcblx0XHRcdH1cblxuXHRcdFx0cm93Q2VsbC5pZCA9IGl0ZW1zLmlkO1xuXHRcdFx0cm93Q2VsbC5jbGFzc05hbWUgPSBpdGVtcy5jbGFzc05hbWU7XG5cblx0XHRcdF9sYXlvdXRJdGVtcyhyb3csIGFsaWduLCBpdGVtcy5mZWF0dXJlcyk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0T2JqZWN0LmtleXMoaXRlbXMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRcdHJvd0NlbGwuY29udGVudHMucHVzaCgge1xuXHRcdFx0XHRcdGZlYXR1cmU6IGtleSxcblx0XHRcdFx0XHRvcHRzOiBpdGVtc1trZXldXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cdGVsc2Uge1xuXHRcdHJvd0NlbGwuY29udGVudHMucHVzaChpdGVtcyk7XG5cdH1cbn1cblxuLyoqXG4gKiBGaW5kLCBvciBjcmVhdGUgYSBsYXlvdXQgcm93XG4gKi9cbmZ1bmN0aW9uIF9sYXlvdXRHZXRSb3cocm93cywgcm93TnVtLCBhbGlnbikge1xuXHR2YXIgcm93O1xuXG5cdC8vIEZpbmQgZXhpc3Rpbmcgcm93c1xuXHRmb3IgKHZhciBpPTA7IGk8cm93cy5sZW5ndGg7IGkrKykge1xuXHRcdHJvdyA9IHJvd3NbaV07XG5cblx0XHRpZiAocm93LnJvd051bSA9PT0gcm93TnVtKSB7XG5cdFx0XHQvLyBmdWxsIGlzIG9uIGl0cyBvd24sIGJ1dCBzdGFydCBhbmQgZW5kIHNoYXJlIGEgcm93XG5cdFx0XHRpZiAoXG5cdFx0XHRcdChhbGlnbiA9PT0gJ2Z1bGwnICYmIHJvdy5mdWxsKSB8fFxuXHRcdFx0XHQoKGFsaWduID09PSAnc3RhcnQnIHx8IGFsaWduID09PSAnZW5kJykgJiYgKHJvdy5zdGFydCB8fCByb3cuZW5kKSlcblx0XHRcdCkge1xuXHRcdFx0XHRpZiAoISByb3dbYWxpZ25dKSB7XG5cdFx0XHRcdFx0cm93W2FsaWduXSA9IHtcblx0XHRcdFx0XHRcdGNvbnRlbnRzOiBbXVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gcm93O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIElmIHdlIGdldCB0aGlzIGZhciwgdGhlbiB0aGVyZSB3YXMgbm8gbWF0Y2gsIGNyZWF0ZSBhIG5ldyByb3dcblx0cm93ID0ge1xuXHRcdHJvd051bTogcm93TnVtXHRcblx0fTtcblxuXHRyb3dbYWxpZ25dID0ge1xuXHRcdGNvbnRlbnRzOiBbXVxuXHR9O1xuXG5cdHJvd3MucHVzaChyb3cpO1xuXG5cdHJldHVybiByb3c7XG59XG5cbi8qKlxuICogQ29udmVydCBhIGBsYXlvdXRgIG9iamVjdCBnaXZlbiBieSBhIHVzZXIgdG8gdGhlIG9iamVjdCBzdHJ1Y3R1cmUgbmVlZGVkXG4gKiBmb3IgdGhlIHJlbmRlcmVyLiBUaGlzIGlzIGRvbmUgdHdpY2UsIG9uY2UgZm9yIGFib3ZlIGFuZCBvbmNlIGZvciBiZWxvd1xuICogdGhlIHRhYmxlLiBPcmRlcmluZyBtdXN0IGFsc28gYmUgY29uc2lkZXJlZC5cbiAqXG4gKiBAcGFyYW0geyp9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiBAcGFyYW0geyp9IGxheW91dCBMYXlvdXQgb2JqZWN0IHRvIGNvbnZlcnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBzaWRlIGB0b3BgIG9yIGBib3R0b21gXG4gKiBAcmV0dXJucyBDb252ZXJ0ZWQgYXJyYXkgc3RydWN0dXJlIC0gb25lIGl0ZW0gZm9yIGVhY2ggcm93LlxuICovXG5mdW5jdGlvbiBfbGF5b3V0QXJyYXkgKCBzZXR0aW5ncywgbGF5b3V0LCBzaWRlICkge1xuXHR2YXIgcm93cyA9IFtdO1xuXHRcblx0Ly8gU3BsaXQgb3V0IGludG8gYW4gYXJyYXlcblx0JC5lYWNoKCBsYXlvdXQsIGZ1bmN0aW9uICggcG9zLCBpdGVtcyApIHtcblx0XHRpZiAoaXRlbXMgPT09IG51bGwpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgcGFydHMgPSBwb3MubWF0Y2goL14oW2Etel0rKShbMC05XSopKFtBLVphLXpdKikkLyk7XG5cdFx0dmFyIHJvd051bSA9IHBhcnRzWzJdXG5cdFx0XHQ/IHBhcnRzWzJdICogMVxuXHRcdFx0OiAwO1xuXHRcdHZhciBhbGlnbiA9IHBhcnRzWzNdXG5cdFx0XHQ/IHBhcnRzWzNdLnRvTG93ZXJDYXNlKClcblx0XHRcdDogJ2Z1bGwnO1xuXG5cdFx0Ly8gRmlsdGVyIG91dCB0aGUgc2lkZSB3ZSBhcmVuJ3QgaW50ZXJlc3RlZCBpblxuXHRcdGlmIChwYXJ0c1sxXSAhPT0gc2lkZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEdldCBvciBjcmVhdGUgdGhlIHJvdyB3ZSBzaG91bGQgYXR0YWNoIHRvXG5cdFx0dmFyIHJvdyA9IF9sYXlvdXRHZXRSb3cocm93cywgcm93TnVtLCBhbGlnbik7XG5cblx0XHRfbGF5b3V0SXRlbXMocm93LCBhbGlnbiwgaXRlbXMpO1xuXHR9KTtcblxuXHQvLyBPcmRlciBieSBpdGVtIGlkZW50aWZpZXJcblx0cm93cy5zb3J0KCBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cdFx0dmFyIG9yZGVyMSA9IGEucm93TnVtO1xuXHRcdHZhciBvcmRlcjIgPSBiLnJvd051bTtcblxuXHRcdC8vIElmIGJvdGggaW4gdGhlIHNhbWUgcm93LCB0aGVuIHRoZSByb3cgd2l0aCBgZnVsbGAgY29tZXMgZmlyc3Rcblx0XHRpZiAob3JkZXIxID09PSBvcmRlcjIpIHtcblx0XHRcdHZhciByZXQgPSBhLmZ1bGwgJiYgISBiLmZ1bGwgPyAtMSA6IDE7XG5cblx0XHRcdHJldHVybiBzaWRlID09PSAnYm90dG9tJ1xuXHRcdFx0XHQ/IHJldCAqIC0xXG5cdFx0XHRcdDogcmV0O1xuXHRcdH1cblxuXHRcdHJldHVybiBvcmRlcjIgLSBvcmRlcjE7XG5cdH0gKTtcblxuXHQvLyBJbnZlcnQgZm9yIGJlbG93IHRoZSB0YWJsZVxuXHRpZiAoIHNpZGUgPT09ICdib3R0b20nICkge1xuXHRcdHJvd3MucmV2ZXJzZSgpO1xuXHR9XG5cblx0Zm9yICh2YXIgcm93ID0gMDsgcm93PHJvd3MubGVuZ3RoOyByb3crKykge1xuXHRcdGRlbGV0ZSByb3dzW3Jvd10ucm93TnVtO1xuXG5cdFx0X2xheW91dFJlc29sdmUoc2V0dGluZ3MsIHJvd3Nbcm93XSk7XG5cdH1cblxuXHRyZXR1cm4gcm93cztcbn1cblxuXG4vKipcbiAqIENvbnZlcnQgdGhlIGNvbnRlbnRzIG9mIGEgcm93J3MgbGF5b3V0IG9iamVjdCB0byBub2RlcyB0aGF0IGNhbiBiZSBpbnNlcnRlZFxuICogaW50byB0aGUgZG9jdW1lbnQgYnkgYSByZW5kZXJlci4gRXhlY3V0ZSBmdW5jdGlvbnMsIGxvb2sgdXAgcGx1Zy1pbnMsIGV0Yy5cbiAqXG4gKiBAcGFyYW0geyp9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiBAcGFyYW0geyp9IHJvdyBMYXlvdXQgb2JqZWN0IGZvciB0aGlzIHJvd1xuICovXG5mdW5jdGlvbiBfbGF5b3V0UmVzb2x2ZSggc2V0dGluZ3MsIHJvdyApIHtcblx0dmFyIGdldEZlYXR1cmUgPSBmdW5jdGlvbiAoZmVhdHVyZSwgb3B0cykge1xuXHRcdGlmICggISBfZXh0LmZlYXR1cmVzWyBmZWF0dXJlIF0gKSB7XG5cdFx0XHRfZm5Mb2coIHNldHRpbmdzLCAwLCAnVW5rbm93biBmZWF0dXJlOiAnKyBmZWF0dXJlICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIF9leHQuZmVhdHVyZXNbIGZlYXR1cmUgXS5hcHBseSggdGhpcywgW3NldHRpbmdzLCBvcHRzXSApO1xuXHR9O1xuXG5cdHZhciByZXNvbHZlID0gZnVuY3Rpb24gKCBpdGVtICkge1xuXHRcdGlmICghIHJvd1sgaXRlbSBdKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGxpbmUgPSByb3dbIGl0ZW0gXS5jb250ZW50cztcblxuXHRcdGZvciAoIHZhciBpPTAsIGllbj1saW5lLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0aWYgKCAhIGxpbmVbaV0gKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIHR5cGVvZiBsaW5lW2ldID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0bGluZVtpXSA9IGdldEZlYXR1cmUoIGxpbmVbaV0sIG51bGwgKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCAkLmlzUGxhaW5PYmplY3QobGluZVtpXSkgKSB7XG5cdFx0XHRcdC8vIElmIGl0J3MgYW4gb2JqZWN0LCBpdCBqdXN0IGhhcyBmZWF0dXJlIGFuZCBvcHRzIHByb3BlcnRpZXMgZnJvbVxuXHRcdFx0XHQvLyB0aGUgdHJhbnNmb3JtIGluIF9sYXlvdXRBcnJheVxuXHRcdFx0XHRsaW5lW2ldID0gZ2V0RmVhdHVyZShsaW5lW2ldLmZlYXR1cmUsIGxpbmVbaV0ub3B0cyk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggdHlwZW9mIGxpbmVbaV0ubm9kZSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0bGluZVtpXSA9IGxpbmVbaV0ubm9kZSggc2V0dGluZ3MgKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCB0eXBlb2YgbGluZVtpXSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0dmFyIGluc3QgPSBsaW5lW2ldKCBzZXR0aW5ncyApO1xuXG5cdFx0XHRcdGxpbmVbaV0gPSB0eXBlb2YgaW5zdC5ub2RlID09PSAnZnVuY3Rpb24nID9cblx0XHRcdFx0XHRpbnN0Lm5vZGUoKSA6XG5cdFx0XHRcdFx0aW5zdDtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0cmVzb2x2ZSgnc3RhcnQnKTtcblx0cmVzb2x2ZSgnZW5kJyk7XG5cdHJlc29sdmUoJ2Z1bGwnKTtcbn1cblxuXG4vKipcbiAqIEFkZCB0aGUgb3B0aW9ucyB0byB0aGUgcGFnZSBIVE1MIGZvciB0aGUgdGFibGVcbiAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuQWRkT3B0aW9uc0h0bWwgKCBzZXR0aW5ncyApXG57XG5cdHZhciBjbGFzc2VzID0gc2V0dGluZ3Mub0NsYXNzZXM7XG5cdHZhciB0YWJsZSA9ICQoc2V0dGluZ3MublRhYmxlKTtcblxuXHQvLyBXcmFwcGVyIGRpdiBhcm91bmQgZXZlcnl0aGluZyBEYXRhVGFibGVzIGNvbnRyb2xzXG5cdHZhciBpbnNlcnQgPSAkKCc8ZGl2Lz4nKVxuXHRcdC5hdHRyKHtcblx0XHRcdGlkOiAgICAgIHNldHRpbmdzLnNUYWJsZUlkKydfd3JhcHBlcicsXG5cdFx0XHQnY2xhc3MnOiBjbGFzc2VzLmNvbnRhaW5lclxuXHRcdH0pXG5cdFx0Lmluc2VydEJlZm9yZSh0YWJsZSk7XG5cblx0c2V0dGluZ3MublRhYmxlV3JhcHBlciA9IGluc2VydFswXTtcblxuXHRpZiAoc2V0dGluZ3Muc0RvbSkge1xuXHRcdC8vIExlZ2FjeVxuXHRcdF9mbkxheW91dERvbShzZXR0aW5ncywgc2V0dGluZ3Muc0RvbSwgaW5zZXJ0KTtcblx0fVxuXHRlbHNlIHtcblx0XHR2YXIgdG9wID0gX2xheW91dEFycmF5KCBzZXR0aW5ncywgc2V0dGluZ3MubGF5b3V0LCAndG9wJyApO1xuXHRcdHZhciBib3R0b20gPSBfbGF5b3V0QXJyYXkoIHNldHRpbmdzLCBzZXR0aW5ncy5sYXlvdXQsICdib3R0b20nICk7XG5cdFx0dmFyIHJlbmRlcmVyID0gX2ZuUmVuZGVyZXIoIHNldHRpbmdzLCAnbGF5b3V0JyApO1xuXHRcblx0XHQvLyBFdmVyeXRoaW5nIGFib3ZlIC0gdGhlIHJlbmRlcmVyIHdpbGwgYWN0dWFsbHkgaW5zZXJ0IHRoZSBjb250ZW50cyBpbnRvIHRoZSBkb2N1bWVudFxuXHRcdHRvcC5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHRyZW5kZXJlciggc2V0dGluZ3MsIGluc2VydCwgaXRlbSApO1xuXHRcdH0pO1xuXG5cdFx0Ly8gVGhlIHRhYmxlIC0gYWx3YXlzIHRoZSBjZW50ZXIgb2YgYXR0ZW50aW9uXG5cdFx0cmVuZGVyZXIoIHNldHRpbmdzLCBpbnNlcnQsIHtcblx0XHRcdGZ1bGw6IHtcblx0XHRcdFx0dGFibGU6IHRydWUsXG5cdFx0XHRcdGNvbnRlbnRzOiBbIF9mbkZlYXR1cmVIdG1sVGFibGUoc2V0dGluZ3MpIF1cblx0XHRcdH1cblx0XHR9ICk7XG5cblx0XHQvLyBFdmVyeXRoaW5nIGJlbG93XG5cdFx0Ym90dG9tLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdHJlbmRlcmVyKCBzZXR0aW5ncywgaW5zZXJ0LCBpdGVtICk7XG5cdFx0fSk7XG5cdH1cblxuXHQvLyBQcm9jZXNzaW5nIGZsb2F0cyBvbiB0b3AsIHNvIGl0IGlzbid0IGFuIGluc2VydGVkIGZlYXR1cmVcblx0X3Byb2Nlc3NpbmdIdG1sKCBzZXR0aW5ncyApO1xufVxuXG4vKipcbiAqIERyYXcgdGhlIHRhYmxlIHdpdGggdGhlIGxlZ2FjeSBET00gcHJvcGVydHlcbiAqIEBwYXJhbSB7Kn0gc2V0dGluZ3MgRFQgc2V0dGluZ3Mgb2JqZWN0XG4gKiBAcGFyYW0geyp9IGRvbSBET00gc3RyaW5nXG4gKiBAcGFyYW0geyp9IGluc2VydCBJbnNlcnQgcG9pbnRcbiAqL1xuZnVuY3Rpb24gX2ZuTGF5b3V0RG9tKCBzZXR0aW5ncywgZG9tLCBpbnNlcnQgKVxue1xuXHR2YXIgcGFydHMgPSBkb20ubWF0Y2goLyhcIi4qP1wiKXwoJy4qPycpfC4vZyk7XG5cdHZhciBmZWF0dXJlTm9kZSwgb3B0aW9uLCBuZXdOb2RlLCBuZXh0LCBhdHRyO1xuXG5cdGZvciAoIHZhciBpPTAgOyBpPHBhcnRzLmxlbmd0aCA7IGkrKyApIHtcblx0XHRmZWF0dXJlTm9kZSA9IG51bGw7XG5cdFx0b3B0aW9uID0gcGFydHNbaV07XG5cblx0XHRpZiAoIG9wdGlvbiA9PSAnPCcgKSB7XG5cdFx0XHQvLyBOZXcgY29udGFpbmVyIGRpdlxuXHRcdFx0bmV3Tm9kZSA9ICQoJzxkaXYvPicpO1xuXG5cdFx0XHQvLyBDaGVjayB0byBzZWUgaWYgd2Ugc2hvdWxkIGFwcGVuZCBhbiBpZCBhbmQvb3IgYSBjbGFzcyBuYW1lIHRvIHRoZSBjb250YWluZXJcblx0XHRcdG5leHQgPSBwYXJ0c1tpKzFdO1xuXG5cdFx0XHRpZiAoIG5leHRbMF0gPT0gXCInXCIgfHwgbmV4dFswXSA9PSAnXCInICkge1xuXHRcdFx0XHRhdHRyID0gbmV4dC5yZXBsYWNlKC9bJ1wiXS9nLCAnJyk7XG5cblx0XHRcdFx0dmFyIGlkID0gJycsIGNsYXNzTmFtZTtcblxuXHRcdFx0XHQvKiBUaGUgYXR0cmlidXRlIGNhbiBiZSBpbiB0aGUgZm9ybWF0IG9mIFwiI2lkLmNsYXNzXCIsIFwiI2lkXCIgb3IgXCJjbGFzc1wiIFRoaXMgbG9naWNcblx0XHRcdFx0ICogYnJlYWtzIHRoZSBzdHJpbmcgaW50byBwYXJ0cyBhbmQgYXBwbGllcyB0aGVtIGFzIG5lZWRlZFxuXHRcdFx0XHQgKi9cblx0XHRcdFx0aWYgKCBhdHRyLmluZGV4T2YoJy4nKSAhPSAtMSApIHtcblx0XHRcdFx0XHR2YXIgc3BsaXQgPSBhdHRyLnNwbGl0KCcuJyk7XG5cblx0XHRcdFx0XHRpZCA9IHNwbGl0WzBdO1xuXHRcdFx0XHRcdGNsYXNzTmFtZSA9IHNwbGl0WzFdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKCBhdHRyWzBdID09IFwiI1wiICkge1xuXHRcdFx0XHRcdGlkID0gYXR0cjtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRjbGFzc05hbWUgPSBhdHRyO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bmV3Tm9kZVxuXHRcdFx0XHRcdC5hdHRyKCdpZCcsIGlkLnN1YnN0cmluZygxKSlcblx0XHRcdFx0XHQuYWRkQ2xhc3MoY2xhc3NOYW1lKTtcblxuXHRcdFx0XHRpKys7IC8vIE1vdmUgYWxvbmcgdGhlIHBvc2l0aW9uIGFycmF5XG5cdFx0XHR9XG5cblx0XHRcdGluc2VydC5hcHBlbmQoIG5ld05vZGUgKTtcblx0XHRcdGluc2VydCA9IG5ld05vZGU7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBvcHRpb24gPT0gJz4nICkge1xuXHRcdFx0Ly8gRW5kIGNvbnRhaW5lciBkaXZcblx0XHRcdGluc2VydCA9IGluc2VydC5wYXJlbnQoKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIG9wdGlvbiA9PSAndCcgKSB7XG5cdFx0XHQvLyBUYWJsZVxuXHRcdFx0ZmVhdHVyZU5vZGUgPSBfZm5GZWF0dXJlSHRtbFRhYmxlKCBzZXR0aW5ncyApO1xuXHRcdH1cblx0XHRlbHNlXG5cdFx0e1xuXHRcdFx0RGF0YVRhYmxlLmV4dC5mZWF0dXJlLmZvckVhY2goZnVuY3Rpb24oZmVhdHVyZSkge1xuXHRcdFx0XHRpZiAoIG9wdGlvbiA9PSBmZWF0dXJlLmNGZWF0dXJlICkge1xuXHRcdFx0XHRcdGZlYXR1cmVOb2RlID0gZmVhdHVyZS5mbkluaXQoIHNldHRpbmdzICk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdC8vIEFkZCB0byB0aGUgZGlzcGxheVxuXHRcdGlmICggZmVhdHVyZU5vZGUgKSB7XG5cdFx0XHRpbnNlcnQuYXBwZW5kKCBmZWF0dXJlTm9kZSApO1xuXHRcdH1cblx0fVxufVxuXG5cbi8qKlxuICogVXNlIHRoZSBET00gc291cmNlIHRvIGNyZWF0ZSB1cCBhbiBhcnJheSBvZiBoZWFkZXIgY2VsbHMuIFRoZSBpZGVhIGhlcmUgaXMgdG9cbiAqIGNyZWF0ZSBhIGxheW91dCBncmlkIChhcnJheSkgb2Ygcm93cyB4IGNvbHVtbnMsIHdoaWNoIGNvbnRhaW5zIGEgcmVmZXJlbmNlXG4gKiB0byB0aGUgY2VsbCB0aGF0IHRoYXQgcG9pbnQgaW4gdGhlIGdyaWQgKHJlZ2FyZGxlc3Mgb2YgY29sL3Jvd3NwYW4pLCBzdWNoIHRoYXRcbiAqIGFueSBjb2x1bW4gLyByb3cgY291bGQgYmUgcmVtb3ZlZCBhbmQgdGhlIG5ldyBncmlkIGNvbnN0cnVjdGVkXG4gKiAgQHBhcmFtIHtub2RlfSB0aGVhZCBUaGUgaGVhZGVyL2Zvb3RlciBlbGVtZW50IGZvciB0aGUgdGFibGVcbiAqICBAcmV0dXJucyB7YXJyYXl9IENhbGN1bGF0ZWQgbGF5b3V0IGFycmF5XG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkRldGVjdEhlYWRlciAoIHNldHRpbmdzLCB0aGVhZCwgd3JpdGUgKVxue1xuXHR2YXIgY29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucztcblx0dmFyIHJvd3MgPSAkKHRoZWFkKS5jaGlsZHJlbigndHInKTtcblx0dmFyIHJvdywgY2VsbDtcblx0dmFyIGksIGssIGwsIGlMZW4sIHNoaWZ0ZWQsIGNvbHVtbiwgY29sc3Bhbiwgcm93c3Bhbjtcblx0dmFyIHRpdGxlUm93ID0gc2V0dGluZ3MudGl0bGVSb3c7XG5cdHZhciBpc0hlYWRlciA9IHRoZWFkICYmIHRoZWFkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd0aGVhZCc7XG5cdHZhciBsYXlvdXQgPSBbXTtcblx0dmFyIHVuaXF1ZTtcblx0dmFyIHNoaWZ0ID0gZnVuY3Rpb24gKCBhLCBpLCBqICkge1xuXHRcdHZhciBrID0gYVtpXTtcblx0XHR3aGlsZSAoIGtbal0gKSB7XG5cdFx0XHRqKys7XG5cdFx0fVxuXHRcdHJldHVybiBqO1xuXHR9O1xuXG5cdC8vIFdlIGtub3cgaG93IG1hbnkgcm93cyB0aGVyZSBhcmUgaW4gdGhlIGxheW91dCAtIHNvIHByZXAgaXRcblx0Zm9yICggaT0wLCBpTGVuPXJvd3MubGVuZ3RoIDsgaTxpTGVuIDsgaSsrICkge1xuXHRcdGxheW91dC5wdXNoKCBbXSApO1xuXHR9XG5cblx0Zm9yICggaT0wLCBpTGVuPXJvd3MubGVuZ3RoIDsgaTxpTGVuIDsgaSsrICkge1xuXHRcdHJvdyA9IHJvd3NbaV07XG5cdFx0Y29sdW1uID0gMDtcblxuXHRcdC8vIEZvciBldmVyeSBjZWxsIGluIHRoZSByb3cuLlxuXHRcdGNlbGwgPSByb3cuZmlyc3RDaGlsZDtcblx0XHR3aGlsZSAoIGNlbGwgKSB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdGNlbGwubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PSAnVEQnIHx8XG5cdFx0XHRcdGNlbGwubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PSAnVEgnXG5cdFx0XHQpIHtcblx0XHRcdFx0dmFyIGNvbHMgPSBbXTtcblx0XHRcdFx0dmFyIGpxQ2VsbCA9ICQoY2VsbCk7XG5cblx0XHRcdFx0Ly8gR2V0IHRoZSBjb2wgYW5kIHJvd3NwYW4gYXR0cmlidXRlcyBmcm9tIHRoZSBET00gYW5kIHNhbml0aXNlIHRoZW1cblx0XHRcdFx0Y29sc3BhbiA9IGNlbGwuZ2V0QXR0cmlidXRlKCdjb2xzcGFuJykgKiAxO1xuXHRcdFx0XHRyb3dzcGFuID0gY2VsbC5nZXRBdHRyaWJ1dGUoJ3Jvd3NwYW4nKSAqIDE7XG5cdFx0XHRcdGNvbHNwYW4gPSAoIWNvbHNwYW4gfHwgY29sc3Bhbj09PTAgfHwgY29sc3Bhbj09PTEpID8gMSA6IGNvbHNwYW47XG5cdFx0XHRcdHJvd3NwYW4gPSAoIXJvd3NwYW4gfHwgcm93c3Bhbj09PTAgfHwgcm93c3Bhbj09PTEpID8gMSA6IHJvd3NwYW47XG5cblx0XHRcdFx0Ly8gVGhlcmUgbWlnaHQgYmUgY29sc3BhbiBjZWxscyBhbHJlYWR5IGluIHRoaXMgcm93LCBzbyBzaGlmdCBvdXIgdGFyZ2V0XG5cdFx0XHRcdC8vIGFjY29yZGluZ2x5XG5cdFx0XHRcdHNoaWZ0ZWQgPSBzaGlmdCggbGF5b3V0LCBpLCBjb2x1bW4gKTtcblxuXHRcdFx0XHQvLyBDYWNoZSBjYWxjdWxhdGlvbiBmb3IgdW5pcXVlIGNvbHVtbnNcblx0XHRcdFx0dW5pcXVlID0gY29sc3BhbiA9PT0gMSA/XG5cdFx0XHRcdFx0dHJ1ZSA6XG5cdFx0XHRcdFx0ZmFsc2U7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBQZXJmb3JtIGhlYWRlciBzZXR1cFxuXHRcdFx0XHRpZiAoIHdyaXRlICkge1xuXHRcdFx0XHRcdGlmICh1bmlxdWUpIHtcblx0XHRcdFx0XHRcdC8vIEFsbG93IGNvbHVtbiBvcHRpb25zIHRvIGJlIHNldCBmcm9tIEhUTUwgYXR0cmlidXRlc1xuXHRcdFx0XHRcdFx0X2ZuQ29sdW1uT3B0aW9ucyggc2V0dGluZ3MsIHNoaWZ0ZWQsIGpxQ2VsbC5kYXRhKCkgKTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0Ly8gR2V0IHRoZSB3aWR0aCBmb3IgdGhlIGNvbHVtbi4gVGhpcyBjYW4gYmUgZGVmaW5lZCBmcm9tIHRoZVxuXHRcdFx0XHRcdFx0Ly8gd2lkdGggYXR0cmlidXRlLCBzdHlsZSBhdHRyaWJ1dGUgb3IgYGNvbHVtbnMud2lkdGhgIG9wdGlvblxuXHRcdFx0XHRcdFx0dmFyIGNvbHVtbkRlZiA9IGNvbHVtbnNbc2hpZnRlZF07XG5cdFx0XHRcdFx0XHR2YXIgd2lkdGggPSBjZWxsLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSB8fCBudWxsO1xuXHRcdFx0XHRcdFx0dmFyIHQgPSBjZWxsLnN0eWxlLndpZHRoLm1hdGNoKC93aWR0aDpcXHMqKFxcZCtbcHhlbSVdKykvKTtcblx0XHRcdFx0XHRcdGlmICggdCApIHtcblx0XHRcdFx0XHRcdFx0d2lkdGggPSB0WzFdO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRjb2x1bW5EZWYuc1dpZHRoT3JpZyA9IGNvbHVtbkRlZi5zV2lkdGggfHwgd2lkdGg7XG5cblx0XHRcdFx0XHRcdGlmIChpc0hlYWRlcikge1xuXHRcdFx0XHRcdFx0XHQvLyBDb2x1bW4gdGl0bGUgaGFuZGxpbmcgLSBjYW4gYmUgdXNlciBzZXQsIG9yIHJlYWQgZnJvbSB0aGUgRE9NXG5cdFx0XHRcdFx0XHRcdC8vIFRoaXMgaGFwcGVucyBiZWZvcmUgdGhlIHJlbmRlciwgc28gdGhlIG9yaWdpbmFsIGlzIHN0aWxsIGluIHBsYWNlXG5cdFx0XHRcdFx0XHRcdGlmICggY29sdW1uRGVmLnNUaXRsZSAhPT0gbnVsbCAmJiAhIGNvbHVtbkRlZi5hdXRvVGl0bGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0XHRcdFx0KHRpdGxlUm93ID09PSB0cnVlICYmIGkgPT09IDApIHx8IC8vIHRvcCByb3dcblx0XHRcdFx0XHRcdFx0XHRcdCh0aXRsZVJvdyA9PT0gZmFsc2UgJiYgaSA9PT0gcm93cy5sZW5ndGggLTEpIHx8IC8vIGJvdHRvbSByb3dcblx0XHRcdFx0XHRcdFx0XHRcdCh0aXRsZVJvdyA9PT0gaSkgfHwgLy8gc3BlY2lmaWMgcm93XG5cdFx0XHRcdFx0XHRcdFx0XHQodGl0bGVSb3cgPT09IG51bGwpXG5cdFx0XHRcdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjZWxsLmlubmVySFRNTCA9IGNvbHVtbkRlZi5zVGl0bGU7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0aWYgKCEgY29sdW1uRGVmLnNUaXRsZSAmJiB1bmlxdWUpIHtcblx0XHRcdFx0XHRcdFx0XHRjb2x1bW5EZWYuc1RpdGxlID0gX3N0cmlwSHRtbChjZWxsLmlubmVySFRNTCk7XG5cdFx0XHRcdFx0XHRcdFx0Y29sdW1uRGVmLmF1dG9UaXRsZSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBGb290ZXIgc3BlY2lmaWMgb3BlcmF0aW9uc1xuXHRcdFx0XHRcdFx0XHRpZiAoY29sdW1uRGVmLmZvb3Rlcikge1xuXHRcdFx0XHRcdFx0XHRcdGNlbGwuaW5uZXJIVE1MID0gY29sdW1uRGVmLmZvb3Rlcjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBGYWxsIGJhY2sgdG8gdGhlIGFyaWEtbGFiZWwgYXR0cmlidXRlIG9uIHRoZSB0YWJsZSBoZWFkZXIgaWYgbm8gYXJpYVRpdGxlIGlzXG5cdFx0XHRcdFx0XHQvLyBwcm92aWRlZC5cblx0XHRcdFx0XHRcdGlmICghIGNvbHVtbkRlZi5hcmlhVGl0bGUpIHtcblx0XHRcdFx0XHRcdFx0Y29sdW1uRGVmLmFyaWFUaXRsZSA9IGpxQ2VsbC5hdHRyKFwiYXJpYS1sYWJlbFwiKSB8fCBjb2x1bW5EZWYuc1RpdGxlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBDb2x1bW4gc3BlY2lmaWMgY2xhc3MgbmFtZXNcblx0XHRcdFx0XHRcdGlmICggY29sdW1uRGVmLmNsYXNzTmFtZSApIHtcblx0XHRcdFx0XHRcdFx0anFDZWxsLmFkZENsYXNzKCBjb2x1bW5EZWYuY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gV3JhcCB0aGUgY29sdW1uIHRpdGxlIHNvIHdlIGNhbiB3cml0ZSB0byBpdCBpbiBmdXR1cmVcblx0XHRcdFx0XHRpZiAoICQoJ3NwYW4uZHQtY29sdW1uLXRpdGxlJywgY2VsbCkubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdFx0XHQkKCc8c3Bhbj4nKVxuXHRcdFx0XHRcdFx0XHQuYWRkQ2xhc3MoJ2R0LWNvbHVtbi10aXRsZScpXG5cdFx0XHRcdFx0XHRcdC5hcHBlbmQoY2VsbC5jaGlsZE5vZGVzKVxuXHRcdFx0XHRcdFx0XHQuYXBwZW5kVG8oY2VsbCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0c2V0dGluZ3Mub3JkZXJJbmRpY2F0b3JzICYmXG5cdFx0XHRcdFx0XHRpc0hlYWRlciAmJlxuXHRcdFx0XHRcdFx0anFDZWxsLmZpbHRlcignOm5vdChbZGF0YS1kdC1vcmRlcj1kaXNhYmxlXSknKS5sZW5ndGggIT09IDAgJiZcblx0XHRcdFx0XHRcdGpxQ2VsbC5wYXJlbnQoJzpub3QoW2RhdGEtZHQtb3JkZXI9ZGlzYWJsZV0pJykubGVuZ3RoICE9PSAwICYmXG5cdFx0XHRcdFx0XHQkKCdzcGFuLmR0LWNvbHVtbi1vcmRlcicsIGNlbGwpLmxlbmd0aCA9PT0gMFxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0JCgnPHNwYW4+Jylcblx0XHRcdFx0XHRcdFx0LmFkZENsYXNzKCdkdC1jb2x1bW4tb3JkZXInKVxuXHRcdFx0XHRcdFx0XHQuYXBwZW5kVG8oY2VsbCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gV2UgbmVlZCB0byB3cmFwIHRoZSBlbGVtZW50cyBpbiB0aGUgaGVhZGVyIGluIGFub3RoZXIgZWxlbWVudCB0byB1c2UgZmxleGJveFxuXHRcdFx0XHRcdC8vIGxheW91dCBmb3IgdGhvc2UgZWxlbWVudHNcblx0XHRcdFx0XHR2YXIgaGVhZGVyRm9vdGVyID0gaXNIZWFkZXIgPyAnaGVhZGVyJyA6ICdmb290ZXInO1xuXG5cdFx0XHRcdFx0aWYgKCAkKCdzcGFuLmR0LWNvbHVtbi0nICsgaGVhZGVyRm9vdGVyLCBjZWxsKS5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0XHRcdCQoJzxkaXY+Jylcblx0XHRcdFx0XHRcdFx0LmFkZENsYXNzKCdkdC1jb2x1bW4tJyArIGhlYWRlckZvb3Rlcilcblx0XHRcdFx0XHRcdFx0LmFwcGVuZChjZWxsLmNoaWxkTm9kZXMpXG5cdFx0XHRcdFx0XHRcdC5hcHBlbmRUbyhjZWxsKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBjb2wgLyByb3dzcGFuLCBjb3B5IHRoZSBpbmZvcm1hdGlvbiBpbnRvIHRoZSBsYXlvdXQgZ3JpZFxuXHRcdFx0XHRmb3IgKCBsPTAgOyBsPGNvbHNwYW4gOyBsKysgKSB7XG5cdFx0XHRcdFx0Zm9yICggaz0wIDsgazxyb3dzcGFuIDsgaysrICkge1xuXHRcdFx0XHRcdFx0bGF5b3V0W2kra11bc2hpZnRlZCtsXSA9IHtcblx0XHRcdFx0XHRcdFx0Y2VsbDogY2VsbCxcblx0XHRcdFx0XHRcdFx0dW5pcXVlOiB1bmlxdWVcblx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdGxheW91dFtpK2tdLnJvdyA9IHJvdztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjb2xzLnB1c2goIHNoaWZ0ZWQrbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXNzaWduIGFuIGF0dHJpYnV0ZSBzbyBzcGFubmluZyBjZWxscyBjYW4gc3RpbGwgYmUgaWRlbnRpZmllZFxuXHRcdFx0XHQvLyBhcyBiZWxvbmdpbmcgdG8gYSBjb2x1bW5cblx0XHRcdFx0Y2VsbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtZHQtY29sdW1uJywgX3VuaXF1ZShjb2xzKS5qb2luKCcsJykpO1xuXHRcdFx0fVxuXG5cdFx0XHRjZWxsID0gY2VsbC5uZXh0U2libGluZztcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbGF5b3V0O1xufVxuXG4vKipcbiAqIFNldCB0aGUgc3RhcnQgcG9zaXRpb24gZm9yIGRyYXdcbiAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIF9mblN0YXJ0KCBvU2V0dGluZ3MgKVxue1xuXHR2YXIgYlNlcnZlclNpZGUgPSBfZm5EYXRhU291cmNlKCBvU2V0dGluZ3MgKSA9PSAnc3NwJztcblx0dmFyIGlJbml0RGlzcGxheVN0YXJ0ID0gb1NldHRpbmdzLmlJbml0RGlzcGxheVN0YXJ0O1xuXG5cdC8vIENoZWNrIGFuZCBzZWUgaWYgd2UgaGF2ZSBhbiBpbml0aWFsIGRyYXcgcG9zaXRpb24gZnJvbSBzdGF0ZSBzYXZpbmdcblx0aWYgKCBpSW5pdERpc3BsYXlTdGFydCAhPT0gdW5kZWZpbmVkICYmIGlJbml0RGlzcGxheVN0YXJ0ICE9PSAtMSApXG5cdHtcblx0XHRvU2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQgPSBiU2VydmVyU2lkZSA/XG5cdFx0XHRpSW5pdERpc3BsYXlTdGFydCA6XG5cdFx0XHRpSW5pdERpc3BsYXlTdGFydCA+PSBvU2V0dGluZ3MuZm5SZWNvcmRzRGlzcGxheSgpID9cblx0XHRcdFx0MCA6XG5cdFx0XHRcdGlJbml0RGlzcGxheVN0YXJ0O1xuXG5cdFx0b1NldHRpbmdzLmlJbml0RGlzcGxheVN0YXJ0ID0gLTE7XG5cdH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gQWpheCBjYWxsIGJhc2VkIG9uIHRoZSB0YWJsZSdzIHNldHRpbmdzLCB0YWtpbmcgaW50byBhY2NvdW50IHRoYXRcbiAqIHBhcmFtZXRlcnMgY2FuIGhhdmUgbXVsdGlwbGUgZm9ybXMsIGFuZCBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiBAcGFyYW0ge2FycmF5fSBkYXRhIERhdGEgdG8gc2VuZCB0byB0aGUgc2VydmVyLCByZXF1aXJlZCBieVxuICogICAgIERhdGFUYWJsZXMgLSBtYXkgYmUgYXVnbWVudGVkIGJ5IGRldmVsb3BlciBjYWxsYmFja3NcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIENhbGxiYWNrIGZ1bmN0aW9uIHRvIHJ1biB3aGVuIGRhdGEgaXMgb2J0YWluZWRcbiAqL1xuZnVuY3Rpb24gX2ZuQnVpbGRBamF4KCBvU2V0dGluZ3MsIGRhdGEsIGZuIClcbntcblx0dmFyIGFqYXhEYXRhO1xuXHR2YXIgYWpheCA9IG9TZXR0aW5ncy5hamF4O1xuXHR2YXIgaW5zdGFuY2UgPSBvU2V0dGluZ3Mub0luc3RhbmNlO1xuXHR2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiAoIGpzb24gKSB7XG5cdFx0dmFyIHN0YXR1cyA9IG9TZXR0aW5ncy5qcVhIUlxuXHRcdFx0PyBvU2V0dGluZ3MuanFYSFIuc3RhdHVzXG5cdFx0XHQ6IG51bGw7XG5cblx0XHRpZiAoIGpzb24gPT09IG51bGwgfHwgKHR5cGVvZiBzdGF0dXMgPT09ICdudW1iZXInICYmIHN0YXR1cyA9PSAyMDQgKSApIHtcblx0XHRcdGpzb24gPSB7fTtcblx0XHRcdF9mbkFqYXhEYXRhU3JjKCBvU2V0dGluZ3MsIGpzb24sIFtdICk7XG5cdFx0fVxuXG5cdFx0dmFyIGVycm9yID0ganNvbi5lcnJvciB8fCBqc29uLnNFcnJvcjtcblx0XHRpZiAoIGVycm9yICkge1xuXHRcdFx0X2ZuTG9nKCBvU2V0dGluZ3MsIDAsIGVycm9yICk7XG5cdFx0fVxuXG5cdFx0Ly8gTWljcm9zb2Z0IG9mdGVuIHdyYXAgSlNPTiBhcyBhIHN0cmluZyBpbiBhbm90aGVyIEpTT04gb2JqZWN0XG5cdFx0Ly8gTGV0J3MgaGFuZGxlIHRoYXQgYXV0b21hdGljYWxseVxuXHRcdGlmIChqc29uLmQgJiYgdHlwZW9mIGpzb24uZCA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGpzb24gPSBKU09OLnBhcnNlKGpzb24uZCk7XG5cdFx0XHR9XG5cdFx0XHRjYXRjaCAoZSkge1xuXHRcdFx0XHQvLyBub29wXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0b1NldHRpbmdzLmpzb24gPSBqc29uO1xuXG5cdFx0X2ZuQ2FsbGJhY2tGaXJlKCBvU2V0dGluZ3MsIG51bGwsICd4aHInLCBbb1NldHRpbmdzLCBqc29uLCBvU2V0dGluZ3MuanFYSFJdLCB0cnVlICk7XG5cdFx0Zm4oIGpzb24gKTtcblx0fTtcblxuXHRpZiAoICQuaXNQbGFpbk9iamVjdCggYWpheCApICYmIGFqYXguZGF0YSApXG5cdHtcblx0XHRhamF4RGF0YSA9IGFqYXguZGF0YTtcblxuXHRcdHZhciBuZXdEYXRhID0gdHlwZW9mIGFqYXhEYXRhID09PSAnZnVuY3Rpb24nID9cblx0XHRcdGFqYXhEYXRhKCBkYXRhLCBvU2V0dGluZ3MgKSA6ICAvLyBmbiBjYW4gbWFuaXB1bGF0ZSBkYXRhIG9yIHJldHVyblxuXHRcdFx0YWpheERhdGE7ICAgICAgICAgICAgICAgICAgICAgIC8vIGFuIG9iamVjdCBvYmplY3Qgb3IgYXJyYXkgdG8gbWVyZ2VcblxuXHRcdC8vIElmIHRoZSBmdW5jdGlvbiByZXR1cm5lZCBzb21ldGhpbmcsIHVzZSB0aGF0IGFsb25lXG5cdFx0ZGF0YSA9IHR5cGVvZiBhamF4RGF0YSA9PT0gJ2Z1bmN0aW9uJyAmJiBuZXdEYXRhID9cblx0XHRcdG5ld0RhdGEgOlxuXHRcdFx0JC5leHRlbmQoIHRydWUsIGRhdGEsIG5ld0RhdGEgKTtcblxuXHRcdC8vIFJlbW92ZSB0aGUgZGF0YSBwcm9wZXJ0eSBhcyB3ZSd2ZSByZXNvbHZlZCBpdCBhbHJlYWR5IGFuZCBkb24ndCB3YW50XG5cdFx0Ly8galF1ZXJ5IHRvIGRvIGl0IGFnYWluIChpdCBpcyByZXN0b3JlZCBhdCB0aGUgZW5kIG9mIHRoZSBmdW5jdGlvbilcblx0XHRkZWxldGUgYWpheC5kYXRhO1xuXHR9XG5cblx0dmFyIGJhc2VBamF4ID0ge1xuXHRcdFwidXJsXCI6IHR5cGVvZiBhamF4ID09PSAnc3RyaW5nJyA/XG5cdFx0XHRhamF4IDpcblx0XHRcdCcnLFxuXHRcdFwiZGF0YVwiOiBkYXRhLFxuXHRcdFwic3VjY2Vzc1wiOiBjYWxsYmFjayxcblx0XHRcImRhdGFUeXBlXCI6IFwianNvblwiLFxuXHRcdFwiY2FjaGVcIjogZmFsc2UsXG5cdFx0XCJ0eXBlXCI6IG9TZXR0aW5ncy5zU2VydmVyTWV0aG9kLFxuXHRcdFwiZXJyb3JcIjogZnVuY3Rpb24gKHhociwgZXJyb3IpIHtcblx0XHRcdHZhciByZXQgPSBfZm5DYWxsYmFja0ZpcmUoIG9TZXR0aW5ncywgbnVsbCwgJ3hocicsIFtvU2V0dGluZ3MsIG51bGwsIG9TZXR0aW5ncy5qcVhIUl0sIHRydWUgKTtcblxuXHRcdFx0aWYgKCByZXQuaW5kZXhPZih0cnVlKSA9PT0gLTEgKSB7XG5cdFx0XHRcdGlmICggZXJyb3IgPT0gXCJwYXJzZXJlcnJvclwiICkge1xuXHRcdFx0XHRcdF9mbkxvZyggb1NldHRpbmdzLCAwLCAnSW52YWxpZCBKU09OIHJlc3BvbnNlJywgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgaWYgKCB4aHIucmVhZHlTdGF0ZSA9PT0gNCApIHtcblx0XHRcdFx0XHRfZm5Mb2coIG9TZXR0aW5ncywgMCwgJ0FqYXggZXJyb3InLCA3ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0X2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoIG9TZXR0aW5ncywgZmFsc2UgKTtcblx0XHR9XG5cdH07XG5cblx0Ly8gSWYgYGFqYXhgIG9wdGlvbiBpcyBhbiBvYmplY3QsIGV4dGVuZCBhbmQgb3ZlcnJpZGUgb3VyIGRlZmF1bHQgYmFzZVxuXHRpZiAoICQuaXNQbGFpbk9iamVjdCggYWpheCApICkge1xuXHRcdCQuZXh0ZW5kKCBiYXNlQWpheCwgYWpheCApXG5cdH1cblxuXHQvLyBTdG9yZSB0aGUgZGF0YSBzdWJtaXR0ZWQgZm9yIHRoZSBBUElcblx0b1NldHRpbmdzLm9BamF4RGF0YSA9IGRhdGE7XG5cblx0Ly8gQWxsb3cgcGx1Zy1pbnMgYW5kIGV4dGVybmFsIHByb2Nlc3NlcyB0byBtb2RpZnkgdGhlIGRhdGFcblx0X2ZuQ2FsbGJhY2tGaXJlKCBvU2V0dGluZ3MsIG51bGwsICdwcmVYaHInLCBbb1NldHRpbmdzLCBkYXRhLCBiYXNlQWpheF0sIHRydWUgKTtcblxuXHQvLyBDdXN0b20gQWpheCBvcHRpb24gdG8gc3VibWl0IHRoZSBwYXJhbWV0ZXJzIGFzIGEgSlNPTiBzdHJpbmdcblx0aWYgKGJhc2VBamF4LnN1Ym1pdEFzID09PSAnanNvbicgJiYgdHlwZW9mIGRhdGEgPT09ICdvYmplY3QnKSB7XG5cdFx0YmFzZUFqYXguZGF0YSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuXHR9XG5cblx0aWYgKCB0eXBlb2YgYWpheCA9PT0gJ2Z1bmN0aW9uJyApXG5cdHtcblx0XHQvLyBJcyBhIGZ1bmN0aW9uIC0gbGV0IHRoZSBjYWxsZXIgZGVmaW5lIHdoYXQgbmVlZHMgdG8gYmUgZG9uZVxuXHRcdG9TZXR0aW5ncy5qcVhIUiA9IGFqYXguY2FsbCggaW5zdGFuY2UsIGRhdGEsIGNhbGxiYWNrLCBvU2V0dGluZ3MgKTtcblx0fVxuXHRlbHNlIGlmIChhamF4LnVybCA9PT0gJycpIHtcblx0XHQvLyBObyB1cmwsIHNvIGRvbid0IGxvYWQgYW55IGRhdGEuIEp1c3QgYXBwbHkgYW4gZW1wdHkgZGF0YSBhcnJheVxuXHRcdC8vIHRvIHRoZSBvYmplY3QgZm9yIHRoZSBjYWxsYmFjay5cblx0XHR2YXIgZW1wdHkgPSB7fTtcblxuXHRcdERhdGFUYWJsZS51dGlsLnNldChhamF4LmRhdGFTcmMpKGVtcHR5LCBbXSk7XG5cdFx0Y2FsbGJhY2soZW1wdHkpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIE9iamVjdCB0byBleHRlbmQgdGhlIGJhc2Ugc2V0dGluZ3Ncblx0XHRvU2V0dGluZ3MuanFYSFIgPSAkLmFqYXgoIGJhc2VBamF4ICk7XG5cdH1cblxuXHQvLyBSZXN0b3JlIGZvciBuZXh0IHRpbWUgYXJvdW5kXG5cdGlmICggYWpheERhdGEgKSB7XG5cdFx0YWpheC5kYXRhID0gYWpheERhdGE7XG5cdH1cbn1cblxuXG4vKipcbiAqIFVwZGF0ZSB0aGUgdGFibGUgdXNpbmcgYW4gQWpheCBjYWxsXG4gKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQHJldHVybnMge2Jvb2xlYW59IEJsb2NrIHRoZSB0YWJsZSBkcmF3aW5nIG9yIG5vdFxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5BamF4VXBkYXRlKCBzZXR0aW5ncyApXG57XG5cdHNldHRpbmdzLmlEcmF3Kys7XG5cdF9mblByb2Nlc3NpbmdEaXNwbGF5KCBzZXR0aW5ncywgdHJ1ZSApO1xuXG5cdF9mbkJ1aWxkQWpheChcblx0XHRzZXR0aW5ncyxcblx0XHRfZm5BamF4UGFyYW1ldGVycyggc2V0dGluZ3MgKSxcblx0XHRmdW5jdGlvbihqc29uKSB7XG5cdFx0XHRfZm5BamF4VXBkYXRlRHJhdyggc2V0dGluZ3MsIGpzb24gKTtcblx0XHR9XG5cdCk7XG59XG5cblxuLyoqXG4gKiBCdWlsZCB1cCB0aGUgcGFyYW1ldGVycyBpbiBhbiBvYmplY3QgbmVlZGVkIGZvciBhIHNlcnZlci1zaWRlIHByb2Nlc3NpbmdcbiAqIHJlcXVlc3QuXG4gKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEByZXR1cm5zIHtib29sfSBibG9jayB0aGUgdGFibGUgZHJhd2luZyBvciBub3RcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuQWpheFBhcmFtZXRlcnMoIHNldHRpbmdzIClcbntcblx0dmFyXG5cdFx0Y29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucyxcblx0XHRmZWF0dXJlcyA9IHNldHRpbmdzLm9GZWF0dXJlcyxcblx0XHRwcmVTZWFyY2ggPSBzZXR0aW5ncy5vUHJldmlvdXNTZWFyY2gsXG5cdFx0cHJlQ29sU2VhcmNoID0gc2V0dGluZ3MuYW9QcmVTZWFyY2hDb2xzLFxuXHRcdGNvbERhdGEgPSBmdW5jdGlvbiAoIGlkeCwgcHJvcCApIHtcblx0XHRcdHJldHVybiB0eXBlb2YgY29sdW1uc1tpZHhdW3Byb3BdID09PSAnZnVuY3Rpb24nID9cblx0XHRcdFx0J2Z1bmN0aW9uJyA6XG5cdFx0XHRcdGNvbHVtbnNbaWR4XVtwcm9wXTtcblx0XHR9O1xuXG5cdHJldHVybiB7XG5cdFx0ZHJhdzogc2V0dGluZ3MuaURyYXcsXG5cdFx0Y29sdW1uczogY29sdW1ucy5tYXAoIGZ1bmN0aW9uICggY29sdW1uLCBpICkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogY29sRGF0YShpLCAnbURhdGEnKSxcblx0XHRcdFx0bmFtZTogY29sdW1uLnNOYW1lLFxuXHRcdFx0XHRzZWFyY2hhYmxlOiBjb2x1bW4uYlNlYXJjaGFibGUsXG5cdFx0XHRcdG9yZGVyYWJsZTogY29sdW1uLmJTb3J0YWJsZSxcblx0XHRcdFx0c2VhcmNoOiB7XG5cdFx0XHRcdFx0dmFsdWU6IHByZUNvbFNlYXJjaFtpXS5zZWFyY2gsXG5cdFx0XHRcdFx0cmVnZXg6IHByZUNvbFNlYXJjaFtpXS5yZWdleCxcblx0XHRcdFx0XHRmaXhlZDogT2JqZWN0LmtleXMoY29sdW1uLnNlYXJjaEZpeGVkKS5tYXAoIGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdG5hbWU6IG5hbWUsXG5cdFx0XHRcdFx0XHRcdHRlcm06IGNvbHVtbi5zZWFyY2hGaXhlZFtuYW1lXS50b1N0cmluZygpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9ICksXG5cdFx0b3JkZXI6IF9mblNvcnRGbGF0dGVuKCBzZXR0aW5ncyApLm1hcCggZnVuY3Rpb24gKCB2YWwgKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRjb2x1bW46IHZhbC5jb2wsXG5cdFx0XHRcdGRpcjogdmFsLmRpcixcblx0XHRcdFx0bmFtZTogY29sRGF0YSh2YWwuY29sLCAnc05hbWUnKVxuXHRcdFx0fTtcblx0XHR9ICksXG5cdFx0c3RhcnQ6IHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0LFxuXHRcdGxlbmd0aDogZmVhdHVyZXMuYlBhZ2luYXRlID9cblx0XHRcdHNldHRpbmdzLl9pRGlzcGxheUxlbmd0aCA6XG5cdFx0XHQtMSxcblx0XHRzZWFyY2g6IHtcblx0XHRcdHZhbHVlOiBwcmVTZWFyY2guc2VhcmNoLFxuXHRcdFx0cmVnZXg6IHByZVNlYXJjaC5yZWdleCxcblx0XHRcdGZpeGVkOiBPYmplY3Qua2V5cyhzZXR0aW5ncy5zZWFyY2hGaXhlZCkubWFwKCBmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0bmFtZTogbmFtZSxcblx0XHRcdFx0XHR0ZXJtOiBzZXR0aW5ncy5zZWFyY2hGaXhlZFtuYW1lXS50b1N0cmluZygpXG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cdFx0fVxuXHR9O1xufVxuXG5cbi8qKlxuICogRGF0YSB0aGUgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIgKG51a2luZyB0aGUgb2xkKSBhbmQgcmVkcmF3IHRoZSB0YWJsZVxuICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAcGFyYW0ge29iamVjdH0ganNvbiBqc29uIGRhdGEgcmV0dXJuIGZyb20gdGhlIHNlcnZlci5cbiAqICBAcGFyYW0ge3N0cmluZ30ganNvbi5zRWNobyBUcmFja2luZyBmbGFnIGZvciBEYXRhVGFibGVzIHRvIG1hdGNoIHJlcXVlc3RzXG4gKiAgQHBhcmFtIHtpbnR9IGpzb24uaVRvdGFsUmVjb3JkcyBOdW1iZXIgb2YgcmVjb3JkcyBpbiB0aGUgZGF0YSBzZXQsIG5vdCBhY2NvdW50aW5nIGZvciBmaWx0ZXJpbmdcbiAqICBAcGFyYW0ge2ludH0ganNvbi5pVG90YWxEaXNwbGF5UmVjb3JkcyBOdW1iZXIgb2YgcmVjb3JkcyBpbiB0aGUgZGF0YSBzZXQsIGFjY291bnRpbmcgZm9yIGZpbHRlcmluZ1xuICogIEBwYXJhbSB7YXJyYXl9IGpzb24uYWFEYXRhIFRoZSBkYXRhIHRvIGRpc3BsYXkgb24gdGhpcyBwYWdlXG4gKiAgQHBhcmFtIHtzdHJpbmd9IFtqc29uLnNDb2x1bW5zXSBDb2x1bW4gb3JkZXJpbmcgKHNOYW1lLCBjb21tYSBzZXBhcmF0ZWQpXG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkFqYXhVcGRhdGVEcmF3ICggc2V0dGluZ3MsIGpzb24gKVxue1xuXHR2YXIgZGF0YSA9IF9mbkFqYXhEYXRhU3JjKHNldHRpbmdzLCBqc29uKTtcblx0dmFyIGRyYXcgPSBfZm5BamF4RGF0YVNyY1BhcmFtKHNldHRpbmdzLCAnZHJhdycsIGpzb24pO1xuXHR2YXIgcmVjb3Jkc1RvdGFsID0gX2ZuQWpheERhdGFTcmNQYXJhbShzZXR0aW5ncywgJ3JlY29yZHNUb3RhbCcsIGpzb24pO1xuXHR2YXIgcmVjb3Jkc0ZpbHRlcmVkID0gX2ZuQWpheERhdGFTcmNQYXJhbShzZXR0aW5ncywgJ3JlY29yZHNGaWx0ZXJlZCcsIGpzb24pO1xuXG5cdGlmICggZHJhdyAhPT0gdW5kZWZpbmVkICkge1xuXHRcdC8vIFByb3RlY3QgYWdhaW5zdCBvdXQgb2Ygc2VxdWVuY2UgcmV0dXJuc1xuXHRcdGlmICggZHJhdyoxIDwgc2V0dGluZ3MuaURyYXcgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHNldHRpbmdzLmlEcmF3ID0gZHJhdyAqIDE7XG5cdH1cblxuXHQvLyBObyBkYXRhIGluIHJldHVybmVkIG9iamVjdCwgc28gcmF0aGVyIHRoYW4gYW4gYXJyYXksIHdlIHNob3cgYW4gZW1wdHkgdGFibGVcblx0aWYgKCAhIGRhdGEgKSB7XG5cdFx0ZGF0YSA9IFtdO1xuXHR9XG5cblx0X2ZuQ2xlYXJUYWJsZSggc2V0dGluZ3MgKTtcblx0c2V0dGluZ3MuX2lSZWNvcmRzVG90YWwgICA9IHBhcnNlSW50KHJlY29yZHNUb3RhbCwgMTApO1xuXHRzZXR0aW5ncy5faVJlY29yZHNEaXNwbGF5ID0gcGFyc2VJbnQocmVjb3Jkc0ZpbHRlcmVkLCAxMCk7XG5cblx0Zm9yICggdmFyIGk9MCwgaWVuPWRhdGEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0X2ZuQWRkRGF0YSggc2V0dGluZ3MsIGRhdGFbaV0gKTtcblx0fVxuXHRzZXR0aW5ncy5haURpc3BsYXkgPSBzZXR0aW5ncy5haURpc3BsYXlNYXN0ZXIuc2xpY2UoKTtcblxuXHRfZm5Db2x1bW5UeXBlcyhzZXR0aW5ncyk7XG5cdF9mbkRyYXcoIHNldHRpbmdzLCB0cnVlICk7XG5cdF9mbkluaXRDb21wbGV0ZSggc2V0dGluZ3MgKTtcblx0X2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoIHNldHRpbmdzLCBmYWxzZSApO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSBkYXRhIGZyb20gdGhlIEpTT04gZGF0YSBzb3VyY2UgdG8gdXNlIGZvciBkcmF3aW5nIGEgdGFibGUuIFVzaW5nXG4gKiBgX2ZuR2V0T2JqZWN0RGF0YUZuYCBhbGxvd3MgdGhlIGRhdGEgdG8gYmUgc291cmNlZCBmcm9tIGEgcHJvcGVydHkgb2YgdGhlXG4gKiBzb3VyY2Ugb2JqZWN0LCBvciBmcm9tIGEgcHJvY2Vzc2luZyBmdW5jdGlvbi5cbiAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAcGFyYW0gIHtvYmplY3R9IGpzb24gRGF0YSBzb3VyY2Ugb2JqZWN0IC8gYXJyYXkgZnJvbSB0aGUgc2VydmVyXG4gKiAgQHJldHVybiB7YXJyYXl9IEFycmF5IG9mIGRhdGEgdG8gdXNlXG4gKi9cbmZ1bmN0aW9uIF9mbkFqYXhEYXRhU3JjICggc2V0dGluZ3MsIGpzb24sIHdyaXRlIClcbntcblx0dmFyIGRhdGFQcm9wID0gJ2RhdGEnO1xuXG5cdGlmICgkLmlzUGxhaW5PYmplY3QoIHNldHRpbmdzLmFqYXggKSAmJiBzZXR0aW5ncy5hamF4LmRhdGFTcmMgIT09IHVuZGVmaW5lZCkge1xuXHRcdC8vIENvdWxkIGluIGluc2lkZSBhIGBkYXRhU3JjYCBvYmplY3QsIG9yIG5vdCFcblx0XHR2YXIgZGF0YVNyYyA9IHNldHRpbmdzLmFqYXguZGF0YVNyYztcblxuXHRcdC8vIHN0cmluZywgZnVuY3Rpb24gYW5kIG9iamVjdCBhcmUgdmFsaWQgdHlwZXNcblx0XHRpZiAodHlwZW9mIGRhdGFTcmMgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBkYXRhU3JjID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRkYXRhUHJvcCA9IGRhdGFTcmM7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKGRhdGFTcmMuZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRkYXRhUHJvcCA9IGRhdGFTcmMuZGF0YTtcblx0XHR9XG5cdH1cblxuXHRpZiAoICEgd3JpdGUgKSB7XG5cdFx0aWYgKCBkYXRhUHJvcCA9PT0gJ2RhdGEnICkge1xuXHRcdFx0Ly8gSWYgdGhlIGRlZmF1bHQsIHRoZW4gd2Ugc3RpbGwgd2FudCB0byBzdXBwb3J0IHRoZSBvbGQgc3R5bGUsIGFuZCBzYWZlbHkgaWdub3JlXG5cdFx0XHQvLyBpdCBpZiBwb3NzaWJsZVxuXHRcdFx0cmV0dXJuIGpzb24uYWFEYXRhIHx8IGpzb25bZGF0YVByb3BdO1xuXHRcdH1cblxuXHRcdHJldHVybiBkYXRhUHJvcCAhPT0gXCJcIiA/XG5cdFx0XHRfZm5HZXRPYmplY3REYXRhRm4oIGRhdGFQcm9wICkoIGpzb24gKSA6XG5cdFx0XHRqc29uO1xuXHR9XG5cdFxuXHQvLyBzZXRcblx0X2ZuU2V0T2JqZWN0RGF0YUZuKCBkYXRhUHJvcCApKCBqc29uLCB3cml0ZSApO1xufVxuXG4vKipcbiAqIFZlcnkgc2ltaWxhciB0byBfZm5BamF4RGF0YVNyYywgYnV0IGZvciB0aGUgb3RoZXIgU1NQIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7Kn0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqIEBwYXJhbSB7Kn0gcGFyYW0gVGFyZ2V0IHBhcmFtZXRlclxuICogQHBhcmFtIHsqfSBqc29uIEpTT04gZGF0YVxuICogQHJldHVybnMgUmVzb2x2ZWQgdmFsdWVcbiAqL1xuZnVuY3Rpb24gX2ZuQWpheERhdGFTcmNQYXJhbSAoc2V0dGluZ3MsIHBhcmFtLCBqc29uKSB7XG5cdHZhciBkYXRhU3JjID0gJC5pc1BsYWluT2JqZWN0KCBzZXR0aW5ncy5hamF4IClcblx0XHQ/IHNldHRpbmdzLmFqYXguZGF0YVNyY1xuXHRcdDogbnVsbDtcblxuXHRpZiAoZGF0YVNyYyAmJiBkYXRhU3JjW3BhcmFtXSkge1xuXHRcdC8vIEdldCBmcm9tIGN1c3RvbSBsb2NhdGlvblxuXHRcdHJldHVybiBfZm5HZXRPYmplY3REYXRhRm4oIGRhdGFTcmNbcGFyYW1dICkoIGpzb24gKTtcblx0fVxuXG5cdC8vIGVsc2UgLSBEZWZhdWx0IGJlaGF2aW91clxuXHR2YXIgb2xkID0gJyc7XG5cblx0Ly8gTGVnYWN5IHN1cHBvcnRcblx0aWYgKHBhcmFtID09PSAnZHJhdycpIHtcblx0XHRvbGQgPSAnc0VjaG8nO1xuXHR9XG5cdGVsc2UgaWYgKHBhcmFtID09PSAncmVjb3Jkc1RvdGFsJykge1xuXHRcdG9sZCA9ICdpVG90YWxSZWNvcmRzJztcblx0fVxuXHRlbHNlIGlmIChwYXJhbSA9PT0gJ3JlY29yZHNGaWx0ZXJlZCcpIHtcblx0XHRvbGQgPSAnaVRvdGFsRGlzcGxheVJlY29yZHMnO1xuXHR9XG5cblx0cmV0dXJuIGpzb25bb2xkXSAhPT0gdW5kZWZpbmVkXG5cdFx0PyBqc29uW29sZF1cblx0XHQ6IGpzb25bcGFyYW1dO1xufVxuXG5cbi8qKlxuICogRmlsdGVyIHRoZSB0YWJsZSB1c2luZyBib3RoIHRoZSBnbG9iYWwgZmlsdGVyIGFuZCBjb2x1bW4gYmFzZWQgZmlsdGVyaW5nXG4gKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQHBhcmFtIHtvYmplY3R9IGlucHV0IHNlYXJjaCBpbmZvcm1hdGlvblxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5GaWx0ZXJDb21wbGV0ZSAoIHNldHRpbmdzLCBpbnB1dCApXG57XG5cdHZhciBjb2x1bW5zU2VhcmNoID0gc2V0dGluZ3MuYW9QcmVTZWFyY2hDb2xzO1xuXG5cdC8vIEluIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcgYWxsIGZpbHRlcmluZyBpcyBkb25lIGJ5IHRoZSBzZXJ2ZXIsIHNvIG5vIHBvaW50IGhhbmdpbmcgYXJvdW5kIGhlcmVcblx0aWYgKCBfZm5EYXRhU291cmNlKCBzZXR0aW5ncyApICE9ICdzc3AnIClcblx0e1xuXHRcdC8vIENoZWNrIGlmIGFueSBvZiB0aGUgcm93cyB3ZXJlIGludmFsaWRhdGVkXG5cdFx0X2ZuRmlsdGVyRGF0YSggc2V0dGluZ3MgKTtcblxuXHRcdC8vIFN0YXJ0IGZyb20gdGhlIGZ1bGwgZGF0YSBzZXRcblx0XHRzZXR0aW5ncy5haURpc3BsYXkgPSBzZXR0aW5ncy5haURpc3BsYXlNYXN0ZXIuc2xpY2UoKTtcblxuXHRcdC8vIEdsb2JhbCBmaWx0ZXIgZmlyc3Rcblx0XHRfZm5GaWx0ZXIoIHNldHRpbmdzLmFpRGlzcGxheSwgc2V0dGluZ3MsIGlucHV0LnNlYXJjaCwgaW5wdXQgKTtcblxuXHRcdCQuZWFjaChzZXR0aW5ncy5zZWFyY2hGaXhlZCwgZnVuY3Rpb24gKG5hbWUsIHRlcm0pIHtcblx0XHRcdF9mbkZpbHRlcihzZXR0aW5ncy5haURpc3BsYXksIHNldHRpbmdzLCB0ZXJtLCB7fSk7XG5cdFx0fSk7XG5cblx0XHQvLyBUaGVuIGluZGl2aWR1YWwgY29sdW1uIGZpbHRlcnNcblx0XHRmb3IgKCB2YXIgaT0wIDsgaTxjb2x1bW5zU2VhcmNoLmxlbmd0aCA7IGkrKyApXG5cdFx0e1xuXHRcdFx0dmFyIGNvbCA9IGNvbHVtbnNTZWFyY2hbaV07XG5cblx0XHRcdF9mbkZpbHRlcihcblx0XHRcdFx0c2V0dGluZ3MuYWlEaXNwbGF5LFxuXHRcdFx0XHRzZXR0aW5ncyxcblx0XHRcdFx0Y29sLnNlYXJjaCxcblx0XHRcdFx0Y29sLFxuXHRcdFx0XHRpXG5cdFx0XHQpO1xuXG5cdFx0XHQkLmVhY2goc2V0dGluZ3MuYW9Db2x1bW5zW2ldLnNlYXJjaEZpeGVkLCBmdW5jdGlvbiAobmFtZSwgdGVybSkge1xuXHRcdFx0XHRfZm5GaWx0ZXIoc2V0dGluZ3MuYWlEaXNwbGF5LCBzZXR0aW5ncywgdGVybSwge30sIGkpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0Ly8gQW5kIGZpbmFsbHkgZ2xvYmFsIGZpbHRlcmluZ1xuXHRcdF9mbkZpbHRlckN1c3RvbSggc2V0dGluZ3MgKTtcblx0fVxuXG5cdC8vIFRlbGwgdGhlIGRyYXcgZnVuY3Rpb24gd2UgaGF2ZSBiZWVuIGZpbHRlcmluZ1xuXHRzZXR0aW5ncy5iRmlsdGVyZWQgPSB0cnVlO1xuXG5cdF9mbkNhbGxiYWNrRmlyZSggc2V0dGluZ3MsIG51bGwsICdzZWFyY2gnLCBbc2V0dGluZ3NdICk7XG59XG5cblxuLyoqXG4gKiBBcHBseSBjdXN0b20gZmlsdGVyaW5nIGZ1bmN0aW9uc1xuICogXG4gKiBUaGlzIGlzIGxlZ2FjeSBub3cgdGhhdCB3ZSBoYXZlIG5hbWVkIGZ1bmN0aW9ucywgYnV0IGl0IGlzIHdpZGVseSB1c2VkXG4gKiBmcm9tIDEueCwgc28gaXQgaXMgbm90IHlldCBkZXByZWNhdGVkLlxuICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuRmlsdGVyQ3VzdG9tKCBzZXR0aW5ncyApXG57XG5cdHZhciBmaWx0ZXJzID0gRGF0YVRhYmxlLmV4dC5zZWFyY2g7XG5cdHZhciBkaXNwbGF5Um93cyA9IHNldHRpbmdzLmFpRGlzcGxheTtcblx0dmFyIHJvdywgcm93SWR4O1xuXG5cdGZvciAoIHZhciBpPTAsIGllbj1maWx0ZXJzLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdHZhciByb3dzID0gW107XG5cblx0XHQvLyBMb29wIG92ZXIgZWFjaCByb3cgYW5kIHNlZSBpZiBpdCBzaG91bGQgYmUgaW5jbHVkZWRcblx0XHRmb3IgKCB2YXIgaj0wLCBqZW49ZGlzcGxheVJvd3MubGVuZ3RoIDsgajxqZW4gOyBqKysgKSB7XG5cdFx0XHRyb3dJZHggPSBkaXNwbGF5Um93c1sgaiBdO1xuXHRcdFx0cm93ID0gc2V0dGluZ3MuYW9EYXRhWyByb3dJZHggXTtcblxuXHRcdFx0aWYgKCBmaWx0ZXJzW2ldKCBzZXR0aW5ncywgcm93Ll9hRmlsdGVyRGF0YSwgcm93SWR4LCByb3cuX2FEYXRhLCBqICkgKSB7XG5cdFx0XHRcdHJvd3MucHVzaCggcm93SWR4ICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU28gdGhlIGFycmF5IHJlZmVyZW5jZSBkb2Vzbid0IGJyZWFrIHNldCB0aGUgcmVzdWx0cyBpbnRvIHRoZVxuXHRcdC8vIGV4aXN0aW5nIGFycmF5XG5cdFx0ZGlzcGxheVJvd3MubGVuZ3RoID0gMDtcblx0XHRfZm5BcnJheUFwcGx5KGRpc3BsYXlSb3dzLCByb3dzKTtcblx0fVxufVxuXG5cbi8qKlxuICogRmlsdGVyIHRoZSBkYXRhIHRhYmxlIGJhc2VkIG9uIHVzZXIgaW5wdXQgYW5kIGRyYXcgdGhlIHRhYmxlXG4gKi9cbmZ1bmN0aW9uIF9mbkZpbHRlciggc2VhcmNoUm93cywgc2V0dGluZ3MsIGlucHV0LCBvcHRpb25zLCBjb2x1bW4gKVxue1xuXHRpZiAoIGlucHV0ID09PSAnJyApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHR2YXIgaSA9IDA7XG5cdHZhciBtYXRjaGVkID0gW107XG5cblx0Ly8gU2VhcmNoIHRlcm0gY2FuIGJlIGEgZnVuY3Rpb24sIHJlZ2V4IG9yIHN0cmluZyAtIGlmIGEgc3RyaW5nIHdlIGFwcGx5IG91clxuXHQvLyBzbWFydCBmaWx0ZXJpbmcgcmVnZXggKGFzc3VtaW5nIHRoZSBvcHRpb25zIHJlcXVpcmUgdGhhdClcblx0dmFyIHNlYXJjaEZ1bmMgPSB0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbicgPyBpbnB1dCA6IG51bGw7XG5cdHZhciBycFNlYXJjaCA9IGlucHV0IGluc3RhbmNlb2YgUmVnRXhwXG5cdFx0PyBpbnB1dFxuXHRcdDogc2VhcmNoRnVuY1xuXHRcdFx0PyBudWxsXG5cdFx0XHQ6IF9mbkZpbHRlckNyZWF0ZVNlYXJjaCggaW5wdXQsIG9wdGlvbnMgKTtcblxuXHQvLyBUaGVuIGZvciBlYWNoIHJvdywgZG9lcyB0aGUgdGVzdCBwYXNzLiBJZiBub3QsIGxvcCB0aGUgcm93IGZyb20gdGhlIGFycmF5XG5cdGZvciAoaT0wIDsgaTxzZWFyY2hSb3dzLmxlbmd0aCA7IGkrKykge1xuXHRcdHZhciByb3cgPSBzZXR0aW5ncy5hb0RhdGFbIHNlYXJjaFJvd3NbaV0gXTtcblx0XHR2YXIgZGF0YSA9IGNvbHVtbiA9PT0gdW5kZWZpbmVkXG5cdFx0XHQ/IHJvdy5fc0ZpbHRlclJvd1xuXHRcdFx0OiByb3cuX2FGaWx0ZXJEYXRhWyBjb2x1bW4gXTtcblxuXHRcdGlmICggKHNlYXJjaEZ1bmMgJiYgc2VhcmNoRnVuYyhkYXRhLCByb3cuX2FEYXRhLCBzZWFyY2hSb3dzW2ldLCBjb2x1bW4pKSB8fCAocnBTZWFyY2ggJiYgcnBTZWFyY2gudGVzdChkYXRhKSkgKSB7XG5cdFx0XHRtYXRjaGVkLnB1c2goc2VhcmNoUm93c1tpXSk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gTXV0YXRlIHRoZSBzZWFyY2hSb3dzIGFycmF5XG5cdHNlYXJjaFJvd3MubGVuZ3RoID0gbWF0Y2hlZC5sZW5ndGg7XG5cblx0Zm9yIChpPTAgOyBpPG1hdGNoZWQubGVuZ3RoIDsgaSsrKSB7XG5cdFx0c2VhcmNoUm93c1tpXSA9IG1hdGNoZWRbaV07XG5cdH1cbn1cblxuXG4vKipcbiAqIEJ1aWxkIGEgcmVndWxhciBleHByZXNzaW9uIG9iamVjdCBzdWl0YWJsZSBmb3Igc2VhcmNoaW5nIGEgdGFibGVcbiAqICBAcGFyYW0ge3N0cmluZ30gc1NlYXJjaCBzdHJpbmcgdG8gc2VhcmNoIGZvclxuICogIEBwYXJhbSB7Ym9vbH0gYlJlZ2V4IHRyZWF0IGFzIGEgcmVndWxhciBleHByZXNzaW9uIG9yIG5vdFxuICogIEBwYXJhbSB7Ym9vbH0gYlNtYXJ0IHBlcmZvcm0gc21hcnQgZmlsdGVyaW5nIG9yIG5vdFxuICogIEBwYXJhbSB7Ym9vbH0gYkNhc2VJbnNlbnNpdGl2ZSBEbyBjYXNlIGluc2Vuc2l0aXZlIG1hdGNoaW5nIG9yIG5vdFxuICogIEByZXR1cm5zIHtSZWdFeHB9IGNvbnN0cnVjdGVkIG9iamVjdFxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5GaWx0ZXJDcmVhdGVTZWFyY2goIHNlYXJjaCwgaW5PcHRzIClcbntcblx0dmFyIG5vdCA9IFtdO1xuXHR2YXIgb3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCB7XG5cdFx0Ym91bmRhcnk6IGZhbHNlLFxuXHRcdGNhc2VJbnNlbnNpdGl2ZTogdHJ1ZSxcblx0XHRleGFjdDogZmFsc2UsXG5cdFx0cmVnZXg6IGZhbHNlLFxuXHRcdHNtYXJ0OiB0cnVlXG5cdH0sIGluT3B0cyk7XG5cblx0aWYgKHR5cGVvZiBzZWFyY2ggIT09ICdzdHJpbmcnKSB7XG5cdFx0c2VhcmNoID0gc2VhcmNoLnRvU3RyaW5nKCk7XG5cdH1cblxuXHQvLyBSZW1vdmUgZGlhY3JpdGljcyBpZiBub3JtYWxpemUgaXMgc2V0IHVwIHRvIGRvIHNvXG5cdHNlYXJjaCA9IF9ub3JtYWxpemUoc2VhcmNoKTtcblxuXHRpZiAob3B0aW9ucy5leGFjdCkge1xuXHRcdHJldHVybiBuZXcgUmVnRXhwKFxuXHRcdFx0J14nK19mbkVzY2FwZVJlZ2V4KHNlYXJjaCkrJyQnLFxuXHRcdFx0b3B0aW9ucy5jYXNlSW5zZW5zaXRpdmUgPyAnaScgOiAnJ1xuXHRcdCk7XG5cdH1cblxuXHRzZWFyY2ggPSBvcHRpb25zLnJlZ2V4ID9cblx0XHRzZWFyY2ggOlxuXHRcdF9mbkVzY2FwZVJlZ2V4KCBzZWFyY2ggKTtcblx0XG5cdGlmICggb3B0aW9ucy5zbWFydCApIHtcblx0XHQvKiBGb3Igc21hcnQgZmlsdGVyaW5nIHdlIHdhbnQgdG8gYWxsb3cgdGhlIHNlYXJjaCB0byB3b3JrIHJlZ2FyZGxlc3Mgb2Zcblx0XHQgKiB3b3JkIG9yZGVyLiBXZSBhbHNvIHdhbnQgZG91YmxlIHF1b3RlZCB0ZXh0IHRvIGJlIHByZXNlcnZlZCwgc28gd29yZFxuXHRcdCAqIG9yZGVyIGlzIGltcG9ydGFudCAtIGEgbGEgZ29vZ2xlLiBBbmQgYSBuZWdhdGl2ZSBsb29rIGFyb3VuZCBmb3Jcblx0XHQgKiBmaW5kaW5nIHJvd3Mgd2hpY2ggZG9uJ3QgY29udGFpbiBhIGdpdmVuIHN0cmluZy5cblx0XHQgKiBcblx0XHQgKiBTbyB0aGlzIGlzIHRoZSBzb3J0IG9mIHRoaW5nIHdlIHdhbnQgdG8gZ2VuZXJhdGU6XG5cdFx0ICogXG5cdFx0ICogXig/PS4qP1xcYm9uZVxcYikoPz0uKj9cXGJ0d28gdGhyZWVcXGIpKD89Lio/XFxiZm91clxcYikuKiRcblx0XHQgKi9cblx0XHR2YXIgcGFydHMgPSBzZWFyY2gubWF0Y2goIC8hP1tcIlxcdTIwMUNdW15cIlxcdTIwMURdK1tcIlxcdTIwMURdfFteIF0rL2cgKSB8fCBbJyddO1xuXHRcdHZhciBhID0gcGFydHMubWFwKCBmdW5jdGlvbiAoIHdvcmQgKSB7XG5cdFx0XHR2YXIgbmVnYXRpdmUgPSBmYWxzZTtcblx0XHRcdHZhciBtO1xuXG5cdFx0XHQvLyBEZXRlcm1pbmUgaWYgaXQgaXMgYSBcImRvZXMgbm90IGluY2x1ZGVcIlxuXHRcdFx0aWYgKCB3b3JkLmNoYXJBdCgwKSA9PT0gJyEnICkge1xuXHRcdFx0XHRuZWdhdGl2ZSA9IHRydWU7XG5cdFx0XHRcdHdvcmQgPSB3b3JkLnN1YnN0cmluZygxKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RyaXAgdGhlIHF1b3RlcyBmcm9tIGFyb3VuZCBtYXRjaGVkIHBocmFzZXNcblx0XHRcdGlmICggd29yZC5jaGFyQXQoMCkgPT09ICdcIicgKSB7XG5cdFx0XHRcdG0gPSB3b3JkLm1hdGNoKCAvXlwiKC4qKVwiJC8gKTtcblx0XHRcdFx0d29yZCA9IG0gPyBtWzFdIDogd29yZDtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCB3b3JkLmNoYXJBdCgwKSA9PT0gJ1xcdTIwMUMnICkge1xuXHRcdFx0XHQvLyBTbWFydCBxdW90ZSBtYXRjaCAoaVBob25lIHVzZXJzKVxuXHRcdFx0XHRtID0gd29yZC5tYXRjaCggL15cXHUyMDFDKC4qKVxcdTIwMUQkLyApO1xuXHRcdFx0XHR3b3JkID0gbSA/IG1bMV0gOiB3b3JkO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGb3Igb3VyIFwibm90XCIgY2FzZSwgd2UgbmVlZCB0byBtb2RpZnkgdGhlIHN0cmluZyB0aGF0IGlzXG5cdFx0XHQvLyBhbGxvd2VkIHRvIG1hdGNoIGF0IHRoZSBlbmQgb2YgdGhlIGV4cHJlc3Npb24uXG5cdFx0XHRpZiAobmVnYXRpdmUpIHtcblx0XHRcdFx0aWYgKHdvcmQubGVuZ3RoID4gMSkge1xuXHRcdFx0XHRcdG5vdC5wdXNoKCcoPyEnK3dvcmQrJyknKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHdvcmQgPSAnJztcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHdvcmQucmVwbGFjZSgvXCIvZywgJycpO1xuXHRcdH0gKTtcblxuXHRcdHZhciBtYXRjaCA9IG5vdC5sZW5ndGhcblx0XHRcdD8gbm90LmpvaW4oJycpXG5cdFx0XHQ6ICcnO1xuXG5cdFx0dmFyIGJvdW5kYXJ5ID0gb3B0aW9ucy5ib3VuZGFyeVxuXHRcdFx0PyAnXFxcXGInXG5cdFx0XHQ6ICcnO1xuXG5cdFx0c2VhcmNoID0gJ14oPz0uKj8nK2JvdW5kYXJ5K2Euam9pbiggJykoPz0uKj8nK2JvdW5kYXJ5ICkrJykoJyttYXRjaCsnLikqJCc7XG5cdH1cblxuXHRyZXR1cm4gbmV3IFJlZ0V4cCggc2VhcmNoLCBvcHRpb25zLmNhc2VJbnNlbnNpdGl2ZSA/ICdpJyA6ICcnICk7XG59XG5cblxuLyoqXG4gKiBFc2NhcGUgYSBzdHJpbmcgc3VjaCB0aGF0IGl0IGNhbiBiZSB1c2VkIGluIGEgcmVndWxhciBleHByZXNzaW9uXG4gKiAgQHBhcmFtIHtzdHJpbmd9IHNWYWwgc3RyaW5nIHRvIGVzY2FwZVxuICogIEByZXR1cm5zIHtzdHJpbmd9IGVzY2FwZWQgc3RyaW5nXG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbnZhciBfZm5Fc2NhcGVSZWdleCA9IERhdGFUYWJsZS51dGlsLmVzY2FwZVJlZ2V4O1xuXG52YXIgX19maWx0ZXJfZGl2ID0gJCgnPGRpdj4nKVswXTtcbnZhciBfX2ZpbHRlcl9kaXZfdGV4dENvbnRlbnQgPSBfX2ZpbHRlcl9kaXYudGV4dENvbnRlbnQgIT09IHVuZGVmaW5lZDtcblxuLy8gVXBkYXRlIHRoZSBmaWx0ZXJpbmcgZGF0YSBmb3IgZWFjaCByb3cgaWYgbmVlZGVkIChieSBpbnZhbGlkYXRpb24gb3IgZmlyc3QgcnVuKVxuZnVuY3Rpb24gX2ZuRmlsdGVyRGF0YSAoIHNldHRpbmdzIClcbntcblx0dmFyIGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnM7XG5cdHZhciBkYXRhID0gc2V0dGluZ3MuYW9EYXRhO1xuXHR2YXIgY29sdW1uO1xuXHR2YXIgaiwgamVuLCBmaWx0ZXJEYXRhLCBjZWxsRGF0YSwgcm93O1xuXHR2YXIgd2FzSW52YWxpZGF0ZWQgPSBmYWxzZTtcblxuXHRmb3IgKCB2YXIgcm93SWR4PTAgOyByb3dJZHg8ZGF0YS5sZW5ndGggOyByb3dJZHgrKyApIHtcblx0XHRpZiAoISBkYXRhW3Jvd0lkeF0pIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdHJvdyA9IGRhdGFbcm93SWR4XTtcblxuXHRcdGlmICggISByb3cuX2FGaWx0ZXJEYXRhICkge1xuXHRcdFx0ZmlsdGVyRGF0YSA9IFtdO1xuXG5cdFx0XHRmb3IgKCBqPTAsIGplbj1jb2x1bW5zLmxlbmd0aCA7IGo8amVuIDsgaisrICkge1xuXHRcdFx0XHRjb2x1bW4gPSBjb2x1bW5zW2pdO1xuXG5cdFx0XHRcdGlmICggY29sdW1uLmJTZWFyY2hhYmxlICkge1xuXHRcdFx0XHRcdGNlbGxEYXRhID0gX2ZuR2V0Q2VsbERhdGEoIHNldHRpbmdzLCByb3dJZHgsIGosICdmaWx0ZXInICk7XG5cblx0XHRcdFx0XHQvLyBTZWFyY2ggaW4gRGF0YVRhYmxlcyBpcyBzdHJpbmcgYmFzZWRcblx0XHRcdFx0XHRpZiAoIGNlbGxEYXRhID09PSBudWxsICkge1xuXHRcdFx0XHRcdFx0Y2VsbERhdGEgPSAnJztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIHR5cGVvZiBjZWxsRGF0YSAhPT0gJ3N0cmluZycgJiYgY2VsbERhdGEudG9TdHJpbmcgKSB7XG5cdFx0XHRcdFx0XHRjZWxsRGF0YSA9IGNlbGxEYXRhLnRvU3RyaW5nKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGNlbGxEYXRhID0gJyc7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiBpdCBsb29rcyBsaWtlIHRoZXJlIGlzIGFuIEhUTUwgZW50aXR5IGluIHRoZSBzdHJpbmcsXG5cdFx0XHRcdC8vIGF0dGVtcHQgdG8gZGVjb2RlIGl0IHNvIHNvcnRpbmcgd29ya3MgYXMgZXhwZWN0ZWQuIE5vdGUgdGhhdFxuXHRcdFx0XHQvLyB3ZSBjb3VsZCB1c2UgYSBzaW5nbGUgbGluZSBvZiBqUXVlcnkgdG8gZG8gdGhpcywgYnV0IHRoZSBET01cblx0XHRcdFx0Ly8gbWV0aG9kIHVzZWQgaGVyZSBpcyBtdWNoIGZhc3RlciBodHRwczovL2pzcGVyZi5jb20vaHRtbC1kZWNvZGVcblx0XHRcdFx0aWYgKCBjZWxsRGF0YS5pbmRleE9mICYmIGNlbGxEYXRhLmluZGV4T2YoJyYnKSAhPT0gLTEgKSB7XG5cdFx0XHRcdFx0X19maWx0ZXJfZGl2LmlubmVySFRNTCA9IGNlbGxEYXRhO1xuXHRcdFx0XHRcdGNlbGxEYXRhID0gX19maWx0ZXJfZGl2X3RleHRDb250ZW50ID9cblx0XHRcdFx0XHRcdF9fZmlsdGVyX2Rpdi50ZXh0Q29udGVudCA6XG5cdFx0XHRcdFx0XHRfX2ZpbHRlcl9kaXYuaW5uZXJUZXh0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBjZWxsRGF0YS5yZXBsYWNlICkge1xuXHRcdFx0XHRcdGNlbGxEYXRhID0gY2VsbERhdGEucmVwbGFjZSgvW1xcclxcblxcdTIwMjhdL2csICcnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZpbHRlckRhdGEucHVzaCggY2VsbERhdGEgKTtcblx0XHRcdH1cblxuXHRcdFx0cm93Ll9hRmlsdGVyRGF0YSA9IGZpbHRlckRhdGE7XG5cdFx0XHRyb3cuX3NGaWx0ZXJSb3cgPSBmaWx0ZXJEYXRhLmpvaW4oJyAgJyk7XG5cdFx0XHR3YXNJbnZhbGlkYXRlZCA9IHRydWU7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHdhc0ludmFsaWRhdGVkO1xufVxuXG5cbi8qKlxuICogRHJhdyB0aGUgdGFibGUgZm9yIHRoZSBmaXJzdCB0aW1lLCBhZGRpbmcgYWxsIHJlcXVpcmVkIGZlYXR1cmVzXG4gKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkluaXRpYWxpc2UgKCBzZXR0aW5ncyApXG57XG5cdHZhciBpO1xuXHR2YXIgaW5pdCA9IHNldHRpbmdzLm9Jbml0O1xuXHR2YXIgZGVmZXJMb2FkaW5nID0gc2V0dGluZ3MuZGVmZXJMb2FkaW5nO1xuXHR2YXIgZGF0YVNyYyA9IF9mbkRhdGFTb3VyY2UoIHNldHRpbmdzICk7XG5cblx0Ly8gRW5zdXJlIHRoYXQgdGhlIHRhYmxlIGRhdGEgaXMgZnVsbHkgaW5pdGlhbGlzZWRcblx0aWYgKCAhIHNldHRpbmdzLmJJbml0aWFsaXNlZCApIHtcblx0XHRzZXRUaW1lb3V0KCBmdW5jdGlvbigpeyBfZm5Jbml0aWFsaXNlKCBzZXR0aW5ncyApOyB9LCAyMDAgKTtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBCdWlsZCB0aGUgaGVhZGVyIC8gZm9vdGVyIGZvciB0aGUgdGFibGVcblx0X2ZuQnVpbGRIZWFkKCBzZXR0aW5ncywgJ2hlYWRlcicgKTtcblx0X2ZuQnVpbGRIZWFkKCBzZXR0aW5ncywgJ2Zvb3RlcicgKTtcblxuXHQvLyBMb2FkIHRoZSB0YWJsZSdzIHN0YXRlIChpZiBuZWVkZWQpIGFuZCB0aGVuIHJlbmRlciBhcm91bmQgaXQgYW5kIGRyYXdcblx0X2ZuTG9hZFN0YXRlKCBzZXR0aW5ncywgaW5pdCwgZnVuY3Rpb24gKCkge1xuXHRcdC8vIFRoZW4gZHJhdyB0aGUgaGVhZGVyIC8gZm9vdGVyXG5cdFx0X2ZuRHJhd0hlYWQoIHNldHRpbmdzLCBzZXR0aW5ncy5hb0hlYWRlciApO1xuXHRcdF9mbkRyYXdIZWFkKCBzZXR0aW5ncywgc2V0dGluZ3MuYW9Gb290ZXIgKTtcblxuXHRcdC8vIENhY2hlIHRoZSBwYWdpbmcgc3RhcnQgcG9pbnQsIGFzIHRoZSBmaXJzdCByZWRyYXcgd2lsbCByZXNldCBpdFxuXHRcdHZhciBpQWpheFN0YXJ0ID0gc2V0dGluZ3MuaUluaXREaXNwbGF5U3RhcnRcblxuXHRcdC8vIExvY2FsIGRhdGEgbG9hZFxuXHRcdC8vIENoZWNrIGlmIHRoZXJlIGlzIGRhdGEgcGFzc2luZyBpbnRvIHRoZSBjb25zdHJ1Y3RvclxuXHRcdGlmICggaW5pdC5hYURhdGEgKSB7XG5cdFx0XHRmb3IgKCBpPTAgOyBpPGluaXQuYWFEYXRhLmxlbmd0aCA7IGkrKyApIHtcblx0XHRcdFx0X2ZuQWRkRGF0YSggc2V0dGluZ3MsIGluaXQuYWFEYXRhWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBpZiAoIGRlZmVyTG9hZGluZyB8fCBkYXRhU3JjID09ICdkb20nICkge1xuXHRcdFx0Ly8gR3JhYiB0aGUgZGF0YSBmcm9tIHRoZSBwYWdlXG5cdFx0XHRfZm5BZGRUciggc2V0dGluZ3MsICQoc2V0dGluZ3MublRCb2R5KS5jaGlsZHJlbigndHInKSApO1xuXHRcdH1cblxuXHRcdC8vIEZpbHRlciBub3QgeWV0IGFwcGxpZWQgLSBjb3B5IHRoZSBkaXNwbGF5IG1hc3RlclxuXHRcdHNldHRpbmdzLmFpRGlzcGxheSA9IHNldHRpbmdzLmFpRGlzcGxheU1hc3Rlci5zbGljZSgpO1xuXG5cdFx0Ly8gRW5hYmxlIGZlYXR1cmVzXG5cdFx0X2ZuQWRkT3B0aW9uc0h0bWwoIHNldHRpbmdzICk7XG5cdFx0X2ZuU29ydEluaXQoIHNldHRpbmdzICk7XG5cblx0XHRfY29sR3JvdXAoIHNldHRpbmdzICk7XG5cblx0XHQvKiBPa2F5IHRvIHNob3cgdGhhdCBzb21ldGhpbmcgaXMgZ29pbmcgb24gbm93ICovXG5cdFx0X2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoIHNldHRpbmdzLCB0cnVlICk7XG5cblx0XHRfZm5DYWxsYmFja0ZpcmUoIHNldHRpbmdzLCBudWxsLCAncHJlSW5pdCcsIFtzZXR0aW5nc10sIHRydWUgKTtcblxuXHRcdC8vIElmIHRoZXJlIGlzIGRlZmF1bHQgc29ydGluZyByZXF1aXJlZCAtIGxldCdzIGRvIGl0LiBUaGUgc29ydCBmdW5jdGlvblxuXHRcdC8vIHdpbGwgZG8gdGhlIGRyYXdpbmcgZm9yIHVzLiBPdGhlcndpc2Ugd2UgZHJhdyB0aGUgdGFibGUgcmVnYXJkbGVzcyBvZiB0aGVcblx0XHQvLyBBamF4IHNvdXJjZSAtIHRoaXMgYWxsb3dzIHRoZSB0YWJsZSB0byBsb29rIGluaXRpYWxpc2VkIGZvciBBamF4IHNvdXJjaW5nXG5cdFx0Ly8gZGF0YSAoc2hvdyAnbG9hZGluZycgbWVzc2FnZSBwb3NzaWJseSlcblx0XHRfZm5SZURyYXcoIHNldHRpbmdzICk7XG5cblx0XHQvLyBTZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIGluaXQgY29tcGxldGUgaXMgZG9uZSBieSBfZm5BamF4VXBkYXRlRHJhd1xuXHRcdGlmICggZGF0YVNyYyAhPSAnc3NwJyB8fCBkZWZlckxvYWRpbmcgKSB7XG5cdFx0XHQvLyBpZiB0aGVyZSBpcyBhbiBhamF4IHNvdXJjZSBsb2FkIHRoZSBkYXRhXG5cdFx0XHRpZiAoIGRhdGFTcmMgPT0gJ2FqYXgnICkge1xuXHRcdFx0XHRfZm5CdWlsZEFqYXgoIHNldHRpbmdzLCB7fSwgZnVuY3Rpb24oanNvbikge1xuXHRcdFx0XHRcdHZhciBhRGF0YSA9IF9mbkFqYXhEYXRhU3JjKCBzZXR0aW5ncywganNvbiApO1xuXG5cdFx0XHRcdFx0Ly8gR290IHRoZSBkYXRhIC0gYWRkIGl0IHRvIHRoZSB0YWJsZVxuXHRcdFx0XHRcdGZvciAoIGk9MCA7IGk8YURhdGEubGVuZ3RoIDsgaSsrICkge1xuXHRcdFx0XHRcdFx0X2ZuQWRkRGF0YSggc2V0dGluZ3MsIGFEYXRhW2ldICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUmVzZXQgdGhlIGluaXQgZGlzcGxheSBmb3IgY29va2llIHNhdmluZy4gV2UndmUgYWxyZWFkeSBkb25lXG5cdFx0XHRcdFx0Ly8gYSBmaWx0ZXIsIGFuZCB0aGVyZWZvcmUgY2xlYXJlZCBpdCBiZWZvcmUuIFNvIHdlIG5lZWQgdG8gbWFrZVxuXHRcdFx0XHRcdC8vIGl0IGFwcGVhciAnZnJlc2gnXG5cdFx0XHRcdFx0c2V0dGluZ3MuaUluaXREaXNwbGF5U3RhcnQgPSBpQWpheFN0YXJ0O1xuXG5cdFx0XHRcdFx0X2ZuUmVEcmF3KCBzZXR0aW5ncyApO1xuXHRcdFx0XHRcdF9mblByb2Nlc3NpbmdEaXNwbGF5KCBzZXR0aW5ncywgZmFsc2UgKTtcblx0XHRcdFx0XHRfZm5Jbml0Q29tcGxldGUoIHNldHRpbmdzICk7XG5cdFx0XHRcdH0sIHNldHRpbmdzICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0X2ZuSW5pdENvbXBsZXRlKCBzZXR0aW5ncyApO1xuXHRcdFx0XHRfZm5Qcm9jZXNzaW5nRGlzcGxheSggc2V0dGluZ3MsIGZhbHNlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9ICk7XG59XG5cblxuLyoqXG4gKiBEcmF3IHRoZSB0YWJsZSBmb3IgdGhlIGZpcnN0IHRpbWUsIGFkZGluZyBhbGwgcmVxdWlyZWQgZmVhdHVyZXNcbiAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuSW5pdENvbXBsZXRlICggc2V0dGluZ3MgKVxue1xuXHRpZiAoc2V0dGluZ3MuX2JJbml0Q29tcGxldGUpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHR2YXIgYXJncyA9IFtzZXR0aW5ncywgc2V0dGluZ3MuanNvbl07XG5cblx0c2V0dGluZ3MuX2JJbml0Q29tcGxldGUgPSB0cnVlO1xuXG5cdC8vIFRhYmxlIGlzIGZ1bGx5IHNldCB1cCBhbmQgd2UgaGF2ZSBkYXRhLCBzbyBjYWxjdWxhdGUgdGhlXG5cdC8vIGNvbHVtbiB3aWR0aHNcblx0X2ZuQWRqdXN0Q29sdW1uU2l6aW5nKCBzZXR0aW5ncyApO1xuXG5cdF9mbkNhbGxiYWNrRmlyZSggc2V0dGluZ3MsIG51bGwsICdwbHVnaW4taW5pdCcsIGFyZ3MsIHRydWUgKTtcblx0X2ZuQ2FsbGJhY2tGaXJlKCBzZXR0aW5ncywgJ2FvSW5pdENvbXBsZXRlJywgJ2luaXQnLCBhcmdzLCB0cnVlICk7XG59XG5cbmZ1bmN0aW9uIF9mbkxlbmd0aENoYW5nZSAoIHNldHRpbmdzLCB2YWwgKVxue1xuXHR2YXIgbGVuID0gcGFyc2VJbnQoIHZhbCwgMTAgKTtcblx0c2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoID0gbGVuO1xuXG5cdF9mbkxlbmd0aE92ZXJmbG93KCBzZXR0aW5ncyApO1xuXG5cdC8vIEZpcmUgbGVuZ3RoIGNoYW5nZSBldmVudFxuXHRfZm5DYWxsYmFja0ZpcmUoIHNldHRpbmdzLCBudWxsLCAnbGVuZ3RoJywgW3NldHRpbmdzLCBsZW5dICk7XG59XG5cbi8qKlxuICogQWx0ZXIgdGhlIGRpc3BsYXkgc2V0dGluZ3MgdG8gY2hhbmdlIHRoZSBwYWdlXG4gKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQHBhcmFtIHtzdHJpbmd8aW50fSBhY3Rpb24gUGFnaW5nIGFjdGlvbiB0byB0YWtlOiBcImZpcnN0XCIsIFwicHJldmlvdXNcIixcbiAqICAgIFwibmV4dFwiIG9yIFwibGFzdFwiIG9yIHBhZ2UgbnVtYmVyIHRvIGp1bXAgdG8gKGludGVnZXIpXG4gKiAgQHBhcmFtIFtib29sXSByZWRyYXcgQXV0b21hdGljYWxseSBkcmF3IHRoZSB1cGRhdGUgb3Igbm90XG4gKiAgQHJldHVybnMge2Jvb2x9IHRydWUgcGFnZSBoYXMgY2hhbmdlZCwgZmFsc2UgLSBubyBjaGFuZ2VcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuUGFnZUNoYW5nZSAoIHNldHRpbmdzLCBhY3Rpb24sIHJlZHJhdyApXG57XG5cdHZhclxuXHRcdHN0YXJ0ICAgICA9IHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0LFxuXHRcdGxlbiAgICAgICA9IHNldHRpbmdzLl9pRGlzcGxheUxlbmd0aCxcblx0XHRyZWNvcmRzICAgPSBzZXR0aW5ncy5mblJlY29yZHNEaXNwbGF5KCk7XG5cblx0aWYgKCByZWNvcmRzID09PSAwIHx8IGxlbiA9PT0gLTEgKVxuXHR7XG5cdFx0c3RhcnQgPSAwO1xuXHR9XG5cdGVsc2UgaWYgKCB0eXBlb2YgYWN0aW9uID09PSBcIm51bWJlclwiIClcblx0e1xuXHRcdHN0YXJ0ID0gYWN0aW9uICogbGVuO1xuXG5cdFx0aWYgKCBzdGFydCA+IHJlY29yZHMgKVxuXHRcdHtcblx0XHRcdHN0YXJ0ID0gMDtcblx0XHR9XG5cdH1cblx0ZWxzZSBpZiAoIGFjdGlvbiA9PSBcImZpcnN0XCIgKVxuXHR7XG5cdFx0c3RhcnQgPSAwO1xuXHR9XG5cdGVsc2UgaWYgKCBhY3Rpb24gPT0gXCJwcmV2aW91c1wiIClcblx0e1xuXHRcdHN0YXJ0ID0gbGVuID49IDAgP1xuXHRcdFx0c3RhcnQgLSBsZW4gOlxuXHRcdFx0MDtcblxuXHRcdGlmICggc3RhcnQgPCAwIClcblx0XHR7XG5cdFx0XHRzdGFydCA9IDA7XG5cdFx0fVxuXHR9XG5cdGVsc2UgaWYgKCBhY3Rpb24gPT0gXCJuZXh0XCIgKVxuXHR7XG5cdFx0aWYgKCBzdGFydCArIGxlbiA8IHJlY29yZHMgKVxuXHRcdHtcblx0XHRcdHN0YXJ0ICs9IGxlbjtcblx0XHR9XG5cdH1cblx0ZWxzZSBpZiAoIGFjdGlvbiA9PSBcImxhc3RcIiApXG5cdHtcblx0XHRzdGFydCA9IE1hdGguZmxvb3IoIChyZWNvcmRzLTEpIC8gbGVuKSAqIGxlbjtcblx0fVxuXHRlbHNlIGlmICggYWN0aW9uID09PSAnZWxsaXBzaXMnIClcblx0e1xuXHRcdHJldHVybjtcblx0fVxuXHRlbHNlXG5cdHtcblx0XHRfZm5Mb2coIHNldHRpbmdzLCAwLCBcIlVua25vd24gcGFnaW5nIGFjdGlvbjogXCIrYWN0aW9uLCA1ICk7XG5cdH1cblxuXHR2YXIgY2hhbmdlZCA9IHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0ICE9PSBzdGFydDtcblx0c2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQgPSBzdGFydDtcblxuXHRfZm5DYWxsYmFja0ZpcmUoIHNldHRpbmdzLCBudWxsLCBjaGFuZ2VkID8gJ3BhZ2UnIDogJ3BhZ2UtbmMnLCBbc2V0dGluZ3NdICk7XG5cblx0aWYgKCBjaGFuZ2VkICYmIHJlZHJhdyApIHtcblx0XHRfZm5EcmF3KCBzZXR0aW5ncyApO1xuXHR9XG5cblx0cmV0dXJuIGNoYW5nZWQ7XG59XG5cblxuLyoqXG4gKiBHZW5lcmF0ZSB0aGUgbm9kZSByZXF1aXJlZCBmb3IgdGhlIHByb2Nlc3Npbmcgbm9kZVxuICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICovXG5mdW5jdGlvbiBfcHJvY2Vzc2luZ0h0bWwgKCBzZXR0aW5ncyApXG57XG5cdHZhciB0YWJsZSA9IHNldHRpbmdzLm5UYWJsZTtcblx0dmFyIHNjcm9sbGluZyA9IHNldHRpbmdzLm9TY3JvbGwuc1ggIT09ICcnIHx8IHNldHRpbmdzLm9TY3JvbGwuc1kgIT09ICcnO1xuXG5cdGlmICggc2V0dGluZ3Mub0ZlYXR1cmVzLmJQcm9jZXNzaW5nICkge1xuXHRcdHZhciBuID0gJCgnPGRpdi8+Jywge1xuXHRcdFx0XHQnaWQnOiBzZXR0aW5ncy5zVGFibGVJZCArICdfcHJvY2Vzc2luZycsXG5cdFx0XHRcdCdjbGFzcyc6IHNldHRpbmdzLm9DbGFzc2VzLnByb2Nlc3NpbmcuY29udGFpbmVyLFxuXHRcdFx0XHQncm9sZSc6ICdzdGF0dXMnXG5cdFx0XHR9IClcblx0XHRcdC5odG1sKCBzZXR0aW5ncy5vTGFuZ3VhZ2Uuc1Byb2Nlc3NpbmcgKVxuXHRcdFx0LmFwcGVuZCgnPGRpdj48ZGl2PjwvZGl2PjxkaXY+PC9kaXY+PGRpdj48L2Rpdj48ZGl2PjwvZGl2PjwvZGl2PicpO1xuXG5cdFx0Ly8gRGlmZmVyZW50IHBvc2l0aW9uaW5nIGRlcGVuZGluZyBvbiBpZiBzY3JvbGxpbmcgaXMgZW5hYmxlZCBvciBub3Rcblx0XHRpZiAoc2Nyb2xsaW5nKSB7XG5cdFx0XHRuLnByZXBlbmRUbyggJCgnZGl2LmR0LXNjcm9sbCcsIHNldHRpbmdzLm5UYWJsZVdyYXBwZXIpICk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0bi5pbnNlcnRCZWZvcmUoIHRhYmxlICk7XG5cdFx0fVxuXG5cdFx0JCh0YWJsZSkub24oICdwcm9jZXNzaW5nLmR0LkRUJywgZnVuY3Rpb24gKGUsIHMsIHNob3cpIHtcblx0XHRcdG4uY3NzKCAnZGlzcGxheScsIHNob3cgPyAnYmxvY2snIDogJ25vbmUnICk7XG5cdFx0fSApO1xuXHR9XG59XG5cblxuLyoqXG4gKiBEaXNwbGF5IG9yIGhpZGUgdGhlIHByb2Nlc3NpbmcgaW5kaWNhdG9yXG4gKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQHBhcmFtIHtib29sfSBzaG93IFNob3cgdGhlIHByb2Nlc3NpbmcgaW5kaWNhdG9yICh0cnVlKSBvciBub3QgKGZhbHNlKVxuICovXG5mdW5jdGlvbiBfZm5Qcm9jZXNzaW5nRGlzcGxheSAoIHNldHRpbmdzLCBzaG93IClcbntcblx0Ly8gSWdub3JlIGNhc2VzIHdoZW4gd2UgYXJlIHN0aWxsIHJlZHJhd2luZ1xuXHRpZiAoc2V0dGluZ3MuYkRyYXdpbmcgJiYgc2hvdyA9PT0gZmFsc2UpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRfZm5DYWxsYmFja0ZpcmUoIHNldHRpbmdzLCBudWxsLCAncHJvY2Vzc2luZycsIFtzZXR0aW5ncywgc2hvd10gKTtcbn1cblxuLyoqXG4gKiBTaG93IHRoZSBwcm9jZXNzaW5nIGVsZW1lbnQgaWYgYW4gYWN0aW9uIHRha2VzIGxvbmdlciB0aGFuIGEgZ2l2ZW4gdGltZVxuICpcbiAqIEBwYXJhbSB7Kn0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqIEBwYXJhbSB7Kn0gZW5hYmxlIERvICh0cnVlKSBvciBub3QgKGZhbHNlKSBhc3luYyBwcm9jZXNzaW5nIChsb2NhbCBmZWF0dXJlIGVuYWJsZW1lbnQpXG4gKiBAcGFyYW0geyp9IHJ1biBGdW5jdGlvbiB0byBydW5cbiAqL1xuZnVuY3Rpb24gX2ZuUHJvY2Vzc2luZ1J1biggc2V0dGluZ3MsIGVuYWJsZSwgcnVuICkge1xuXHRpZiAoISBlbmFibGUpIHtcblx0XHQvLyBJbW1lZGlhdGUgZXhlY3V0aW9uLCBzeW5jaHJvbm91c1xuXHRcdHJ1bigpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdF9mblByb2Nlc3NpbmdEaXNwbGF5KHNldHRpbmdzLCB0cnVlKTtcblx0XHRcblx0XHQvLyBBbGxvdyB0aGUgcHJvY2Vzc2luZyBkaXNwbGF5IHRvIHNob3cgaWYgbmVlZGVkXG5cdFx0c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0XHRydW4oKTtcblxuXHRcdFx0X2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoc2V0dGluZ3MsIGZhbHNlKTtcblx0XHR9LCAwKTtcblx0fVxufVxuLyoqXG4gKiBBZGQgYW55IGNvbnRyb2wgZWxlbWVudHMgZm9yIHRoZSB0YWJsZSAtIHNwZWNpZmljYWxseSBzY3JvbGxpbmdcbiAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAcmV0dXJucyB7bm9kZX0gTm9kZSB0byBhZGQgdG8gdGhlIERPTVxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5GZWF0dXJlSHRtbFRhYmxlICggc2V0dGluZ3MgKVxue1xuXHR2YXIgdGFibGUgPSAkKHNldHRpbmdzLm5UYWJsZSk7XG5cblx0Ly8gU2Nyb2xsaW5nIGZyb20gaGVyZSBvbiBpblxuXHR2YXIgc2Nyb2xsID0gc2V0dGluZ3Mub1Njcm9sbDtcblxuXHRpZiAoIHNjcm9sbC5zWCA9PT0gJycgJiYgc2Nyb2xsLnNZID09PSAnJyApIHtcblx0XHRyZXR1cm4gc2V0dGluZ3MublRhYmxlO1xuXHR9XG5cblx0dmFyIHNjcm9sbFggPSBzY3JvbGwuc1g7XG5cdHZhciBzY3JvbGxZID0gc2Nyb2xsLnNZO1xuXHR2YXIgY2xhc3NlcyA9IHNldHRpbmdzLm9DbGFzc2VzLnNjcm9sbGluZztcblx0dmFyIGNhcHRpb24gPSBzZXR0aW5ncy5jYXB0aW9uTm9kZTtcblx0dmFyIGNhcHRpb25TaWRlID0gY2FwdGlvbiA/IGNhcHRpb24uX2NhcHRpb25TaWRlIDogbnVsbDtcblx0dmFyIGhlYWRlckNsb25lID0gJCggdGFibGVbMF0uY2xvbmVOb2RlKGZhbHNlKSApO1xuXHR2YXIgZm9vdGVyQ2xvbmUgPSAkKCB0YWJsZVswXS5jbG9uZU5vZGUoZmFsc2UpICk7XG5cdHZhciBmb290ZXIgPSB0YWJsZS5jaGlsZHJlbigndGZvb3QnKTtcblx0dmFyIF9kaXYgPSAnPGRpdi8+Jztcblx0dmFyIHNpemUgPSBmdW5jdGlvbiAoIHMgKSB7XG5cdFx0cmV0dXJuICFzID8gbnVsbCA6IF9mblN0cmluZ1RvQ3NzKCBzICk7XG5cdH07XG5cblx0aWYgKCAhIGZvb3Rlci5sZW5ndGggKSB7XG5cdFx0Zm9vdGVyID0gbnVsbDtcblx0fVxuXG5cdC8qXG5cdCAqIFRoZSBIVE1MIHN0cnVjdHVyZSB0aGF0IHdlIHdhbnQgdG8gZ2VuZXJhdGUgaW4gdGhpcyBmdW5jdGlvbiBpczpcblx0ICogIGRpdiAtIHNjcm9sbGVyXG5cdCAqICAgIGRpdiAtIHNjcm9sbCBoZWFkXG5cdCAqICAgICAgZGl2IC0gc2Nyb2xsIGhlYWQgaW5uZXJcblx0ICogICAgICAgIHRhYmxlIC0gc2Nyb2xsIGhlYWQgdGFibGVcblx0ICogICAgICAgICAgdGhlYWQgLSB0aGVhZFxuXHQgKiAgICBkaXYgLSBzY3JvbGwgYm9keVxuXHQgKiAgICAgIHRhYmxlIC0gdGFibGUgKG1hc3RlciB0YWJsZSlcblx0ICogICAgICAgIHRoZWFkIC0gdGhlYWQgY2xvbmUgZm9yIHNpemluZ1xuXHQgKiAgICAgICAgdGJvZHkgLSB0Ym9keVxuXHQgKiAgICBkaXYgLSBzY3JvbGwgZm9vdFxuXHQgKiAgICAgIGRpdiAtIHNjcm9sbCBmb290IGlubmVyXG5cdCAqICAgICAgICB0YWJsZSAtIHNjcm9sbCBmb290IHRhYmxlXG5cdCAqICAgICAgICAgIHRmb290IC0gdGZvb3Rcblx0ICovXG5cdHZhciBzY3JvbGxlciA9ICQoIF9kaXYsIHsgJ2NsYXNzJzogY2xhc3Nlcy5jb250YWluZXIgfSApXG5cdFx0LmFwcGVuZChcblx0XHRcdCQoX2RpdiwgeyAnY2xhc3MnOiBjbGFzc2VzLmhlYWRlci5zZWxmIH0gKVxuXHRcdFx0XHQuY3NzKCB7XG5cdFx0XHRcdFx0b3ZlcmZsb3c6ICdoaWRkZW4nLFxuXHRcdFx0XHRcdHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuXHRcdFx0XHRcdGJvcmRlcjogMCxcblx0XHRcdFx0XHR3aWR0aDogc2Nyb2xsWCA/IHNpemUoc2Nyb2xsWCkgOiAnMTAwJSdcblx0XHRcdFx0fSApXG5cdFx0XHRcdC5hcHBlbmQoXG5cdFx0XHRcdFx0JChfZGl2LCB7ICdjbGFzcyc6IGNsYXNzZXMuaGVhZGVyLmlubmVyIH0gKVxuXHRcdFx0XHRcdFx0LmNzcygge1xuXHRcdFx0XHRcdFx0XHQnYm94LXNpemluZyc6ICdjb250ZW50LWJveCcsXG5cdFx0XHRcdFx0XHRcdHdpZHRoOiBzY3JvbGwuc1hJbm5lciB8fCAnMTAwJSdcblx0XHRcdFx0XHRcdH0gKVxuXHRcdFx0XHRcdFx0LmFwcGVuZChcblx0XHRcdFx0XHRcdFx0aGVhZGVyQ2xvbmVcblx0XHRcdFx0XHRcdFx0XHQucmVtb3ZlQXR0cignaWQnKVxuXHRcdFx0XHRcdFx0XHRcdC5jc3MoICdtYXJnaW4tbGVmdCcsIDAgKVxuXHRcdFx0XHRcdFx0XHRcdC5hcHBlbmQoIGNhcHRpb25TaWRlID09PSAndG9wJyA/IGNhcHRpb24gOiBudWxsIClcblx0XHRcdFx0XHRcdFx0XHQuYXBwZW5kKFxuXHRcdFx0XHRcdFx0XHRcdFx0dGFibGUuY2hpbGRyZW4oJ3RoZWFkJylcblx0XHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpXG5cdFx0XHRcdClcblx0XHQpXG5cdFx0LmFwcGVuZChcblx0XHRcdCQoX2RpdiwgeyAnY2xhc3MnOiBjbGFzc2VzLmJvZHkgfSApXG5cdFx0XHRcdC5jc3MoIHtcblx0XHRcdFx0XHRwb3NpdGlvbjogJ3JlbGF0aXZlJyxcblx0XHRcdFx0XHRvdmVyZmxvdzogJ2F1dG8nLFxuXHRcdFx0XHRcdHdpZHRoOiBzaXplKCBzY3JvbGxYIClcblx0XHRcdFx0fSApXG5cdFx0XHRcdC5hcHBlbmQoIHRhYmxlIClcblx0XHQpO1xuXG5cdGlmICggZm9vdGVyICkge1xuXHRcdHNjcm9sbGVyLmFwcGVuZChcblx0XHRcdCQoX2RpdiwgeyAnY2xhc3MnOiBjbGFzc2VzLmZvb3Rlci5zZWxmIH0gKVxuXHRcdFx0XHQuY3NzKCB7XG5cdFx0XHRcdFx0b3ZlcmZsb3c6ICdoaWRkZW4nLFxuXHRcdFx0XHRcdGJvcmRlcjogMCxcblx0XHRcdFx0XHR3aWR0aDogc2Nyb2xsWCA/IHNpemUoc2Nyb2xsWCkgOiAnMTAwJSdcblx0XHRcdFx0fSApXG5cdFx0XHRcdC5hcHBlbmQoXG5cdFx0XHRcdFx0JChfZGl2LCB7ICdjbGFzcyc6IGNsYXNzZXMuZm9vdGVyLmlubmVyIH0gKVxuXHRcdFx0XHRcdFx0LmFwcGVuZChcblx0XHRcdFx0XHRcdFx0Zm9vdGVyQ2xvbmVcblx0XHRcdFx0XHRcdFx0XHQucmVtb3ZlQXR0cignaWQnKVxuXHRcdFx0XHRcdFx0XHRcdC5jc3MoICdtYXJnaW4tbGVmdCcsIDAgKVxuXHRcdFx0XHRcdFx0XHRcdC5hcHBlbmQoIGNhcHRpb25TaWRlID09PSAnYm90dG9tJyA/IGNhcHRpb24gOiBudWxsIClcblx0XHRcdFx0XHRcdFx0XHQuYXBwZW5kKFxuXHRcdFx0XHRcdFx0XHRcdFx0dGFibGUuY2hpbGRyZW4oJ3Rmb290Jylcblx0XHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpXG5cdFx0XHRcdClcblx0XHQpO1xuXHR9XG5cblx0dmFyIGNoaWxkcmVuID0gc2Nyb2xsZXIuY2hpbGRyZW4oKTtcblx0dmFyIHNjcm9sbEhlYWQgPSBjaGlsZHJlblswXTtcblx0dmFyIHNjcm9sbEJvZHkgPSBjaGlsZHJlblsxXTtcblx0dmFyIHNjcm9sbEZvb3QgPSBmb290ZXIgPyBjaGlsZHJlblsyXSA6IG51bGw7XG5cblx0Ly8gV2hlbiB0aGUgYm9keSBpcyBzY3JvbGxlZCwgdGhlbiB3ZSBhbHNvIHdhbnQgdG8gc2Nyb2xsIHRoZSBoZWFkZXJzXG5cdCQoc2Nyb2xsQm9keSkub24oICdzY3JvbGwuRFQnLCBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHNjcm9sbExlZnQgPSB0aGlzLnNjcm9sbExlZnQ7XG5cblx0XHRzY3JvbGxIZWFkLnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0O1xuXG5cdFx0aWYgKCBmb290ZXIgKSB7XG5cdFx0XHRzY3JvbGxGb290LnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0O1xuXHRcdH1cblx0fSApO1xuXG5cdC8vIFdoZW4gZm9jdXMgaXMgcHV0IG9uIHRoZSBoZWFkZXIgY2VsbHMsIHdlIG1pZ2h0IG5lZWQgdG8gc2Nyb2xsIHRoZSBib2R5XG5cdCQoJ3RoLCB0ZCcsIHNjcm9sbEhlYWQpLm9uKCdmb2N1cycsIGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgc2Nyb2xsTGVmdCA9IHNjcm9sbEhlYWQuc2Nyb2xsTGVmdDtcblxuXHRcdHNjcm9sbEJvZHkuc2Nyb2xsTGVmdCA9IHNjcm9sbExlZnQ7XG5cblx0XHRpZiAoIGZvb3RlciApIHtcblx0XHRcdHNjcm9sbEJvZHkuc2Nyb2xsTGVmdCA9IHNjcm9sbExlZnQ7XG5cdFx0fVxuXHR9KTtcblxuXHQkKHNjcm9sbEJvZHkpLmNzcygnbWF4LWhlaWdodCcsIHNjcm9sbFkpO1xuXHRpZiAoISBzY3JvbGwuYkNvbGxhcHNlKSB7XG5cdFx0JChzY3JvbGxCb2R5KS5jc3MoJ2hlaWdodCcsIHNjcm9sbFkpO1xuXHR9XG5cblx0c2V0dGluZ3MublNjcm9sbEhlYWQgPSBzY3JvbGxIZWFkO1xuXHRzZXR0aW5ncy5uU2Nyb2xsQm9keSA9IHNjcm9sbEJvZHk7XG5cdHNldHRpbmdzLm5TY3JvbGxGb290ID0gc2Nyb2xsRm9vdDtcblxuXHQvLyBPbiByZWRyYXcgLSBhbGlnbiBjb2x1bW5zXG5cdHNldHRpbmdzLmFvRHJhd0NhbGxiYWNrLnB1c2goX2ZuU2Nyb2xsRHJhdyk7XG5cblx0cmV0dXJuIHNjcm9sbGVyWzBdO1xufVxuXG5cblxuLyoqXG4gKiBVcGRhdGUgdGhlIGhlYWRlciwgZm9vdGVyIGFuZCBib2R5IHRhYmxlcyBmb3IgcmVzaXppbmcgLSBpLmUuIGNvbHVtblxuICogYWxpZ25tZW50LlxuICpcbiAqIFdlbGNvbWUgdG8gdGhlIG1vc3QgaG9ycmlibGUgZnVuY3Rpb24gRGF0YVRhYmxlcy4gVGhlIHByb2Nlc3MgdGhhdCB0aGlzXG4gKiBmdW5jdGlvbiBmb2xsb3dzIGlzIGJhc2ljYWxseTpcbiAqICAgMS4gUmUtY3JlYXRlIHRoZSB0YWJsZSBpbnNpZGUgdGhlIHNjcm9sbGluZyBkaXZcbiAqICAgMi4gQ29ycmVjdCBjb2xncm91cCA+IGNvbCB2YWx1ZXMgaWYgbmVlZGVkXG4gKiAgIDMuIENvcHkgY29sZ3JvdXAgPiBjb2wgb3ZlciB0byBoZWFkZXIgYW5kIGZvb3RlclxuICogICA0LiBDbGVhbiB1cFxuICpcbiAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuU2Nyb2xsRHJhdyAoIHNldHRpbmdzIClcbntcblx0Ly8gR2l2ZW4gdGhhdCB0aGlzIGlzIHN1Y2ggYSBtb25zdGVyIGZ1bmN0aW9uLCBhIGxvdCBvZiB2YXJpYWJsZXMgYXJlIHVzZVxuXHQvLyB0byB0cnkgYW5kIGtlZXAgdGhlIG1pbmltaXNlZCBzaXplIGFzIHNtYWxsIGFzIHBvc3NpYmxlXG5cdHZhclxuXHRcdHNjcm9sbCAgICAgICAgID0gc2V0dGluZ3Mub1Njcm9sbCxcblx0XHRiYXJXaWR0aCAgICAgICA9IHNjcm9sbC5pQmFyV2lkdGgsXG5cdFx0ZGl2SGVhZGVyICAgICAgPSAkKHNldHRpbmdzLm5TY3JvbGxIZWFkKSxcblx0XHRkaXZIZWFkZXJJbm5lciA9IGRpdkhlYWRlci5jaGlsZHJlbignZGl2JyksXG5cdFx0ZGl2SGVhZGVyVGFibGUgPSBkaXZIZWFkZXJJbm5lci5jaGlsZHJlbigndGFibGUnKSxcblx0XHRkaXZCb2R5RWwgICAgICA9IHNldHRpbmdzLm5TY3JvbGxCb2R5LFxuXHRcdGRpdkJvZHkgICAgICAgID0gJChkaXZCb2R5RWwpLFxuXHRcdGRpdkZvb3RlciAgICAgID0gJChzZXR0aW5ncy5uU2Nyb2xsRm9vdCksXG5cdFx0ZGl2Rm9vdGVySW5uZXIgPSBkaXZGb290ZXIuY2hpbGRyZW4oJ2RpdicpLFxuXHRcdGRpdkZvb3RlclRhYmxlID0gZGl2Rm9vdGVySW5uZXIuY2hpbGRyZW4oJ3RhYmxlJyksXG5cdFx0aGVhZGVyICAgICAgICAgPSAkKHNldHRpbmdzLm5USGVhZCksXG5cdFx0dGFibGUgICAgICAgICAgPSAkKHNldHRpbmdzLm5UYWJsZSksXG5cdFx0Zm9vdGVyICAgICAgICAgPSBzZXR0aW5ncy5uVEZvb3QgJiYgJCgndGgsIHRkJywgc2V0dGluZ3MublRGb290KS5sZW5ndGggPyAkKHNldHRpbmdzLm5URm9vdCkgOiBudWxsLFxuXHRcdGJyb3dzZXIgICAgICAgID0gc2V0dGluZ3Mub0Jyb3dzZXIsXG5cdFx0aGVhZGVyQ29weSwgZm9vdGVyQ29weTtcblxuXHQvLyBJZiB0aGUgc2Nyb2xsYmFyIHZpc2liaWxpdHkgaGFzIGNoYW5nZWQgZnJvbSB0aGUgbGFzdCBkcmF3LCB3ZSBuZWVkIHRvXG5cdC8vIGFkanVzdCB0aGUgY29sdW1uIHNpemVzIGFzIHRoZSB0YWJsZSB3aWR0aCB3aWxsIGhhdmUgY2hhbmdlZCB0byBhY2NvdW50XG5cdC8vIGZvciB0aGUgc2Nyb2xsYmFyXG5cdHZhciBzY3JvbGxCYXJWaXMgPSBkaXZCb2R5RWwuc2Nyb2xsSGVpZ2h0ID4gZGl2Qm9keUVsLmNsaWVudEhlaWdodDtcblx0XG5cdGlmICggc2V0dGluZ3Muc2Nyb2xsQmFyVmlzICE9PSBzY3JvbGxCYXJWaXMgJiYgc2V0dGluZ3Muc2Nyb2xsQmFyVmlzICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0c2V0dGluZ3Muc2Nyb2xsQmFyVmlzID0gc2Nyb2xsQmFyVmlzO1xuXHRcdF9mbkFkanVzdENvbHVtblNpemluZyggc2V0dGluZ3MgKTtcblx0XHRyZXR1cm47IC8vIGFkanVzdCBjb2x1bW4gc2l6aW5nIHdpbGwgY2FsbCB0aGlzIGZ1bmN0aW9uIGFnYWluXG5cdH1cblx0ZWxzZSB7XG5cdFx0c2V0dGluZ3Muc2Nyb2xsQmFyVmlzID0gc2Nyb2xsQmFyVmlzO1xuXHR9XG5cblx0Ly8gMS4gUmUtY3JlYXRlIHRoZSB0YWJsZSBpbnNpZGUgdGhlIHNjcm9sbGluZyBkaXZcblx0Ly8gUmVtb3ZlIHRoZSBvbGQgbWluaW1pc2VkIHRoZWFkIGFuZCB0Zm9vdCBlbGVtZW50cyBpbiB0aGUgaW5uZXIgdGFibGVcblx0dGFibGUuY2hpbGRyZW4oJ3RoZWFkLCB0Zm9vdCcpLnJlbW92ZSgpO1xuXG5cdC8vIENsb25lIHRoZSBjdXJyZW50IGhlYWRlciBhbmQgZm9vdGVyIGVsZW1lbnRzIGFuZCB0aGVuIHBsYWNlIGl0IGludG8gdGhlIGlubmVyIHRhYmxlXG5cdGhlYWRlckNvcHkgPSBoZWFkZXIuY2xvbmUoKS5wcmVwZW5kVG8oIHRhYmxlICk7XG5cdGhlYWRlckNvcHkuZmluZCgndGgsIHRkJykucmVtb3ZlQXR0cigndGFiaW5kZXgnKTtcblx0aGVhZGVyQ29weS5maW5kKCdbaWRdJykucmVtb3ZlQXR0cignaWQnKTtcblxuXHRpZiAoIGZvb3RlciApIHtcblx0XHRmb290ZXJDb3B5ID0gZm9vdGVyLmNsb25lKCkucHJlcGVuZFRvKCB0YWJsZSApO1xuXHRcdGZvb3RlckNvcHkuZmluZCgnW2lkXScpLnJlbW92ZUF0dHIoJ2lkJyk7XG5cdH1cblxuXHQvLyAyLiBDb3JyZWN0IGNvbGdyb3VwID4gY29sIHZhbHVlcyBpZiBuZWVkZWRcblx0Ly8gSXQgaXMgcG9zc2libGUgdGhhdCB0aGUgY2VsbCBzaXplcyBhcmUgc21hbGxlciB0aGFuIHRoZSBjb250ZW50LCBzbyB3ZSBuZWVkIHRvXG5cdC8vIGNvcnJlY3QgY29sZ3JvdXA+Y29sIGZvciBzdWNoIGNhc2VzLiBUaGlzIGNhbiBoYXBwZW4gaWYgdGhlIGF1dG8gd2lkdGggZGV0ZWN0aW9uXG5cdC8vIHVzZXMgYSBjZWxsIHdoaWNoIGhhcyBhIGxvbmdlciBzdHJpbmcsIGJ1dCBpc24ndCB0aGUgd2lkZXN0ISBGb3IgZXhhbXBsZSBcblx0Ly8gXCJDaGllZiBFeGVjdXRpdmUgT2ZmaWNlciAoQ0VPKVwiIGlzIHRoZSBsb25nZXN0IHN0cmluZyBpbiB0aGUgZGVtbywgYnV0XG5cdC8vIFwiU3lzdGVtcyBBZG1pbmlzdHJhdG9yXCIgaXMgYWN0dWFsbHkgdGhlIHdpZGVzdCBzdHJpbmcgc2luY2UgaXQgZG9lc24ndCBjb2xsYXBzZS5cblx0Ly8gTm90ZSB0aGUgdXNlIG9mIHRyYW5zbGF0aW5nIGludG8gYSBjb2x1bW4gaW5kZXggdG8gZ2V0IHRoZSBgY29sYCBlbGVtZW50LiBUaGlzXG5cdC8vIGlzIGJlY2F1c2Ugb2YgUmVzcG9uc2l2ZSB3aGljaCBtaWdodCByZW1vdmUgYGNvbGAgZWxlbWVudHMsIGtub2NraW5nIHRoZSBhbGlnbm1lbnRcblx0Ly8gb2YgdGhlIGluZGV4ZXMgb3V0LlxuXHRpZiAoc2V0dGluZ3MuYWlEaXNwbGF5Lmxlbmd0aCkge1xuXHRcdC8vIEdldCB0aGUgY29sdW1uIHNpemVzIGZyb20gdGhlIGZpcnN0IHJvdyBpbiB0aGUgdGFibGUuIFRoaXMgc2hvdWxkIHJlYWxseSBiZSBhXG5cdFx0Ly8gW10uZmluZCwgYnV0IGl0IHdhc24ndCBzdXBwb3J0ZWQgaW4gQ2hyb21lIHVudGlsIFNlcHQgMjAxNSwgYW5kIERUIGhhcyAxMCB5ZWFyXG5cdFx0Ly8gYnJvd3NlciBzdXBwb3J0XG5cdFx0dmFyIGZpcnN0VHIgPSBudWxsO1xuXHRcdHZhciBzdGFydCA9IF9mbkRhdGFTb3VyY2UoIHNldHRpbmdzICkgIT09ICdzc3AnXG5cdFx0XHQ/IHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0XG5cdFx0XHQ6IDA7XG5cblx0XHRmb3IgKGk9c3RhcnQgOyBpPHN0YXJ0ICsgc2V0dGluZ3MuYWlEaXNwbGF5Lmxlbmd0aCA7IGkrKykge1xuXHRcdFx0dmFyIGlkeCA9IHNldHRpbmdzLmFpRGlzcGxheVtpXTtcblx0XHRcdHZhciB0ciA9IHNldHRpbmdzLmFvRGF0YVtpZHhdLm5UcjtcblxuXHRcdFx0aWYgKHRyKSB7XG5cdFx0XHRcdGZpcnN0VHIgPSB0cjtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGZpcnN0VHIpIHtcblx0XHRcdHZhciBjb2xTaXplcyA9ICQoZmlyc3RUcikuY2hpbGRyZW4oJ3RoLCB0ZCcpLm1hcChmdW5jdGlvbiAodmlzKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0aWR4OiBfZm5WaXNpYmxlVG9Db2x1bW5JbmRleChzZXR0aW5ncywgdmlzKSxcblx0XHRcdFx0XHR3aWR0aDogJCh0aGlzKS5vdXRlcldpZHRoKClcblx0XHRcdFx0fTtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBDaGVjayBhZ2FpbnN0IHdoYXQgdGhlIGNvbGdyb3VwID4gY29sIGlzIHNldCB0byBhbmQgY29ycmVjdCBpZiBuZWVkZWRcblx0XHRcdGZvciAodmFyIGk9MCA7IGk8Y29sU2l6ZXMubGVuZ3RoIDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjb2xFbCA9IHNldHRpbmdzLmFvQ29sdW1uc1sgY29sU2l6ZXNbaV0uaWR4IF0uY29sRWxbMF07XG5cdFx0XHRcdHZhciBjb2xXaWR0aCA9IGNvbEVsLnN0eWxlLndpZHRoLnJlcGxhY2UoJ3B4JywgJycpO1xuXG5cdFx0XHRcdGlmIChjb2xXaWR0aCAhPT0gY29sU2l6ZXNbaV0ud2lkdGgpIHtcblx0XHRcdFx0XHRjb2xFbC5zdHlsZS53aWR0aCA9IGNvbFNpemVzW2ldLndpZHRoICsgJ3B4JztcblxuXHRcdFx0XHRcdGlmIChzY3JvbGwuc1gpIHtcblx0XHRcdFx0XHRcdGNvbEVsLnN0eWxlLm1pbldpZHRoID0gY29sU2l6ZXNbaV0ud2lkdGggKyAncHgnO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIDMuIENvcHkgdGhlIGNvbGdyb3VwIG92ZXIgdG8gdGhlIGhlYWRlciBhbmQgZm9vdGVyXG5cdGRpdkhlYWRlclRhYmxlXG5cdFx0LmZpbmQoJ2NvbGdyb3VwJylcblx0XHQucmVtb3ZlKCk7XG5cblx0ZGl2SGVhZGVyVGFibGUuYXBwZW5kKHNldHRpbmdzLmNvbGdyb3VwLmNsb25lKCkpO1xuXG5cdGlmICggZm9vdGVyICkge1xuXHRcdGRpdkZvb3RlclRhYmxlXG5cdFx0XHQuZmluZCgnY29sZ3JvdXAnKVxuXHRcdFx0LnJlbW92ZSgpO1xuXG5cdFx0ZGl2Rm9vdGVyVGFibGUuYXBwZW5kKHNldHRpbmdzLmNvbGdyb3VwLmNsb25lKCkpO1xuXHR9XG5cblx0Ly8gXCJIaWRlXCIgdGhlIGhlYWRlciBhbmQgZm9vdGVyIHRoYXQgd2UgdXNlZCBmb3IgdGhlIHNpemluZy4gV2UgbmVlZCB0byBrZWVwXG5cdC8vIHRoZSBjb250ZW50IG9mIHRoZSBjZWxsIHNvIHRoYXQgdGhlIHdpZHRoIGFwcGxpZWQgdG8gdGhlIGhlYWRlciBhbmQgYm9keVxuXHQvLyBib3RoIG1hdGNoLCBidXQgd2Ugd2FudCB0byBoaWRlIGl0IGNvbXBsZXRlbHkuXG5cdCQoJ3RoLCB0ZCcsIGhlYWRlckNvcHkpLmVhY2goZnVuY3Rpb24gKCkge1xuXHRcdCQodGhpcy5jaGlsZE5vZGVzKS53cmFwQWxsKCc8ZGl2IGNsYXNzPVwiZHQtc2Nyb2xsLXNpemluZ1wiPicpO1xuXHR9KTtcblxuXHRpZiAoIGZvb3RlciApIHtcblx0XHQkKCd0aCwgdGQnLCBmb290ZXJDb3B5KS5lYWNoKGZ1bmN0aW9uICgpIHtcblx0XHRcdCQodGhpcy5jaGlsZE5vZGVzKS53cmFwQWxsKCc8ZGl2IGNsYXNzPVwiZHQtc2Nyb2xsLXNpemluZ1wiPicpO1xuXHRcdH0pO1xuXHR9XG5cblx0Ly8gNC4gQ2xlYW4gdXBcblx0Ly8gRmlndXJlIG91dCBpZiB0aGVyZSBhcmUgc2Nyb2xsYmFyIHByZXNlbnQgLSBpZiBzbyB0aGVuIHdlIG5lZWQgYSB0aGUgaGVhZGVyIGFuZCBmb290ZXIgdG9cblx0Ly8gcHJvdmlkZSBhIGJpdCBtb3JlIHNwYWNlIHRvIGFsbG93IFwib3ZlcmZsb3dcIiBzY3JvbGxpbmcgKGkuZS4gcGFzdCB0aGUgc2Nyb2xsYmFyKVxuXHR2YXIgaXNTY3JvbGxpbmcgPSBNYXRoLmZsb29yKHRhYmxlLmhlaWdodCgpKSA+IGRpdkJvZHlFbC5jbGllbnRIZWlnaHQgfHwgZGl2Qm9keS5jc3MoJ292ZXJmbG93LXknKSA9PSBcInNjcm9sbFwiO1xuXHR2YXIgcGFkZGluZ1NpZGUgPSAncGFkZGluZycgKyAoYnJvd3Nlci5iU2Nyb2xsYmFyTGVmdCA/ICdMZWZ0JyA6ICdSaWdodCcgKTtcblxuXHQvLyBTZXQgdGhlIHdpZHRoJ3Mgb2YgdGhlIGhlYWRlciBhbmQgZm9vdGVyIHRhYmxlc1xuXHR2YXIgb3V0ZXJXaWR0aCA9IHRhYmxlLm91dGVyV2lkdGgoKTtcblxuXHRkaXZIZWFkZXJUYWJsZS5jc3MoJ3dpZHRoJywgX2ZuU3RyaW5nVG9Dc3MoIG91dGVyV2lkdGggKSk7XG5cdGRpdkhlYWRlcklubmVyXG5cdFx0LmNzcygnd2lkdGgnLCBfZm5TdHJpbmdUb0Nzcyggb3V0ZXJXaWR0aCApKVxuXHRcdC5jc3MocGFkZGluZ1NpZGUsIGlzU2Nyb2xsaW5nID8gYmFyV2lkdGgrXCJweFwiIDogXCIwcHhcIik7XG5cblx0aWYgKCBmb290ZXIgKSB7XG5cdFx0ZGl2Rm9vdGVyVGFibGUuY3NzKCd3aWR0aCcsIF9mblN0cmluZ1RvQ3NzKCBvdXRlcldpZHRoICkpO1xuXHRcdGRpdkZvb3RlcklubmVyXG5cdFx0XHQuY3NzKCd3aWR0aCcsIF9mblN0cmluZ1RvQ3NzKCBvdXRlcldpZHRoICkpXG5cdFx0XHQuY3NzKHBhZGRpbmdTaWRlLCBpc1Njcm9sbGluZyA/IGJhcldpZHRoK1wicHhcIiA6IFwiMHB4XCIpO1xuXHR9XG5cblx0Ly8gQ29ycmVjdCBET00gb3JkZXJpbmcgZm9yIGNvbGdyb3VwIC0gY29tZXMgYmVmb3JlIHRoZSB0aGVhZFxuXHR0YWJsZS5jaGlsZHJlbignY29sZ3JvdXAnKS5wcmVwZW5kVG8odGFibGUpO1xuXG5cdC8vIEFkanVzdCB0aGUgcG9zaXRpb24gb2YgdGhlIGhlYWRlciBpbiBjYXNlIHdlIGxvb3NlIHRoZSB5LXNjcm9sbGJhclxuXHRkaXZCb2R5LnRyaWdnZXIoJ3Njcm9sbCcpO1xuXG5cdC8vIElmIHNvcnRpbmcgb3IgZmlsdGVyaW5nIGhhcyBvY2N1cnJlZCwganVtcCB0aGUgc2Nyb2xsaW5nIGJhY2sgdG8gdGhlIHRvcFxuXHQvLyBvbmx5IGlmIHdlIGFyZW4ndCBob2xkaW5nIHRoZSBwb3NpdGlvblxuXHRpZiAoIChzZXR0aW5ncy5iU29ydGVkIHx8IHNldHRpbmdzLmJGaWx0ZXJlZCkgJiYgISBzZXR0aW5ncy5fZHJhd0hvbGQgKSB7XG5cdFx0ZGl2Qm9keUVsLnNjcm9sbFRvcCA9IDA7XG5cdH1cbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIHdpZHRoIG9mIGNvbHVtbnMgZm9yIHRoZSB0YWJsZVxuICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5DYWxjdWxhdGVDb2x1bW5XaWR0aHMgKCBzZXR0aW5ncyApXG57XG5cdC8vIE5vdCBpbnRlcmVzdGVkIGluIGRvaW5nIGNvbHVtbiB3aWR0aCBjYWxjdWxhdGlvbiBpZiBhdXRvLXdpZHRoIGlzIGRpc2FibGVkXG5cdGlmICghIHNldHRpbmdzLm9GZWF0dXJlcy5iQXV0b1dpZHRoKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dmFyXG5cdFx0dGFibGUgPSBzZXR0aW5ncy5uVGFibGUsXG5cdFx0Y29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucyxcblx0XHRzY3JvbGwgPSBzZXR0aW5ncy5vU2Nyb2xsLFxuXHRcdHNjcm9sbFkgPSBzY3JvbGwuc1ksXG5cdFx0c2Nyb2xsWCA9IHNjcm9sbC5zWCxcblx0XHRzY3JvbGxYSW5uZXIgPSBzY3JvbGwuc1hJbm5lcixcblx0XHR2aXNpYmxlQ29sdW1ucyA9IF9mbkdldENvbHVtbnMoIHNldHRpbmdzLCAnYlZpc2libGUnICksXG5cdFx0dGFibGVXaWR0aEF0dHIgPSB0YWJsZS5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyksIC8vIGZyb20gRE9NIGVsZW1lbnRcblx0XHR0YWJsZUNvbnRhaW5lciA9IHRhYmxlLnBhcmVudE5vZGUsXG5cdFx0aSwgY29sdW1uLCBjb2x1bW5JZHg7XG5cdFx0XG5cdHZhciBzdHlsZVdpZHRoID0gdGFibGUuc3R5bGUud2lkdGg7XG5cdHZhciBjb250YWluZXJXaWR0aCA9IF9mbldyYXBwZXJXaWR0aChzZXR0aW5ncyk7XG5cblx0Ly8gRG9uJ3QgcmUtcnVuIGZvciB0aGUgc2FtZSB3aWR0aCBhcyB0aGUgbGFzdCB0aW1lXG5cdGlmIChjb250YWluZXJXaWR0aCA9PT0gc2V0dGluZ3MuY29udGFpbmVyV2lkdGgpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRzZXR0aW5ncy5jb250YWluZXJXaWR0aCA9IGNvbnRhaW5lcldpZHRoO1xuXG5cdC8vIElmIHRoZXJlIGlzIG5vIHdpZHRoIGFwcGxpZWQgYXMgYSBDU1Mgc3R5bGUgb3IgYXMgYW4gYXR0cmlidXRlLCB3ZSBhc3N1bWUgdGhhdFxuXHQvLyB0aGUgd2lkdGggaXMgaW50ZW5kZWQgdG8gYmUgMTAwJSwgd2hpY2ggaXMgdXN1YWxseSBpcyBpbiBDU1MsIGJ1dCBpdCBpcyB2ZXJ5XG5cdC8vIGRpZmZpY3VsdCB0byBjb3JyZWN0bHkgcGFyc2UgdGhlIHJ1bGVzIHRvIGdldCB0aGUgZmluYWwgcmVzdWx0LlxuXHRpZiAoICEgc3R5bGVXaWR0aCAmJiAhIHRhYmxlV2lkdGhBdHRyKSB7XG5cdFx0dGFibGUuc3R5bGUud2lkdGggPSAnMTAwJSc7XG5cdFx0c3R5bGVXaWR0aCA9ICcxMDAlJztcblx0fVxuXG5cdGlmICggc3R5bGVXaWR0aCAmJiBzdHlsZVdpZHRoLmluZGV4T2YoJyUnKSAhPT0gLTEgKSB7XG5cdFx0dGFibGVXaWR0aEF0dHIgPSBzdHlsZVdpZHRoO1xuXHR9XG5cblx0Ly8gTGV0IHBsdWctaW5zIGtub3cgdGhhdCB3ZSBhcmUgZG9pbmcgYSByZWNhbGMsIGluIGNhc2UgdGhleSBoYXZlIGNoYW5nZWQgYW55IG9mIHRoZVxuXHQvLyB2aXNpYmxlIGNvbHVtbnMgdGhlaXIgb3duIHdheSAoZS5nLiBSZXNwb25zaXZlIHVzZXMgZGlzcGxheTpub25lKS5cblx0X2ZuQ2FsbGJhY2tGaXJlKFxuXHRcdHNldHRpbmdzLFxuXHRcdG51bGwsXG5cdFx0J2NvbHVtbi1jYWxjJyxcblx0XHR7dmlzaWJsZTogdmlzaWJsZUNvbHVtbnN9LFxuXHRcdGZhbHNlXG5cdCk7XG5cblx0Ly8gQ29uc3RydWN0IGEgc2luZ2xlIHJvdywgd29yc3QgY2FzZSwgdGFibGUgd2l0aCB0aGUgd2lkZXN0XG5cdC8vIG5vZGUgaW4gdGhlIGRhdGEsIGFzc2lnbiBhbnkgdXNlciBkZWZpbmVkIHdpZHRocywgdGhlbiBpbnNlcnQgaXQgaW50b1xuXHQvLyB0aGUgRE9NIGFuZCBhbGxvdyB0aGUgYnJvd3NlciB0byBkbyBhbGwgdGhlIGhhcmQgd29yayBvZiBjYWxjdWxhdGluZ1xuXHQvLyB0YWJsZSB3aWR0aHNcblx0dmFyIHRtcFRhYmxlID0gJCh0YWJsZS5jbG9uZU5vZGUoKSlcblx0XHQuY3NzKCAndmlzaWJpbGl0eScsICdoaWRkZW4nIClcblx0XHQucmVtb3ZlQXR0ciggJ2lkJyApO1xuXG5cdC8vIENsZWFuIHVwIHRoZSB0YWJsZSBib2R5XG5cdHRtcFRhYmxlLmFwcGVuZCgnPHRib2R5PicpXG5cdHZhciB0ciA9ICQoJzx0ci8+JykuYXBwZW5kVG8oIHRtcFRhYmxlLmZpbmQoJ3Rib2R5JykgKTtcblxuXHQvLyBDbG9uZSB0aGUgdGFibGUgaGVhZGVyIGFuZCBmb290ZXIgLSB3ZSBjYW4ndCB1c2UgdGhlIGhlYWRlciAvIGZvb3RlclxuXHQvLyBmcm9tIHRoZSBjbG9uZWQgdGFibGUsIHNpbmNlIGlmIHNjcm9sbGluZyBpcyBhY3RpdmUsIHRoZSB0YWJsZSdzXG5cdC8vIHJlYWwgaGVhZGVyIGFuZCBmb290ZXIgYXJlIGNvbnRhaW5lZCBpbiBkaWZmZXJlbnQgdGFibGUgdGFnc1xuXHR0bXBUYWJsZVxuXHRcdC5hcHBlbmQoICQoc2V0dGluZ3MublRIZWFkKS5jbG9uZSgpIClcblx0XHQuYXBwZW5kKCAkKHNldHRpbmdzLm5URm9vdCkuY2xvbmUoKSApO1xuXG5cdC8vIFJlbW92ZSBhbnkgYXNzaWduZWQgd2lkdGhzIGZyb20gdGhlIGZvb3RlciAoZnJvbSBzY3JvbGxpbmcpXG5cdHRtcFRhYmxlLmZpbmQoJ3Rmb290IHRoLCB0Zm9vdCB0ZCcpLmNzcygnd2lkdGgnLCAnJyk7XG5cblx0Ly8gQXBwbHkgY3VzdG9tIHNpemluZyB0byB0aGUgY2xvbmVkIGhlYWRlclxuXHR0bXBUYWJsZS5maW5kKCd0aGVhZCB0aCwgdGhlYWQgdGQnKS5lYWNoKCBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gR2V0IHRoZSBgd2lkdGhgIGZyb20gdGhlIGhlYWRlciBsYXlvdXRcblx0XHR2YXIgd2lkdGggPSBfZm5Db2x1bW5zU3VtV2lkdGgoIHNldHRpbmdzLCB0aGlzLCB0cnVlLCBmYWxzZSApO1xuXG5cdFx0aWYgKCB3aWR0aCApIHtcblx0XHRcdHRoaXMuc3R5bGUud2lkdGggPSB3aWR0aDtcblxuXHRcdFx0Ly8gRm9yIHNjcm9sbFggd2UgbmVlZCB0byBmb3JjZSB0aGUgY29sdW1uIHdpZHRoIG90aGVyd2lzZSB0aGVcblx0XHRcdC8vIGJyb3dzZXIgd2lsbCBjb2xsYXBzZSBpdC4gSWYgdGhpcyB3aWR0aCBpcyBzbWFsbGVyIHRoYW4gdGhlXG5cdFx0XHQvLyB3aWR0aCB0aGUgY29sdW1uIHJlcXVpcmVzLCB0aGVuIGl0IHdpbGwgaGF2ZSBubyBlZmZlY3Rcblx0XHRcdGlmICggc2Nyb2xsWCApIHtcblx0XHRcdFx0dGhpcy5zdHlsZS5taW5XaWR0aCA9IHdpZHRoO1xuXG5cdFx0XHRcdCQoIHRoaXMgKS5hcHBlbmQoICQoJzxkaXYvPicpLmNzcygge1xuXHRcdFx0XHRcdHdpZHRoOiB3aWR0aCxcblx0XHRcdFx0XHRtYXJnaW46IDAsXG5cdFx0XHRcdFx0cGFkZGluZzogMCxcblx0XHRcdFx0XHRib3JkZXI6IDAsXG5cdFx0XHRcdFx0aGVpZ2h0OiAxXG5cdFx0XHRcdH0gKSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHRoaXMuc3R5bGUud2lkdGggPSAnJztcblx0XHR9XG5cdH0gKTtcblxuXHQvLyBGaW5kIHRoZSB3aWRlc3QgcGllY2Ugb2YgZGF0YSBmb3IgZWFjaCBjb2x1bW4gYW5kIHB1dCBpdCBpbnRvIHRoZSB0YWJsZVxuXHRmb3IgKCBpPTAgOyBpPHZpc2libGVDb2x1bW5zLmxlbmd0aCA7IGkrKyApIHtcblx0XHRjb2x1bW5JZHggPSB2aXNpYmxlQ29sdW1uc1tpXTtcblx0XHRjb2x1bW4gPSBjb2x1bW5zWyBjb2x1bW5JZHggXTtcblxuXHRcdHZhciBsb25nZXN0ID0gX2ZuR2V0TWF4TGVuU3RyaW5nKHNldHRpbmdzLCBjb2x1bW5JZHgpO1xuXHRcdHZhciBhdXRvQ2xhc3MgPSBfZXh0LnR5cGUuY2xhc3NOYW1lW2NvbHVtbi5zVHlwZV07XG5cdFx0dmFyIHRleHQgPSBsb25nZXN0ICsgY29sdW1uLnNDb250ZW50UGFkZGluZztcblx0XHR2YXIgaW5zZXJ0ID0gbG9uZ2VzdC5pbmRleE9mKCc8JykgPT09IC0xXG5cdFx0XHQ/IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpXG5cdFx0XHQ6IHRleHRcblx0XHRcblx0XHQkKCc8dGQvPicpXG5cdFx0XHQuYWRkQ2xhc3MoYXV0b0NsYXNzKVxuXHRcdFx0LmFkZENsYXNzKGNvbHVtbi5zQ2xhc3MpXG5cdFx0XHQuYXBwZW5kKGluc2VydClcblx0XHRcdC5hcHBlbmRUbyh0cik7XG5cdH1cblxuXHQvLyBUaWR5IHRoZSB0ZW1wb3JhcnkgdGFibGUgLSByZW1vdmUgbmFtZSBhdHRyaWJ1dGVzIHNvIHRoZXJlIGFyZW4ndFxuXHQvLyBkdXBsaWNhdGVkIGluIHRoZSBkb20gKHJhZGlvIGVsZW1lbnRzIGZvciBleGFtcGxlKVxuXHQkKCdbbmFtZV0nLCB0bXBUYWJsZSkucmVtb3ZlQXR0cignbmFtZScpO1xuXG5cdC8vIFRhYmxlIGhhcyBiZWVuIGJ1aWx0LCBhdHRhY2ggdG8gdGhlIGRvY3VtZW50IHNvIHdlIGNhbiB3b3JrIHdpdGggaXQuXG5cdC8vIEEgaG9sZGluZyBlbGVtZW50IGlzIHVzZWQsIHBvc2l0aW9uZWQgYXQgdGhlIHRvcCBvZiB0aGUgY29udGFpbmVyXG5cdC8vIHdpdGggbWluaW1hbCBoZWlnaHQsIHNvIGl0IGhhcyBubyBlZmZlY3Qgb24gaWYgdGhlIGNvbnRhaW5lciBzY3JvbGxzXG5cdC8vIG9yIG5vdC4gT3RoZXJ3aXNlIGl0IG1pZ2h0IHRyaWdnZXIgc2Nyb2xsaW5nIHdoZW4gaXQgYWN0dWFsbHkgaXNuJ3Rcblx0Ly8gbmVlZGVkXG5cdHZhciBob2xkZXIgPSAkKCc8ZGl2Lz4nKS5jc3MoIHNjcm9sbFggfHwgc2Nyb2xsWSA/XG5cdFx0XHR7XG5cdFx0XHRcdHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuXHRcdFx0XHR0b3A6IDAsXG5cdFx0XHRcdGxlZnQ6IDAsXG5cdFx0XHRcdGhlaWdodDogMSxcblx0XHRcdFx0cmlnaHQ6IDAsXG5cdFx0XHRcdG92ZXJmbG93OiAnaGlkZGVuJ1xuXHRcdFx0fSA6XG5cdFx0XHR7fVxuXHRcdClcblx0XHQuYXBwZW5kKCB0bXBUYWJsZSApXG5cdFx0LmFwcGVuZFRvKCB0YWJsZUNvbnRhaW5lciApO1xuXG5cdC8vIFdoZW4gc2Nyb2xsaW5nIChYIG9yIFkpIHdlIHdhbnQgdG8gc2V0IHRoZSB3aWR0aCBvZiB0aGUgdGFibGUgYXMgXG5cdC8vIGFwcHJvcHJpYXRlLiBIb3dldmVyLCB3aGVuIG5vdCBzY3JvbGxpbmcgbGVhdmUgdGhlIHRhYmxlIHdpZHRoIGFzIGl0XG5cdC8vIGlzLiBUaGlzIHJlc3VsdHMgaW4gc2xpZ2h0bHkgZGlmZmVyZW50LCBidXQgSSB0aGluayBjb3JyZWN0IGJlaGF2aW91clxuXHRpZiAoIHNjcm9sbFggJiYgc2Nyb2xsWElubmVyICkge1xuXHRcdHRtcFRhYmxlLndpZHRoKCBzY3JvbGxYSW5uZXIgKTtcblx0fVxuXHRlbHNlIGlmICggc2Nyb2xsWCApIHtcblx0XHR0bXBUYWJsZS5jc3MoICd3aWR0aCcsICdhdXRvJyApO1xuXHRcdHRtcFRhYmxlLnJlbW92ZUF0dHIoJ3dpZHRoJyk7XG5cblx0XHQvLyBJZiB0aGVyZSBpcyBubyB3aWR0aCBhdHRyaWJ1dGUgb3Igc3R5bGUsIHRoZW4gYWxsb3cgdGhlIHRhYmxlIHRvXG5cdFx0Ly8gY29sbGFwc2Vcblx0XHRpZiAoIHRtcFRhYmxlLm91dGVyV2lkdGgoKSA8IHRhYmxlQ29udGFpbmVyLmNsaWVudFdpZHRoICYmIHRhYmxlV2lkdGhBdHRyICkge1xuXHRcdFx0dG1wVGFibGUub3V0ZXJXaWR0aCggdGFibGVDb250YWluZXIuY2xpZW50V2lkdGggKTtcblx0XHR9XG5cdH1cblx0ZWxzZSBpZiAoIHNjcm9sbFkgKSB7XG5cdFx0dG1wVGFibGUub3V0ZXJXaWR0aCggdGFibGVDb250YWluZXIuY2xpZW50V2lkdGggKTtcblx0fVxuXHRlbHNlIGlmICggdGFibGVXaWR0aEF0dHIgKSB7XG5cdFx0dG1wVGFibGUub3V0ZXJXaWR0aCggdGFibGVXaWR0aEF0dHIgKTtcblx0fVxuXG5cdC8vIEdldCB0aGUgd2lkdGggb2YgZWFjaCBjb2x1bW4gaW4gdGhlIGNvbnN0cnVjdGVkIHRhYmxlXG5cdHZhciB0b3RhbCA9IDA7XG5cdHZhciBib2R5Q2VsbHMgPSB0bXBUYWJsZS5maW5kKCd0Ym9keSB0cicpLmVxKDApLmNoaWxkcmVuKCk7XG5cblx0Zm9yICggaT0wIDsgaTx2aXNpYmxlQ29sdW1ucy5sZW5ndGggOyBpKysgKSB7XG5cdFx0Ly8gVXNlIGdldEJvdW5kaW5nIGZvciBzdWItcGl4ZWwgYWNjdXJhY3ksIHdoaWNoIHdlIHRoZW4gd2FudCB0byByb3VuZCB1cCFcblx0XHR2YXIgYm91bmRpbmcgPSBib2R5Q2VsbHNbaV0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG5cblx0XHQvLyBUb3RhbCBpcyB0cmFja2VkIHRvIHJlbW92ZSBhbnkgc3ViLXBpeGVsIGVycm9ycyBhcyB0aGUgb3V0ZXJXaWR0aFxuXHRcdC8vIG9mIHRoZSB0YWJsZSBtaWdodCBub3QgZXF1YWwgdGhlIHRvdGFsIGdpdmVuIGhlcmVcblx0XHR0b3RhbCArPSBib3VuZGluZztcblxuXHRcdC8vIFdpZHRoIGZvciBlYWNoIGNvbHVtbiB0byB1c2Vcblx0XHRjb2x1bW5zWyB2aXNpYmxlQ29sdW1uc1tpXSBdLnNXaWR0aCA9IF9mblN0cmluZ1RvQ3NzKCBib3VuZGluZyApO1xuXHR9XG5cblx0dGFibGUuc3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0NzcyggdG90YWwgKTtcblxuXHQvLyBGaW5pc2hlZCB3aXRoIHRoZSB0YWJsZSAtIGRpdGNoIGl0XG5cdGhvbGRlci5yZW1vdmUoKTtcblxuXHQvLyBJZiB0aGVyZSBpcyBhIHdpZHRoIGF0dHIsIHdlIHdhbnQgdG8gYXR0YWNoIGFuIGV2ZW50IGxpc3RlbmVyIHdoaWNoXG5cdC8vIGFsbG93cyB0aGUgdGFibGUgc2l6aW5nIHRvIGF1dG9tYXRpY2FsbHkgYWRqdXN0IHdoZW4gdGhlIHdpbmRvdyBpc1xuXHQvLyByZXNpemVkLiBVc2UgdGhlIHdpZHRoIGF0dHIgcmF0aGVyIHRoYW4gQ1NTLCBzaW5jZSB3ZSBjYW4ndCBrbm93IGlmIHRoZVxuXHQvLyBDU1MgaXMgYSByZWxhdGl2ZSB2YWx1ZSBvciBhYnNvbHV0ZSAtIERPTSByZWFkIGlzIGFsd2F5cyBweC5cblx0aWYgKCB0YWJsZVdpZHRoQXR0ciApIHtcblx0XHR0YWJsZS5zdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKCB0YWJsZVdpZHRoQXR0ciApO1xuXHR9XG5cblx0aWYgKCAodGFibGVXaWR0aEF0dHIgfHwgc2Nyb2xsWCkgJiYgISBzZXR0aW5ncy5fcmVzekV2dCApIHtcblx0XHR2YXIgcmVzaXplID0gRGF0YVRhYmxlLnV0aWwudGhyb3R0bGUoIGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBuZXdXaWR0aCA9IF9mbldyYXBwZXJXaWR0aChzZXR0aW5ncyk7XG5cblx0XHRcdC8vIERvbid0IGRvIGl0IGlmIGRlc3Ryb3lpbmcgb3IgdGhlIGNvbnRhaW5lciB3aWR0aCBpcyAwXG5cdFx0XHRpZiAoISBzZXR0aW5ncy5iRGVzdHJveWluZyAmJiBuZXdXaWR0aCAhPT0gMCkge1xuXHRcdFx0XHRfZm5BZGp1c3RDb2x1bW5TaXppbmcoIHNldHRpbmdzICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdFx0Ly8gRm9yIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBpdCAofjIwMjAgb253YXJkcyBmb3Igd2lkZSBzdXBwb3J0KSB3ZSBjYW4gd2F0Y2ggZm9yIHRoZVxuXHRcdC8vIGNvbnRhaW5lciBjaGFuZ2luZyB3aWR0aC5cblx0XHRpZiAod2luZG93LlJlc2l6ZU9ic2VydmVyKSB7XG5cdFx0XHQvLyBUaGlzIGlzIGEgdHJpY2t5IGJlYXN0IC0gaWYgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSB3aGVuIGAub2JzZXJ2ZSgpYCBpcyBjYWxsZWQsXG5cdFx0XHQvLyB0aGVuIHRoZSBjYWxsYmFjayBpcyBpbW1lZGlhdGVseSBydW4uIFdoaWNoIHdlIGRvbid0IHdhbnQuIElmIHRoZSBlbGVtZW50IGlzbid0XG5cdFx0XHQvLyB2aXNpYmxlLCB0aGVuIGl0IGlzbid0IHJ1biwgYnV0IHdlIHdhbnQgaXQgdG8gcnVuIHdoZW4gaXQgaXMgdGhlbiBtYWRlIHZpc2libGUuXG5cdFx0XHQvLyBUaGlzIGZsYWcgYWxsb3dzIHRoZSBhYm92ZSB0byBiZSBzYXRpc2ZpZWQuXG5cdFx0XHR2YXIgZmlyc3QgPSAkKHNldHRpbmdzLm5UYWJsZVdyYXBwZXIpLmlzKCc6dmlzaWJsZScpO1xuXG5cdFx0XHQvLyBVc2UgYW4gZW1wdHkgZGl2IHRvIGF0dGFjaCB0aGUgb2JzZXJ2ZXIgc28gaXQgaXNuJ3QgaW1wYWN0ZWQgYnkgaGVpZ2h0IGNoYW5nZXNcblx0XHRcdHZhciByZXNpemVyID0gJCgnPGRpdj4nKVxuXHRcdFx0XHQuY3NzKHtcblx0XHRcdFx0XHR3aWR0aDogJzEwMCUnLFxuXHRcdFx0XHRcdGhlaWdodDogMFxuXHRcdFx0XHR9KVxuXHRcdFx0XHQuYWRkQ2xhc3MoJ2R0LWF1dG9zaXplJylcblx0XHRcdFx0LmFwcGVuZFRvKHNldHRpbmdzLm5UYWJsZVdyYXBwZXIpO1xuXG5cdFx0XHRzZXR0aW5ncy5yZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRpZiAoZmlyc3QpIHtcblx0XHRcdFx0XHRmaXJzdCA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHJlc2l6ZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0c2V0dGluZ3MucmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShyZXNpemVyWzBdKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHQvLyBGb3Igb2xkIGJyb3dzZXJzLCB0aGUgYmVzdCB3ZSBjYW4gZG8gaXMgbGlzdGVuIGZvciBhIHdpbmRvdyByZXNpemVcblx0XHRcdCQod2luZG93KS5vbigncmVzaXplLkRULScrc2V0dGluZ3Muc0luc3RhbmNlLCByZXNpemUpO1xuXHRcdH1cblxuXHRcdHNldHRpbmdzLl9yZXN6RXZ0ID0gdHJ1ZTtcblx0fVxufVxuXG4vKipcbiAqIEdldCB0aGUgd2lkdGggb2YgdGhlIERhdGFUYWJsZXMgd3JhcHBlciBlbGVtZW50XG4gKlxuICogQHBhcmFtIHsqfSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogQHJldHVybnMgV2lkdGhcbiAqL1xuZnVuY3Rpb24gX2ZuV3JhcHBlcldpZHRoKHNldHRpbmdzKSB7XG5cdHJldHVybiAkKHNldHRpbmdzLm5UYWJsZVdyYXBwZXIpLmlzKCc6dmlzaWJsZScpXG5cdFx0PyAkKHNldHRpbmdzLm5UYWJsZVdyYXBwZXIpLndpZHRoKClcblx0XHQ6IDA7XG59XG5cbi8qKlxuICogR2V0IHRoZSBtYXhpbXVtIHN0cmxlbiBmb3IgZWFjaCBkYXRhIGNvbHVtblxuICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBwYXJhbSB7aW50fSBjb2xJZHggY29sdW1uIG9mIGludGVyZXN0XG4gKiAgQHJldHVybnMge3N0cmluZ30gc3RyaW5nIG9mIHRoZSBtYXggbGVuZ3RoXG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkdldE1heExlblN0cmluZyggc2V0dGluZ3MsIGNvbElkeCApXG57XG5cdHZhciBjb2x1bW4gPSBzZXR0aW5ncy5hb0NvbHVtbnNbY29sSWR4XTtcblxuXHRpZiAoISBjb2x1bW4ubWF4TGVuU3RyaW5nKSB7XG5cdFx0dmFyIHMsIG1heD0nJywgbWF4TGVuID0gLTE7XG5cdFxuXHRcdGZvciAoIHZhciBpPTAsIGllbj1zZXR0aW5ncy5haURpc3BsYXlNYXN0ZXIubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHR2YXIgcm93SWR4ID0gc2V0dGluZ3MuYWlEaXNwbGF5TWFzdGVyW2ldO1xuXHRcdFx0dmFyIGRhdGEgPSBfZm5HZXRSb3dEaXNwbGF5KHNldHRpbmdzLCByb3dJZHgpW2NvbElkeF07XG5cblx0XHRcdHZhciBjZWxsU3RyaW5nID0gZGF0YSAmJiB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiYgZGF0YS5ub2RlVHlwZVxuXHRcdFx0XHQ/IGRhdGEuaW5uZXJIVE1MXG5cdFx0XHRcdDogZGF0YSsnJztcblxuXHRcdFx0Ly8gUmVtb3ZlIGlkIC8gbmFtZSBhdHRyaWJ1dGVzIGZyb20gZWxlbWVudHMgc28gdGhleVxuXHRcdFx0Ly8gZG9uJ3QgaW50ZXJmZXJlIHdpdGggZXhpc3RpbmcgZWxlbWVudHNcblx0XHRcdGNlbGxTdHJpbmcgPSBjZWxsU3RyaW5nXG5cdFx0XHRcdC5yZXBsYWNlKC9pZD1cIi4qP1wiL2csICcnKVxuXHRcdFx0XHQucmVwbGFjZSgvbmFtZT1cIi4qP1wiL2csICcnKTtcblxuXHRcdFx0cyA9IF9zdHJpcEh0bWwoY2VsbFN0cmluZylcblx0XHRcdFx0LnJlcGxhY2UoIC8mbmJzcDsvZywgJyAnICk7XG5cdFxuXHRcdFx0aWYgKCBzLmxlbmd0aCA+IG1heExlbiApIHtcblx0XHRcdFx0Ly8gV2Ugd2FudCB0aGUgSFRNTCBpbiB0aGUgc3RyaW5nLCBidXQgdGhlIGxlbmd0aCB0aGF0XG5cdFx0XHRcdC8vIGlzIGltcG9ydGFudCBpcyB0aGUgc3RyaXBwZWQgc3RyaW5nXG5cdFx0XHRcdG1heCA9IGNlbGxTdHJpbmc7XG5cdFx0XHRcdG1heExlbiA9IHMubGVuZ3RoO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNvbHVtbi5tYXhMZW5TdHJpbmcgPSBtYXg7XG5cdH1cblxuXHRyZXR1cm4gY29sdW1uLm1heExlblN0cmluZztcbn1cblxuXG4vKipcbiAqIEFwcGVuZCBhIENTUyB1bml0IChvbmx5IGlmIHJlcXVpcmVkKSB0byBhIHN0cmluZ1xuICogIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSB0byBjc3MtaWZ5XG4gKiAgQHJldHVybnMge3N0cmluZ30gdmFsdWUgd2l0aCBjc3MgdW5pdFxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5TdHJpbmdUb0NzcyggcyApXG57XG5cdGlmICggcyA9PT0gbnVsbCApIHtcblx0XHRyZXR1cm4gJzBweCc7XG5cdH1cblxuXHRpZiAoIHR5cGVvZiBzID09ICdudW1iZXInICkge1xuXHRcdHJldHVybiBzIDwgMCA/XG5cdFx0XHQnMHB4JyA6XG5cdFx0XHRzKydweCc7XG5cdH1cblxuXHQvLyBDaGVjayBpdCBoYXMgYSB1bml0IGNoYXJhY3RlciBhbHJlYWR5XG5cdHJldHVybiBzLm1hdGNoKC9cXGQkLykgP1xuXHRcdHMrJ3B4JyA6XG5cdFx0cztcbn1cblxuLyoqXG4gKiBSZS1pbnNlcnQgdGhlIGBjb2xgIGVsZW1lbnRzIGZvciBjdXJyZW50IHZpc2liaWxpdHlcbiAqXG4gKiBAcGFyYW0geyp9IHNldHRpbmdzIERUIHNldHRpbmdzXG4gKi9cbmZ1bmN0aW9uIF9jb2xHcm91cCggc2V0dGluZ3MgKSB7XG5cdHZhciBjb2xzID0gc2V0dGluZ3MuYW9Db2x1bW5zO1xuXG5cdHNldHRpbmdzLmNvbGdyb3VwLmVtcHR5KCk7XG5cblx0Zm9yIChpPTAgOyBpPGNvbHMubGVuZ3RoIDsgaSsrKSB7XG5cdFx0aWYgKGNvbHNbaV0uYlZpc2libGUpIHtcblx0XHRcdHNldHRpbmdzLmNvbGdyb3VwLmFwcGVuZChjb2xzW2ldLmNvbEVsKTtcblx0XHR9XG5cdH1cbn1cblxuXG5mdW5jdGlvbiBfZm5Tb3J0SW5pdCggc2V0dGluZ3MgKSB7XG5cdHZhciB0YXJnZXQgPSBzZXR0aW5ncy5uVEhlYWQ7XG5cdHZhciBoZWFkZXJSb3dzID0gdGFyZ2V0LnF1ZXJ5U2VsZWN0b3JBbGwoJ3RyJyk7XG5cdHZhciB0aXRsZVJvdyA9IHNldHRpbmdzLnRpdGxlUm93O1xuXHR2YXIgbm90U2VsZWN0b3IgPSAnOm5vdChbZGF0YS1kdC1vcmRlcj1cImRpc2FibGVcIl0pOm5vdChbZGF0YS1kdC1vcmRlcj1cImljb24tb25seVwiXSknO1xuXHRcblx0Ly8gTGVnYWN5IHN1cHBvcnQgZm9yIGBvcmRlckNlbGxzVG9wYFxuXHRpZiAodGl0bGVSb3cgPT09IHRydWUpIHtcblx0XHR0YXJnZXQgPSBoZWFkZXJSb3dzWzBdO1xuXHR9XG5cdGVsc2UgaWYgKHRpdGxlUm93ID09PSBmYWxzZSkge1xuXHRcdHRhcmdldCA9IGhlYWRlclJvd3NbIGhlYWRlclJvd3MubGVuZ3RoIC0gMSBdO1xuXHR9XG5cdGVsc2UgaWYgKHRpdGxlUm93ICE9PSBudWxsKSB7XG5cdFx0dGFyZ2V0ID0gaGVhZGVyUm93c1t0aXRsZVJvd107XG5cdH1cblx0Ly8gZWxzZSAtIGFsbCByb3dzXG5cblx0aWYgKHNldHRpbmdzLm9yZGVySGFuZGxlcikge1xuXHRcdF9mblNvcnRBdHRhY2hMaXN0ZW5lcihcblx0XHRcdHNldHRpbmdzLFxuXHRcdFx0dGFyZ2V0LFxuXHRcdFx0dGFyZ2V0ID09PSBzZXR0aW5ncy5uVEhlYWRcblx0XHRcdFx0PyAndHInK25vdFNlbGVjdG9yKycgdGgnK25vdFNlbGVjdG9yKycsIHRyJytub3RTZWxlY3RvcisnIHRkJytub3RTZWxlY3RvclxuXHRcdFx0XHQ6ICd0aCcrbm90U2VsZWN0b3IrJywgdGQnK25vdFNlbGVjdG9yXG5cdFx0KTtcblx0fVxuXG5cdC8vIE5lZWQgdG8gcmVzb2x2ZSB0aGUgdXNlciBpbnB1dCBhcnJheSBpbnRvIG91ciBpbnRlcm5hbCBzdHJ1Y3R1cmVcblx0dmFyIG9yZGVyID0gW107XG5cdF9mblNvcnRSZXNvbHZlKCBzZXR0aW5ncywgb3JkZXIsIHNldHRpbmdzLmFhU29ydGluZyApO1xuXG5cdHNldHRpbmdzLmFhU29ydGluZyA9IG9yZGVyO1xufVxuXG5cbmZ1bmN0aW9uIF9mblNvcnRBdHRhY2hMaXN0ZW5lcihzZXR0aW5ncywgbm9kZSwgc2VsZWN0b3IsIGNvbHVtbiwgY2FsbGJhY2spIHtcblx0X2ZuQmluZEFjdGlvbiggbm9kZSwgc2VsZWN0b3IsIGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIHJ1biA9IGZhbHNlO1xuXHRcdHZhciBjb2x1bW5zID0gY29sdW1uID09PSB1bmRlZmluZWRcblx0XHRcdD8gX2ZuQ29sdW1uc0Zyb21IZWFkZXIoIGUudGFyZ2V0IClcblx0XHRcdDogQXJyYXkuaXNBcnJheShjb2x1bW4pXG5cdFx0XHRcdD8gY29sdW1uXG5cdFx0XHRcdDogW2NvbHVtbl07XG5cblx0XHRpZiAoIGNvbHVtbnMubGVuZ3RoICkge1xuXHRcdFx0Zm9yICggdmFyIGk9MCwgaWVuPWNvbHVtbnMubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdHZhciByZXQgPSBfZm5Tb3J0QWRkKCBzZXR0aW5ncywgY29sdW1uc1tpXSwgaSwgZS5zaGlmdEtleSApO1xuXG5cdFx0XHRcdGlmIChyZXQgIT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0cnVuID0gdHJ1ZTtcblx0XHRcdFx0fVx0XHRcdFx0XHRcblxuXHRcdFx0XHQvLyBJZiB0aGUgZmlyc3QgZW50cnkgaXMgbm8gc29ydCwgdGhlbiBzdWJzZXF1ZW50XG5cdFx0XHRcdC8vIHNvcnQgY29sdW1ucyBhcmUgaWdub3JlZFxuXHRcdFx0XHRpZiAoc2V0dGluZ3MuYWFTb3J0aW5nLmxlbmd0aCA9PT0gMSAmJiBzZXR0aW5ncy5hYVNvcnRpbmdbMF1bMV0gPT09ICcnKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHJ1bikge1xuXHRcdFx0XHRfZm5Qcm9jZXNzaW5nUnVuKHNldHRpbmdzLCB0cnVlLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0X2ZuU29ydCggc2V0dGluZ3MgKTtcblx0XHRcdFx0XHRfZm5Tb3J0RGlzcGxheSggc2V0dGluZ3MsIHNldHRpbmdzLmFpRGlzcGxheSApO1xuXG5cdFx0XHRcdFx0X2ZuUmVEcmF3KCBzZXR0aW5ncywgZmFsc2UsIGZhbHNlICk7XG5cblx0XHRcdFx0XHRpZiAoY2FsbGJhY2spIHtcblx0XHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cdH0gKTtcbn1cblxuLyoqXG4gKiBTb3J0IHRoZSBkaXNwbGF5IGFycmF5IHRvIG1hdGNoIHRoZSBtYXN0ZXIncyBvcmRlclxuICogQHBhcmFtIHsqfSBzZXR0aW5nc1xuICovXG5mdW5jdGlvbiBfZm5Tb3J0RGlzcGxheShzZXR0aW5ncywgZGlzcGxheSkge1xuXHRpZiAoZGlzcGxheS5sZW5ndGggPCAyKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dmFyIG1hc3RlciA9IHNldHRpbmdzLmFpRGlzcGxheU1hc3Rlcjtcblx0dmFyIG1hc3Rlck1hcCA9IHt9O1xuXHR2YXIgbWFwID0ge307XG5cdHZhciBpO1xuXG5cdC8vIFJhdGhlciB0aGFuIG5lZWRpbmcgYW4gYGluZGV4T2ZgIG9uIG1hc3RlciBhcnJheSwgd2UgY2FuIGNyZWF0ZSBhIG1hcFxuXHRmb3IgKGk9MCA7IGk8bWFzdGVyLmxlbmd0aCA7IGkrKykge1xuXHRcdG1hc3Rlck1hcFttYXN0ZXJbaV1dID0gaTtcblx0fVxuXG5cdC8vIEFuZCB0aGVuIGNhY2hlIHdoYXQgd291bGQgYmUgdGhlIGluZGV4T2YgZm9tIHRoZSBkaXNwbGF5XG5cdGZvciAoaT0wIDsgaTxkaXNwbGF5Lmxlbmd0aCA7IGkrKykge1xuXHRcdG1hcFtkaXNwbGF5W2ldXSA9IG1hc3Rlck1hcFtkaXNwbGF5W2ldXTtcblx0fVxuXG5cdGRpc3BsYXkuc29ydChmdW5jdGlvbihhLCBiKXtcblx0XHQvLyBTaG9ydCB2ZXJzaW9uIG9mIHRoaXMgZnVuY3Rpb24gaXMgc2ltcGx5IGBtYXN0ZXIuaW5kZXhPZihhKSAtIG1hc3Rlci5pbmRleE9mKGIpO2Bcblx0XHRyZXR1cm4gbWFwW2FdIC0gbWFwW2JdO1xuXHR9KTtcbn1cblxuXG5mdW5jdGlvbiBfZm5Tb3J0UmVzb2x2ZSAoc2V0dGluZ3MsIG5lc3RlZFNvcnQsIHNvcnQpIHtcblx0dmFyIHB1c2ggPSBmdW5jdGlvbiAoIGEgKSB7XG5cdFx0aWYgKCQuaXNQbGFpbk9iamVjdChhKSkge1xuXHRcdFx0aWYgKGEuaWR4ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Ly8gSW5kZXggYmFzZWQgb3JkZXJpbmdcblx0XHRcdFx0bmVzdGVkU29ydC5wdXNoKFthLmlkeCwgYS5kaXJdKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKGEubmFtZSkge1xuXHRcdFx0XHQvLyBOYW1lIGJhc2VkIG9yZGVyaW5nXG5cdFx0XHRcdHZhciBjb2xzID0gX3BsdWNrKCBzZXR0aW5ncy5hb0NvbHVtbnMsICdzTmFtZScpO1xuXHRcdFx0XHR2YXIgaWR4ID0gY29scy5pbmRleE9mKGEubmFtZSk7XG5cblx0XHRcdFx0aWYgKGlkeCAhPT0gLTEpIHtcblx0XHRcdFx0XHRuZXN0ZWRTb3J0LnB1c2goW2lkeCwgYS5kaXJdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIFBsYWluIGNvbHVtbiBpbmRleCBhbmQgZGlyZWN0aW9uIHBhaXJcblx0XHRcdG5lc3RlZFNvcnQucHVzaChhKTtcblx0XHR9XG5cdH07XG5cblx0aWYgKCAkLmlzUGxhaW5PYmplY3Qoc29ydCkgKSB7XG5cdFx0Ly8gT2JqZWN0XG5cdFx0cHVzaChzb3J0KTtcblx0fVxuXHRlbHNlIGlmICggc29ydC5sZW5ndGggJiYgdHlwZW9mIHNvcnRbMF0gPT09ICdudW1iZXInICkge1xuXHRcdC8vIDFEIGFycmF5XG5cdFx0cHVzaChzb3J0KTtcblx0fVxuXHRlbHNlIGlmICggc29ydC5sZW5ndGggKSB7XG5cdFx0Ly8gMkQgYXJyYXlcblx0XHRmb3IgKHZhciB6PTA7IHo8c29ydC5sZW5ndGg7IHorKykge1xuXHRcdFx0cHVzaChzb3J0W3pdKTsgLy8gT2JqZWN0IG9yIGFycmF5XG5cdFx0fVxuXHR9XG59XG5cblxuZnVuY3Rpb24gX2ZuU29ydEZsYXR0ZW4gKCBzZXR0aW5ncyApXG57XG5cdHZhclxuXHRcdGksIGssIGtMZW4sXG5cdFx0YVNvcnQgPSBbXSxcblx0XHRleHRTb3J0ID0gRGF0YVRhYmxlLmV4dC50eXBlLm9yZGVyLFxuXHRcdGFvQ29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucyxcblx0XHRhRGF0YVNvcnQsIGlDb2wsIHNUeXBlLCBzcmNDb2wsXG5cdFx0Zml4ZWQgPSBzZXR0aW5ncy5hYVNvcnRpbmdGaXhlZCxcblx0XHRmaXhlZE9iaiA9ICQuaXNQbGFpbk9iamVjdCggZml4ZWQgKSxcblx0XHRuZXN0ZWRTb3J0ID0gW107XG5cdFxuXHRpZiAoICEgc2V0dGluZ3Mub0ZlYXR1cmVzLmJTb3J0ICkge1xuXHRcdHJldHVybiBhU29ydDtcblx0fVxuXG5cdC8vIEJ1aWxkIHRoZSBzb3J0IGFycmF5LCB3aXRoIHByZS1maXggYW5kIHBvc3QtZml4IG9wdGlvbnMgaWYgdGhleSBoYXZlIGJlZW5cblx0Ly8gc3BlY2lmaWVkXG5cdGlmICggQXJyYXkuaXNBcnJheSggZml4ZWQgKSApIHtcblx0XHRfZm5Tb3J0UmVzb2x2ZSggc2V0dGluZ3MsIG5lc3RlZFNvcnQsIGZpeGVkICk7XG5cdH1cblxuXHRpZiAoIGZpeGVkT2JqICYmIGZpeGVkLnByZSApIHtcblx0XHRfZm5Tb3J0UmVzb2x2ZSggc2V0dGluZ3MsIG5lc3RlZFNvcnQsIGZpeGVkLnByZSApO1xuXHR9XG5cblx0X2ZuU29ydFJlc29sdmUoIHNldHRpbmdzLCBuZXN0ZWRTb3J0LCBzZXR0aW5ncy5hYVNvcnRpbmcgKTtcblxuXHRpZiAoZml4ZWRPYmogJiYgZml4ZWQucG9zdCApIHtcblx0XHRfZm5Tb3J0UmVzb2x2ZSggc2V0dGluZ3MsIG5lc3RlZFNvcnQsIGZpeGVkLnBvc3QgKTtcblx0fVxuXG5cdGZvciAoIGk9MCA7IGk8bmVzdGVkU29ydC5sZW5ndGggOyBpKysgKVxuXHR7XG5cdFx0c3JjQ29sID0gbmVzdGVkU29ydFtpXVswXTtcblxuXHRcdGlmICggYW9Db2x1bW5zWyBzcmNDb2wgXSApIHtcblx0XHRcdGFEYXRhU29ydCA9IGFvQ29sdW1uc1sgc3JjQ29sIF0uYURhdGFTb3J0O1xuXG5cdFx0XHRmb3IgKCBrPTAsIGtMZW49YURhdGFTb3J0Lmxlbmd0aCA7IGs8a0xlbiA7IGsrKyApXG5cdFx0XHR7XG5cdFx0XHRcdGlDb2wgPSBhRGF0YVNvcnRba107XG5cdFx0XHRcdHNUeXBlID0gYW9Db2x1bW5zWyBpQ29sIF0uc1R5cGUgfHwgJ3N0cmluZyc7XG5cblx0XHRcdFx0aWYgKCBuZXN0ZWRTb3J0W2ldLl9pZHggPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRuZXN0ZWRTb3J0W2ldLl9pZHggPSBhb0NvbHVtbnNbaUNvbF0uYXNTb3J0aW5nLmluZGV4T2YobmVzdGVkU29ydFtpXVsxXSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIG5lc3RlZFNvcnRbaV1bMV0gKSB7XG5cdFx0XHRcdFx0YVNvcnQucHVzaCgge1xuXHRcdFx0XHRcdFx0c3JjOiAgICAgICBzcmNDb2wsXG5cdFx0XHRcdFx0XHRjb2w6ICAgICAgIGlDb2wsXG5cdFx0XHRcdFx0XHRkaXI6ICAgICAgIG5lc3RlZFNvcnRbaV1bMV0sXG5cdFx0XHRcdFx0XHRpbmRleDogICAgIG5lc3RlZFNvcnRbaV0uX2lkeCxcblx0XHRcdFx0XHRcdHR5cGU6ICAgICAgc1R5cGUsXG5cdFx0XHRcdFx0XHRmb3JtYXR0ZXI6IGV4dFNvcnRbIHNUeXBlK1wiLXByZVwiIF0sXG5cdFx0XHRcdFx0XHRzb3J0ZXI6ICAgIGV4dFNvcnRbIHNUeXBlK1wiLVwiK25lc3RlZFNvcnRbaV1bMV0gXVxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBhU29ydDtcbn1cblxuLyoqXG4gKiBDaGFuZ2UgdGhlIG9yZGVyIG9mIHRoZSB0YWJsZVxuICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuU29ydCAoIG9TZXR0aW5ncywgY29sLCBkaXIgKVxue1xuXHR2YXJcblx0XHRpLCBpZW4sIGlMZW4sXG5cdFx0YWlPcmlnID0gW10sXG5cdFx0ZXh0U29ydCA9IERhdGFUYWJsZS5leHQudHlwZS5vcmRlcixcblx0XHRhb0RhdGEgPSBvU2V0dGluZ3MuYW9EYXRhLFxuXHRcdHNvcnRDb2wsXG5cdFx0ZGlzcGxheU1hc3RlciA9IG9TZXR0aW5ncy5haURpc3BsYXlNYXN0ZXIsXG5cdFx0YVNvcnQ7XG5cblx0Ly8gTWFrZSBzdXJlIHRoZSBjb2x1bW5zIGFsbCBoYXZlIHR5cGVzIGRlZmluZWRcblx0X2ZuQ29sdW1uVHlwZXMob1NldHRpbmdzKTtcblxuXHQvLyBBbGxvdyBhIHNwZWNpZmljIGNvbHVtbiB0byBiZSBzb3J0ZWQsIHdoaWNoIHdpbGwgX25vdF8gYWx0ZXIgdGhlIGRpc3BsYXlcblx0Ly8gbWFzdGVyXG5cdGlmIChjb2wgIT09IHVuZGVmaW5lZCkge1xuXHRcdHZhciBzcmNDb2wgPSBvU2V0dGluZ3MuYW9Db2x1bW5zW2NvbF07XG5cblx0XHRhU29ydCA9IFt7XG5cdFx0XHRzcmM6ICAgICAgIGNvbCxcblx0XHRcdGNvbDogICAgICAgY29sLFxuXHRcdFx0ZGlyOiAgICAgICBkaXIsXG5cdFx0XHRpbmRleDogICAgIDAsXG5cdFx0XHR0eXBlOiAgICAgIHNyY0NvbC5zVHlwZSxcblx0XHRcdGZvcm1hdHRlcjogZXh0U29ydFsgc3JjQ29sLnNUeXBlK1wiLXByZVwiIF0sXG5cdFx0XHRzb3J0ZXI6ICAgIGV4dFNvcnRbIHNyY0NvbC5zVHlwZStcIi1cIitkaXIgXVxuXHRcdH1dO1xuXHRcdGRpc3BsYXlNYXN0ZXIgPSBkaXNwbGF5TWFzdGVyLnNsaWNlKCk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0YVNvcnQgPSBfZm5Tb3J0RmxhdHRlbiggb1NldHRpbmdzICk7XG5cdH1cblxuXHRmb3IgKCBpPTAsIGllbj1hU29ydC5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRzb3J0Q29sID0gYVNvcnRbaV07XG5cblx0XHQvLyBMb2FkIHRoZSBkYXRhIG5lZWRlZCBmb3IgdGhlIHNvcnQsIGZvciBlYWNoIGNlbGxcblx0XHRfZm5Tb3J0RGF0YSggb1NldHRpbmdzLCBzb3J0Q29sLmNvbCApO1xuXHR9XG5cblx0LyogTm8gc29ydGluZyByZXF1aXJlZCBpZiBzZXJ2ZXItc2lkZSBvciBubyBzb3J0aW5nIGFycmF5ICovXG5cdGlmICggX2ZuRGF0YVNvdXJjZSggb1NldHRpbmdzICkgIT0gJ3NzcCcgJiYgYVNvcnQubGVuZ3RoICE9PSAwIClcblx0e1xuXHRcdC8vIFJlc2V0IHRoZSBpbml0aWFsIHBvc2l0aW9ucyBvbiBlYWNoIHBhc3Mgc28gd2UgZ2V0IGEgc3RhYmxlIHNvcnRcblx0XHRmb3IgKCBpPTAsIGlMZW49ZGlzcGxheU1hc3Rlci5sZW5ndGggOyBpPGlMZW4gOyBpKysgKSB7XG5cdFx0XHRhaU9yaWdbIGkgXSA9IGk7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlIGZpcnN0IHNvcnQgaXMgZGVzYywgdGhlbiByZXZlcnNlIHRoZSBhcnJheSB0byBwcmVzZXJ2ZSBvcmlnaW5hbFxuXHRcdC8vIG9yZGVyLCBqdXN0IGluIHJldmVyc2Vcblx0XHRpZiAoYVNvcnQubGVuZ3RoICYmIGFTb3J0WzBdLmRpciA9PT0gJ2Rlc2MnICYmIG9TZXR0aW5ncy5vcmRlckRlc2NSZXZlcnNlKSB7XG5cdFx0XHRhaU9yaWcucmV2ZXJzZSgpO1xuXHRcdH1cblxuXHRcdC8qIERvIHRoZSBzb3J0IC0gaGVyZSB3ZSB3YW50IG11bHRpLWNvbHVtbiBzb3J0aW5nIGJhc2VkIG9uIGEgZ2l2ZW4gZGF0YSBzb3VyY2UgKGNvbHVtbilcblx0XHQgKiBhbmQgc29ydGluZyBmdW5jdGlvbiAoZnJvbSBvU29ydCkgaW4gYSBjZXJ0YWluIGRpcmVjdGlvbi4gSXQncyByZWFzb25hYmx5IGNvbXBsZXggdG9cblx0XHQgKiBmb2xsb3cgb24gaXQncyBvd24sIGJ1dCB0aGlzIGlzIHdoYXQgd2Ugd2FudCAoZXhhbXBsZSB0d28gY29sdW1uIHNvcnRpbmcpOlxuXHRcdCAqICBmbkxvY2FsU29ydGluZyA9IGZ1bmN0aW9uKGEsYil7XG5cdFx0ICogICAgdmFyIHRlc3Q7XG5cdFx0ICogICAgdGVzdCA9IG9Tb3J0WydzdHJpbmctYXNjJ10oJ2RhdGExMScsICdkYXRhMTInKTtcblx0XHQgKiAgICAgIGlmICh0ZXN0ICE9PSAwKVxuXHRcdCAqICAgICAgICByZXR1cm4gdGVzdDtcblx0XHQgKiAgICB0ZXN0ID0gb1NvcnRbJ251bWVyaWMtZGVzYyddKCdkYXRhMjEnLCAnZGF0YTIyJyk7XG5cdFx0ICogICAgaWYgKHRlc3QgIT09IDApXG5cdFx0ICogICAgICByZXR1cm4gdGVzdDtcblx0XHQgKiAgICByZXR1cm4gb1NvcnRbJ251bWVyaWMtYXNjJ10oIGFpT3JpZ1thXSwgYWlPcmlnW2JdICk7XG5cdFx0ICogIH1cblx0XHQgKiBCYXNpY2FsbHkgd2UgaGF2ZSBhIHRlc3QgZm9yIGVhY2ggc29ydGluZyBjb2x1bW4sIGlmIHRoZSBkYXRhIGluIHRoYXQgY29sdW1uIGlzIGVxdWFsLFxuXHRcdCAqIHRlc3QgdGhlIG5leHQgY29sdW1uLiBJZiBhbGwgY29sdW1ucyBtYXRjaCwgdGhlbiB3ZSB1c2UgYSBudW1lcmljIHNvcnQgb24gdGhlIHJvd1xuXHRcdCAqIHBvc2l0aW9ucyBpbiB0aGUgb3JpZ2luYWwgZGF0YSBhcnJheSB0byBwcm92aWRlIGEgc3RhYmxlIHNvcnQuXG5cdFx0ICovXG5cdFx0ZGlzcGxheU1hc3Rlci5zb3J0KCBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cdFx0XHR2YXJcblx0XHRcdFx0eCwgeSwgaywgdGVzdCwgc29ydCxcblx0XHRcdFx0bGVuPWFTb3J0Lmxlbmd0aCxcblx0XHRcdFx0ZGF0YUEgPSBhb0RhdGFbYV0uX2FTb3J0RGF0YSxcblx0XHRcdFx0ZGF0YUIgPSBhb0RhdGFbYl0uX2FTb3J0RGF0YTtcblxuXHRcdFx0Zm9yICggaz0wIDsgazxsZW4gOyBrKysgKSB7XG5cdFx0XHRcdHNvcnQgPSBhU29ydFtrXTtcblxuXHRcdFx0XHQvLyBEYXRhLCB3aGljaCBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gdGhyb3VnaCBhIGAtcHJlYCBmdW5jdGlvblxuXHRcdFx0XHR4ID0gZGF0YUFbIHNvcnQuY29sIF07XG5cdFx0XHRcdHkgPSBkYXRhQlsgc29ydC5jb2wgXTtcblxuXHRcdFx0XHRpZiAoc29ydC5zb3J0ZXIpIHtcblx0XHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBhIGN1c3RvbSBzb3J0ZXIgKGAtYXNjYCBvciBgLWRlc2NgKSBmb3IgdGhpc1xuXHRcdFx0XHRcdC8vIGRhdGEgdHlwZSwgdXNlIGl0XG5cdFx0XHRcdFx0dGVzdCA9IHNvcnQuc29ydGVyKHgsIHkpO1xuXG5cdFx0XHRcdFx0aWYgKCB0ZXN0ICE9PSAwICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRlc3Q7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgdXNlIGdlbmVyaWMgc29ydGluZ1xuXHRcdFx0XHRcdHRlc3QgPSB4PHkgPyAtMSA6IHg+eSA/IDEgOiAwO1xuXG5cdFx0XHRcdFx0aWYgKCB0ZXN0ICE9PSAwICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHNvcnQuZGlyID09PSAnYXNjJyA/IHRlc3QgOiAtdGVzdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0eCA9IGFpT3JpZ1thXTtcblx0XHRcdHkgPSBhaU9yaWdbYl07XG5cblx0XHRcdHJldHVybiB4PHkgPyAtMSA6IHg+eSA/IDEgOiAwO1xuXHRcdH0gKTtcblx0fVxuXHRlbHNlIGlmICggYVNvcnQubGVuZ3RoID09PSAwICkge1xuXHRcdC8vIEFwcGx5IGluZGV4IG9yZGVyXG5cdFx0ZGlzcGxheU1hc3Rlci5zb3J0KGZ1bmN0aW9uICh4LCB5KSB7XG5cdFx0XHRyZXR1cm4geDx5ID8gLTEgOiB4PnkgPyAxIDogMDtcblx0XHR9KTtcblx0fVxuXG5cdGlmIChjb2wgPT09IHVuZGVmaW5lZCkge1xuXHRcdC8vIFRlbGwgdGhlIGRyYXcgZnVuY3Rpb24gdGhhdCB3ZSBoYXZlIHNvcnRlZCB0aGUgZGF0YVxuXHRcdG9TZXR0aW5ncy5iU29ydGVkID0gdHJ1ZTtcblx0XHRvU2V0dGluZ3Muc29ydERldGFpbHMgPSBhU29ydDtcblxuXHRcdF9mbkNhbGxiYWNrRmlyZSggb1NldHRpbmdzLCBudWxsLCAnb3JkZXInLCBbb1NldHRpbmdzLCBhU29ydF0gKTtcblx0fVxuXG5cdHJldHVybiBkaXNwbGF5TWFzdGVyO1xufVxuXG5cbi8qKlxuICogRnVuY3Rpb24gdG8gcnVuIG9uIHVzZXIgc29ydCByZXF1ZXN0XG4gKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQHBhcmFtIHtub2RlfSBhdHRhY2hUbyBub2RlIHRvIGF0dGFjaCB0aGUgaGFuZGxlciB0b1xuICogIEBwYXJhbSB7aW50fSBjb2xJZHggY29sdW1uIHNvcnRpbmcgaW5kZXhcbiAqICBAcGFyYW0ge2ludH0gYWRkSW5kZXggQ291bnRlclxuICogIEBwYXJhbSB7Ym9vbGVhbn0gW3NoaWZ0PWZhbHNlXSBTaGlmdCBjbGljayBhZGRcbiAqICBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mblNvcnRBZGQgKCBzZXR0aW5ncywgY29sSWR4LCBhZGRJbmRleCwgc2hpZnQgKVxue1xuXHR2YXIgY29sID0gc2V0dGluZ3MuYW9Db2x1bW5zWyBjb2xJZHggXTtcblx0dmFyIHNvcnRpbmcgPSBzZXR0aW5ncy5hYVNvcnRpbmc7XG5cdHZhciBhc1NvcnRpbmcgPSBjb2wuYXNTb3J0aW5nO1xuXHR2YXIgbmV4dFNvcnRJZHg7XG5cdHZhciBuZXh0ID0gZnVuY3Rpb24gKCBhLCBvdmVyZmxvdyApIHtcblx0XHR2YXIgaWR4ID0gYS5faWR4O1xuXHRcdGlmICggaWR4ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZHggPSBhc1NvcnRpbmcuaW5kZXhPZihhWzFdKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaWR4KzEgPCBhc1NvcnRpbmcubGVuZ3RoID9cblx0XHRcdGlkeCsxIDpcblx0XHRcdG92ZXJmbG93ID9cblx0XHRcdFx0bnVsbCA6XG5cdFx0XHRcdDA7XG5cdH07XG5cblx0aWYgKCAhIGNvbC5iU29ydGFibGUgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Ly8gQ29udmVydCB0byAyRCBhcnJheSBpZiBuZWVkZWRcblx0aWYgKCB0eXBlb2Ygc29ydGluZ1swXSA9PT0gJ251bWJlcicgKSB7XG5cdFx0c29ydGluZyA9IHNldHRpbmdzLmFhU29ydGluZyA9IFsgc29ydGluZyBdO1xuXHR9XG5cblx0Ly8gSWYgYXBwZW5kaW5nIHRoZSBzb3J0IHRoZW4gd2UgYXJlIG11bHRpLWNvbHVtbiBzb3J0aW5nXG5cdGlmICggKHNoaWZ0IHx8IGFkZEluZGV4KSAmJiBzZXR0aW5ncy5vRmVhdHVyZXMuYlNvcnRNdWx0aSApIHtcblx0XHQvLyBBcmUgd2UgYWxyZWFkeSBkb2luZyBzb21lIGtpbmQgb2Ygc29ydCBvbiB0aGlzIGNvbHVtbj9cblx0XHR2YXIgc29ydElkeCA9IF9wbHVjayhzb3J0aW5nLCAnMCcpLmluZGV4T2YoY29sSWR4KTtcblxuXHRcdGlmICggc29ydElkeCAhPT0gLTEgKSB7XG5cdFx0XHQvLyBZZXMsIG1vZGlmeSB0aGUgc29ydFxuXHRcdFx0bmV4dFNvcnRJZHggPSBuZXh0KCBzb3J0aW5nW3NvcnRJZHhdLCB0cnVlICk7XG5cblx0XHRcdGlmICggbmV4dFNvcnRJZHggPT09IG51bGwgJiYgc29ydGluZy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRcdG5leHRTb3J0SWR4ID0gMDsgLy8gY2FuJ3QgcmVtb3ZlIHNvcnRpbmcgY29tcGxldGVseVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG5leHRTb3J0SWR4ID09PSBudWxsICkge1xuXHRcdFx0XHRzb3J0aW5nLnNwbGljZSggc29ydElkeCwgMSApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdHNvcnRpbmdbc29ydElkeF1bMV0gPSBhc1NvcnRpbmdbIG5leHRTb3J0SWR4IF07XG5cdFx0XHRcdHNvcnRpbmdbc29ydElkeF0uX2lkeCA9IG5leHRTb3J0SWR4O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIGlmIChzaGlmdCkge1xuXHRcdFx0Ly8gTm8gc29ydCBvbiB0aGlzIGNvbHVtbiB5ZXQsIGJlaW5nIGFkZGVkIGJ5IHNoaWZ0IGNsaWNrXG5cdFx0XHQvLyBhZGQgaXQgYXMgaXRzZWxmXG5cdFx0XHRzb3J0aW5nLnB1c2goIFsgY29sSWR4LCBhc1NvcnRpbmdbMF0sIDAgXSApO1xuXHRcdFx0c29ydGluZ1tzb3J0aW5nLmxlbmd0aC0xXS5faWR4ID0gMDtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHQvLyBObyBzb3J0IG9uIHRoaXMgY29sdW1uIHlldCwgYmVpbmcgYWRkZWQgZnJvbSBhIGNvbHNwYW5cblx0XHRcdC8vIHNvIGFkZCB3aXRoIHNhbWUgZGlyZWN0aW9uIGFzIGZpcnN0IGNvbHVtblxuXHRcdFx0c29ydGluZy5wdXNoKCBbIGNvbElkeCwgc29ydGluZ1swXVsxXSwgMCBdICk7XG5cdFx0XHRzb3J0aW5nW3NvcnRpbmcubGVuZ3RoLTFdLl9pZHggPSAwO1xuXHRcdH1cblx0fVxuXHRlbHNlIGlmICggc29ydGluZy5sZW5ndGggJiYgc29ydGluZ1swXVswXSA9PSBjb2xJZHggKSB7XG5cdFx0Ly8gU2luZ2xlIGNvbHVtbiAtIGFscmVhZHkgc29ydGluZyBvbiB0aGlzIGNvbHVtbiwgbW9kaWZ5IHRoZSBzb3J0XG5cdFx0bmV4dFNvcnRJZHggPSBuZXh0KCBzb3J0aW5nWzBdICk7XG5cblx0XHRzb3J0aW5nLmxlbmd0aCA9IDE7XG5cdFx0c29ydGluZ1swXVsxXSA9IGFzU29ydGluZ1sgbmV4dFNvcnRJZHggXTtcblx0XHRzb3J0aW5nWzBdLl9pZHggPSBuZXh0U29ydElkeDtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBTaW5nbGUgY29sdW1uIC0gc29ydCBvbmx5IG9uIHRoaXMgY29sdW1uXG5cdFx0c29ydGluZy5sZW5ndGggPSAwO1xuXHRcdHNvcnRpbmcucHVzaCggWyBjb2xJZHgsIGFzU29ydGluZ1swXSBdICk7XG5cdFx0c29ydGluZ1swXS5faWR4ID0gMDtcblx0fVxufVxuXG5cbi8qKlxuICogU2V0IHRoZSBzb3J0aW5nIGNsYXNzZXMgb24gdGFibGUncyBib2R5LCBOb3RlOiBpdCBpcyBzYWZlIHRvIGNhbGwgdGhpcyBmdW5jdGlvblxuICogd2hlbiBiU29ydCBhbmQgYlNvcnRDbGFzc2VzIGFyZSBmYWxzZVxuICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuU29ydGluZ0NsYXNzZXMoIHNldHRpbmdzIClcbntcblx0dmFyIG9sZFNvcnQgPSBzZXR0aW5ncy5hTGFzdFNvcnQ7XG5cdHZhciBzb3J0Q2xhc3MgPSBzZXR0aW5ncy5vQ2xhc3Nlcy5vcmRlci5wb3NpdGlvbjtcblx0dmFyIHNvcnQgPSBfZm5Tb3J0RmxhdHRlbiggc2V0dGluZ3MgKTtcblx0dmFyIGZlYXR1cmVzID0gc2V0dGluZ3Mub0ZlYXR1cmVzO1xuXHR2YXIgaSwgaWVuLCBjb2xJZHg7XG5cblx0aWYgKCBmZWF0dXJlcy5iU29ydCAmJiBmZWF0dXJlcy5iU29ydENsYXNzZXMgKSB7XG5cdFx0Ly8gUmVtb3ZlIG9sZCBzb3J0aW5nIGNsYXNzZXNcblx0XHRmb3IgKCBpPTAsIGllbj1vbGRTb3J0Lmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0Y29sSWR4ID0gb2xkU29ydFtpXS5zcmM7XG5cblx0XHRcdC8vIFJlbW92ZSBjb2x1bW4gc29ydGluZ1xuXHRcdFx0JCggX3BsdWNrKCBzZXR0aW5ncy5hb0RhdGEsICdhbkNlbGxzJywgY29sSWR4ICkgKVxuXHRcdFx0XHQucmVtb3ZlQ2xhc3MoIHNvcnRDbGFzcyArIChpPDIgPyBpKzEgOiAzKSApO1xuXHRcdH1cblxuXHRcdC8vIEFkZCBuZXcgY29sdW1uIHNvcnRpbmdcblx0XHRmb3IgKCBpPTAsIGllbj1zb3J0Lmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0Y29sSWR4ID0gc29ydFtpXS5zcmM7XG5cblx0XHRcdCQoIF9wbHVjayggc2V0dGluZ3MuYW9EYXRhLCAnYW5DZWxscycsIGNvbElkeCApIClcblx0XHRcdFx0LmFkZENsYXNzKCBzb3J0Q2xhc3MgKyAoaTwyID8gaSsxIDogMykgKTtcblx0XHR9XG5cdH1cblxuXHRzZXR0aW5ncy5hTGFzdFNvcnQgPSBzb3J0O1xufVxuXG5cbi8vIEdldCB0aGUgZGF0YSB0byBzb3J0IGEgY29sdW1uLCBiZSBpdCBmcm9tIGNhY2hlLCBmcmVzaCAocG9wdWxhdGluZyB0aGVcbi8vIGNhY2hlKSwgb3IgZnJvbSBhIHNvcnQgZm9ybWF0dGVyXG5mdW5jdGlvbiBfZm5Tb3J0RGF0YSggc2V0dGluZ3MsIGNvbElkeCApXG57XG5cdC8vIEN1c3RvbSBzb3J0aW5nIGZ1bmN0aW9uIC0gcHJvdmlkZWQgYnkgdGhlIHNvcnQgZGF0YSB0eXBlXG5cdHZhciBjb2x1bW4gPSBzZXR0aW5ncy5hb0NvbHVtbnNbIGNvbElkeCBdO1xuXHR2YXIgY3VzdG9tU29ydCA9IERhdGFUYWJsZS5leHQub3JkZXJbIGNvbHVtbi5zU29ydERhdGFUeXBlIF07XG5cdHZhciBjdXN0b21EYXRhO1xuXG5cdGlmICggY3VzdG9tU29ydCApIHtcblx0XHRjdXN0b21EYXRhID0gY3VzdG9tU29ydC5jYWxsKCBzZXR0aW5ncy5vSW5zdGFuY2UsIHNldHRpbmdzLCBjb2xJZHgsXG5cdFx0XHRfZm5Db2x1bW5JbmRleFRvVmlzaWJsZSggc2V0dGluZ3MsIGNvbElkeCApXG5cdFx0KTtcblx0fVxuXG5cdC8vIFVzZSAvIHBvcHVsYXRlIGNhY2hlXG5cdHZhciByb3csIGNlbGxEYXRhO1xuXHR2YXIgZm9ybWF0dGVyID0gRGF0YVRhYmxlLmV4dC50eXBlLm9yZGVyWyBjb2x1bW4uc1R5cGUrXCItcHJlXCIgXTtcblx0dmFyIGRhdGEgPSBzZXR0aW5ncy5hb0RhdGE7XG5cblx0Zm9yICggdmFyIHJvd0lkeD0wIDsgcm93SWR4PGRhdGEubGVuZ3RoIDsgcm93SWR4KysgKSB7XG5cdFx0Ly8gU3BhcnNlIGFycmF5XG5cdFx0aWYgKCEgZGF0YVtyb3dJZHhdKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRyb3cgPSBkYXRhW3Jvd0lkeF07XG5cblx0XHRpZiAoICEgcm93Ll9hU29ydERhdGEgKSB7XG5cdFx0XHRyb3cuX2FTb3J0RGF0YSA9IFtdO1xuXHRcdH1cblxuXHRcdGlmICggISByb3cuX2FTb3J0RGF0YVtjb2xJZHhdIHx8IGN1c3RvbVNvcnQgKSB7XG5cdFx0XHRjZWxsRGF0YSA9IGN1c3RvbVNvcnQgP1xuXHRcdFx0XHRjdXN0b21EYXRhW3Jvd0lkeF0gOiAvLyBJZiB0aGVyZSB3YXMgYSBjdXN0b20gc29ydCBmdW5jdGlvbiwgdXNlIGRhdGEgZnJvbSB0aGVyZVxuXHRcdFx0XHRfZm5HZXRDZWxsRGF0YSggc2V0dGluZ3MsIHJvd0lkeCwgY29sSWR4LCAnc29ydCcgKTtcblxuXHRcdFx0cm93Ll9hU29ydERhdGFbIGNvbElkeCBdID0gZm9ybWF0dGVyID9cblx0XHRcdFx0Zm9ybWF0dGVyKCBjZWxsRGF0YSwgc2V0dGluZ3MgKSA6XG5cdFx0XHRcdGNlbGxEYXRhO1xuXHRcdH1cblx0fVxufVxuXG5cbi8qKlxuICogU3RhdGUgaW5mb3JtYXRpb24gZm9yIGEgdGFibGVcbiAqXG4gKiBAcGFyYW0geyp9IHNldHRpbmdzXG4gKiBAcmV0dXJucyBTdGF0ZSBvYmplY3RcbiAqL1xuZnVuY3Rpb24gX2ZuU2F2ZVN0YXRlICggc2V0dGluZ3MgKVxue1xuXHRpZiAoc2V0dGluZ3MuX2JMb2FkaW5nU3RhdGUpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBTb3J0IHN0YXRlIHNhdmluZyB1c2VzIFtbaWR4LCBvcmRlcl1dIHN0cnVjdHVyZS5cblx0dmFyIHNvcnRpbmcgPSBbXTtcblx0X2ZuU29ydFJlc29sdmUoc2V0dGluZ3MsIHNvcnRpbmcsIHNldHRpbmdzLmFhU29ydGluZyApO1xuXG5cdC8qIFN0b3JlIHRoZSBpbnRlcmVzdGluZyB2YXJpYWJsZXMgKi9cblx0dmFyIGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnM7XG5cdHZhciBzdGF0ZSA9IHtcblx0XHR0aW1lOiAgICArbmV3IERhdGUoKSxcblx0XHRzdGFydDogICBzZXR0aW5ncy5faURpc3BsYXlTdGFydCxcblx0XHRsZW5ndGg6ICBzZXR0aW5ncy5faURpc3BsYXlMZW5ndGgsXG5cdFx0b3JkZXI6ICAgc29ydGluZy5tYXAoZnVuY3Rpb24gKHNvcnQpIHtcblx0XHRcdC8vIElmIGEgY29sdW1uIG5hbWUgaXMgYXZhaWxhYmxlLCB1c2UgaXRcblx0XHRcdHJldHVybiBjb2x1bW5zW3NvcnRbMF1dICYmIGNvbHVtbnNbc29ydFswXV0uc05hbWVcblx0XHRcdFx0PyBbIGNvbHVtbnNbc29ydFswXV0uc05hbWUsIHNvcnRbMV0gXVxuXHRcdFx0XHQ6IHNvcnQuc2xpY2UoKTtcblx0XHR9ICksXG5cdFx0c2VhcmNoOiAgJC5leHRlbmQoe30sIHNldHRpbmdzLm9QcmV2aW91c1NlYXJjaCksXG5cdFx0Y29sdW1uczogc2V0dGluZ3MuYW9Db2x1bW5zLm1hcCggZnVuY3Rpb24gKCBjb2wsIGkgKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRuYW1lOiBjb2wuc05hbWUsXG5cdFx0XHRcdHZpc2libGU6IGNvbC5iVmlzaWJsZSxcblx0XHRcdFx0c2VhcmNoOiAkLmV4dGVuZCh7fSwgc2V0dGluZ3MuYW9QcmVTZWFyY2hDb2xzW2ldKVxuXHRcdFx0fTtcblx0XHR9IClcblx0fTtcblxuXHRzZXR0aW5ncy5vU2F2ZWRTdGF0ZSA9IHN0YXRlO1xuXHRfZm5DYWxsYmFja0ZpcmUoIHNldHRpbmdzLCBcImFvU3RhdGVTYXZlUGFyYW1zXCIsICdzdGF0ZVNhdmVQYXJhbXMnLCBbc2V0dGluZ3MsIHN0YXRlXSApO1xuXHRcblx0aWYgKCBzZXR0aW5ncy5vRmVhdHVyZXMuYlN0YXRlU2F2ZSAmJiAhc2V0dGluZ3MuYkRlc3Ryb3lpbmcgKVxuXHR7XG5cdFx0c2V0dGluZ3MuZm5TdGF0ZVNhdmVDYWxsYmFjay5jYWxsKCBzZXR0aW5ncy5vSW5zdGFuY2UsIHNldHRpbmdzLCBzdGF0ZSApO1xuXHR9XHRcbn1cblxuXG4vKipcbiAqIEF0dGVtcHQgdG8gbG9hZCBhIHNhdmVkIHRhYmxlIHN0YXRlXG4gKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBwYXJhbSB7b2JqZWN0fSBvSW5pdCBEYXRhVGFibGVzIGluaXQgb2JqZWN0IHNvIHdlIGNhbiBvdmVycmlkZSBzZXR0aW5nc1xuICogIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGV4ZWN1dGUgd2hlbiB0aGUgc3RhdGUgaGFzIGJlZW4gbG9hZGVkXG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkxvYWRTdGF0ZSAoIHNldHRpbmdzLCBpbml0LCBjYWxsYmFjayApXG57XG5cdGlmICggISBzZXR0aW5ncy5vRmVhdHVyZXMuYlN0YXRlU2F2ZSApIHtcblx0XHRjYWxsYmFjaygpO1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHZhciBsb2FkZWQgPSBmdW5jdGlvbihzdGF0ZSkge1xuXHRcdF9mbkltcGxlbWVudFN0YXRlKHNldHRpbmdzLCBzdGF0ZSwgY2FsbGJhY2spO1xuXHR9XG5cblx0dmFyIHN0YXRlID0gc2V0dGluZ3MuZm5TdGF0ZUxvYWRDYWxsYmFjay5jYWxsKCBzZXR0aW5ncy5vSW5zdGFuY2UsIHNldHRpbmdzLCBsb2FkZWQgKTtcblxuXHRpZiAoIHN0YXRlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0X2ZuSW1wbGVtZW50U3RhdGUoIHNldHRpbmdzLCBzdGF0ZSwgY2FsbGJhY2sgKTtcblx0fVxuXHQvLyBvdGhlcndpc2UsIHdhaXQgZm9yIHRoZSBsb2FkZWQgY2FsbGJhY2sgdG8gYmUgZXhlY3V0ZWRcblxuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gX2ZuSW1wbGVtZW50U3RhdGUgKCBzZXR0aW5ncywgcywgY2FsbGJhY2spIHtcblx0dmFyIGksIGllbjtcblx0dmFyIGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnM7XG5cdHZhciBjdXJyZW50TmFtZXMgPSBfcGx1Y2soc2V0dGluZ3MuYW9Db2x1bW5zLCAnc05hbWUnKTtcblxuXHRzZXR0aW5ncy5fYkxvYWRpbmdTdGF0ZSA9IHRydWU7XG5cblx0Ly8gV2hlbiBTdGF0ZVJlc3RvcmUgd2FzIGludHJvZHVjZWQgdGhlIHN0YXRlIGNvdWxkIG5vdyBiZSBpbXBsZW1lbnRlZCBhdCBhbnkgdGltZVxuXHQvLyBOb3QganVzdCBpbml0aWFsaXNhdGlvbi4gVG8gZG8gdGhpcyBhbiBhcGkgaW5zdGFuY2UgaXMgcmVxdWlyZWQgaW4gc29tZSBwbGFjZXNcblx0dmFyIGFwaSA9IHNldHRpbmdzLl9iSW5pdENvbXBsZXRlID8gbmV3IERhdGFUYWJsZS5BcGkoc2V0dGluZ3MpIDogbnVsbDtcblxuXHRpZiAoICEgcyB8fCAhIHMudGltZSApIHtcblx0XHRzZXR0aW5ncy5fYkxvYWRpbmdTdGF0ZSA9IGZhbHNlO1xuXHRcdGNhbGxiYWNrKCk7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gUmVqZWN0IG9sZCBkYXRhXG5cdHZhciBkdXJhdGlvbiA9IHNldHRpbmdzLmlTdGF0ZUR1cmF0aW9uO1xuXHRpZiAoIGR1cmF0aW9uID4gMCAmJiBzLnRpbWUgPCArbmV3IERhdGUoKSAtIChkdXJhdGlvbioxMDAwKSApIHtcblx0XHRzZXR0aW5ncy5fYkxvYWRpbmdTdGF0ZSA9IGZhbHNlO1xuXHRcdGNhbGxiYWNrKCk7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gQWxsb3cgY3VzdG9tIGFuZCBwbHVnLWluIG1hbmlwdWxhdGlvbiBmdW5jdGlvbnMgdG8gYWx0ZXIgdGhlIHNhdmVkIGRhdGEgc2V0IGFuZFxuXHQvLyBjYW5jZWxsaW5nIG9mIGxvYWRpbmcgYnkgcmV0dXJuaW5nIGZhbHNlXG5cdHZhciBhYlN0YXRlTG9hZCA9IF9mbkNhbGxiYWNrRmlyZSggc2V0dGluZ3MsICdhb1N0YXRlTG9hZFBhcmFtcycsICdzdGF0ZUxvYWRQYXJhbXMnLCBbc2V0dGluZ3MsIHNdICk7XG5cdGlmICggYWJTdGF0ZUxvYWQuaW5kZXhPZihmYWxzZSkgIT09IC0xICkge1xuXHRcdHNldHRpbmdzLl9iTG9hZGluZ1N0YXRlID0gZmFsc2U7XG5cdFx0Y2FsbGJhY2soKTtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBTdG9yZSB0aGUgc2F2ZWQgc3RhdGUgc28gaXQgbWlnaHQgYmUgYWNjZXNzZWQgYXQgYW55IHRpbWVcblx0c2V0dGluZ3Mub0xvYWRlZFN0YXRlID0gJC5leHRlbmQoIHRydWUsIHt9LCBzICk7XG5cblx0Ly8gVGhpcyBpcyBuZWVkZWQgZm9yIENvbFJlb3JkZXIsIHdoaWNoIGhhcyB0byBoYXBwZW4gZmlyc3QgdG8gYWxsb3cgYWxsXG5cdC8vIHRoZSBzdG9yZWQgaW5kZXhlcyB0byBiZSB1c2FibGUuIEl0IGlzIG5vdCBwdWJsaWNseSBkb2N1bWVudGVkLlxuXHRfZm5DYWxsYmFja0ZpcmUoIHNldHRpbmdzLCBudWxsLCAnc3RhdGVMb2FkSW5pdCcsIFtzZXR0aW5ncywgc10sIHRydWUgKTtcblxuXHQvLyBQYWdlIExlbmd0aFxuXHRpZiAoIHMubGVuZ3RoICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0Ly8gSWYgYWxyZWFkeSBpbml0aWFsaXNlZCBqdXN0IHNldCB0aGUgdmFsdWUgZGlyZWN0bHkgc28gdGhhdCB0aGUgc2VsZWN0IGVsZW1lbnQgaXMgYWxzbyB1cGRhdGVkXG5cdFx0aWYgKGFwaSkge1xuXHRcdFx0YXBpLnBhZ2UubGVuKHMubGVuZ3RoKVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHNldHRpbmdzLl9pRGlzcGxheUxlbmd0aCAgID0gcy5sZW5ndGg7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmVzdG9yZSBrZXkgZmVhdHVyZXNcblx0aWYgKCBzLnN0YXJ0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0aWYoYXBpID09PSBudWxsKSB7XG5cdFx0XHRzZXR0aW5ncy5faURpc3BsYXlTdGFydCAgICA9IHMuc3RhcnQ7XG5cdFx0XHRzZXR0aW5ncy5pSW5pdERpc3BsYXlTdGFydCA9IHMuc3RhcnQ7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0X2ZuUGFnZUNoYW5nZShzZXR0aW5ncywgcy5zdGFydC9zZXR0aW5ncy5faURpc3BsYXlMZW5ndGgpO1xuXHRcdH1cblx0fVxuXG5cdC8vIE9yZGVyXG5cdGlmICggcy5vcmRlciAhPT0gdW5kZWZpbmVkICkge1xuXHRcdHNldHRpbmdzLmFhU29ydGluZyA9IFtdO1xuXHRcdCQuZWFjaCggcy5vcmRlciwgZnVuY3Rpb24gKCBpLCBjb2wgKSB7XG5cdFx0XHR2YXIgc2V0ID0gWyBjb2xbMF0sIGNvbFsxXSBdO1xuXG5cdFx0XHQvLyBBIGNvbHVtbiBuYW1lIHdhcyBzdG9yZWQgYW5kIHNob3VsZCBiZSB1c2VkIGZvciByZXN0b3JlXG5cdFx0XHRpZiAodHlwZW9mIGNvbFswXSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0Ly8gRmluZCB0aGUgbmFtZSBmcm9tIHRoZSBjdXJyZW50IGxpc3Qgb2YgY29sdW1uIG5hbWVzXG5cdFx0XHRcdHZhciBpZHggPSBjdXJyZW50TmFtZXMuaW5kZXhPZihjb2xbMF0pO1xuXG5cdFx0XHRcdGlmIChpZHggPCAwKSB7XG5cdFx0XHRcdFx0Ly8gSWYgdGhlIGNvbHVtbiB3YXMgbm90IGZvdW5kIGlnbm9yZSBpdCBhbmQgY29udGludWVcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzZXRbMF0gPSBpZHg7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChzZXRbMF0gPj0gY29sdW1ucy5sZW5ndGgpIHtcblx0XHRcdFx0Ly8gSWYgdGhlIGNvbHVtbiBpbmRleCBpcyBvdXQgb2YgYm91bmRzIGlnbm9yZSBpdCBhbmQgY29udGludWVcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRzZXR0aW5ncy5hYVNvcnRpbmcucHVzaChzZXQpO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIFNlYXJjaFxuXHRpZiAoIHMuc2VhcmNoICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0JC5leHRlbmQoIHNldHRpbmdzLm9QcmV2aW91c1NlYXJjaCwgcy5zZWFyY2ggKTtcblx0fVxuXG5cdC8vIENvbHVtbnNcblx0aWYgKCBzLmNvbHVtbnMgKSB7XG5cdFx0dmFyIHNldCA9IHMuY29sdW1ucztcblx0XHR2YXIgaW5jb21pbmcgPSBfcGx1Y2socy5jb2x1bW5zLCAnbmFtZScpO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgaXQgaXMgYSAyLjIgc3R5bGUgc3RhdGUgb2JqZWN0IHdpdGggYSBgbmFtZWAgcHJvcGVydHkgZm9yIHRoZSBjb2x1bW5zLCBhbmQgaWZcblx0XHQvLyB0aGUgbmFtZSB3YXMgZGVmaW5lZC4gSWYgc28sIHRoZW4gY3JlYXRlIGEgbmV3IGFycmF5IHRoYXQgd2lsbCBtYXAgdGhlIHN0YXRlIG9iamVjdFxuXHRcdC8vIGdpdmVuLCB0byB0aGUgY3VycmVudCBjb2x1bW5zIChkb24ndCBib3RoZXIgaWYgdGhleSBhcmUgYWxyZWFkeSBtYXRjaGluZyB0aG8pLlxuXHRcdGlmIChpbmNvbWluZy5qb2luKCcnKS5sZW5ndGggJiYgaW5jb21pbmcuam9pbignJykgIT09IGN1cnJlbnROYW1lcy5qb2luKCcnKSkge1xuXHRcdFx0c2V0ID0gW107XG5cblx0XHRcdC8vIEZvciBlYWNoIGNvbHVtbiwgdHJ5IHRvIGZpbmQgdGhlIG5hbWUgaW4gdGhlIGluY29taW5nIGFycmF5XG5cdFx0XHRmb3IgKGk9MCA7IGk8Y3VycmVudE5hbWVzLmxlbmd0aCA7IGkrKykge1xuXHRcdFx0XHRpZiAoY3VycmVudE5hbWVzW2ldICE9ICcnKSB7XG5cdFx0XHRcdFx0dmFyIGlkeCA9IGluY29taW5nLmluZGV4T2YoY3VycmVudE5hbWVzW2ldKTtcblxuXHRcdFx0XHRcdGlmIChpZHggPj0gMCkge1xuXHRcdFx0XHRcdFx0c2V0LnB1c2gocy5jb2x1bW5zW2lkeF0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdC8vIE5vIG1hdGNoaW5nIGNvbHVtbiBuYW1lIGluIHRoZSBzdGF0ZSdzIGNvbHVtbnMsIHNvIHRoaXMgbWlnaHQgYmUgYSBuZXdcblx0XHRcdFx0XHRcdC8vIGNvbHVtbiBhbmQgdGh1cyBjYW4ndCBoYXZlIGEgc3RhdGUgYWxyZWFkeS5cblx0XHRcdFx0XHRcdHNldC5wdXNoKHt9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Ly8gSWYgbm8gbmFtZSwgYnV0IG90aGVyIGNvbHVtbnMgZGlkIGhhdmUgYSBuYW1lLCB0aGVuIHRoZXJlIGlzIG5vIGtub3dpbmdcblx0XHRcdFx0XHQvLyB3aGVyZSB0aGlzIG9uZSBjYW1lIGZyb20gb3JpZ2luYWxseSBzbyBpdCBjYW4ndCBiZSByZXN0b3JlZC5cblx0XHRcdFx0XHRzZXQucHVzaCh7fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBJZiB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgdG8gcmVzdG9yZSBpcyBkaWZmZXJlbnQgZnJvbSBjdXJyZW50LCB0aGVuIGFsbCBiZXRzIGFyZSBvZmYuXG5cdFx0aWYgKHNldC5sZW5ndGggPT09IGNvbHVtbnMubGVuZ3RoKSB7XG5cdFx0XHRmb3IgKCBpPTAsIGllbj1zZXQubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdHZhciBjb2wgPSBzZXRbaV07XG5cblx0XHRcdFx0Ly8gVmlzaWJpbGl0eVxuXHRcdFx0XHRpZiAoIGNvbC52aXNpYmxlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0Ly8gSWYgdGhlIGFwaSBpcyBkZWZpbmVkLCB0aGUgdGFibGUgaGFzIGJlZW4gaW5pdGlhbGlzZWQgc28gd2UgbmVlZCB0byB1c2UgaXQgcmF0aGVyIHRoYW4gaW50ZXJuYWwgc2V0dGluZ3Ncblx0XHRcdFx0XHRpZiAoYXBpKSB7XG5cdFx0XHRcdFx0XHQvLyBEb24ndCByZWRyYXcgdGhlIGNvbHVtbnMgb24gZXZlcnkgaXRlcmF0aW9uIG9mIHRoaXMgbG9vcCwgd2Ugd2lsbCBkbyB0aGlzIGF0IHRoZSBlbmQgaW5zdGVhZFxuXHRcdFx0XHRcdFx0YXBpLmNvbHVtbihpKS52aXNpYmxlKGNvbC52aXNpYmxlLCBmYWxzZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29sdW1uc1tpXS5iVmlzaWJsZSA9IGNvbC52aXNpYmxlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNlYXJjaFxuXHRcdFx0XHRpZiAoIGNvbC5zZWFyY2ggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHQkLmV4dGVuZCggc2V0dGluZ3MuYW9QcmVTZWFyY2hDb2xzW2ldLCBjb2wuc2VhcmNoICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhlIGFwaSBpcyBkZWZpbmVkIHRoZW4gd2UgbmVlZCB0byBhZGp1c3QgdGhlIGNvbHVtbnMgb25jZSB0aGUgdmlzaWJpbGl0eSBoYXMgYmVlbiBjaGFuZ2VkXG5cdFx0XHRpZiAoYXBpKSB7XG5cdFx0XHRcdGFwaS5jb2x1bW5zLmFkanVzdCgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHNldHRpbmdzLl9iTG9hZGluZ1N0YXRlID0gZmFsc2U7XG5cdF9mbkNhbGxiYWNrRmlyZSggc2V0dGluZ3MsICdhb1N0YXRlTG9hZGVkJywgJ3N0YXRlTG9hZGVkJywgW3NldHRpbmdzLCBzXSApO1xuXHRjYWxsYmFjaygpO1xufVxuXG4vKipcbiAqIExvZyBhbiBlcnJvciBtZXNzYWdlXG4gKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQHBhcmFtIHtpbnR9IGxldmVsIGxvZyBlcnJvciBtZXNzYWdlcywgb3IgZGlzcGxheSB0aGVtIHRvIHRoZSB1c2VyXG4gKiAgQHBhcmFtIHtzdHJpbmd9IG1zZyBlcnJvciBtZXNzYWdlXG4gKiAgQHBhcmFtIHtpbnR9IHRuIFRlY2huaWNhbCBub3RlIGlkIHRvIGdldCBtb3JlIGluZm9ybWF0aW9uIGFib3V0IHRoZSBlcnJvci5cbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuTG9nKCBzZXR0aW5ncywgbGV2ZWwsIG1zZywgdG4gKVxue1xuXHRtc2cgPSAnRGF0YVRhYmxlcyB3YXJuaW5nOiAnK1xuXHRcdChzZXR0aW5ncyA/ICd0YWJsZSBpZD0nK3NldHRpbmdzLnNUYWJsZUlkKycgLSAnIDogJycpK21zZztcblxuXHRpZiAoIHRuICkge1xuXHRcdG1zZyArPSAnLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCB0aGlzIGVycm9yLCBwbGVhc2Ugc2VlICcrXG5cdFx0J2h0dHBzOi8vZGF0YXRhYmxlcy5uZXQvdG4vJyt0bjtcblx0fVxuXG5cdGlmICggISBsZXZlbCAgKSB7XG5cdFx0Ly8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgcHJlIDEuMTBcblx0XHR2YXIgZXh0ID0gRGF0YVRhYmxlLmV4dDtcblx0XHR2YXIgdHlwZSA9IGV4dC5zRXJyTW9kZSB8fCBleHQuZXJyTW9kZTtcblxuXHRcdGlmICggc2V0dGluZ3MgKSB7XG5cdFx0XHRfZm5DYWxsYmFja0ZpcmUoIHNldHRpbmdzLCBudWxsLCAnZHQtZXJyb3InLCBbIHNldHRpbmdzLCB0biwgbXNnIF0sIHRydWUgKTtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGUgPT0gJ2FsZXJ0JyApIHtcblx0XHRcdGFsZXJ0KCBtc2cgKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIHR5cGUgPT0gJ3Rocm93JyApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihtc2cpO1xuXHRcdH1cblx0XHRlbHNlIGlmICggdHlwZW9mIHR5cGUgPT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdHR5cGUoIHNldHRpbmdzLCB0biwgbXNnICk7XG5cdFx0fVxuXHR9XG5cdGVsc2UgaWYgKCB3aW5kb3cuY29uc29sZSAmJiBjb25zb2xlLmxvZyApIHtcblx0XHRjb25zb2xlLmxvZyggbXNnICk7XG5cdH1cbn1cblxuXG4vKipcbiAqIFNlZSBpZiBhIHByb3BlcnR5IGlzIGRlZmluZWQgb24gb25lIG9iamVjdCwgaWYgc28gYXNzaWduIGl0IHRvIHRoZSBvdGhlciBvYmplY3RcbiAqICBAcGFyYW0ge29iamVjdH0gcmV0IHRhcmdldCBvYmplY3RcbiAqICBAcGFyYW0ge29iamVjdH0gc3JjIHNvdXJjZSBvYmplY3RcbiAqICBAcGFyYW0ge3N0cmluZ30gbmFtZSBwcm9wZXJ0eVxuICogIEBwYXJhbSB7c3RyaW5nfSBbbWFwcGVkTmFtZV0gbmFtZSB0byBtYXAgdG9vIC0gb3B0aW9uYWwsIG5hbWUgdXNlZCBpZiBub3QgZ2l2ZW5cbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuTWFwKCByZXQsIHNyYywgbmFtZSwgbWFwcGVkTmFtZSApXG57XG5cdGlmICggQXJyYXkuaXNBcnJheSggbmFtZSApICkge1xuXHRcdCQuZWFjaCggbmFtZSwgZnVuY3Rpb24gKGksIHZhbCkge1xuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0X2ZuTWFwKCByZXQsIHNyYywgdmFsWzBdLCB2YWxbMV0gKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRfZm5NYXAoIHJldCwgc3JjLCB2YWwgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0XHRyZXR1cm47XG5cdH1cblxuXHRpZiAoIG1hcHBlZE5hbWUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRtYXBwZWROYW1lID0gbmFtZTtcblx0fVxuXG5cdGlmICggc3JjW25hbWVdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0cmV0W21hcHBlZE5hbWVdID0gc3JjW25hbWVdO1xuXHR9XG59XG5cblxuLyoqXG4gKiBFeHRlbmQgb2JqZWN0cyAtIHZlcnkgc2ltaWxhciB0byBqUXVlcnkuZXh0ZW5kLCBidXQgZGVlcCBjb3B5IG9iamVjdHMsIGFuZFxuICogc2hhbGxvdyBjb3B5IGFycmF5cy4gVGhlIHJlYXNvbiB3ZSBuZWVkIHRvIGRvIHRoaXMsIGlzIHRoYXQgd2UgZG9uJ3Qgd2FudCB0b1xuICogZGVlcCBjb3B5IGFycmF5IGluaXQgdmFsdWVzIChzdWNoIGFzIGFhU29ydGluZykgc2luY2UgdGhlIGRldiB3b3VsZG4ndCBiZVxuICogYWJsZSB0byBvdmVycmlkZSB0aGVtLCBidXQgd2UgZG8gd2FudCB0byBkZWVwIGNvcHkgYXJyYXlzLlxuICogIEBwYXJhbSB7b2JqZWN0fSBvdXQgT2JqZWN0IHRvIGV4dGVuZFxuICogIEBwYXJhbSB7b2JqZWN0fSBleHRlbmRlciBPYmplY3QgZnJvbSB3aGljaCB0aGUgcHJvcGVydGllcyB3aWxsIGJlIGFwcGxpZWQgdG9cbiAqICAgICAgb3V0XG4gKiAgQHBhcmFtIHtib29sZWFufSBicmVha1JlZnMgSWYgdHJ1ZSwgdGhlbiBhcnJheXMgd2lsbCBiZSBzbGljZWQgdG8gdGFrZSBhblxuICogICAgICBpbmRlcGVuZGVudCBjb3B5IHdpdGggdGhlIGV4Y2VwdGlvbiBvZiB0aGUgYGRhdGFgIG9yIGBhYURhdGFgIHBhcmFtZXRlcnNcbiAqICAgICAgaWYgdGhleSBhcmUgcHJlc2VudC4gVGhpcyBpcyBzbyB5b3UgY2FuIHBhc3MgaW4gYSBjb2xsZWN0aW9uIHRvXG4gKiAgICAgIERhdGFUYWJsZXMgYW5kIGhhdmUgdGhhdCB1c2VkIGFzIHlvdXIgZGF0YSBzb3VyY2Ugd2l0aG91dCBicmVha2luZyB0aGVcbiAqICAgICAgcmVmZXJlbmNlc1xuICogIEByZXR1cm5zIHtvYmplY3R9IG91dCBSZWZlcmVuY2UsIGp1c3QgZm9yIGNvbnZlbmllbmNlIC0gb3V0ID09PSB0aGUgcmV0dXJuLlxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICogIEB0b2RvIFRoaXMgZG9lc24ndCB0YWtlIGFjY291bnQgb2YgYXJyYXlzIGluc2lkZSB0aGUgZGVlcCBjb3BpZWQgb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gX2ZuRXh0ZW5kKCBvdXQsIGV4dGVuZGVyLCBicmVha1JlZnMgKVxue1xuXHR2YXIgdmFsO1xuXG5cdGZvciAoIHZhciBwcm9wIGluIGV4dGVuZGVyICkge1xuXHRcdGlmICggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4dGVuZGVyLCBwcm9wKSApIHtcblx0XHRcdHZhbCA9IGV4dGVuZGVyW3Byb3BdO1xuXG5cdFx0XHRpZiAoICQuaXNQbGFpbk9iamVjdCggdmFsICkgKSB7XG5cdFx0XHRcdGlmICggISAkLmlzUGxhaW5PYmplY3QoIG91dFtwcm9wXSApICkge1xuXHRcdFx0XHRcdG91dFtwcm9wXSA9IHt9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdCQuZXh0ZW5kKCB0cnVlLCBvdXRbcHJvcF0sIHZhbCApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoIGJyZWFrUmVmcyAmJiBwcm9wICE9PSAnZGF0YScgJiYgcHJvcCAhPT0gJ2FhRGF0YScgJiYgQXJyYXkuaXNBcnJheSh2YWwpICkge1xuXHRcdFx0XHRvdXRbcHJvcF0gPSB2YWwuc2xpY2UoKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRvdXRbcHJvcF0gPSB2YWw7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG91dDtcbn1cblxuXG4vKipcbiAqIEJpbmQgYW4gZXZlbnQgaGFuZGVycyB0byBhbGxvdyBhIGNsaWNrIG9yIHJldHVybiBrZXkgdG8gYWN0aXZhdGUgdGhlIGNhbGxiYWNrLlxuICogVGhpcyBpcyBnb29kIGZvciBhY2Nlc3NpYmlsaXR5IHNpbmNlIGEgcmV0dXJuIG9uIHRoZSBrZXlib2FyZCB3aWxsIGhhdmUgdGhlXG4gKiBzYW1lIGVmZmVjdCBhcyBhIGNsaWNrLCBpZiB0aGUgZWxlbWVudCBoYXMgZm9jdXMuXG4gKiAgQHBhcmFtIHtlbGVtZW50fSBuIEVsZW1lbnQgdG8gYmluZCB0aGUgYWN0aW9uIHRvXG4gKiAgQHBhcmFtIHtvYmplY3R8c3RyaW5nfSBzZWxlY3RvciBTZWxlY3RvciAoZm9yIGRlbGVnYXRlZCBldmVudHMpIG9yIGRhdGEgb2JqZWN0XG4gKiAgIHRvIHBhc3MgdG8gdGhlIHRyaWdnZXJlZCBmdW5jdGlvblxuICogIEBwYXJhbSB7ZnVuY3Rpb259IGZuIENhbGxiYWNrIGZ1bmN0aW9uIGZvciB3aGVuIHRoZSBldmVudCBpcyB0cmlnZ2VyZWRcbiAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAqL1xuZnVuY3Rpb24gX2ZuQmluZEFjdGlvbiggbiwgc2VsZWN0b3IsIGZuIClcbntcblx0JChuKVxuXHRcdC5vbiggJ2NsaWNrLkRUJywgc2VsZWN0b3IsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRmbihlKTtcblx0XHR9IClcblx0XHQub24oICdrZXlwcmVzcy5EVCcsIHNlbGVjdG9yLCBmdW5jdGlvbiAoZSl7XG5cdFx0XHRpZiAoIGUud2hpY2ggPT09IDEzICkge1xuXHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdGZuKGUpO1xuXHRcdFx0fVxuXHRcdH0gKVxuXHRcdC5vbiggJ3NlbGVjdHN0YXJ0LkRUJywgc2VsZWN0b3IsIGZ1bmN0aW9uICgpIHtcblx0XHRcdC8vIERvbid0IHdhbnQgYSBkb3VibGUgY2xpY2sgcmVzdWx0aW5nIGluIHRleHQgc2VsZWN0aW9uXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSApO1xufVxuXG5cbi8qKlxuICogUmVnaXN0ZXIgYSBjYWxsYmFjayBmdW5jdGlvbi4gRWFzaWx5IGFsbG93cyBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGFkZGVkIHRvXG4gKiBhbiBhcnJheSBzdG9yZSBvZiBjYWxsYmFjayBmdW5jdGlvbnMgdGhhdCBjYW4gdGhlbiBhbGwgYmUgY2FsbGVkIHRvZ2V0aGVyLlxuICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEBwYXJhbSB7c3RyaW5nfSBzdG9yZSBOYW1lIG9mIHRoZSBhcnJheSBzdG9yYWdlIGZvciB0aGUgY2FsbGJhY2tzIGluIG9TZXR0aW5nc1xuICogIEBwYXJhbSB7ZnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBiYWNrXG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkNhbGxiYWNrUmVnKCBzZXR0aW5ncywgc3RvcmUsIGZuIClcbntcblx0aWYgKCBmbiApIHtcblx0XHRzZXR0aW5nc1tzdG9yZV0ucHVzaChmbik7XG5cdH1cbn1cblxuXG4vKipcbiAqIEZpcmUgY2FsbGJhY2sgZnVuY3Rpb25zIGFuZCB0cmlnZ2VyIGV2ZW50cy4gTm90ZSB0aGF0IHRoZSBsb29wIG92ZXIgdGhlXG4gKiBjYWxsYmFjayBhcnJheSBzdG9yZSBpcyBkb25lIGJhY2t3YXJkcyEgRnVydGhlciBub3RlIHRoYXQgeW91IGRvIG5vdCB3YW50IHRvXG4gKiBmaXJlIG9mZiB0cmlnZ2VycyBpbiB0aW1lIHNlbnNpdGl2ZSBhcHBsaWNhdGlvbnMgKGZvciBleGFtcGxlIGNlbGwgY3JlYXRpb24pXG4gKiBhcyBpdHMgc2xvdy5cbiAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAqICBAcGFyYW0ge3N0cmluZ30gY2FsbGJhY2tBcnIgTmFtZSBvZiB0aGUgYXJyYXkgc3RvcmFnZSBmb3IgdGhlIGNhbGxiYWNrcyBpblxuICogICAgICBvU2V0dGluZ3NcbiAqICBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIE5hbWUgb2YgdGhlIGpRdWVyeSBjdXN0b20gZXZlbnQgdG8gdHJpZ2dlci4gSWZcbiAqICAgICAgbnVsbCBubyB0cmlnZ2VyIGlzIGZpcmVkXG4gKiAgQHBhcmFtIHthcnJheX0gYXJncyBBcnJheSBvZiBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gL1xuICogICAgICB0cmlnZ2VyXG4gKiAgQHBhcmFtIHtib29sZWFufSBbYnViYmxlc10gVHJ1ZSBpZiB0aGUgZXZlbnQgc2hvdWxkIGJ1YmJsZVxuICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICovXG5mdW5jdGlvbiBfZm5DYWxsYmFja0ZpcmUoIHNldHRpbmdzLCBjYWxsYmFja0FyciwgZXZlbnROYW1lLCBhcmdzLCBidWJibGVzIClcbntcblx0dmFyIHJldCA9IFtdO1xuXG5cdGlmICggY2FsbGJhY2tBcnIgKSB7XG5cdFx0cmV0ID0gc2V0dGluZ3NbY2FsbGJhY2tBcnJdLnNsaWNlKCkucmV2ZXJzZSgpLm1hcCggZnVuY3Rpb24gKHZhbCkge1xuXHRcdFx0cmV0dXJuIHZhbC5hcHBseSggc2V0dGluZ3Mub0luc3RhbmNlLCBhcmdzICk7XG5cdFx0fSApO1xuXHR9XG5cblx0aWYgKCBldmVudE5hbWUgIT09IG51bGwpIHtcblx0XHR2YXIgZSA9ICQuRXZlbnQoIGV2ZW50TmFtZSsnLmR0JyApO1xuXHRcdHZhciB0YWJsZSA9ICQoc2V0dGluZ3MublRhYmxlKTtcblx0XHRcblx0XHQvLyBFeHBvc2UgdGhlIERhdGFUYWJsZXMgQVBJIG9uIHRoZSBldmVudCBvYmplY3QgZm9yIGVhc3kgYWNjZXNzXG5cdFx0ZS5kdCA9IHNldHRpbmdzLmFwaTtcblxuXHRcdHRhYmxlW2J1YmJsZXMgPyAgJ3RyaWdnZXInIDogJ3RyaWdnZXJIYW5kbGVyJ10oIGUsIGFyZ3MgKTtcblxuXHRcdC8vIElmIG5vdCB5ZXQgYXR0YWNoZWQgdG8gdGhlIGRvY3VtZW50LCB0cmlnZ2VyIHRoZSBldmVudFxuXHRcdC8vIG9uIHRoZSBib2R5IGRpcmVjdGx5IHRvIHNvcnQgb2Ygc2ltdWxhdGUgdGhlIGJ1YmJsZVxuXHRcdGlmIChidWJibGVzICYmIHRhYmxlLnBhcmVudHMoJ2JvZHknKS5sZW5ndGggPT09IDApIHtcblx0XHRcdCQoJ2JvZHknKS50cmlnZ2VyKCBlLCBhcmdzICk7XG5cdFx0fVxuXG5cdFx0cmV0LnB1c2goIGUucmVzdWx0ICk7XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufVxuXG5cbmZ1bmN0aW9uIF9mbkxlbmd0aE92ZXJmbG93ICggc2V0dGluZ3MgKVxue1xuXHR2YXJcblx0XHRzdGFydCA9IHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0LFxuXHRcdGVuZCA9IHNldHRpbmdzLmZuRGlzcGxheUVuZCgpLFxuXHRcdGxlbiA9IHNldHRpbmdzLl9pRGlzcGxheUxlbmd0aDtcblxuXHQvKiBJZiB3ZSBoYXZlIHNwYWNlIHRvIHNob3cgZXh0cmEgcm93cyAoYmFja2luZyB1cCBmcm9tIHRoZSBlbmQgcG9pbnQgLSB0aGVuIGRvIHNvICovXG5cdGlmICggc3RhcnQgPj0gZW5kIClcblx0e1xuXHRcdHN0YXJ0ID0gZW5kIC0gbGVuO1xuXHR9XG5cblx0Ly8gS2VlcCB0aGUgc3RhcnQgcmVjb3JkIG9uIHRoZSBjdXJyZW50IHBhZ2Vcblx0c3RhcnQgLT0gKHN0YXJ0ICUgbGVuKTtcblxuXHRpZiAoIGxlbiA9PT0gLTEgfHwgc3RhcnQgPCAwIClcblx0e1xuXHRcdHN0YXJ0ID0gMDtcblx0fVxuXG5cdHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0ID0gc3RhcnQ7XG59XG5cblxuZnVuY3Rpb24gX2ZuUmVuZGVyZXIoIHNldHRpbmdzLCB0eXBlIClcbntcblx0dmFyIHJlbmRlcmVyID0gc2V0dGluZ3MucmVuZGVyZXI7XG5cdHZhciBob3N0ID0gRGF0YVRhYmxlLmV4dC5yZW5kZXJlclt0eXBlXTtcblxuXHRpZiAoICQuaXNQbGFpbk9iamVjdCggcmVuZGVyZXIgKSAmJiByZW5kZXJlclt0eXBlXSApIHtcblx0XHQvLyBTcGVjaWZpYyByZW5kZXJlciBmb3IgdGhpcyB0eXBlLiBJZiBhdmFpbGFibGUgdXNlIGl0LCBvdGhlcndpc2UgdXNlXG5cdFx0Ly8gdGhlIGRlZmF1bHQuXG5cdFx0cmV0dXJuIGhvc3RbcmVuZGVyZXJbdHlwZV1dIHx8IGhvc3QuXztcblx0fVxuXHRlbHNlIGlmICggdHlwZW9mIHJlbmRlcmVyID09PSAnc3RyaW5nJyApIHtcblx0XHQvLyBDb21tb24gcmVuZGVyZXIgLSBpZiB0aGVyZSBpcyBvbmUgYXZhaWxhYmxlIGZvciB0aGlzIHR5cGUgdXNlIGl0LFxuXHRcdC8vIG90aGVyd2lzZSB1c2UgdGhlIGRlZmF1bHRcblx0XHRyZXR1cm4gaG9zdFtyZW5kZXJlcl0gfHwgaG9zdC5fO1xuXHR9XG5cblx0Ly8gVXNlIHRoZSBkZWZhdWx0XG5cdHJldHVybiBob3N0Ll87XG59XG5cblxuLyoqXG4gKiBEZXRlY3QgdGhlIGRhdGEgc291cmNlIGJlaW5nIHVzZWQgZm9yIHRoZSB0YWJsZS4gVXNlZCB0byBzaW1wbGlmeSB0aGUgY29kZVxuICogYSBsaXR0bGUgKGFqYXgpIGFuZCB0byBtYWtlIGl0IGNvbXByZXNzIGEgbGl0dGxlIHNtYWxsZXIuXG4gKlxuICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogIEByZXR1cm5zIHtzdHJpbmd9IERhdGEgc291cmNlXG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mbkRhdGFTb3VyY2UgKCBzZXR0aW5ncyApXG57XG5cdGlmICggc2V0dGluZ3Mub0ZlYXR1cmVzLmJTZXJ2ZXJTaWRlICkge1xuXHRcdHJldHVybiAnc3NwJztcblx0fVxuXHRlbHNlIGlmICggc2V0dGluZ3MuYWpheCApIHtcblx0XHRyZXR1cm4gJ2FqYXgnO1xuXHR9XG5cdHJldHVybiAnZG9tJztcbn1cblxuLyoqXG4gKiBDb21tb24gcmVwbGFjZW1lbnQgZm9yIGxhbmd1YWdlIHN0cmluZ3NcbiAqXG4gKiBAcGFyYW0geyp9IHNldHRpbmdzIERUIHNldHRpbmdzIG9iamVjdFxuICogQHBhcmFtIHsqfSBzdHIgU3RyaW5nIHdpdGggdmFsdWVzIHRvIHJlcGxhY2VcbiAqIEBwYXJhbSB7Kn0gZW50cmllcyBQbHVyYWwgbnVtYmVyIGZvciBfRU5UUklFU18gLSBjYW4gYmUgdW5kZWZpbmVkXG4gKiBAcmV0dXJucyBTdHJpbmdcbiAqL1xuZnVuY3Rpb24gX2ZuTWFjcm9zICggc2V0dGluZ3MsIHN0ciwgZW50cmllcyApXG57XG5cdC8vIFdoZW4gaW5maW5pdGUgc2Nyb2xsaW5nLCB3ZSBhcmUgYWx3YXlzIHN0YXJ0aW5nIGF0IDEuIF9pRGlzcGxheVN0YXJ0IGlzXG5cdC8vIHVzZWQgb25seSBpbnRlcm5hbGx5XG5cdHZhclxuXHRcdGZvcm1hdHRlciAgPSBzZXR0aW5ncy5mbkZvcm1hdE51bWJlcixcblx0XHRzdGFydCAgICAgID0gc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQrMSxcblx0XHRsZW4gICAgICAgID0gc2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoLFxuXHRcdHZpcyAgICAgICAgPSBzZXR0aW5ncy5mblJlY29yZHNEaXNwbGF5KCksXG5cdFx0bWF4ICAgICAgICA9IHNldHRpbmdzLmZuUmVjb3Jkc1RvdGFsKCksXG5cdFx0YWxsICAgICAgICA9IGxlbiA9PT0gLTE7XG5cblx0cmV0dXJuIHN0ci5cblx0XHRyZXBsYWNlKC9fU1RBUlRfL2csIGZvcm1hdHRlci5jYWxsKCBzZXR0aW5ncywgc3RhcnQgKSApLlxuXHRcdHJlcGxhY2UoL19FTkRfL2csICAgZm9ybWF0dGVyLmNhbGwoIHNldHRpbmdzLCBzZXR0aW5ncy5mbkRpc3BsYXlFbmQoKSApICkuXG5cdFx0cmVwbGFjZSgvX01BWF8vZywgICBmb3JtYXR0ZXIuY2FsbCggc2V0dGluZ3MsIG1heCApICkuXG5cdFx0cmVwbGFjZSgvX1RPVEFMXy9nLCBmb3JtYXR0ZXIuY2FsbCggc2V0dGluZ3MsIHZpcyApICkuXG5cdFx0cmVwbGFjZSgvX1BBR0VfL2csICBmb3JtYXR0ZXIuY2FsbCggc2V0dGluZ3MsIGFsbCA/IDEgOiBNYXRoLmNlaWwoIHN0YXJ0IC8gbGVuICkgKSApLlxuXHRcdHJlcGxhY2UoL19QQUdFU18vZywgZm9ybWF0dGVyLmNhbGwoIHNldHRpbmdzLCBhbGwgPyAxIDogTWF0aC5jZWlsKCB2aXMgLyBsZW4gKSApICkuXG5cdFx0cmVwbGFjZSgvX0VOVFJJRVNfL2csIHNldHRpbmdzLmFwaS5pMThuKCdlbnRyaWVzJywgJycsIGVudHJpZXMpICkuXG5cdFx0cmVwbGFjZSgvX0VOVFJJRVMtTUFYXy9nLCBzZXR0aW5ncy5hcGkuaTE4bignZW50cmllcycsICcnLCBtYXgpICkuXG5cdFx0cmVwbGFjZSgvX0VOVFJJRVMtVE9UQUxfL2csIHNldHRpbmdzLmFwaS5pMThuKCdlbnRyaWVzJywgJycsIHZpcykgKTtcbn1cblxuLyoqXG4gKiBBZGQgZWxlbWVudHMgdG8gYW4gYXJyYXkgYXMgcXVpY2tseSBhcyBwb3NzaWJsZSwgYnV0IHN0YWNrIHN0YWZlLlxuICpcbiAqIEBwYXJhbSB7Kn0gYXJyIEFycmF5IHRvIGFkZCB0aGUgZGF0YSB0b1xuICogQHBhcmFtIHsqfSBkYXRhIERhdGEgYXJyYXkgdGhhdCBpcyB0byBiZSBhZGRlZFxuICogQHJldHVybnMgXG4gKi9cbmZ1bmN0aW9uIF9mbkFycmF5QXBwbHkoYXJyLCBkYXRhKSB7XG5cdGlmICghIGRhdGEpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBDaHJvbWUgY2FuIHRocm93IGEgbWF4IHN0YWNrIGVycm9yIGlmIGFwcGx5IGlzIGNhbGxlZCB3aXRoXG5cdC8vIHRvbyBsYXJnZSBhbiBhcnJheSwgYnV0IGFwcGx5IGlzIGZhc3Rlci5cblx0aWYgKGRhdGEubGVuZ3RoIDwgMTAwMDApIHtcblx0XHRhcnIucHVzaC5hcHBseShhcnIsIGRhdGEpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdGZvciAoaT0wIDsgaTxkYXRhLmxlbmd0aCA7IGkrKykge1xuXHRcdFx0YXJyLnB1c2goZGF0YVtpXSk7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQWRkIG9uZSBvciBtb3JlIGxpc3RlbmVycyB0byB0aGUgdGFibGVcbiAqXG4gKiBAcGFyYW0geyp9IHRoYXQgSlEgZm9yIHRoZSB0YWJsZVxuICogQHBhcmFtIHsqfSBuYW1lIEV2ZW50IG5hbWVcbiAqIEBwYXJhbSB7Kn0gc3JjIExpc3RlbmVyKHMpXG4gKi9cbmZ1bmN0aW9uIF9mbkxpc3RlbmVyKHRoYXQsIG5hbWUsIHNyYykge1xuXHRpZiAoIUFycmF5LmlzQXJyYXkoc3JjKSkge1xuXHRcdHNyYyA9IFtzcmNdO1xuXHR9XG5cblx0Zm9yIChpPTAgOyBpPHNyYy5sZW5ndGggOyBpKyspIHtcblx0XHR0aGF0Lm9uKG5hbWUgKyAnLmR0Jywgc3JjW2ldKTtcblx0fVxufVxuXG5cblxuLyoqXG4gKiBDb21wdXRlZCBzdHJ1Y3R1cmUgb2YgdGhlIERhdGFUYWJsZXMgQVBJLCBkZWZpbmVkIGJ5IHRoZSBvcHRpb25zIHBhc3NlZCB0b1xuICogYERhdGFUYWJsZS5BcGkucmVnaXN0ZXIoKWAgd2hlbiBidWlsZGluZyB0aGUgQVBJLlxuICpcbiAqIFRoZSBzdHJ1Y3R1cmUgaXMgYnVpbHQgaW4gb3JkZXIgdG8gc3BlZWQgY3JlYXRpb24gYW5kIGV4dGVuc2lvbiBvZiB0aGUgQXBpXG4gKiBvYmplY3RzIHNpbmNlIHRoZSBleHRlbnNpb25zIGFyZSBlZmZlY3RpdmVseSBwcmUtcGFyc2VkLlxuICpcbiAqIFRoZSBhcnJheSBpcyBhbiBhcnJheSBvZiBvYmplY3RzIHdpdGggdGhlIGZvbGxvd2luZyBzdHJ1Y3R1cmUsIHdoZXJlIHRoaXNcbiAqIGJhc2UgYXJyYXkgcmVwcmVzZW50cyB0aGUgQXBpIHByb3RvdHlwZSBiYXNlOlxuICpcbiAqICAgICBbXG4gKiAgICAgICB7XG4gKiAgICAgICAgIG5hbWU6ICAgICAgJ2RhdGEnICAgICAgICAgICAgICAgIC0tIHN0cmluZyAgIC0gUHJvcGVydHkgbmFtZVxuICogICAgICAgICB2YWw6ICAgICAgIGZ1bmN0aW9uICgpIHt9LCAgICAgICAtLSBmdW5jdGlvbiAtIEFwaSBtZXRob2QgKG9yIHVuZGVmaW5lZCBpZiBqdXN0IGFuIG9iamVjdFxuICogICAgICAgICBtZXRob2RFeHQ6IFsgLi4uIF0sICAgICAgICAgICAgICAtLSBhcnJheSAgICAtIEFycmF5IG9mIEFwaSBvYmplY3QgZGVmaW5pdGlvbnMgdG8gZXh0ZW5kIHRoZSBtZXRob2QgcmVzdWx0XG4gKiAgICAgICAgIHByb3BFeHQ6ICAgWyAuLi4gXSAgICAgICAgICAgICAgIC0tIGFycmF5ICAgIC0gQXJyYXkgb2YgQXBpIG9iamVjdCBkZWZpbml0aW9ucyB0byBleHRlbmQgdGhlIHByb3BlcnR5XG4gKiAgICAgICB9LFxuICogICAgICAge1xuICogICAgICAgICBuYW1lOiAgICAgJ3JvdydcbiAqICAgICAgICAgdmFsOiAgICAgICB7fSxcbiAqICAgICAgICAgbWV0aG9kRXh0OiBbIC4uLiBdLFxuICogICAgICAgICBwcm9wRXh0OiAgIFtcbiAqICAgICAgICAgICB7XG4gKiAgICAgICAgICAgICBuYW1lOiAgICAgICdkYXRhJ1xuICogICAgICAgICAgICAgdmFsOiAgICAgICBmdW5jdGlvbiAoKSB7fSxcbiAqICAgICAgICAgICAgIG1ldGhvZEV4dDogWyAuLi4gXSxcbiAqICAgICAgICAgICAgIHByb3BFeHQ6ICAgWyAuLi4gXVxuICogICAgICAgICAgIH0sXG4gKiAgICAgICAgICAgLi4uXG4gKiAgICAgICAgIF1cbiAqICAgICAgIH1cbiAqICAgICBdXG4gKlxuICogQHR5cGUge0FycmF5fVxuICogQGlnbm9yZVxuICovXG52YXIgX19hcGlTdHJ1Y3QgPSBbXTtcblxuXG4vKipcbiAqIGBBcnJheS5wcm90b3R5cGVgIHJlZmVyZW5jZS5cbiAqXG4gKiBAdHlwZSBvYmplY3RcbiAqIEBpZ25vcmVcbiAqL1xudmFyIF9fYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxuXG4vKipcbiAqIEFic3RyYWN0aW9uIGZvciBgY29udGV4dGAgcGFyYW1ldGVyIG9mIHRoZSBgQXBpYCBjb25zdHJ1Y3RvciB0byBhbGxvdyBpdCB0b1xuICogdGFrZSBzZXZlcmFsIGRpZmZlcmVudCBmb3JtcyBmb3IgZWFzZSBvZiB1c2UuXG4gKlxuICogRWFjaCBvZiB0aGUgaW5wdXQgcGFyYW1ldGVyIHR5cGVzIHdpbGwgYmUgY29udmVydGVkIHRvIGEgRGF0YVRhYmxlcyBzZXR0aW5nc1xuICogb2JqZWN0IHdoZXJlIHBvc3NpYmxlLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ3xub2RlfGpRdWVyeXxvYmplY3R9IG1peGVkIERhdGFUYWJsZSBpZGVudGlmaWVyLiBDYW4gYmUgb25lXG4gKiAgIG9mOlxuICpcbiAqICAgKiBgc3RyaW5nYCAtIGpRdWVyeSBzZWxlY3Rvci4gQW55IERhdGFUYWJsZXMnIG1hdGNoaW5nIHRoZSBnaXZlbiBzZWxlY3RvclxuICogICAgIHdpdGggYmUgZm91bmQgYW5kIHVzZWQuXG4gKiAgICogYG5vZGVgIC0gYFRBQkxFYCBub2RlIHdoaWNoIGhhcyBhbHJlYWR5IGJlZW4gZm9ybWVkIGludG8gYSBEYXRhVGFibGUuXG4gKiAgICogYGpRdWVyeWAgLSBBIGpRdWVyeSBvYmplY3Qgb2YgYFRBQkxFYCBub2Rlcy5cbiAqICAgKiBgb2JqZWN0YCAtIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgICogYERhdGFUYWJsZXMuQXBpYCAtIEFQSSBpbnN0YW5jZVxuICogQHJldHVybiB7YXJyYXl8bnVsbH0gTWF0Y2hpbmcgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RzLiBgbnVsbGAgb3JcbiAqICAgYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQgaWYgbm8gbWF0Y2hpbmcgRGF0YVRhYmxlIGlzIGZvdW5kLlxuICogQGlnbm9yZVxuICovXG52YXIgX3RvU2V0dGluZ3MgPSBmdW5jdGlvbiAoIG1peGVkIClcbntcblx0dmFyIGlkeCwganE7XG5cdHZhciBzZXR0aW5ncyA9IERhdGFUYWJsZS5zZXR0aW5ncztcblx0dmFyIHRhYmxlcyA9IF9wbHVjayhzZXR0aW5ncywgJ25UYWJsZScpO1xuXG5cdGlmICggISBtaXhlZCApIHtcblx0XHRyZXR1cm4gW107XG5cdH1cblx0ZWxzZSBpZiAoIG1peGVkLm5UYWJsZSAmJiBtaXhlZC5vRmVhdHVyZXMgKSB7XG5cdFx0Ly8gRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Rcblx0XHRyZXR1cm4gWyBtaXhlZCBdO1xuXHR9XG5cdGVsc2UgaWYgKCBtaXhlZC5ub2RlTmFtZSAmJiBtaXhlZC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAndGFibGUnICkge1xuXHRcdC8vIFRhYmxlIG5vZGVcblx0XHRpZHggPSB0YWJsZXMuaW5kZXhPZihtaXhlZCk7XG5cdFx0cmV0dXJuIGlkeCAhPT0gLTEgPyBbIHNldHRpbmdzW2lkeF0gXSA6IG51bGw7XG5cdH1cblx0ZWxzZSBpZiAoIG1peGVkICYmIHR5cGVvZiBtaXhlZC5zZXR0aW5ncyA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRyZXR1cm4gbWl4ZWQuc2V0dGluZ3MoKS50b0FycmF5KCk7XG5cdH1cblx0ZWxzZSBpZiAoIHR5cGVvZiBtaXhlZCA9PT0gJ3N0cmluZycgKSB7XG5cdFx0Ly8galF1ZXJ5IHNlbGVjdG9yXG5cdFx0anEgPSAkKG1peGVkKS5nZXQoKTtcblx0fVxuXHRlbHNlIGlmICggbWl4ZWQgaW5zdGFuY2VvZiAkICkge1xuXHRcdC8vIGpRdWVyeSBvYmplY3QgKGFsc28gRGF0YVRhYmxlcyBpbnN0YW5jZSlcblx0XHRqcSA9IG1peGVkLmdldCgpO1xuXHR9XG5cblx0aWYgKCBqcSApIHtcblx0XHRyZXR1cm4gc2V0dGluZ3MuZmlsdGVyKGZ1bmN0aW9uICh2LCBpZHgpIHtcblx0XHRcdHJldHVybiBqcS5pbmNsdWRlcyh0YWJsZXNbaWR4XSk7XG5cdFx0fSk7XG5cdH1cbn07XG5cblxuLyoqXG4gKiBEYXRhVGFibGVzIEFQSSBjbGFzcyAtIHVzZWQgdG8gY29udHJvbCBhbmQgaW50ZXJmYWNlIHdpdGggIG9uZSBvciBtb3JlXG4gKiBEYXRhVGFibGVzIGVuaGFuY2VkIHRhYmxlcy5cbiAqXG4gKiBUaGUgQVBJIGNsYXNzIGlzIGhlYXZpbHkgYmFzZWQgb24galF1ZXJ5LCBwcmVzZW50aW5nIGEgY2hhaW5hYmxlIGludGVyZmFjZVxuICogdGhhdCB5b3UgY2FuIHVzZSB0byBpbnRlcmFjdCB3aXRoIHRhYmxlcy4gRWFjaCBpbnN0YW5jZSBvZiB0aGUgQVBJIGNsYXNzIGhhc1xuICogYSBcImNvbnRleHRcIiAtIGkuZS4gdGhlIHRhYmxlcyB0aGF0IGl0IHdpbGwgb3BlcmF0ZSBvbi4gVGhpcyBjb3VsZCBiZSBhIHNpbmdsZVxuICogdGFibGUsIGFsbCB0YWJsZXMgb24gYSBwYWdlIG9yIGEgc3ViLXNldCB0aGVyZW9mLlxuICpcbiAqIEFkZGl0aW9uYWxseSB0aGUgQVBJIGlzIGRlc2lnbmVkIHRvIGFsbG93IHlvdSB0byBlYXNpbHkgd29yayB3aXRoIHRoZSBkYXRhIGluXG4gKiB0aGUgdGFibGVzLCByZXRyaWV2aW5nIGFuZCBtYW5pcHVsYXRpbmcgaXQgYXMgcmVxdWlyZWQuIFRoaXMgaXMgZG9uZSBieVxuICogcHJlc2VudGluZyB0aGUgQVBJIGNsYXNzIGFzIGFuIGFycmF5IGxpa2UgaW50ZXJmYWNlLiBUaGUgY29udGVudHMgb2YgdGhlXG4gKiBhcnJheSBkZXBlbmQgdXBvbiB0aGUgYWN0aW9ucyByZXF1ZXN0ZWQgYnkgZWFjaCBtZXRob2QgKGZvciBleGFtcGxlXG4gKiBgcm93cygpLm5vZGVzKClgIHdpbGwgcmV0dXJuIGFuIGFycmF5IG9mIG5vZGVzLCB3aGlsZSBgcm93cygpLmRhdGEoKWAgd2lsbFxuICogcmV0dXJuIGFuIGFycmF5IG9mIG9iamVjdHMgb3IgYXJyYXlzIGRlcGVuZGluZyB1cG9uIHlvdXIgdGFibGUnc1xuICogY29uZmlndXJhdGlvbikuIFRoZSBBUEkgb2JqZWN0IGhhcyBhIG51bWJlciBvZiBhcnJheSBsaWtlIG1ldGhvZHMgKGBwdXNoYCxcbiAqIGBwb3BgLCBgcmV2ZXJzZWAgZXRjKSBhcyB3ZWxsIGFzIGFkZGl0aW9uYWwgaGVscGVyIG1ldGhvZHMgKGBlYWNoYCwgYHBsdWNrYCxcbiAqIGB1bmlxdWVgIGV0YykgdG8gYXNzaXN0IHlvdXIgd29ya2luZyB3aXRoIHRoZSBkYXRhIGhlbGQgaW4gYSB0YWJsZS5cbiAqXG4gKiBNb3N0IG1ldGhvZHMgKHRob3NlIHdoaWNoIHJldHVybiBhbiBBcGkgaW5zdGFuY2UpIGFyZSBjaGFpbmFibGUsIHdoaWNoIG1lYW5zXG4gKiB0aGUgcmV0dXJuIGZyb20gYSBtZXRob2QgY2FsbCBhbHNvIGhhcyBhbGwgb2YgdGhlIG1ldGhvZHMgYXZhaWxhYmxlIHRoYXQgdGhlXG4gKiB0b3AgbGV2ZWwgb2JqZWN0IGhhZC4gRm9yIGV4YW1wbGUsIHRoZXNlIHR3byBjYWxscyBhcmUgZXF1aXZhbGVudDpcbiAqXG4gKiAgICAgLy8gTm90IGNoYWluZWRcbiAqICAgICBhcGkucm93LmFkZCggey4uLn0gKTtcbiAqICAgICBhcGkuZHJhdygpO1xuICpcbiAqICAgICAvLyBDaGFpbmVkXG4gKiAgICAgYXBpLnJvdy5hZGQoIHsuLi59ICkuZHJhdygpO1xuICpcbiAqIEBjbGFzcyBEYXRhVGFibGUuQXBpXG4gKiBAcGFyYW0ge2FycmF5fG9iamVjdHxzdHJpbmd8alF1ZXJ5fSBjb250ZXh0IERhdGFUYWJsZSBpZGVudGlmaWVyLiBUaGlzIGlzXG4gKiAgIHVzZWQgdG8gZGVmaW5lIHdoaWNoIERhdGFUYWJsZXMgZW5oYW5jZWQgdGFibGVzIHRoaXMgQVBJIHdpbGwgb3BlcmF0ZSBvbi5cbiAqICAgQ2FuIGJlIG9uZSBvZjpcbiAqXG4gKiAgICogYHN0cmluZ2AgLSBqUXVlcnkgc2VsZWN0b3IuIEFueSBEYXRhVGFibGVzJyBtYXRjaGluZyB0aGUgZ2l2ZW4gc2VsZWN0b3JcbiAqICAgICB3aXRoIGJlIGZvdW5kIGFuZCB1c2VkLlxuICogICAqIGBub2RlYCAtIGBUQUJMRWAgbm9kZSB3aGljaCBoYXMgYWxyZWFkeSBiZWVuIGZvcm1lZCBpbnRvIGEgRGF0YVRhYmxlLlxuICogICAqIGBqUXVlcnlgIC0gQSBqUXVlcnkgb2JqZWN0IG9mIGBUQUJMRWAgbm9kZXMuXG4gKiAgICogYG9iamVjdGAgLSBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICogQHBhcmFtIHthcnJheX0gW2RhdGFdIERhdGEgdG8gaW5pdGlhbGlzZSB0aGUgQXBpIGluc3RhbmNlIHdpdGguXG4gKlxuICogQGV4YW1wbGVcbiAqICAgLy8gRGlyZWN0IGluaXRpYWxpc2F0aW9uIGR1cmluZyBEYXRhVGFibGVzIGNvbnN0cnVjdGlvblxuICogICB2YXIgYXBpID0gJCgnI2V4YW1wbGUnKS5EYXRhVGFibGUoKTtcbiAqXG4gKiBAZXhhbXBsZVxuICogICAvLyBJbml0aWFsaXNhdGlvbiB1c2luZyBhIERhdGFUYWJsZXMgalF1ZXJ5IG9iamVjdFxuICogICB2YXIgYXBpID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKS5hcGkoKTtcbiAqXG4gKiBAZXhhbXBsZVxuICogICAvLyBJbml0aWFsaXNhdGlvbiBhcyBhIGNvbnN0cnVjdG9yXG4gKiAgIHZhciBhcGkgPSBuZXcgRGF0YVRhYmxlLkFwaSggJ3RhYmxlLmRhdGFUYWJsZScgKTtcbiAqL1xuX0FwaSA9IGZ1bmN0aW9uICggY29udGV4dCwgZGF0YSApXG57XG5cdGlmICggISAodGhpcyBpbnN0YW5jZW9mIF9BcGkpICkge1xuXHRcdHJldHVybiBuZXcgX0FwaSggY29udGV4dCwgZGF0YSApO1xuXHR9XG5cblx0dmFyIGk7XG5cdHZhciBzZXR0aW5ncyA9IFtdO1xuXHR2YXIgY3R4U2V0dGluZ3MgPSBmdW5jdGlvbiAoIG8gKSB7XG5cdFx0dmFyIGEgPSBfdG9TZXR0aW5ncyggbyApO1xuXHRcdGlmICggYSApIHtcblx0XHRcdHNldHRpbmdzLnB1c2guYXBwbHkoIHNldHRpbmdzLCBhICk7XG5cdFx0fVxuXHR9O1xuXG5cdGlmICggQXJyYXkuaXNBcnJheSggY29udGV4dCApICkge1xuXHRcdGZvciAoIGk9MCA7IGk8Y29udGV4dC5sZW5ndGggOyBpKysgKSB7XG5cdFx0XHRjdHhTZXR0aW5ncyggY29udGV4dFtpXSApO1xuXHRcdH1cblx0fVxuXHRlbHNlIHtcblx0XHRjdHhTZXR0aW5ncyggY29udGV4dCApO1xuXHR9XG5cblx0Ly8gUmVtb3ZlIGR1cGxpY2F0ZXNcblx0dGhpcy5jb250ZXh0ID0gc2V0dGluZ3MubGVuZ3RoID4gMVxuXHRcdD8gX3VuaXF1ZSggc2V0dGluZ3MgKVxuXHRcdDogc2V0dGluZ3M7XG5cblx0Ly8gSW5pdGlhbCBkYXRhXG5cdF9mbkFycmF5QXBwbHkodGhpcywgZGF0YSk7XG5cblx0Ly8gc2VsZWN0b3Jcblx0dGhpcy5zZWxlY3RvciA9IHtcblx0XHRyb3dzOiBudWxsLFxuXHRcdGNvbHM6IG51bGwsXG5cdFx0b3B0czogbnVsbFxuXHR9O1xuXG5cdF9BcGkuZXh0ZW5kKCB0aGlzLCB0aGlzLCBfX2FwaVN0cnVjdCApO1xufTtcblxuRGF0YVRhYmxlLkFwaSA9IF9BcGk7XG5cbi8vIERvbid0IGRlc3Ryb3kgdGhlIGV4aXN0aW5nIHByb3RvdHlwZSwganVzdCBleHRlbmQgaXQuIFJlcXVpcmVkIGZvciBqUXVlcnkgMidzXG4vLyBpc1BsYWluT2JqZWN0LlxuJC5leHRlbmQoIF9BcGkucHJvdG90eXBlLCB7XG5cdGFueTogZnVuY3Rpb24gKClcblx0e1xuXHRcdHJldHVybiB0aGlzLmNvdW50KCkgIT09IDA7XG5cdH0sXG5cblx0Y29udGV4dDogW10sIC8vIGFycmF5IG9mIHRhYmxlIHNldHRpbmdzIG9iamVjdHNcblxuXHRjb3VudDogZnVuY3Rpb24gKClcblx0e1xuXHRcdHJldHVybiB0aGlzLmZsYXR0ZW4oKS5sZW5ndGg7XG5cdH0sXG5cblx0ZWFjaDogZnVuY3Rpb24gKCBmbiApXG5cdHtcblx0XHRmb3IgKCB2YXIgaT0wLCBpZW49dGhpcy5sZW5ndGggOyBpPGllbjsgaSsrICkge1xuXHRcdFx0Zm4uY2FsbCggdGhpcywgdGhpc1tpXSwgaSwgdGhpcyApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGVxOiBmdW5jdGlvbiAoIGlkeCApXG5cdHtcblx0XHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXG5cdFx0cmV0dXJuIGN0eC5sZW5ndGggPiBpZHggP1xuXHRcdFx0bmV3IF9BcGkoIGN0eFtpZHhdLCB0aGlzW2lkeF0gKSA6XG5cdFx0XHRudWxsO1xuXHR9LFxuXG5cdGZpbHRlcjogZnVuY3Rpb24gKCBmbiApXG5cdHtcblx0XHR2YXIgYSA9IF9fYXJyYXlQcm90by5maWx0ZXIuY2FsbCggdGhpcywgZm4sIHRoaXMgKTtcblxuXHRcdHJldHVybiBuZXcgX0FwaSggdGhpcy5jb250ZXh0LCBhICk7XG5cdH0sXG5cblx0ZmxhdHRlbjogZnVuY3Rpb24gKClcblx0e1xuXHRcdHZhciBhID0gW107XG5cblx0XHRyZXR1cm4gbmV3IF9BcGkoIHRoaXMuY29udGV4dCwgYS5jb25jYXQuYXBwbHkoIGEsIHRoaXMudG9BcnJheSgpICkgKTtcblx0fSxcblxuXHRnZXQ6IGZ1bmN0aW9uICggaWR4IClcblx0e1xuXHRcdHJldHVybiB0aGlzWyBpZHggXTtcblx0fSxcblxuXHRqb2luOiAgICBfX2FycmF5UHJvdG8uam9pbixcblxuXHRpbmNsdWRlczogZnVuY3Rpb24gKCBmaW5kICkge1xuXHRcdHJldHVybiB0aGlzLmluZGV4T2YoIGZpbmQgKSA9PT0gLTEgPyBmYWxzZSA6IHRydWU7XG5cdH0sXG5cblx0aW5kZXhPZjogX19hcnJheVByb3RvLmluZGV4T2YsXG5cblx0aXRlcmF0b3I6IGZ1bmN0aW9uICggZmxhdHRlbiwgdHlwZSwgZm4sIGFsd2F5c05ldyApIHtcblx0XHR2YXJcblx0XHRcdGEgPSBbXSwgcmV0LFxuXHRcdFx0aSwgaWVuLCBqLCBqZW4sXG5cdFx0XHRjb250ZXh0ID0gdGhpcy5jb250ZXh0LFxuXHRcdFx0cm93cywgaXRlbXMsIGl0ZW0sXG5cdFx0XHRzZWxlY3RvciA9IHRoaXMuc2VsZWN0b3I7XG5cblx0XHQvLyBBcmd1bWVudCBzaGlmdGluZ1xuXHRcdGlmICggdHlwZW9mIGZsYXR0ZW4gPT09ICdzdHJpbmcnICkge1xuXHRcdFx0YWx3YXlzTmV3ID0gZm47XG5cdFx0XHRmbiA9IHR5cGU7XG5cdFx0XHR0eXBlID0gZmxhdHRlbjtcblx0XHRcdGZsYXR0ZW4gPSBmYWxzZTtcblx0XHR9XG5cblx0XHRmb3IgKCBpPTAsIGllbj1jb250ZXh0Lmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0dmFyIGFwaUluc3QgPSBuZXcgX0FwaSggY29udGV4dFtpXSApO1xuXG5cdFx0XHRpZiAoIHR5cGUgPT09ICd0YWJsZScgKSB7XG5cdFx0XHRcdHJldCA9IGZuLmNhbGwoIGFwaUluc3QsIGNvbnRleHRbaV0sIGkgKTtcblxuXHRcdFx0XHRpZiAoIHJldCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGEucHVzaCggcmV0ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCB0eXBlID09PSAnY29sdW1ucycgfHwgdHlwZSA9PT0gJ3Jvd3MnICkge1xuXHRcdFx0XHQvLyB0aGlzIGhhcyBzYW1lIGxlbmd0aCBhcyBjb250ZXh0IC0gb25lIGVudHJ5IGZvciBlYWNoIHRhYmxlXG5cdFx0XHRcdHJldCA9IGZuLmNhbGwoIGFwaUluc3QsIGNvbnRleHRbaV0sIHRoaXNbaV0sIGkgKTtcblxuXHRcdFx0XHRpZiAoIHJldCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGEucHVzaCggcmV0ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCB0eXBlID09PSAnZXZlcnknIHx8IHR5cGUgPT09ICdjb2x1bW4nIHx8IHR5cGUgPT09ICdjb2x1bW4tcm93cycgfHwgdHlwZSA9PT0gJ3JvdycgfHwgdHlwZSA9PT0gJ2NlbGwnICkge1xuXHRcdFx0XHQvLyBjb2x1bW5zIGFuZCByb3dzIHNoYXJlIHRoZSBzYW1lIHN0cnVjdHVyZS5cblx0XHRcdFx0Ly8gJ3RoaXMnIGlzIGFuIGFycmF5IG9mIGNvbHVtbiBpbmRleGVzIGZvciBlYWNoIGNvbnRleHRcblx0XHRcdFx0aXRlbXMgPSB0aGlzW2ldO1xuXG5cdFx0XHRcdGlmICggdHlwZSA9PT0gJ2NvbHVtbi1yb3dzJyApIHtcblx0XHRcdFx0XHRyb3dzID0gX3NlbGVjdG9yX3Jvd19pbmRleGVzKCBjb250ZXh0W2ldLCBzZWxlY3Rvci5vcHRzICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKCBqPTAsIGplbj1pdGVtcy5sZW5ndGggOyBqPGplbiA7IGorKyApIHtcblx0XHRcdFx0XHRpdGVtID0gaXRlbXNbal07XG5cblx0XHRcdFx0XHRpZiAoIHR5cGUgPT09ICdjZWxsJyApIHtcblx0XHRcdFx0XHRcdHJldCA9IGZuLmNhbGwoIGFwaUluc3QsIGNvbnRleHRbaV0sIGl0ZW0ucm93LCBpdGVtLmNvbHVtbiwgaSwgaiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdHJldCA9IGZuLmNhbGwoIGFwaUluc3QsIGNvbnRleHRbaV0sIGl0ZW0sIGksIGosIHJvd3MgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIHJldCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0YS5wdXNoKCByZXQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIGEubGVuZ3RoIHx8IGFsd2F5c05ldyApIHtcblx0XHRcdHZhciBhcGkgPSBuZXcgX0FwaSggY29udGV4dCwgZmxhdHRlbiA/IGEuY29uY2F0LmFwcGx5KCBbXSwgYSApIDogYSApO1xuXHRcdFx0dmFyIGFwaVNlbGVjdG9yID0gYXBpLnNlbGVjdG9yO1xuXHRcdFx0YXBpU2VsZWN0b3Iucm93cyA9IHNlbGVjdG9yLnJvd3M7XG5cdFx0XHRhcGlTZWxlY3Rvci5jb2xzID0gc2VsZWN0b3IuY29scztcblx0XHRcdGFwaVNlbGVjdG9yLm9wdHMgPSBzZWxlY3Rvci5vcHRzO1xuXHRcdFx0cmV0dXJuIGFwaTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0bGFzdEluZGV4T2Y6IF9fYXJyYXlQcm90by5sYXN0SW5kZXhPZixcblxuXHRsZW5ndGg6ICAwLFxuXG5cdG1hcDogZnVuY3Rpb24gKCBmbiApXG5cdHtcblx0XHR2YXIgYSA9IF9fYXJyYXlQcm90by5tYXAuY2FsbCggdGhpcywgZm4sIHRoaXMgKTtcblxuXHRcdHJldHVybiBuZXcgX0FwaSggdGhpcy5jb250ZXh0LCBhICk7XG5cdH0sXG5cblx0cGx1Y2s6IGZ1bmN0aW9uICggcHJvcCApXG5cdHtcblx0XHR2YXIgZm4gPSBEYXRhVGFibGUudXRpbC5nZXQocHJvcCk7XG5cblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uICggZWwgKSB7XG5cdFx0XHRyZXR1cm4gZm4oZWwpO1xuXHRcdH0gKTtcblx0fSxcblxuXHRwb3A6ICAgICBfX2FycmF5UHJvdG8ucG9wLFxuXG5cdHB1c2g6ICAgIF9fYXJyYXlQcm90by5wdXNoLFxuXG5cdHJlZHVjZTogX19hcnJheVByb3RvLnJlZHVjZSxcblxuXHRyZWR1Y2VSaWdodDogX19hcnJheVByb3RvLnJlZHVjZVJpZ2h0LFxuXG5cdHJldmVyc2U6IF9fYXJyYXlQcm90by5yZXZlcnNlLFxuXG5cdC8vIE9iamVjdCB3aXRoIHJvd3MsIGNvbHVtbnMgYW5kIG9wdHNcblx0c2VsZWN0b3I6IG51bGwsXG5cblx0c2hpZnQ6ICAgX19hcnJheVByb3RvLnNoaWZ0LFxuXG5cdHNsaWNlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIG5ldyBfQXBpKCB0aGlzLmNvbnRleHQsIHRoaXMgKTtcblx0fSxcblxuXHRzb3J0OiAgICBfX2FycmF5UHJvdG8uc29ydCxcblxuXHRzcGxpY2U6ICBfX2FycmF5UHJvdG8uc3BsaWNlLFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uICgpXG5cdHtcblx0XHRyZXR1cm4gX19hcnJheVByb3RvLnNsaWNlLmNhbGwoIHRoaXMgKTtcblx0fSxcblxuXHR0byQ6IGZ1bmN0aW9uICgpXG5cdHtcblx0XHRyZXR1cm4gJCggdGhpcyApO1xuXHR9LFxuXG5cdHRvSlF1ZXJ5OiBmdW5jdGlvbiAoKVxuXHR7XG5cdFx0cmV0dXJuICQoIHRoaXMgKTtcblx0fSxcblxuXHR1bmlxdWU6IGZ1bmN0aW9uICgpXG5cdHtcblx0XHRyZXR1cm4gbmV3IF9BcGkoIHRoaXMuY29udGV4dCwgX3VuaXF1ZSh0aGlzLnRvQXJyYXkoKSkgKTtcblx0fSxcblxuXHR1bnNoaWZ0OiBfX2FycmF5UHJvdG8udW5zaGlmdFxufSApO1xuXG5cbmZ1bmN0aW9uIF9hcGlfc2NvcGUoIHNjb3BlLCBmbiwgc3RydWMgKSB7XG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHJldCA9IGZuLmFwcGx5KCBzY29wZSB8fCB0aGlzLCBhcmd1bWVudHMgKTtcblxuXHRcdC8vIE1ldGhvZCBleHRlbnNpb25cblx0XHRfQXBpLmV4dGVuZCggcmV0LCByZXQsIHN0cnVjLm1ldGhvZEV4dCApO1xuXHRcdHJldHVybiByZXQ7XG5cdH07XG59XG5cbmZ1bmN0aW9uIF9hcGlfZmluZCggc3JjLCBuYW1lICkge1xuXHRmb3IgKCB2YXIgaT0wLCBpZW49c3JjLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdGlmICggc3JjW2ldLm5hbWUgPT09IG5hbWUgKSB7XG5cdFx0XHRyZXR1cm4gc3JjW2ldO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbnVsbDtcbn1cblxud2luZG93Ll9fYXBpU3RydWN0ID0gX19hcGlTdHJ1Y3Q7XG5cbl9BcGkuZXh0ZW5kID0gZnVuY3Rpb24gKCBzY29wZSwgb2JqLCBleHQgKVxue1xuXHQvLyBPbmx5IGV4dGVuZCBBUEkgaW5zdGFuY2VzIGFuZCBzdGF0aWMgcHJvcGVydGllcyBvZiB0aGUgQVBJXG5cdGlmICggISBleHQubGVuZ3RoIHx8ICEgb2JqIHx8ICggISAob2JqIGluc3RhbmNlb2YgX0FwaSkgJiYgISBvYmouX19kdF93cmFwcGVyICkgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dmFyXG5cdFx0aSwgaWVuLFxuXHRcdHN0cnVjdDtcblxuXHRmb3IgKCBpPTAsIGllbj1leHQubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0c3RydWN0ID0gZXh0W2ldO1xuXG5cdFx0aWYgKHN0cnVjdC5uYW1lID09PSAnX19wcm90b19fJykge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0Ly8gVmFsdWVcblx0XHRvYmpbIHN0cnVjdC5uYW1lIF0gPSBzdHJ1Y3QudHlwZSA9PT0gJ2Z1bmN0aW9uJyA/XG5cdFx0XHRfYXBpX3Njb3BlKCBzY29wZSwgc3RydWN0LnZhbCwgc3RydWN0ICkgOlxuXHRcdFx0c3RydWN0LnR5cGUgPT09ICdvYmplY3QnID9cblx0XHRcdFx0e30gOlxuXHRcdFx0XHRzdHJ1Y3QudmFsO1xuXG5cdFx0b2JqWyBzdHJ1Y3QubmFtZSBdLl9fZHRfd3JhcHBlciA9IHRydWU7XG5cblx0XHQvLyBQcm9wZXJ0eSBleHRlbnNpb25cblx0XHRfQXBpLmV4dGVuZCggc2NvcGUsIG9ialsgc3RydWN0Lm5hbWUgXSwgc3RydWN0LnByb3BFeHQgKTtcblx0fVxufTtcblxuLy8gICAgIFtcbi8vICAgICAgIHtcbi8vICAgICAgICAgbmFtZTogICAgICAnZGF0YScgICAgICAgICAgICAgICAgLS0gc3RyaW5nICAgLSBQcm9wZXJ0eSBuYW1lXG4vLyAgICAgICAgIHZhbDogICAgICAgZnVuY3Rpb24gKCkge30sICAgICAgIC0tIGZ1bmN0aW9uIC0gQXBpIG1ldGhvZCAob3IgdW5kZWZpbmVkIGlmIGp1c3QgYW4gb2JqZWN0XG4vLyAgICAgICAgIG1ldGhvZEV4dDogWyAuLi4gXSwgICAgICAgICAgICAgIC0tIGFycmF5ICAgIC0gQXJyYXkgb2YgQXBpIG9iamVjdCBkZWZpbml0aW9ucyB0byBleHRlbmQgdGhlIG1ldGhvZCByZXN1bHRcbi8vICAgICAgICAgcHJvcEV4dDogICBbIC4uLiBdICAgICAgICAgICAgICAgLS0gYXJyYXkgICAgLSBBcnJheSBvZiBBcGkgb2JqZWN0IGRlZmluaXRpb25zIHRvIGV4dGVuZCB0aGUgcHJvcGVydHlcbi8vICAgICAgIH0sXG4vLyAgICAgICB7XG4vLyAgICAgICAgIG5hbWU6ICAgICAncm93J1xuLy8gICAgICAgICB2YWw6ICAgICAgIHt9LFxuLy8gICAgICAgICBtZXRob2RFeHQ6IFsgLi4uIF0sXG4vLyAgICAgICAgIHByb3BFeHQ6ICAgW1xuLy8gICAgICAgICAgIHtcbi8vICAgICAgICAgICAgIG5hbWU6ICAgICAgJ2RhdGEnXG4vLyAgICAgICAgICAgICB2YWw6ICAgICAgIGZ1bmN0aW9uICgpIHt9LFxuLy8gICAgICAgICAgICAgbWV0aG9kRXh0OiBbIC4uLiBdLFxuLy8gICAgICAgICAgICAgcHJvcEV4dDogICBbIC4uLiBdXG4vLyAgICAgICAgICAgfSxcbi8vICAgICAgICAgICAuLi5cbi8vICAgICAgICAgXVxuLy8gICAgICAgfVxuLy8gICAgIF1cblxuXG5fQXBpLnJlZ2lzdGVyID0gX2FwaV9yZWdpc3RlciA9IGZ1bmN0aW9uICggbmFtZSwgdmFsIClcbntcblx0aWYgKCBBcnJheS5pc0FycmF5KCBuYW1lICkgKSB7XG5cdFx0Zm9yICggdmFyIGo9MCwgamVuPW5hbWUubGVuZ3RoIDsgajxqZW4gOyBqKysgKSB7XG5cdFx0XHRfQXBpLnJlZ2lzdGVyKCBuYW1lW2pdLCB2YWwgKTtcblx0XHR9XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dmFyXG5cdFx0aSwgaWVuLFxuXHRcdGhlaXIgPSBuYW1lLnNwbGl0KCcuJyksXG5cdFx0c3RydWN0ID0gX19hcGlTdHJ1Y3QsXG5cdFx0a2V5LCBtZXRob2Q7XG5cblx0Zm9yICggaT0wLCBpZW49aGVpci5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRtZXRob2QgPSBoZWlyW2ldLmluZGV4T2YoJygpJykgIT09IC0xO1xuXHRcdGtleSA9IG1ldGhvZCA/XG5cdFx0XHRoZWlyW2ldLnJlcGxhY2UoJygpJywgJycpIDpcblx0XHRcdGhlaXJbaV07XG5cblx0XHR2YXIgc3JjID0gX2FwaV9maW5kKCBzdHJ1Y3QsIGtleSApO1xuXHRcdGlmICggISBzcmMgKSB7XG5cdFx0XHRzcmMgPSB7XG5cdFx0XHRcdG5hbWU6ICAgICAga2V5LFxuXHRcdFx0XHR2YWw6ICAgICAgIHt9LFxuXHRcdFx0XHRtZXRob2RFeHQ6IFtdLFxuXHRcdFx0XHRwcm9wRXh0OiAgIFtdLFxuXHRcdFx0XHR0eXBlOiAgICAgICdvYmplY3QnXG5cdFx0XHR9O1xuXHRcdFx0c3RydWN0LnB1c2goIHNyYyApO1xuXHRcdH1cblxuXHRcdGlmICggaSA9PT0gaWVuLTEgKSB7XG5cdFx0XHRzcmMudmFsID0gdmFsO1xuXHRcdFx0c3JjLnR5cGUgPSB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nID9cblx0XHRcdFx0J2Z1bmN0aW9uJyA6XG5cdFx0XHRcdCQuaXNQbGFpbk9iamVjdCggdmFsICkgP1xuXHRcdFx0XHRcdCdvYmplY3QnIDpcblx0XHRcdFx0XHQnb3RoZXInO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHN0cnVjdCA9IG1ldGhvZCA/XG5cdFx0XHRcdHNyYy5tZXRob2RFeHQgOlxuXHRcdFx0XHRzcmMucHJvcEV4dDtcblx0XHR9XG5cdH1cbn07XG5cbl9BcGkucmVnaXN0ZXJQbHVyYWwgPSBfYXBpX3JlZ2lzdGVyUGx1cmFsID0gZnVuY3Rpb24gKCBwbHVyYWxOYW1lLCBzaW5ndWxhck5hbWUsIHZhbCApIHtcblx0X0FwaS5yZWdpc3RlciggcGx1cmFsTmFtZSwgdmFsICk7XG5cblx0X0FwaS5yZWdpc3Rlciggc2luZ3VsYXJOYW1lLCBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHJldCA9IHZhbC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cblx0XHRpZiAoIHJldCA9PT0gdGhpcyApIHtcblx0XHRcdC8vIFJldHVybmVkIGl0ZW0gaXMgdGhlIEFQSSBpbnN0YW5jZSB0aGF0IHdhcyBwYXNzZWQgaW4sIHJldHVybiBpdFxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCByZXQgaW5zdGFuY2VvZiBfQXBpICkge1xuXHRcdFx0Ly8gTmV3IEFQSSBpbnN0YW5jZSByZXR1cm5lZCwgd2FudCB0aGUgdmFsdWUgZnJvbSB0aGUgZmlyc3QgaXRlbVxuXHRcdFx0Ly8gaW4gdGhlIHJldHVybmVkIGFycmF5IGZvciB0aGUgc2luZ3VsYXIgcmVzdWx0LlxuXHRcdFx0cmV0dXJuIHJldC5sZW5ndGggP1xuXHRcdFx0XHRBcnJheS5pc0FycmF5KCByZXRbMF0gKSA/XG5cdFx0XHRcdFx0bmV3IF9BcGkoIHJldC5jb250ZXh0LCByZXRbMF0gKSA6IC8vIEFycmF5IHJlc3VsdHMgYXJlICdlbmhhbmNlZCdcblx0XHRcdFx0XHRyZXRbMF0gOlxuXHRcdFx0XHR1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gTm9uLUFQSSByZXR1cm4gLSBqdXN0IGZpcmUgaXQgYmFja1xuXHRcdHJldHVybiByZXQ7XG5cdH0gKTtcbn07XG5cblxuLyoqXG4gKiBTZWxlY3RvciBmb3IgSFRNTCB0YWJsZXMuIEFwcGx5IHRoZSBnaXZlbiBzZWxlY3RvciB0byB0aGUgZ2l2ZSBhcnJheSBvZlxuICogRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfGludGVnZXJ9IFtzZWxlY3Rvcl0galF1ZXJ5IHNlbGVjdG9yIHN0cmluZyBvciBpbnRlZ2VyXG4gKiBAcGFyYW0gIHthcnJheX0gQXJyYXkgb2YgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RzIHRvIGJlIGZpbHRlcmVkXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqIEBpZ25vcmVcbiAqL1xudmFyIF9fdGFibGVfc2VsZWN0b3IgPSBmdW5jdGlvbiAoIHNlbGVjdG9yLCBhIClcbntcblx0aWYgKCBBcnJheS5pc0FycmF5KHNlbGVjdG9yKSApIHtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cblx0XHRzZWxlY3Rvci5mb3JFYWNoKGZ1bmN0aW9uIChzZWwpIHtcblx0XHRcdHZhciBpbm5lciA9IF9fdGFibGVfc2VsZWN0b3Ioc2VsLCBhKTtcblxuXHRcdFx0X2ZuQXJyYXlBcHBseShyZXN1bHQsIGlubmVyKTtcblx0XHR9KTtcblxuXHRcdHJldHVybiByZXN1bHQuZmlsdGVyKCBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0cmV0dXJuIGl0ZW07XG5cdFx0fSk7XG5cdH1cblxuXHQvLyBJbnRlZ2VyIGlzIHVzZWQgdG8gcGljayBvdXQgYSB0YWJsZSBieSBpbmRleFxuXHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gJ251bWJlcicgKSB7XG5cdFx0cmV0dXJuIFsgYVsgc2VsZWN0b3IgXSBdO1xuXHR9XG5cblx0Ly8gUGVyZm9ybSBhIGpRdWVyeSBzZWxlY3RvciBvbiB0aGUgdGFibGUgbm9kZXNcblx0dmFyIG5vZGVzID0gYS5tYXAoIGZ1bmN0aW9uIChlbCkge1xuXHRcdHJldHVybiBlbC5uVGFibGU7XG5cdH0gKTtcblxuXHRyZXR1cm4gJChub2Rlcylcblx0XHQuZmlsdGVyKCBzZWxlY3RvciApXG5cdFx0Lm1hcCggZnVuY3Rpb24gKCkge1xuXHRcdFx0Ly8gTmVlZCB0byB0cmFuc2xhdGUgYmFjayBmcm9tIHRoZSB0YWJsZSBub2RlIHRvIHRoZSBzZXR0aW5nc1xuXHRcdFx0dmFyIGlkeCA9IG5vZGVzLmluZGV4T2YodGhpcyk7XG5cdFx0XHRyZXR1cm4gYVsgaWR4IF07XG5cdFx0fSApXG5cdFx0LnRvQXJyYXkoKTtcbn07XG5cblxuXG4vKipcbiAqIENvbnRleHQgc2VsZWN0b3IgZm9yIHRoZSBBUEkncyBjb250ZXh0IChpLmUuIHRoZSB0YWJsZXMgdGhlIEFQSSBpbnN0YW5jZVxuICogcmVmZXJzIHRvLlxuICpcbiAqIEBuYW1lICAgIERhdGFUYWJsZS5BcGkjdGFibGVzXG4gKiBAcGFyYW0ge3N0cmluZ3xpbnRlZ2VyfSBbc2VsZWN0b3JdIFNlbGVjdG9yIHRvIHBpY2sgd2hpY2ggdGFibGVzIHRoZSBpdGVyYXRvclxuICogICBzaG91bGQgb3BlcmF0ZSBvbi4gSWYgbm90IGdpdmVuLCBhbGwgdGFibGVzIGluIHRoZSBjdXJyZW50IGNvbnRleHQgYXJlXG4gKiAgIHVzZWQuIFRoaXMgY2FuIGJlIGdpdmVuIGFzIGEgalF1ZXJ5IHNlbGVjdG9yIChmb3IgZXhhbXBsZSBgJzpndCgwKSdgKSB0b1xuICogICBzZWxlY3QgbXVsdGlwbGUgdGFibGVzIG9yIGFzIGFuIGludGVnZXIgdG8gc2VsZWN0IGEgc2luZ2xlIHRhYmxlLlxuICogQHJldHVybnMge0RhdGFUYWJsZS5BcGl9IFJldHVybnMgYSBuZXcgQVBJIGluc3RhbmNlIGlmIGEgc2VsZWN0b3IgaXMgZ2l2ZW4uXG4gKi9cbl9hcGlfcmVnaXN0ZXIoICd0YWJsZXMoKScsIGZ1bmN0aW9uICggc2VsZWN0b3IgKSB7XG5cdC8vIEEgbmV3IGluc3RhbmNlIGlzIGNyZWF0ZWQgaWYgdGhlcmUgd2FzIGEgc2VsZWN0b3Igc3BlY2lmaWVkXG5cdHJldHVybiBzZWxlY3RvciAhPT0gdW5kZWZpbmVkICYmIHNlbGVjdG9yICE9PSBudWxsID9cblx0XHRuZXcgX0FwaSggX190YWJsZV9zZWxlY3Rvciggc2VsZWN0b3IsIHRoaXMuY29udGV4dCApICkgOlxuXHRcdHRoaXM7XG59ICk7XG5cblxuX2FwaV9yZWdpc3RlciggJ3RhYmxlKCknLCBmdW5jdGlvbiAoIHNlbGVjdG9yICkge1xuXHR2YXIgdGFibGVzID0gdGhpcy50YWJsZXMoIHNlbGVjdG9yICk7XG5cdHZhciBjdHggPSB0YWJsZXMuY29udGV4dDtcblxuXHQvLyBUcnVuY2F0ZSB0byB0aGUgZmlyc3QgbWF0Y2hlZCB0YWJsZVxuXHRyZXR1cm4gY3R4Lmxlbmd0aCA/XG5cdFx0bmV3IF9BcGkoIGN0eFswXSApIDpcblx0XHR0YWJsZXM7XG59ICk7XG5cbi8vIENvbW1vbiBtZXRob2RzLCBjb21iaW5lZCB0byByZWR1Y2Ugc2l6ZVxuW1xuXHRbJ25vZGVzJywgJ25vZGUnLCAnblRhYmxlJ10sXG5cdFsnYm9keScsICdib2R5JywgJ25UQm9keSddLFxuXHRbJ2hlYWRlcicsICdoZWFkZXInLCAnblRIZWFkJ10sXG5cdFsnZm9vdGVyJywgJ2Zvb3RlcicsICduVEZvb3QnXSxcbl0uZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuXHRfYXBpX3JlZ2lzdGVyUGx1cmFsKFxuXHRcdCd0YWJsZXMoKS4nICsgaXRlbVswXSArICcoKScsXG5cdFx0J3RhYmxlKCkuJyArIGl0ZW1bMV0gKyAnKCknICxcblx0XHRmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBjdHggKSB7XG5cdFx0XHRcdHJldHVybiBjdHhbaXRlbVsyXV07XG5cdFx0XHR9LCAxICk7XG5cdFx0fVxuXHQpO1xufSk7XG5cbi8vIFN0cnVjdHVyZSBtZXRob2RzXG5bXG5cdFsnaGVhZGVyJywgJ2FvSGVhZGVyJ10sXG5cdFsnZm9vdGVyJywgJ2FvRm9vdGVyJ10sXG5dLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcblx0X2FwaV9yZWdpc3RlciggJ3RhYmxlKCkuJyArIGl0ZW1bMF0gKyAnLnN0cnVjdHVyZSgpJyAsIGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuXHRcdHZhciBpbmRleGVzID0gdGhpcy5jb2x1bW5zKHNlbGVjdG9yKS5pbmRleGVzKCkuZmxhdHRlbigpLnRvQXJyYXkoKTtcblx0XHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0WzBdO1xuXHRcdHZhciBzdHJ1Y3R1cmUgPSBfZm5IZWFkZXJMYXlvdXQoY3R4LCBjdHhbaXRlbVsxXV0sIGluZGV4ZXMpO1xuXG5cdFx0Ly8gVGhlIHN0cnVjdHVyZSBpcyBpbiBjb2x1bW4gaW5kZXggb3JkZXIgLSBidXQgZnJvbSB0aGlzIG1ldGhvZCB3ZSB3YW50IHRoZSByZXR1cm4gdG8gYmVcblx0XHQvLyBpbiB0aGUgY29sdW1ucygpIHNlbGVjdG9yIEFQSSBvcmRlci4gSW4gb3JkZXIgdG8gZG8gdGhhdCB3ZSBuZWVkIHRvIG1hcCBmcm9tIG9uZSBmb3JtXG5cdFx0Ly8gdG8gdGhlIG90aGVyXG5cdFx0dmFyIG9yZGVyZWRJbmRleGVzID0gaW5kZXhlcy5zbGljZSgpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcblx0XHRcdHJldHVybiBhIC0gYjtcblx0XHR9KTtcblxuXHRcdHJldHVybiBzdHJ1Y3R1cmUubWFwKGZ1bmN0aW9uIChyb3cpIHtcblx0XHRcdHJldHVybiBpbmRleGVzLm1hcChmdW5jdGlvbiAoY29sSWR4KSB7XG5cdFx0XHRcdHJldHVybiByb3dbb3JkZXJlZEluZGV4ZXMuaW5kZXhPZihjb2xJZHgpXTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9KTtcbn0pO1xuXG5cbl9hcGlfcmVnaXN0ZXJQbHVyYWwoICd0YWJsZXMoKS5jb250YWluZXJzKCknLCAndGFibGUoKS5jb250YWluZXIoKScgLCBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIGN0eCApIHtcblx0XHRyZXR1cm4gY3R4Lm5UYWJsZVdyYXBwZXI7XG5cdH0sIDEgKTtcbn0gKTtcblxuX2FwaV9yZWdpc3RlciggJ3RhYmxlcygpLmV2ZXJ5KCknLCBmdW5jdGlvbiAoIGZuICkge1xuXHR2YXIgdGhhdCA9IHRoaXM7XG5cblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKHMsIGkpIHtcblx0XHRmbi5jYWxsKHRoYXQudGFibGUoaSksIGkpO1xuXHR9KTtcbn0pO1xuXG5fYXBpX3JlZ2lzdGVyKCAnY2FwdGlvbigpJywgZnVuY3Rpb24gKCB2YWx1ZSwgc2lkZSApIHtcblx0dmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG5cblx0Ly8gR2V0dGVyIC0gcmV0dXJuIGV4aXN0aW5nIG5vZGUncyBjb250ZW50XG5cdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblx0XHR2YXIgY2FwdGlvbiA9IGNvbnRleHRbMF0uY2FwdGlvbk5vZGU7XG5cblx0XHRyZXR1cm4gY2FwdGlvbiAmJiBjb250ZXh0Lmxlbmd0aCA/XG5cdFx0XHRjYXB0aW9uLmlubmVySFRNTCA6IFxuXHRcdFx0bnVsbDtcblx0fVxuXG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIGN0eCApIHtcblx0XHR2YXIgdGFibGUgPSAkKGN0eC5uVGFibGUpO1xuXHRcdHZhciBjYXB0aW9uID0gJChjdHguY2FwdGlvbk5vZGUpO1xuXHRcdHZhciBjb250YWluZXIgPSAkKGN0eC5uVGFibGVXcmFwcGVyKTtcblxuXHRcdC8vIENyZWF0ZSB0aGUgbm9kZSBpZiBpdCBkb2Vzbid0IGV4aXN0IHlldFxuXHRcdGlmICggISBjYXB0aW9uLmxlbmd0aCApIHtcblx0XHRcdGNhcHRpb24gPSAkKCc8Y2FwdGlvbi8+JykuaHRtbCggdmFsdWUgKTtcblx0XHRcdGN0eC5jYXB0aW9uTm9kZSA9IGNhcHRpb25bMF07XG5cblx0XHRcdC8vIElmIHNpZGUgaXNuJ3Qgc2V0LCB3ZSBuZWVkIHRvIGluc2VydCBpbnRvIHRoZSBkb2N1bWVudCB0byBsZXQgdGhlXG5cdFx0XHQvLyBDU1MgZGVjaWRlIHNvIHdlIGNhbiByZWFkIGl0IGJhY2ssIG90aGVyd2lzZSB0aGVyZSBpcyBubyB3YXkgdG9cblx0XHRcdC8vIGtub3cgaWYgdGhlIENTUyB3b3VsZCBwdXQgaXQgdG9wIG9yIGJvdHRvbSBmb3Igc2Nyb2xsaW5nXG5cdFx0XHRpZiAoISBzaWRlKSB7XG5cdFx0XHRcdHRhYmxlLnByZXBlbmQoY2FwdGlvbik7XG5cblx0XHRcdFx0c2lkZSA9IGNhcHRpb24uY3NzKCdjYXB0aW9uLXNpZGUnKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRjYXB0aW9uLmh0bWwoIHZhbHVlICk7XG5cblx0XHRpZiAoIHNpZGUgKSB7XG5cdFx0XHRjYXB0aW9uLmNzcyggJ2NhcHRpb24tc2lkZScsIHNpZGUgKTtcblx0XHRcdGNhcHRpb25bMF0uX2NhcHRpb25TaWRlID0gc2lkZTtcblx0XHR9XG5cblx0XHRpZiAoY29udGFpbmVyLmZpbmQoJ2Rpdi5kYXRhVGFibGVzX3Njcm9sbCcpLmxlbmd0aCkge1xuXHRcdFx0dmFyIHNlbGVjdG9yID0gKHNpZGUgPT09ICd0b3AnID8gJ0hlYWQnIDogJ0Zvb3QnKTtcblxuXHRcdFx0Y29udGFpbmVyLmZpbmQoJ2Rpdi5kYXRhVGFibGVzX3Njcm9sbCcrIHNlbGVjdG9yICsnIHRhYmxlJykucHJlcGVuZChjYXB0aW9uKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHR0YWJsZS5wcmVwZW5kKGNhcHRpb24pO1xuXHRcdH1cblx0fSwgMSApO1xufSApO1xuXG5fYXBpX3JlZ2lzdGVyKCAnY2FwdGlvbi5ub2RlKCknLCBmdW5jdGlvbiAoKSB7XG5cdHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG5cblx0cmV0dXJuIGN0eC5sZW5ndGggPyBjdHhbMF0uY2FwdGlvbk5vZGUgOiBudWxsO1xufSApO1xuXG5cbi8qKlxuICogUmVkcmF3IHRoZSB0YWJsZXMgaW4gdGhlIGN1cnJlbnQgY29udGV4dC5cbiAqL1xuX2FwaV9yZWdpc3RlciggJ2RyYXcoKScsIGZ1bmN0aW9uICggcGFnaW5nICkge1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRpZiAoIHBhZ2luZyA9PT0gJ3BhZ2UnICkge1xuXHRcdFx0X2ZuRHJhdyggc2V0dGluZ3MgKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBwYWdpbmcgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRwYWdpbmcgPSBwYWdpbmcgPT09ICdmdWxsLWhvbGQnID9cblx0XHRcdFx0XHRmYWxzZSA6XG5cdFx0XHRcdFx0dHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0X2ZuUmVEcmF3KCBzZXR0aW5ncywgcGFnaW5nPT09ZmFsc2UgKTtcblx0XHR9XG5cdH0gKTtcbn0gKTtcblxuXG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IHBhZ2UgaW5kZXguXG4gKlxuICogQHJldHVybiB7aW50ZWdlcn0gQ3VycmVudCBwYWdlIGluZGV4ICh6ZXJvIGJhc2VkKVxuICovLyoqXG4gKiBTZXQgdGhlIGN1cnJlbnQgcGFnZS5cbiAqXG4gKiBOb3RlIHRoYXQgaWYgeW91IGF0dGVtcHQgdG8gc2hvdyBhIHBhZ2Ugd2hpY2ggZG9lcyBub3QgZXhpc3QsIERhdGFUYWJsZXMgd2lsbFxuICogbm90IHRocm93IGFuIGVycm9yLCBidXQgcmF0aGVyIHJlc2V0IHRoZSBwYWdpbmcuXG4gKlxuICogQHBhcmFtIHtpbnRlZ2VyfHN0cmluZ30gYWN0aW9uIFRoZSBwYWdpbmcgYWN0aW9uIHRvIHRha2UuIFRoaXMgY2FuIGJlIG9uZSBvZjpcbiAqICAqIGBpbnRlZ2VyYCAtIFRoZSBwYWdlIGluZGV4IHRvIGp1bXAgdG9cbiAqICAqIGBzdHJpbmdgIC0gQW4gYWN0aW9uIHRvIHRha2U6XG4gKiAgICAqIGBmaXJzdGAgLSBKdW1wIHRvIGZpcnN0IHBhZ2UuXG4gKiAgICAqIGBuZXh0YCAtIEp1bXAgdG8gdGhlIG5leHQgcGFnZVxuICogICAgKiBgcHJldmlvdXNgIC0gSnVtcCB0byBwcmV2aW91cyBwYWdlXG4gKiAgICAqIGBsYXN0YCAtIEp1bXAgdG8gdGhlIGxhc3QgcGFnZS5cbiAqIEByZXR1cm5zIHtEYXRhVGFibGVzLkFwaX0gdGhpc1xuICovXG5fYXBpX3JlZ2lzdGVyKCAncGFnZSgpJywgZnVuY3Rpb24gKCBhY3Rpb24gKSB7XG5cdGlmICggYWN0aW9uID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cmV0dXJuIHRoaXMucGFnZS5pbmZvKCkucGFnZTsgLy8gbm90IGFuIGV4cGVuc2l2ZSBjYWxsXG5cdH1cblxuXHQvLyBlbHNlLCBoYXZlIGFuIGFjdGlvbiB0byB0YWtlIG9uIGFsbCB0YWJsZXNcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0X2ZuUGFnZUNoYW5nZSggc2V0dGluZ3MsIGFjdGlvbiApO1xuXHR9ICk7XG59ICk7XG5cblxuLyoqXG4gKiBQYWdpbmcgaW5mb3JtYXRpb24gZm9yIHRoZSBmaXJzdCB0YWJsZSBpbiB0aGUgY3VycmVudCBjb250ZXh0LlxuICpcbiAqIElmIHlvdSByZXF1aXJlIHBhZ2luZyBpbmZvcm1hdGlvbiBmb3IgYW5vdGhlciB0YWJsZSwgdXNlIHRoZSBgdGFibGUoKWAgbWV0aG9kXG4gKiB3aXRoIGEgc3VpdGFibGUgc2VsZWN0b3IuXG4gKlxuICogQHJldHVybiB7b2JqZWN0fSBPYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgc2V0OlxuICogICogYHBhZ2VgIC0gQ3VycmVudCBwYWdlIGluZGV4ICh6ZXJvIGJhc2VkIC0gaS5lLiB0aGUgZmlyc3QgcGFnZSBpcyBgMGApXG4gKiAgKiBgcGFnZXNgIC0gVG90YWwgbnVtYmVyIG9mIHBhZ2VzXG4gKiAgKiBgc3RhcnRgIC0gRGlzcGxheSBpbmRleCBmb3IgdGhlIGZpcnN0IHJlY29yZCBzaG93biBvbiB0aGUgY3VycmVudCBwYWdlXG4gKiAgKiBgZW5kYCAtIERpc3BsYXkgaW5kZXggZm9yIHRoZSBsYXN0IHJlY29yZCBzaG93biBvbiB0aGUgY3VycmVudCBwYWdlXG4gKiAgKiBgbGVuZ3RoYCAtIERpc3BsYXkgbGVuZ3RoIChudW1iZXIgb2YgcmVjb3JkcykuIE5vdGUgdGhhdCBnZW5lcmFsbHkgYHN0YXJ0XG4gKiAgICArIGxlbmd0aCA9IGVuZGAsIGJ1dCB0aGlzIGlzIG5vdCBhbHdheXMgdHJ1ZSwgZm9yIGV4YW1wbGUgaWYgdGhlcmUgYXJlXG4gKiAgICBvbmx5IDIgcmVjb3JkcyB0byBzaG93IG9uIHRoZSBmaW5hbCBwYWdlLCB3aXRoIGEgbGVuZ3RoIG9mIDEwLlxuICogICogYHJlY29yZHNUb3RhbGAgLSBGdWxsIGRhdGEgc2V0IGxlbmd0aFxuICogICogYHJlY29yZHNEaXNwbGF5YCAtIERhdGEgc2V0IGxlbmd0aCBvbmNlIHRoZSBjdXJyZW50IGZpbHRlcmluZyBjcml0ZXJpb25cbiAqICAgIGFyZSBhcHBsaWVkLlxuICovXG5fYXBpX3JlZ2lzdGVyKCAncGFnZS5pbmZvKCknLCBmdW5jdGlvbiAoKSB7XG5cdGlmICggdGhpcy5jb250ZXh0Lmxlbmd0aCA9PT0gMCApIHtcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHR9XG5cblx0dmFyXG5cdFx0c2V0dGluZ3MgICA9IHRoaXMuY29udGV4dFswXSxcblx0XHRzdGFydCAgICAgID0gc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQsXG5cdFx0bGVuICAgICAgICA9IHNldHRpbmdzLm9GZWF0dXJlcy5iUGFnaW5hdGUgPyBzZXR0aW5ncy5faURpc3BsYXlMZW5ndGggOiAtMSxcblx0XHR2aXNSZWNvcmRzID0gc2V0dGluZ3MuZm5SZWNvcmRzRGlzcGxheSgpLFxuXHRcdGFsbCAgICAgICAgPSBsZW4gPT09IC0xO1xuXG5cdHJldHVybiB7XG5cdFx0XCJwYWdlXCI6ICAgICAgICAgICBhbGwgPyAwIDogTWF0aC5mbG9vciggc3RhcnQgLyBsZW4gKSxcblx0XHRcInBhZ2VzXCI6ICAgICAgICAgIGFsbCA/IDEgOiBNYXRoLmNlaWwoIHZpc1JlY29yZHMgLyBsZW4gKSxcblx0XHRcInN0YXJ0XCI6ICAgICAgICAgIHN0YXJ0LFxuXHRcdFwiZW5kXCI6ICAgICAgICAgICAgc2V0dGluZ3MuZm5EaXNwbGF5RW5kKCksXG5cdFx0XCJsZW5ndGhcIjogICAgICAgICBsZW4sXG5cdFx0XCJyZWNvcmRzVG90YWxcIjogICBzZXR0aW5ncy5mblJlY29yZHNUb3RhbCgpLFxuXHRcdFwicmVjb3Jkc0Rpc3BsYXlcIjogdmlzUmVjb3Jkcyxcblx0XHRcInNlcnZlclNpZGVcIjogICAgIF9mbkRhdGFTb3VyY2UoIHNldHRpbmdzICkgPT09ICdzc3AnXG5cdH07XG59ICk7XG5cblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgcGFnZSBsZW5ndGguXG4gKlxuICogQHJldHVybiB7aW50ZWdlcn0gQ3VycmVudCBwYWdlIGxlbmd0aC4gTm90ZSBgLTFgIGluZGljYXRlcyB0aGF0IGFsbCByZWNvcmRzXG4gKiAgIGFyZSB0byBiZSBzaG93bi5cbiAqLy8qKlxuICogU2V0IHRoZSBjdXJyZW50IHBhZ2UgbGVuZ3RoLlxuICpcbiAqIEBwYXJhbSB7aW50ZWdlcn0gUGFnZSBsZW5ndGggdG8gc2V0LiBVc2UgYC0xYCB0byBzaG93IGFsbCByZWNvcmRzLlxuICogQHJldHVybnMge0RhdGFUYWJsZXMuQXBpfSB0aGlzXG4gKi9cbl9hcGlfcmVnaXN0ZXIoICdwYWdlLmxlbigpJywgZnVuY3Rpb24gKCBsZW4gKSB7XG5cdC8vIE5vdGUgdGhhdCB3ZSBjYW4ndCBjYWxsIHRoaXMgZnVuY3Rpb24gJ2xlbmd0aCgpJyBiZWNhdXNlIGBsZW5ndGhgXG5cdC8vIGlzIGEgSmF2YXNjcmlwdCBwcm9wZXJ0eSBvZiBmdW5jdGlvbnMgd2hpY2ggZGVmaW5lcyBob3cgbWFueSBhcmd1bWVudHNcblx0Ly8gdGhlIGZ1bmN0aW9uIGV4cGVjdHMuXG5cdGlmICggbGVuID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29udGV4dC5sZW5ndGggIT09IDAgP1xuXHRcdFx0dGhpcy5jb250ZXh0WzBdLl9pRGlzcGxheUxlbmd0aCA6XG5cdFx0XHR1bmRlZmluZWQ7XG5cdH1cblxuXHQvLyBlbHNlLCBzZXQgdGhlIHBhZ2UgbGVuZ3RoXG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdF9mbkxlbmd0aENoYW5nZSggc2V0dGluZ3MsIGxlbiApO1xuXHR9ICk7XG59ICk7XG5cblxuXG52YXIgX19yZWxvYWQgPSBmdW5jdGlvbiAoIHNldHRpbmdzLCBob2xkUG9zaXRpb24sIGNhbGxiYWNrICkge1xuXHQvLyBVc2UgdGhlIGRyYXcgZXZlbnQgdG8gdHJpZ2dlciBhIGNhbGxiYWNrXG5cdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGFwaSA9IG5ldyBfQXBpKCBzZXR0aW5ncyApO1xuXG5cdFx0YXBpLm9uZSggJ2RyYXcnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRjYWxsYmFjayggYXBpLmFqYXguanNvbigpICk7XG5cdFx0fSApO1xuXHR9XG5cblx0aWYgKCBfZm5EYXRhU291cmNlKCBzZXR0aW5ncyApID09ICdzc3AnICkge1xuXHRcdF9mblJlRHJhdyggc2V0dGluZ3MsIGhvbGRQb3NpdGlvbiApO1xuXHR9XG5cdGVsc2Uge1xuXHRcdF9mblByb2Nlc3NpbmdEaXNwbGF5KCBzZXR0aW5ncywgdHJ1ZSApO1xuXG5cdFx0Ly8gQ2FuY2VsIGFuIGV4aXN0aW5nIHJlcXVlc3Rcblx0XHR2YXIgeGhyID0gc2V0dGluZ3MuanFYSFI7XG5cdFx0aWYgKCB4aHIgJiYgeGhyLnJlYWR5U3RhdGUgIT09IDQgKSB7XG5cdFx0XHR4aHIuYWJvcnQoKTtcblx0XHR9XG5cblx0XHQvLyBUcmlnZ2VyIHhoclxuXHRcdF9mbkJ1aWxkQWpheCggc2V0dGluZ3MsIHt9LCBmdW5jdGlvbigganNvbiApIHtcblx0XHRcdF9mbkNsZWFyVGFibGUoIHNldHRpbmdzICk7XG5cblx0XHRcdHZhciBkYXRhID0gX2ZuQWpheERhdGFTcmMoIHNldHRpbmdzLCBqc29uICk7XG5cdFx0XHRmb3IgKCB2YXIgaT0wLCBpZW49ZGF0YS5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0X2ZuQWRkRGF0YSggc2V0dGluZ3MsIGRhdGFbaV0gKTtcblx0XHRcdH1cblxuXHRcdFx0X2ZuUmVEcmF3KCBzZXR0aW5ncywgaG9sZFBvc2l0aW9uICk7XG5cdFx0XHRfZm5Jbml0Q29tcGxldGUoIHNldHRpbmdzICk7XG5cdFx0XHRfZm5Qcm9jZXNzaW5nRGlzcGxheSggc2V0dGluZ3MsIGZhbHNlICk7XG5cdFx0fSApO1xuXHR9XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSBKU09OIHJlc3BvbnNlIGZyb20gdGhlIGxhc3QgQWpheCByZXF1ZXN0IHRoYXQgRGF0YVRhYmxlcyBtYWRlIHRvIHRoZVxuICogc2VydmVyLiBOb3RlIHRoYXQgdGhpcyByZXR1cm5zIHRoZSBKU09OIGZyb20gdGhlIGZpcnN0IHRhYmxlIGluIHRoZSBjdXJyZW50XG4gKiBjb250ZXh0LlxuICpcbiAqIEByZXR1cm4ge29iamVjdH0gSlNPTiByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXIuXG4gKi9cbl9hcGlfcmVnaXN0ZXIoICdhamF4Lmpzb24oKScsIGZ1bmN0aW9uICgpIHtcblx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblxuXHRpZiAoIGN0eC5sZW5ndGggPiAwICkge1xuXHRcdHJldHVybiBjdHhbMF0uanNvbjtcblx0fVxuXG5cdC8vIGVsc2UgcmV0dXJuIHVuZGVmaW5lZDtcbn0gKTtcblxuXG4vKipcbiAqIEdldCB0aGUgZGF0YSBzdWJtaXR0ZWQgaW4gdGhlIGxhc3QgQWpheCByZXF1ZXN0XG4gKi9cbl9hcGlfcmVnaXN0ZXIoICdhamF4LnBhcmFtcygpJywgZnVuY3Rpb24gKCkge1xuXHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXG5cdGlmICggY3R4Lmxlbmd0aCA+IDAgKSB7XG5cdFx0cmV0dXJuIGN0eFswXS5vQWpheERhdGE7XG5cdH1cblxuXHQvLyBlbHNlIHJldHVybiB1bmRlZmluZWQ7XG59ICk7XG5cblxuLyoqXG4gKiBSZWxvYWQgdGFibGVzIGZyb20gdGhlIEFqYXggZGF0YSBzb3VyY2UuIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIHdpbGxcbiAqIGF1dG9tYXRpY2FsbHkgcmUtZHJhdyB0aGUgdGFibGUgd2hlbiB0aGUgcmVtb3RlIGRhdGEgaGFzIGJlZW4gbG9hZGVkLlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Jlc2V0PXRydWVdIFJlc2V0IChkZWZhdWx0KSBvciBob2xkIHRoZSBjdXJyZW50IHBhZ2luZ1xuICogICBwb3NpdGlvbi4gQSBmdWxsIHJlLXNvcnQgYW5kIHJlLWZpbHRlciBpcyBwZXJmb3JtZWQgd2hlbiB0aGlzIG1ldGhvZCBpc1xuICogICBjYWxsZWQsIHdoaWNoIGlzIHdoeSB0aGUgcGFnaW5hdGlvbiByZXNldCBpcyB0aGUgZGVmYXVsdCBhY3Rpb24uXG4gKiBAcmV0dXJucyB7RGF0YVRhYmxlcy5BcGl9IHRoaXNcbiAqL1xuX2FwaV9yZWdpc3RlciggJ2FqYXgucmVsb2FkKCknLCBmdW5jdGlvbiAoIGNhbGxiYWNrLCByZXNldFBhZ2luZyApIHtcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uIChzZXR0aW5ncykge1xuXHRcdF9fcmVsb2FkKCBzZXR0aW5ncywgcmVzZXRQYWdpbmc9PT1mYWxzZSwgY2FsbGJhY2sgKTtcblx0fSApO1xufSApO1xuXG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IEFqYXggVVJMLiBOb3RlIHRoYXQgdGhpcyByZXR1cm5zIHRoZSBVUkwgZnJvbSB0aGUgZmlyc3RcbiAqIHRhYmxlIGluIHRoZSBjdXJyZW50IGNvbnRleHQuXG4gKlxuICogQHJldHVybiB7c3RyaW5nfSBDdXJyZW50IEFqYXggc291cmNlIFVSTFxuICovLyoqXG4gKiBTZXQgdGhlIEFqYXggVVJMLiBOb3RlIHRoYXQgdGhpcyB3aWxsIHNldCB0aGUgVVJMIGZvciBhbGwgdGFibGVzIGluIHRoZVxuICogY3VycmVudCBjb250ZXh0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVVJMIHRvIHNldC5cbiAqIEByZXR1cm5zIHtEYXRhVGFibGVzLkFwaX0gdGhpc1xuICovXG5fYXBpX3JlZ2lzdGVyKCAnYWpheC51cmwoKScsIGZ1bmN0aW9uICggdXJsICkge1xuXHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXG5cdGlmICggdXJsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0Ly8gZ2V0XG5cdFx0aWYgKCBjdHgubGVuZ3RoID09PSAwICkge1xuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0Y3R4ID0gY3R4WzBdO1xuXG5cdFx0cmV0dXJuICQuaXNQbGFpbk9iamVjdCggY3R4LmFqYXggKSA/XG5cdFx0XHRjdHguYWpheC51cmwgOlxuXHRcdFx0Y3R4LmFqYXg7XG5cdH1cblxuXHQvLyBzZXRcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0aWYgKCAkLmlzUGxhaW5PYmplY3QoIHNldHRpbmdzLmFqYXggKSApIHtcblx0XHRcdHNldHRpbmdzLmFqYXgudXJsID0gdXJsO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHNldHRpbmdzLmFqYXggPSB1cmw7XG5cdFx0fVxuXHR9ICk7XG59ICk7XG5cblxuLyoqXG4gKiBMb2FkIGRhdGEgZnJvbSB0aGUgbmV3bHkgc2V0IEFqYXggVVJMLiBOb3RlIHRoYXQgdGhpcyBtZXRob2QgaXMgb25seVxuICogYXZhaWxhYmxlIHdoZW4gYGFqYXgudXJsKClgIGlzIHVzZWQgdG8gc2V0IGEgVVJMLiBBZGRpdGlvbmFsbHksIHRoaXMgbWV0aG9kXG4gKiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzIGNhbGxpbmcgYGFqYXgucmVsb2FkKClgIGJ1dCBpcyBwcm92aWRlZCBmb3JcbiAqIGNvbnZlbmllbmNlIHdoZW4gc2V0dGluZyBhIG5ldyBVUkwuIExpa2UgYGFqYXgucmVsb2FkKClgIGl0IHdpbGxcbiAqIGF1dG9tYXRpY2FsbHkgcmVkcmF3IHRoZSB0YWJsZSBvbmNlIHRoZSByZW1vdGUgZGF0YSBoYXMgYmVlbiBsb2FkZWQuXG4gKlxuICogQHJldHVybnMge0RhdGFUYWJsZXMuQXBpfSB0aGlzXG4gKi9cbl9hcGlfcmVnaXN0ZXIoICdhamF4LnVybCgpLmxvYWQoKScsIGZ1bmN0aW9uICggY2FsbGJhY2ssIHJlc2V0UGFnaW5nICkge1xuXHQvLyBTYW1lIGFzIGEgcmVsb2FkLCBidXQgbWFrZXMgc2Vuc2UgdG8gcHJlc2VudCBpdCBmb3IgZWFzeSBhY2Nlc3MgYWZ0ZXIgYVxuXHQvLyB1cmwgY2hhbmdlXG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIGN0eCApIHtcblx0XHRfX3JlbG9hZCggY3R4LCByZXNldFBhZ2luZz09PWZhbHNlLCBjYWxsYmFjayApO1xuXHR9ICk7XG59ICk7XG5cblxuXG5cbnZhciBfc2VsZWN0b3JfcnVuID0gZnVuY3Rpb24gKCB0eXBlLCBzZWxlY3Rvciwgc2VsZWN0Rm4sIHNldHRpbmdzLCBvcHRzIClcbntcblx0dmFyXG5cdFx0b3V0ID0gW10sIHJlcyxcblx0XHRpLCBpZW4sXG5cdFx0c2VsZWN0b3JUeXBlID0gdHlwZW9mIHNlbGVjdG9yO1xuXG5cdC8vIENhbid0IGp1c3QgY2hlY2sgZm9yIGlzQXJyYXkgaGVyZSwgYXMgYW4gQVBJIG9yIGpRdWVyeSBpbnN0YW5jZSBtaWdodCBiZVxuXHQvLyBnaXZlbiB3aXRoIHRoZWlyIGFycmF5IGxpa2UgbG9va1xuXHRpZiAoICEgc2VsZWN0b3IgfHwgc2VsZWN0b3JUeXBlID09PSAnc3RyaW5nJyB8fCBzZWxlY3RvclR5cGUgPT09ICdmdW5jdGlvbicgfHwgc2VsZWN0b3IubGVuZ3RoID09PSB1bmRlZmluZWQgKSB7XG5cdFx0c2VsZWN0b3IgPSBbIHNlbGVjdG9yIF07XG5cdH1cblxuXHRmb3IgKCBpPTAsIGllbj1zZWxlY3Rvci5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRyZXMgPSBzZWxlY3RGbiggdHlwZW9mIHNlbGVjdG9yW2ldID09PSAnc3RyaW5nJyA/IHNlbGVjdG9yW2ldLnRyaW0oKSA6IHNlbGVjdG9yW2ldICk7XG5cblx0XHQvLyBSZW1vdmUgZW1wdHkgaXRlbXNcblx0XHRyZXMgPSByZXMuZmlsdGVyKCBmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0cmV0dXJuIGl0ZW0gIT09IG51bGwgJiYgaXRlbSAhPT0gdW5kZWZpbmVkO1xuXHRcdH0pO1xuXG5cdFx0aWYgKCByZXMgJiYgcmVzLmxlbmd0aCApIHtcblx0XHRcdG91dCA9IG91dC5jb25jYXQoIHJlcyApO1xuXHRcdH1cblx0fVxuXG5cdC8vIHNlbGVjdG9yIGV4dGVuc2lvbnNcblx0dmFyIGV4dCA9IF9leHQuc2VsZWN0b3JbIHR5cGUgXTtcblx0aWYgKCBleHQubGVuZ3RoICkge1xuXHRcdGZvciAoIGk9MCwgaWVuPWV4dC5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdG91dCA9IGV4dFtpXSggc2V0dGluZ3MsIG9wdHMsIG91dCApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBfdW5pcXVlKCBvdXQgKTtcbn07XG5cblxudmFyIF9zZWxlY3Rvcl9vcHRzID0gZnVuY3Rpb24gKCBvcHRzIClcbntcblx0aWYgKCAhIG9wdHMgKSB7XG5cdFx0b3B0cyA9IHt9O1xuXHR9XG5cblx0Ly8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgZm9yIDEuOS0gd2hpY2ggdXNlZCB0aGUgdGVybWlub2xvZ3kgZmlsdGVyIHJhdGhlclxuXHQvLyB0aGFuIHNlYXJjaFxuXHRpZiAoIG9wdHMuZmlsdGVyICYmIG9wdHMuc2VhcmNoID09PSB1bmRlZmluZWQgKSB7XG5cdFx0b3B0cy5zZWFyY2ggPSBvcHRzLmZpbHRlcjtcblx0fVxuXG5cdHJldHVybiAkLmV4dGVuZCgge1xuXHRcdGNvbHVtbk9yZGVyOiAnaW1wbGllZCcsXG5cdFx0c2VhcmNoOiAnbm9uZScsXG5cdFx0b3JkZXI6ICdjdXJyZW50Jyxcblx0XHRwYWdlOiAnYWxsJ1xuXHR9LCBvcHRzICk7XG59O1xuXG5cbi8vIFJlZHVjZSB0aGUgQVBJIGluc3RhbmNlIHRvIHRoZSBmaXJzdCBpdGVtIGZvdW5kXG52YXIgX3NlbGVjdG9yX2ZpcnN0ID0gZnVuY3Rpb24gKCBvbGQgKVxue1xuXHR2YXIgaW5zdCA9IG5ldyBfQXBpKG9sZC5jb250ZXh0WzBdKTtcblxuXHQvLyBVc2UgYSBwdXNoIHJhdGhlciB0aGFuIHBhc3NpbmcgdG8gdGhlIGNvbnN0cnVjdG9yLCBzaW5jZSBpdCB3aWxsXG5cdC8vIG1lcmdlIGFycmF5cyBkb3duIGF1dG9tYXRpY2FsbHksIHdoaWNoIGlzbid0IHdoYXQgaXMgd2FudGVkIGhlcmVcblx0aWYgKG9sZC5sZW5ndGgpIHtcblx0XHRpbnN0LnB1c2goIG9sZFswXSApO1xuXHR9XG5cblx0aW5zdC5zZWxlY3RvciA9IG9sZC5zZWxlY3RvcjtcblxuXHQvLyBMaW1pdCB0byBhIHNpbmdsZSByb3cgLyBjb2x1bW4gLyBjZWxsXG5cdGlmIChpbnN0Lmxlbmd0aCAmJiBpbnN0WzBdLmxlbmd0aCA+IDEpIHtcblx0XHRpbnN0WzBdLnNwbGljZSgxKTtcblx0fVxuXG5cdHJldHVybiBpbnN0O1xufTtcblxuXG52YXIgX3NlbGVjdG9yX3Jvd19pbmRleGVzID0gZnVuY3Rpb24gKCBzZXR0aW5ncywgb3B0cyApXG57XG5cdHZhclxuXHRcdGksIGllbiwgdG1wLCBhPVtdLFxuXHRcdGRpc3BsYXlGaWx0ZXJlZCA9IHNldHRpbmdzLmFpRGlzcGxheSxcblx0XHRkaXNwbGF5TWFzdGVyID0gc2V0dGluZ3MuYWlEaXNwbGF5TWFzdGVyO1xuXG5cdHZhclxuXHRcdHNlYXJjaCA9IG9wdHMuc2VhcmNoLCAgLy8gbm9uZSwgYXBwbGllZCwgcmVtb3ZlZFxuXHRcdG9yZGVyICA9IG9wdHMub3JkZXIsICAgLy8gYXBwbGllZCwgY3VycmVudCwgaW5kZXggKG9yaWdpbmFsIC0gY29tcGF0aWJpbGl0eSB3aXRoIDEuOSlcblx0XHRwYWdlICAgPSBvcHRzLnBhZ2U7ICAgIC8vIGFsbCwgY3VycmVudFxuXG5cdGlmICggX2ZuRGF0YVNvdXJjZSggc2V0dGluZ3MgKSA9PSAnc3NwJyApIHtcblx0XHQvLyBJbiBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIG1vZGUsIG1vc3Qgb3B0aW9ucyBhcmUgaXJyZWxldmFudCBzaW5jZVxuXHRcdC8vIHJvd3Mgbm90IHNob3duIGRvbid0IGV4aXN0IGFuZCB0aGUgaW5kZXggb3JkZXIgaXMgdGhlIGFwcGxpZWQgb3JkZXJcblx0XHQvLyBSZW1vdmVkIGlzIGEgc3BlY2lhbCBjYXNlIC0gZm9yIGNvbnNpc3RlbmN5IGp1c3QgcmV0dXJuIGFuIGVtcHR5XG5cdFx0Ly8gYXJyYXlcblx0XHRyZXR1cm4gc2VhcmNoID09PSAncmVtb3ZlZCcgP1xuXHRcdFx0W10gOlxuXHRcdFx0X3JhbmdlKCAwLCBkaXNwbGF5TWFzdGVyLmxlbmd0aCApO1xuXHR9XG5cblx0aWYgKCBwYWdlID09ICdjdXJyZW50JyApIHtcblx0XHQvLyBDdXJyZW50IHBhZ2UgaW1wbGllcyB0aGF0IG9yZGVyPWN1cnJlbnQgYW5kIGZpbHRlcj1hcHBsaWVkLCBzaW5jZSBpdCBpc1xuXHRcdC8vIGZhaXJseSBzZW5zZWxlc3Mgb3RoZXJ3aXNlLCByZWdhcmRsZXNzIG9mIHdoYXQgb3JkZXIgYW5kIHNlYXJjaCBhY3R1YWxseVxuXHRcdC8vIGFyZVxuXHRcdGZvciAoIGk9c2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQsIGllbj1zZXR0aW5ncy5mbkRpc3BsYXlFbmQoKSA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0YS5wdXNoKCBkaXNwbGF5RmlsdGVyZWRbaV0gKTtcblx0XHR9XG5cdH1cblx0ZWxzZSBpZiAoIG9yZGVyID09ICdjdXJyZW50JyB8fCBvcmRlciA9PSAnYXBwbGllZCcgKSB7XG5cdFx0aWYgKCBzZWFyY2ggPT0gJ25vbmUnKSB7XG5cdFx0XHRhID0gZGlzcGxheU1hc3Rlci5zbGljZSgpO1xuXHRcdH1cblx0XHRlbHNlIGlmICggc2VhcmNoID09ICdhcHBsaWVkJyApIHtcblx0XHRcdGEgPSBkaXNwbGF5RmlsdGVyZWQuc2xpY2UoKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIHNlYXJjaCA9PSAncmVtb3ZlZCcgKSB7XG5cdFx0XHQvLyBPKG4rbSkgc29sdXRpb24gYnkgY3JlYXRpbmcgYSBoYXNoIG1hcFxuXHRcdFx0dmFyIGRpc3BsYXlGaWx0ZXJlZE1hcCA9IHt9O1xuXG5cdFx0XHRmb3IgKCBpPTAsIGllbj1kaXNwbGF5RmlsdGVyZWQubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdGRpc3BsYXlGaWx0ZXJlZE1hcFtkaXNwbGF5RmlsdGVyZWRbaV1dID0gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0ZGlzcGxheU1hc3Rlci5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHRcdGlmICghIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkaXNwbGF5RmlsdGVyZWRNYXAsIGl0ZW0pKSB7XG5cdFx0XHRcdFx0YS5wdXNoKGl0ZW0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblx0ZWxzZSBpZiAoIG9yZGVyID09ICdpbmRleCcgfHwgb3JkZXIgPT0gJ29yaWdpbmFsJyApIHtcblx0XHRmb3IgKCBpPTAsIGllbj1zZXR0aW5ncy5hb0RhdGEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRpZiAoISBzZXR0aW5ncy5hb0RhdGFbaV0pIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggc2VhcmNoID09ICdub25lJyApIHtcblx0XHRcdFx0YS5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHsgLy8gYXBwbGllZCB8IHJlbW92ZWRcblx0XHRcdFx0dG1wID0gZGlzcGxheUZpbHRlcmVkLmluZGV4T2YoaSk7XG5cblx0XHRcdFx0aWYgKCh0bXAgPT09IC0xICYmIHNlYXJjaCA9PSAncmVtb3ZlZCcpIHx8XG5cdFx0XHRcdFx0KHRtcCA+PSAwICAgJiYgc2VhcmNoID09ICdhcHBsaWVkJykgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0YS5wdXNoKCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0ZWxzZSBpZiAoIHR5cGVvZiBvcmRlciA9PT0gJ251bWJlcicgKSB7XG5cdFx0Ly8gT3JkZXIgdGhlIHJvd3MgYnkgdGhlIGdpdmVuIGNvbHVtblxuXHRcdHZhciBvcmRlcmVkID0gX2ZuU29ydChzZXR0aW5ncywgb3JkZXIsICdhc2MnKTtcblxuXHRcdGlmIChzZWFyY2ggPT09ICdub25lJykge1xuXHRcdFx0YSA9IG9yZGVyZWQ7XG5cdFx0fVxuXHRcdGVsc2UgeyAvLyBhcHBsaWVkIHwgcmVtb3ZlZFxuXHRcdFx0Zm9yIChpPTA7IGk8b3JkZXJlZC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR0bXAgPSBkaXNwbGF5RmlsdGVyZWQuaW5kZXhPZihvcmRlcmVkW2ldKTtcblxuXHRcdFx0XHRpZiAoKHRtcCA9PT0gLTEgJiYgc2VhcmNoID09ICdyZW1vdmVkJykgfHxcblx0XHRcdFx0XHQodG1wID49IDAgICAmJiBzZWFyY2ggPT0gJ2FwcGxpZWQnKSApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRhLnB1c2goIG9yZGVyZWRbaV0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBhO1xufTtcblxuXG4vKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcbiAqIFJvd3NcbiAqXG4gKiB7fSAgICAgICAgICAtIG5vIHNlbGVjdG9yIC0gdXNlIGFsbCBhdmFpbGFibGUgcm93c1xuICoge2ludGVnZXJ9ICAgLSByb3cgYW9EYXRhIGluZGV4XG4gKiB7bm9kZX0gICAgICAtIFRSIG5vZGVcbiAqIHtzdHJpbmd9ICAgIC0galF1ZXJ5IHNlbGVjdG9yIHRvIGFwcGx5IHRvIHRoZSBUUiBlbGVtZW50c1xuICoge2FycmF5fSAgICAgLSBqUXVlcnkgYXJyYXkgb2Ygbm9kZXMsIG9yIHNpbXBseSBhbiBhcnJheSBvZiBUUiBub2Rlc1xuICpcbiAqL1xudmFyIF9fcm93X3NlbGVjdG9yID0gZnVuY3Rpb24gKCBzZXR0aW5ncywgc2VsZWN0b3IsIG9wdHMgKVxue1xuXHR2YXIgcm93cztcblx0dmFyIHJ1biA9IGZ1bmN0aW9uICggc2VsICkge1xuXHRcdHZhciBzZWxJbnQgPSBfaW50VmFsKCBzZWwgKTtcblx0XHR2YXIgYW9EYXRhID0gc2V0dGluZ3MuYW9EYXRhO1xuXG5cdFx0Ly8gU2hvcnQgY3V0IC0gc2VsZWN0b3IgaXMgYSBudW1iZXIgYW5kIG5vIG9wdGlvbnMgcHJvdmlkZWQgKGRlZmF1bHQgaXNcblx0XHQvLyBhbGwgcmVjb3Jkcywgc28gbm8gbmVlZCB0byBjaGVjayBpZiB0aGUgaW5kZXggaXMgaW4gdGhlcmUsIHNpbmNlIGl0XG5cdFx0Ly8gbXVzdCBiZSAtIGRldiBlcnJvciBpZiB0aGUgaW5kZXggZG9lc24ndCBleGlzdCkuXG5cdFx0aWYgKCBzZWxJbnQgIT09IG51bGwgJiYgISBvcHRzICkge1xuXHRcdFx0cmV0dXJuIFsgc2VsSW50IF07XG5cdFx0fVxuXG5cdFx0aWYgKCAhIHJvd3MgKSB7XG5cdFx0XHRyb3dzID0gX3NlbGVjdG9yX3Jvd19pbmRleGVzKCBzZXR0aW5ncywgb3B0cyApO1xuXHRcdH1cblxuXHRcdGlmICggc2VsSW50ICE9PSBudWxsICYmIHJvd3MuaW5kZXhPZihzZWxJbnQpICE9PSAtMSApIHtcblx0XHRcdC8vIFNlbGVjdG9yIC0gaW50ZWdlclxuXHRcdFx0cmV0dXJuIFsgc2VsSW50IF07XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBzZWwgPT09IG51bGwgfHwgc2VsID09PSB1bmRlZmluZWQgfHwgc2VsID09PSAnJyApIHtcblx0XHRcdC8vIFNlbGVjdG9yIC0gbm9uZVxuXHRcdFx0cmV0dXJuIHJvd3M7XG5cdFx0fVxuXG5cdFx0Ly8gU2VsZWN0b3IgLSBmdW5jdGlvblxuXHRcdGlmICggdHlwZW9mIHNlbCA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdHJldHVybiByb3dzLm1hcCggZnVuY3Rpb24gKGlkeCkge1xuXHRcdFx0XHR2YXIgcm93ID0gYW9EYXRhWyBpZHggXTtcblx0XHRcdFx0cmV0dXJuIHNlbCggaWR4LCByb3cuX2FEYXRhLCByb3cublRyICkgPyBpZHggOiBudWxsO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdC8vIFNlbGVjdG9yIC0gbm9kZVxuXHRcdGlmICggc2VsLm5vZGVOYW1lICkge1xuXHRcdFx0dmFyIHJvd0lkeCA9IHNlbC5fRFRfUm93SW5kZXg7ICAvLyBQcm9wZXJ0eSBhZGRlZCBieSBEVCBmb3IgZmFzdCBsb29rdXBcblx0XHRcdHZhciBjZWxsSWR4ID0gc2VsLl9EVF9DZWxsSW5kZXg7XG5cblx0XHRcdGlmICggcm93SWR4ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSByb3cgaXMgYWN0dWFsbHkgc3RpbGwgcHJlc2VudCBpbiB0aGUgdGFibGVcblx0XHRcdFx0cmV0dXJuIGFvRGF0YVsgcm93SWR4IF0gJiYgYW9EYXRhWyByb3dJZHggXS5uVHIgPT09IHNlbCA/XG5cdFx0XHRcdFx0WyByb3dJZHggXSA6XG5cdFx0XHRcdFx0W107XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggY2VsbElkeCApIHtcblx0XHRcdFx0cmV0dXJuIGFvRGF0YVsgY2VsbElkeC5yb3cgXSAmJiBhb0RhdGFbIGNlbGxJZHgucm93IF0ublRyID09PSBzZWwucGFyZW50Tm9kZSA/XG5cdFx0XHRcdFx0WyBjZWxsSWR4LnJvdyBdIDpcblx0XHRcdFx0XHRbXTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR2YXIgaG9zdCA9ICQoc2VsKS5jbG9zZXN0KCcqW2RhdGEtZHQtcm93XScpO1xuXHRcdFx0XHRyZXR1cm4gaG9zdC5sZW5ndGggP1xuXHRcdFx0XHRcdFsgaG9zdC5kYXRhKCdkdC1yb3cnKSBdIDpcblx0XHRcdFx0XHRbXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBJRCBzZWxlY3Rvci4gV2FudCB0byBhbHdheXMgYmUgYWJsZSB0byBzZWxlY3Qgcm93cyBieSBpZCwgcmVnYXJkbGVzc1xuXHRcdC8vIG9mIGlmIHRoZSB0ciBlbGVtZW50IGhhcyBiZWVuIGNyZWF0ZWQgb3Igbm90LCBzbyBjYW4ndCByZWx5IHVwb25cblx0XHQvLyBqUXVlcnkgaGVyZSAtIGhlbmNlIGEgY3VzdG9tIGltcGxlbWVudGF0aW9uLiBUaGlzIGRvZXMgbm90IG1hdGNoXG5cdFx0Ly8gU2l6emxlJ3MgZmFzdCBzZWxlY3RvciBvciBIVE1MNCAtIGluIEhUTUw1IHRoZSBJRCBjYW4gYmUgYW55dGhpbmcsXG5cdFx0Ly8gYnV0IHRvIHNlbGVjdCBpdCB1c2luZyBhIENTUyBzZWxlY3RvciBlbmdpbmUgKGxpa2UgU2l6emxlIG9yXG5cdFx0Ly8gcXVlcnlTZWxlY3QpIGl0IHdvdWxkIG5lZWQgdG8gbmVlZCB0byBiZSBlc2NhcGVkIGZvciBzb21lIGNoYXJhY3RlcnMuXG5cdFx0Ly8gRGF0YVRhYmxlcyBzaW1wbGlmaWVzIHRoaXMgZm9yIHJvdyBzZWxlY3RvcnMgc2luY2UgeW91IGNhbiBzZWxlY3Rcblx0XHQvLyBvbmx5IGEgcm93LiBBICMgaW5kaWNhdGVzIGFuIGlkIGFueSBhbnl0aGluZyB0aGF0IGZvbGxvd3MgaXMgdGhlIGlkIC1cblx0XHQvLyB1bmVzY2FwZWQuXG5cdFx0aWYgKCB0eXBlb2Ygc2VsID09PSAnc3RyaW5nJyAmJiBzZWwuY2hhckF0KDApID09PSAnIycgKSB7XG5cdFx0XHQvLyBnZXQgcm93IGluZGV4IGZyb20gaWRcblx0XHRcdHZhciByb3dPYmogPSBzZXR0aW5ncy5hSWRzWyBzZWwucmVwbGFjZSggL14jLywgJycgKSBdO1xuXHRcdFx0aWYgKCByb3dPYmogIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIFsgcm93T2JqLmlkeCBdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBuZWVkIHRvIGZhbGwgdGhyb3VnaCB0byBqUXVlcnkgaW4gY2FzZSB0aGVyZSBpcyBET00gaWQgdGhhdFxuXHRcdFx0Ly8gbWF0Y2hlc1xuXHRcdH1cblx0XHRcblx0XHQvLyBHZXQgbm9kZXMgaW4gdGhlIG9yZGVyIGZyb20gdGhlIGByb3dzYCBhcnJheSB3aXRoIG51bGwgdmFsdWVzIHJlbW92ZWRcblx0XHR2YXIgbm9kZXMgPSBfcmVtb3ZlRW1wdHkoXG5cdFx0XHRfcGx1Y2tfb3JkZXIoIHNldHRpbmdzLmFvRGF0YSwgcm93cywgJ25UcicgKVxuXHRcdCk7XG5cblx0XHQvLyBTZWxlY3RvciAtIGpRdWVyeSBzZWxlY3RvciBzdHJpbmcsIGFycmF5IG9mIG5vZGVzIG9yIGpRdWVyeSBvYmplY3QvXG5cdFx0Ly8gQXMgalF1ZXJ5J3MgLmZpbHRlcigpIGFsbG93cyBqUXVlcnkgb2JqZWN0cyB0byBiZSBwYXNzZWQgaW4gZmlsdGVyLFxuXHRcdC8vIGl0IGFsc28gYWxsb3dzIGFycmF5cywgc28gdGhpcyB3aWxsIGNvcGUgd2l0aCBhbGwgdGhyZWUgb3B0aW9uc1xuXHRcdHJldHVybiAkKG5vZGVzKVxuXHRcdFx0LmZpbHRlciggc2VsIClcblx0XHRcdC5tYXAoIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX0RUX1Jvd0luZGV4O1xuXHRcdFx0fSApXG5cdFx0XHQudG9BcnJheSgpO1xuXHR9O1xuXG5cdHZhciBtYXRjaGVkID0gX3NlbGVjdG9yX3J1biggJ3JvdycsIHNlbGVjdG9yLCBydW4sIHNldHRpbmdzLCBvcHRzICk7XG5cblx0aWYgKG9wdHMub3JkZXIgPT09ICdjdXJyZW50JyB8fCBvcHRzLm9yZGVyID09PSAnYXBwbGllZCcpIHtcblx0XHRfZm5Tb3J0RGlzcGxheShzZXR0aW5ncywgbWF0Y2hlZCk7XG5cdH1cblxuXHRyZXR1cm4gbWF0Y2hlZDtcbn07XG5cblxuX2FwaV9yZWdpc3RlciggJ3Jvd3MoKScsIGZ1bmN0aW9uICggc2VsZWN0b3IsIG9wdHMgKSB7XG5cdC8vIGFyZ3VtZW50IHNoaWZ0aW5nXG5cdGlmICggc2VsZWN0b3IgPT09IHVuZGVmaW5lZCApIHtcblx0XHRzZWxlY3RvciA9ICcnO1xuXHR9XG5cdGVsc2UgaWYgKCAkLmlzUGxhaW5PYmplY3QoIHNlbGVjdG9yICkgKSB7XG5cdFx0b3B0cyA9IHNlbGVjdG9yO1xuXHRcdHNlbGVjdG9yID0gJyc7XG5cdH1cblxuXHRvcHRzID0gX3NlbGVjdG9yX29wdHMoIG9wdHMgKTtcblxuXHR2YXIgaW5zdCA9IHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0cmV0dXJuIF9fcm93X3NlbGVjdG9yKCBzZXR0aW5ncywgc2VsZWN0b3IsIG9wdHMgKTtcblx0fSwgMSApO1xuXG5cdC8vIFdhbnQgYXJndW1lbnQgc2hpZnRpbmcgaGVyZSBhbmQgaW4gX19yb3dfc2VsZWN0b3I/XG5cdGluc3Quc2VsZWN0b3Iucm93cyA9IHNlbGVjdG9yO1xuXHRpbnN0LnNlbGVjdG9yLm9wdHMgPSBvcHRzO1xuXG5cdHJldHVybiBpbnN0O1xufSApO1xuXG5fYXBpX3JlZ2lzdGVyKCAncm93cygpLm5vZGVzKCknLCBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAncm93JywgZnVuY3Rpb24gKCBzZXR0aW5ncywgcm93ICkge1xuXHRcdHJldHVybiBzZXR0aW5ncy5hb0RhdGFbIHJvdyBdLm5UciB8fCB1bmRlZmluZWQ7XG5cdH0sIDEgKTtcbn0gKTtcblxuX2FwaV9yZWdpc3RlciggJ3Jvd3MoKS5kYXRhKCknLCBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCB0cnVlLCAncm93cycsIGZ1bmN0aW9uICggc2V0dGluZ3MsIHJvd3MgKSB7XG5cdFx0cmV0dXJuIF9wbHVja19vcmRlciggc2V0dGluZ3MuYW9EYXRhLCByb3dzLCAnX2FEYXRhJyApO1xuXHR9LCAxICk7XG59ICk7XG5cbl9hcGlfcmVnaXN0ZXJQbHVyYWwoICdyb3dzKCkuY2FjaGUoKScsICdyb3coKS5jYWNoZSgpJywgZnVuY3Rpb24gKCB0eXBlICkge1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3JvdycsIGZ1bmN0aW9uICggc2V0dGluZ3MsIHJvdyApIHtcblx0XHR2YXIgciA9IHNldHRpbmdzLmFvRGF0YVsgcm93IF07XG5cdFx0cmV0dXJuIHR5cGUgPT09ICdzZWFyY2gnID8gci5fYUZpbHRlckRhdGEgOiByLl9hU29ydERhdGE7XG5cdH0sIDEgKTtcbn0gKTtcblxuX2FwaV9yZWdpc3RlclBsdXJhbCggJ3Jvd3MoKS5pbnZhbGlkYXRlKCknLCAncm93KCkuaW52YWxpZGF0ZSgpJywgZnVuY3Rpb24gKCBzcmMgKSB7XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAncm93JywgZnVuY3Rpb24gKCBzZXR0aW5ncywgcm93ICkge1xuXHRcdF9mbkludmFsaWRhdGUoIHNldHRpbmdzLCByb3csIHNyYyApO1xuXHR9ICk7XG59ICk7XG5cbl9hcGlfcmVnaXN0ZXJQbHVyYWwoICdyb3dzKCkuaW5kZXhlcygpJywgJ3JvdygpLmluZGV4KCknLCBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAncm93JywgZnVuY3Rpb24gKCBzZXR0aW5ncywgcm93ICkge1xuXHRcdHJldHVybiByb3c7XG5cdH0sIDEgKTtcbn0gKTtcblxuX2FwaV9yZWdpc3RlclBsdXJhbCggJ3Jvd3MoKS5pZHMoKScsICdyb3coKS5pZCgpJywgZnVuY3Rpb24gKCBoYXNoICkge1xuXHR2YXIgYSA9IFtdO1xuXHR2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuXHQvLyBgaXRlcmF0b3JgIHdpbGwgZHJvcCB1bmRlZmluZWQgdmFsdWVzLCBidXQgaW4gdGhpcyBjYXNlIHdlIHdhbnQgdGhlbVxuXHRmb3IgKCB2YXIgaT0wLCBpZW49Y29udGV4dC5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRmb3IgKCB2YXIgaj0wLCBqZW49dGhpc1tpXS5sZW5ndGggOyBqPGplbiA7IGorKyApIHtcblx0XHRcdHZhciBpZCA9IGNvbnRleHRbaV0ucm93SWRGbiggY29udGV4dFtpXS5hb0RhdGFbIHRoaXNbaV1bal0gXS5fYURhdGEgKTtcblx0XHRcdGEucHVzaCggKGhhc2ggPT09IHRydWUgPyAnIycgOiAnJyApKyBpZCApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBuZXcgX0FwaSggY29udGV4dCwgYSApO1xufSApO1xuXG5fYXBpX3JlZ2lzdGVyUGx1cmFsKCAncm93cygpLnJlbW92ZSgpJywgJ3JvdygpLnJlbW92ZSgpJywgZnVuY3Rpb24gKCkge1xuXHR0aGlzLml0ZXJhdG9yKCAncm93JywgZnVuY3Rpb24gKCBzZXR0aW5ncywgcm93ICkge1xuXHRcdHZhciBkYXRhID0gc2V0dGluZ3MuYW9EYXRhO1xuXHRcdHZhciByb3dEYXRhID0gZGF0YVsgcm93IF07XG5cblx0XHQvLyBEZWxldGUgZnJvbSB0aGUgZGlzcGxheSBhcnJheXNcblx0XHR2YXIgaWR4ID0gc2V0dGluZ3MuYWlEaXNwbGF5TWFzdGVyLmluZGV4T2Yocm93KTtcblx0XHRpZiAoaWR4ICE9PSAtMSkge1xuXHRcdFx0c2V0dGluZ3MuYWlEaXNwbGF5TWFzdGVyLnNwbGljZShpZHgsIDEpO1xuXHRcdH1cblxuXHRcdC8vIEZvciBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIHRhYmxlcyAtIHN1YnRyYWN0IHRoZSBkZWxldGVkIHJvdyBmcm9tIHRoZSBjb3VudFxuXHRcdGlmICggc2V0dGluZ3MuX2lSZWNvcmRzRGlzcGxheSA+IDAgKSB7XG5cdFx0XHRzZXR0aW5ncy5faVJlY29yZHNEaXNwbGF5LS07XG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgZm9yIGFuICdvdmVyZmxvdycgdGhleSBjYXNlIGZvciBkaXNwbGF5aW5nIHRoZSB0YWJsZVxuXHRcdF9mbkxlbmd0aE92ZXJmbG93KCBzZXR0aW5ncyApO1xuXG5cdFx0Ly8gUmVtb3ZlIHRoZSByb3cncyBJRCByZWZlcmVuY2UgaWYgdGhlcmUgaXMgb25lXG5cdFx0dmFyIGlkID0gc2V0dGluZ3Mucm93SWRGbiggcm93RGF0YS5fYURhdGEgKTtcblx0XHRpZiAoIGlkICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRkZWxldGUgc2V0dGluZ3MuYUlkc1sgaWQgXTtcblx0XHR9XG5cblx0XHRkYXRhW3Jvd10gPSBudWxsO1xuXHR9ICk7XG5cblx0cmV0dXJuIHRoaXM7XG59ICk7XG5cblxuX2FwaV9yZWdpc3RlciggJ3Jvd3MuYWRkKCknLCBmdW5jdGlvbiAoIHJvd3MgKSB7XG5cdHZhciBuZXdSb3dzID0gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRcdHZhciByb3csIGksIGllbjtcblx0XHRcdHZhciBvdXQgPSBbXTtcblxuXHRcdFx0Zm9yICggaT0wLCBpZW49cm93cy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0cm93ID0gcm93c1tpXTtcblxuXHRcdFx0XHRpZiAoIHJvdy5ub2RlTmFtZSAmJiByb3cubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gJ1RSJyApIHtcblx0XHRcdFx0XHRvdXQucHVzaCggX2ZuQWRkVHIoIHNldHRpbmdzLCByb3cgKVswXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdG91dC5wdXNoKCBfZm5BZGREYXRhKCBzZXR0aW5ncywgcm93ICkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb3V0O1xuXHRcdH0sIDEgKTtcblxuXHQvLyBSZXR1cm4gYW4gQXBpLnJvd3MoKSBleHRlbmRlZCBpbnN0YW5jZSwgc28gcm93cygpLm5vZGVzKCkgZXRjIGNhbiBiZSB1c2VkXG5cdHZhciBtb2RSb3dzID0gdGhpcy5yb3dzKCAtMSApO1xuXHRtb2RSb3dzLnBvcCgpO1xuXHRfZm5BcnJheUFwcGx5KG1vZFJvd3MsIG5ld1Jvd3MpO1xuXG5cdHJldHVybiBtb2RSb3dzO1xufSApO1xuXG5cblxuXG5cbi8qKlxuICpcbiAqL1xuX2FwaV9yZWdpc3RlciggJ3JvdygpJywgZnVuY3Rpb24gKCBzZWxlY3Rvciwgb3B0cyApIHtcblx0cmV0dXJuIF9zZWxlY3Rvcl9maXJzdCggdGhpcy5yb3dzKCBzZWxlY3Rvciwgb3B0cyApICk7XG59ICk7XG5cblxuX2FwaV9yZWdpc3RlciggJ3JvdygpLmRhdGEoKScsIGZ1bmN0aW9uICggZGF0YSApIHtcblx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblxuXHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCApIHtcblx0XHQvLyBHZXRcblx0XHRyZXR1cm4gY3R4Lmxlbmd0aCAmJiB0aGlzLmxlbmd0aCAmJiB0aGlzWzBdLmxlbmd0aCA/XG5cdFx0XHRjdHhbMF0uYW9EYXRhWyB0aGlzWzBdIF0uX2FEYXRhIDpcblx0XHRcdHVuZGVmaW5lZDtcblx0fVxuXG5cdC8vIFNldFxuXHR2YXIgcm93ID0gY3R4WzBdLmFvRGF0YVsgdGhpc1swXSBdO1xuXHRyb3cuX2FEYXRhID0gZGF0YTtcblxuXHQvLyBJZiB0aGUgRE9NIGhhcyBhbiBpZCwgYW5kIHRoZSBkYXRhIHNvdXJjZSBpcyBhbiBhcnJheVxuXHRpZiAoIEFycmF5LmlzQXJyYXkoIGRhdGEgKSAmJiByb3cublRyICYmIHJvdy5uVHIuaWQgKSB7XG5cdFx0X2ZuU2V0T2JqZWN0RGF0YUZuKCBjdHhbMF0ucm93SWQgKSggZGF0YSwgcm93Lm5Uci5pZCApO1xuXHR9XG5cblx0Ly8gQXV0b21hdGljYWxseSBpbnZhbGlkYXRlXG5cdF9mbkludmFsaWRhdGUoIGN0eFswXSwgdGhpc1swXSwgJ2RhdGEnICk7XG5cblx0cmV0dXJuIHRoaXM7XG59ICk7XG5cblxuX2FwaV9yZWdpc3RlciggJ3JvdygpLm5vZGUoKScsIGZ1bmN0aW9uICgpIHtcblx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblxuXHRpZiAoY3R4Lmxlbmd0aCAmJiB0aGlzLmxlbmd0aCAmJiB0aGlzWzBdLmxlbmd0aCkge1xuXHRcdHZhciByb3cgPSBjdHhbMF0uYW9EYXRhWyB0aGlzWzBdIF07XG5cblx0XHRpZiAocm93ICYmIHJvdy5uVHIpIHtcblx0XHRcdHJldHVybiByb3cublRyO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBudWxsO1xufSApO1xuXG5cbl9hcGlfcmVnaXN0ZXIoICdyb3cuYWRkKCknLCBmdW5jdGlvbiAoIHJvdyApIHtcblx0Ly8gQWxsb3cgYSBqUXVlcnkgb2JqZWN0IHRvIGJlIHBhc3NlZCBpbiAtIG9ubHkgYSBzaW5nbGUgcm93IGlzIGFkZGVkIGZyb21cblx0Ly8gaXQgdGhvdWdoIC0gdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHNldFxuXHRpZiAoIHJvdyBpbnN0YW5jZW9mICQgJiYgcm93Lmxlbmd0aCApIHtcblx0XHRyb3cgPSByb3dbMF07XG5cdH1cblxuXHR2YXIgcm93cyA9IHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0aWYgKCByb3cubm9kZU5hbWUgJiYgcm93Lm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdUUicgKSB7XG5cdFx0XHRyZXR1cm4gX2ZuQWRkVHIoIHNldHRpbmdzLCByb3cgKVswXTtcblx0XHR9XG5cdFx0cmV0dXJuIF9mbkFkZERhdGEoIHNldHRpbmdzLCByb3cgKTtcblx0fSApO1xuXG5cdC8vIFJldHVybiBhbiBBcGkucm93cygpIGV4dGVuZGVkIGluc3RhbmNlLCB3aXRoIHRoZSBuZXdseSBhZGRlZCByb3cgc2VsZWN0ZWRcblx0cmV0dXJuIHRoaXMucm93KCByb3dzWzBdICk7XG59ICk7XG5cblxuJChkb2N1bWVudCkub24oJ3BsdWdpbi1pbml0LmR0JywgZnVuY3Rpb24gKGUsIGNvbnRleHQpIHtcblx0dmFyIGFwaSA9IG5ldyBfQXBpKCBjb250ZXh0ICk7XG5cblx0YXBpLm9uKCAnc3RhdGVTYXZlUGFyYW1zLkRUJywgZnVuY3Rpb24gKCBlLCBzZXR0aW5ncywgZCApIHtcblx0XHQvLyBUaGlzIGNvdWxkIGJlIG1vcmUgY29tcGFjdCB3aXRoIHRoZSBBUEksIGJ1dCBpdCBpcyBhIGxvdCBmYXN0ZXIgYXMgYSBzaW1wbGVcblx0XHQvLyBpbnRlcm5hbCBsb29wXG5cdFx0dmFyIGlkRm4gPSBzZXR0aW5ncy5yb3dJZEZuO1xuXHRcdHZhciByb3dzID0gc2V0dGluZ3MuYWlEaXNwbGF5TWFzdGVyO1xuXHRcdHZhciBpZHMgPSBbXTtcblxuXHRcdGZvciAodmFyIGk9MCA7IGk8cm93cy5sZW5ndGggOyBpKyspIHtcblx0XHRcdHZhciByb3dJZHggPSByb3dzW2ldO1xuXHRcdFx0dmFyIGRhdGEgPSBzZXR0aW5ncy5hb0RhdGFbcm93SWR4XTtcblxuXHRcdFx0aWYgKGRhdGEuX2RldGFpbHNTaG93KSB7XG5cdFx0XHRcdGlkcy5wdXNoKCAnIycgKyBpZEZuKGRhdGEuX2FEYXRhKSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGQuY2hpbGRSb3dzID0gaWRzO1xuXHR9KTtcblxuXHQvLyBGb3IgZnV0dXJlIHN0YXRlIGxvYWRzIChlLmcuIHdpdGggU3RhdGVSZXN0b3JlKVxuXHRhcGkub24oICdzdGF0ZUxvYWRlZC5EVCcsIGZ1bmN0aW9uIChlLCBzZXR0aW5ncywgc3RhdGUpIHtcblx0XHRfX2RldGFpbHNfc3RhdGVfbG9hZCggYXBpLCBzdGF0ZSApO1xuXHR9KTtcblxuXHQvLyBBbmQgdGhlIGluaXRpYWwgbG9hZCBzdGF0ZVxuXHRfX2RldGFpbHNfc3RhdGVfbG9hZCggYXBpLCBhcGkuc3RhdGUubG9hZGVkKCkgKTtcbn0pO1xuXG52YXIgX19kZXRhaWxzX3N0YXRlX2xvYWQgPSBmdW5jdGlvbiAoYXBpLCBzdGF0ZSlcbntcblx0aWYgKCBzdGF0ZSAmJiBzdGF0ZS5jaGlsZFJvd3MgKSB7XG5cdFx0YXBpXG5cdFx0XHQucm93cyggc3RhdGUuY2hpbGRSb3dzLm1hcChmdW5jdGlvbiAoaWQpIHtcblx0XHRcdFx0Ly8gRXNjYXBlIGFueSBgOmAgY2hhcmFjdGVycyBmcm9tIHRoZSByb3cgaWQuIEFjY291bnRzIGZvclxuXHRcdFx0XHQvLyBhbHJlYWR5IGVzY2FwZWQgY2hhcmFjdGVycy5cblx0XHRcdFx0cmV0dXJuIGlkLnJlcGxhY2UoLyhbXjpcXFxcXSooPzpcXFxcLlteOlxcXFxdKikqKTovZywgXCIkMVxcXFw6XCIpO1xuXHRcdFx0fSkgKVxuXHRcdFx0LmV2ZXJ5KCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdF9mbkNhbGxiYWNrRmlyZSggYXBpLnNldHRpbmdzKClbMF0sIG51bGwsICdyZXF1ZXN0Q2hpbGQnLCBbIHRoaXMgXSApXG5cdFx0XHR9KTtcblx0fVxufVxuXG52YXIgX19kZXRhaWxzX2FkZCA9IGZ1bmN0aW9uICggY3R4LCByb3csIGRhdGEsIGtsYXNzIClcbntcblx0Ly8gQ29udmVydCB0byBhcnJheSBvZiBUUiBlbGVtZW50c1xuXHR2YXIgcm93cyA9IFtdO1xuXHR2YXIgYWRkUm93ID0gZnVuY3Rpb24gKCByLCBrICkge1xuXHRcdC8vIFJlY3Vyc2lvbiB0byBhbGxvdyBmb3IgYXJyYXlzIG9mIGpRdWVyeSBvYmplY3RzXG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCByICkgfHwgciBpbnN0YW5jZW9mICQgKSB7XG5cdFx0XHRmb3IgKCB2YXIgaT0wLCBpZW49ci5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0YWRkUm93KCByW2ldLCBrICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gSWYgd2UgZ2V0IGEgVFIgZWxlbWVudCwgdGhlbiBqdXN0IGFkZCBpdCBkaXJlY3RseSAtIHVwIHRvIHRoZSBkZXZcblx0XHQvLyB0byBhZGQgdGhlIGNvcnJlY3QgbnVtYmVyIG9mIGNvbHVtbnMgZXRjXG5cdFx0aWYgKCByLm5vZGVOYW1lICYmIHIubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3RyJyApIHtcblx0XHRcdHIuc2V0QXR0cmlidXRlKCAnZGF0YS1kdC1yb3cnLCByb3cuaWR4ICk7XG5cdFx0XHRyb3dzLnB1c2goIHIgKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHQvLyBPdGhlcndpc2UgY3JlYXRlIGEgcm93IHdpdGggYSB3cmFwcGVyXG5cdFx0XHR2YXIgY3JlYXRlZCA9ICQoJzx0cj48dGQ+PC90ZD48L3RyPicpXG5cdFx0XHRcdC5hdHRyKCAnZGF0YS1kdC1yb3cnLCByb3cuaWR4IClcblx0XHRcdFx0LmFkZENsYXNzKCBrICk7XG5cdFx0XHRcblx0XHRcdCQoJ3RkJywgY3JlYXRlZClcblx0XHRcdFx0LmFkZENsYXNzKCBrIClcblx0XHRcdFx0Lmh0bWwoIHIgKVswXS5jb2xTcGFuID0gX2ZuVmlzYmxlQ29sdW1ucyggY3R4ICk7XG5cblx0XHRcdHJvd3MucHVzaCggY3JlYXRlZFswXSApO1xuXHRcdH1cblx0fTtcblxuXHRhZGRSb3coIGRhdGEsIGtsYXNzICk7XG5cblx0aWYgKCByb3cuX2RldGFpbHMgKSB7XG5cdFx0cm93Ll9kZXRhaWxzLmRldGFjaCgpO1xuXHR9XG5cblx0cm93Ll9kZXRhaWxzID0gJChyb3dzKTtcblxuXHQvLyBJZiB0aGUgY2hpbGRyZW4gd2VyZSBhbHJlYWR5IHNob3duLCB0aGF0IHN0YXRlIHNob3VsZCBiZSByZXRhaW5lZFxuXHRpZiAoIHJvdy5fZGV0YWlsc1Nob3cgKSB7XG5cdFx0cm93Ll9kZXRhaWxzLmluc2VydEFmdGVyKCByb3cublRyICk7XG5cdH1cbn07XG5cblxuLy8gTWFrZSBzdGF0ZSBzYXZpbmcgb2YgY2hpbGQgcm93IGRldGFpbHMgYXN5bmMgdG8gYWxsb3cgdGhlbSB0byBiZSBiYXRjaCBwcm9jZXNzZWRcbnZhciBfX2RldGFpbHNfc3RhdGUgPSBEYXRhVGFibGUudXRpbC50aHJvdHRsZShcblx0ZnVuY3Rpb24gKGN0eCkge1xuXHRcdF9mblNhdmVTdGF0ZSggY3R4WzBdIClcblx0fSxcblx0NTAwXG4pO1xuXG5cbnZhciBfX2RldGFpbHNfcmVtb3ZlID0gZnVuY3Rpb24gKCBhcGksIGlkeCApXG57XG5cdHZhciBjdHggPSBhcGkuY29udGV4dDtcblxuXHRpZiAoIGN0eC5sZW5ndGggKSB7XG5cdFx0dmFyIHJvdyA9IGN0eFswXS5hb0RhdGFbIGlkeCAhPT0gdW5kZWZpbmVkID8gaWR4IDogYXBpWzBdIF07XG5cblx0XHRpZiAoIHJvdyAmJiByb3cuX2RldGFpbHMgKSB7XG5cdFx0XHRyb3cuX2RldGFpbHMucmVtb3ZlKCk7XG5cblx0XHRcdHJvdy5fZGV0YWlsc1Nob3cgPSB1bmRlZmluZWQ7XG5cdFx0XHRyb3cuX2RldGFpbHMgPSB1bmRlZmluZWQ7XG5cdFx0XHQkKCByb3cublRyICkucmVtb3ZlQ2xhc3MoICdkdC1oYXNDaGlsZCcgKTtcblx0XHRcdF9fZGV0YWlsc19zdGF0ZSggY3R4ICk7XG5cdFx0fVxuXHR9XG59O1xuXG5cbnZhciBfX2RldGFpbHNfZGlzcGxheSA9IGZ1bmN0aW9uICggYXBpLCBzaG93ICkge1xuXHR2YXIgY3R4ID0gYXBpLmNvbnRleHQ7XG5cblx0aWYgKCBjdHgubGVuZ3RoICYmIGFwaS5sZW5ndGggKSB7XG5cdFx0dmFyIHJvdyA9IGN0eFswXS5hb0RhdGFbIGFwaVswXSBdO1xuXG5cdFx0aWYgKCByb3cuX2RldGFpbHMgKSB7XG5cdFx0XHRyb3cuX2RldGFpbHNTaG93ID0gc2hvdztcblxuXHRcdFx0aWYgKCBzaG93ICkge1xuXHRcdFx0XHRyb3cuX2RldGFpbHMuaW5zZXJ0QWZ0ZXIoIHJvdy5uVHIgKTtcblx0XHRcdFx0JCggcm93Lm5UciApLmFkZENsYXNzKCAnZHQtaGFzQ2hpbGQnICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0cm93Ll9kZXRhaWxzLmRldGFjaCgpO1xuXHRcdFx0XHQkKCByb3cublRyICkucmVtb3ZlQ2xhc3MoICdkdC1oYXNDaGlsZCcgKTtcblx0XHRcdH1cblxuXHRcdFx0X2ZuQ2FsbGJhY2tGaXJlKCBjdHhbMF0sIG51bGwsICdjaGlsZFJvdycsIFsgc2hvdywgYXBpLnJvdyggYXBpWzBdICkgXSApXG5cblx0XHRcdF9fZGV0YWlsc19ldmVudHMoIGN0eFswXSApO1xuXHRcdFx0X19kZXRhaWxzX3N0YXRlKCBjdHggKTtcblx0XHR9XG5cdH1cbn07XG5cblxudmFyIF9fZGV0YWlsc19ldmVudHMgPSBmdW5jdGlvbiAoIHNldHRpbmdzIClcbntcblx0dmFyIGFwaSA9IG5ldyBfQXBpKCBzZXR0aW5ncyApO1xuXHR2YXIgbmFtZXNwYWNlID0gJy5kdC5EVF9kZXRhaWxzJztcblx0dmFyIGRyYXdFdmVudCA9ICdkcmF3JytuYW1lc3BhY2U7XG5cdHZhciBjb2x2aXNFdmVudCA9ICdjb2x1bW4tc2l6aW5nJytuYW1lc3BhY2U7XG5cdHZhciBkZXN0cm95RXZlbnQgPSAnZGVzdHJveScrbmFtZXNwYWNlO1xuXHR2YXIgZGF0YSA9IHNldHRpbmdzLmFvRGF0YTtcblxuXHRhcGkub2ZmKCBkcmF3RXZlbnQgKycgJysgY29sdmlzRXZlbnQgKycgJysgZGVzdHJveUV2ZW50ICk7XG5cblx0aWYgKCBfcGx1Y2soIGRhdGEsICdfZGV0YWlscycgKS5sZW5ndGggPiAwICkge1xuXHRcdC8vIE9uIGVhY2ggZHJhdywgaW5zZXJ0IHRoZSByZXF1aXJlZCBlbGVtZW50cyBpbnRvIHRoZSBkb2N1bWVudFxuXHRcdGFwaS5vbiggZHJhd0V2ZW50LCBmdW5jdGlvbiAoIGUsIGN0eCApIHtcblx0XHRcdGlmICggc2V0dGluZ3MgIT09IGN0eCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRhcGkucm93cygge3BhZ2U6J2N1cnJlbnQnfSApLmVxKDApLmVhY2goIGZ1bmN0aW9uIChpZHgpIHtcblx0XHRcdFx0Ly8gSW50ZXJuYWwgZGF0YSBncmFiXG5cdFx0XHRcdHZhciByb3cgPSBkYXRhWyBpZHggXTtcblxuXHRcdFx0XHRpZiAoIHJvdy5fZGV0YWlsc1Nob3cgKSB7XG5cdFx0XHRcdFx0cm93Ll9kZXRhaWxzLmluc2VydEFmdGVyKCByb3cublRyICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cblx0XHQvLyBDb2x1bW4gdmlzaWJpbGl0eSBjaGFuZ2UgLSB1cGRhdGUgdGhlIGNvbHNwYW5cblx0XHRhcGkub24oIGNvbHZpc0V2ZW50LCBmdW5jdGlvbiAoIGUsIGN0eCApIHtcblx0XHRcdGlmICggc2V0dGluZ3MgIT09IGN0eCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBVcGRhdGUgdGhlIGNvbHNwYW4gZm9yIHRoZSBkZXRhaWxzIHJvd3MgKG5vdGUsIG9ubHkgaWYgaXQgYWxyZWFkeSBoYXNcblx0XHRcdC8vIGEgY29sc3Bhbilcblx0XHRcdHZhciByb3csIHZpc2libGUgPSBfZm5WaXNibGVDb2x1bW5zKCBjdHggKTtcblxuXHRcdFx0Zm9yICggdmFyIGk9MCwgaWVuPWRhdGEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdHJvdyA9IGRhdGFbaV07XG5cblx0XHRcdFx0aWYgKCByb3cgJiYgcm93Ll9kZXRhaWxzICkge1xuXHRcdFx0XHRcdHJvdy5fZGV0YWlscy5lYWNoKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdHZhciBlbCA9ICQodGhpcykuY2hpbGRyZW4oJ3RkJyk7XG5cblx0XHRcdFx0XHRcdGlmIChlbC5sZW5ndGggPT0gMSkge1xuXHRcdFx0XHRcdFx0XHRlbC5hdHRyKCdjb2xzcGFuJywgdmlzaWJsZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cblx0XHQvLyBUYWJsZSBkZXN0cm95ZWQgLSBudWtlIGFueSBjaGlsZCByb3dzXG5cdFx0YXBpLm9uKCBkZXN0cm95RXZlbnQsIGZ1bmN0aW9uICggZSwgY3R4ICkge1xuXHRcdFx0aWYgKCBzZXR0aW5ncyAhPT0gY3R4ICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIHZhciBpPTAsIGllbj1kYXRhLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGRhdGFbaV0gJiYgZGF0YVtpXS5fZGV0YWlscyApIHtcblx0XHRcdFx0XHRfX2RldGFpbHNfcmVtb3ZlKCBhcGksIGkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufTtcblxuLy8gU3RyaW5ncyBmb3IgdGhlIG1ldGhvZCBuYW1lcyB0byBoZWxwIG1pbmlmaWNhdGlvblxudmFyIF9lbXAgPSAnJztcbnZhciBfY2hpbGRfb2JqID0gX2VtcCsncm93KCkuY2hpbGQnO1xudmFyIF9jaGlsZF9tdGggPSBfY2hpbGRfb2JqKycoKSc7XG5cbi8vIGRhdGEgY2FuIGJlOlxuLy8gIHRyXG4vLyAgc3RyaW5nXG4vLyAgalF1ZXJ5IG9yIGFycmF5IG9mIGFueSBvZiB0aGUgYWJvdmVcbl9hcGlfcmVnaXN0ZXIoIF9jaGlsZF9tdGgsIGZ1bmN0aW9uICggZGF0YSwga2xhc3MgKSB7XG5cdHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG5cblx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgKSB7XG5cdFx0Ly8gZ2V0XG5cdFx0cmV0dXJuIGN0eC5sZW5ndGggJiYgdGhpcy5sZW5ndGggJiYgY3R4WzBdLmFvRGF0YVsgdGhpc1swXSBdXG5cdFx0XHQ/IGN0eFswXS5hb0RhdGFbIHRoaXNbMF0gXS5fZGV0YWlsc1xuXHRcdFx0OiB1bmRlZmluZWQ7XG5cdH1cblx0ZWxzZSBpZiAoIGRhdGEgPT09IHRydWUgKSB7XG5cdFx0Ly8gc2hvd1xuXHRcdHRoaXMuY2hpbGQuc2hvdygpO1xuXHR9XG5cdGVsc2UgaWYgKCBkYXRhID09PSBmYWxzZSApIHtcblx0XHQvLyByZW1vdmVcblx0XHRfX2RldGFpbHNfcmVtb3ZlKCB0aGlzICk7XG5cdH1cblx0ZWxzZSBpZiAoIGN0eC5sZW5ndGggJiYgdGhpcy5sZW5ndGggKSB7XG5cdFx0Ly8gc2V0XG5cdFx0X19kZXRhaWxzX2FkZCggY3R4WzBdLCBjdHhbMF0uYW9EYXRhWyB0aGlzWzBdIF0sIGRhdGEsIGtsYXNzICk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn0gKTtcblxuXG5fYXBpX3JlZ2lzdGVyKCBbXG5cdF9jaGlsZF9vYmorJy5zaG93KCknLFxuXHRfY2hpbGRfbXRoKycuc2hvdygpJyAvLyBvbmx5IHdoZW4gYGNoaWxkKClgIHdhcyBjYWxsZWQgd2l0aCBwYXJhbWV0ZXJzICh3aXRob3V0XG5dLCBmdW5jdGlvbiAoKSB7ICAgICAgICAgLy8gaXQgcmV0dXJucyBhbiBvYmplY3QgYW5kIHRoaXMgbWV0aG9kIGlzIG5vdCBleGVjdXRlZClcblx0X19kZXRhaWxzX2Rpc3BsYXkoIHRoaXMsIHRydWUgKTtcblx0cmV0dXJuIHRoaXM7XG59ICk7XG5cblxuX2FwaV9yZWdpc3RlciggW1xuXHRfY2hpbGRfb2JqKycuaGlkZSgpJyxcblx0X2NoaWxkX210aCsnLmhpZGUoKScgLy8gb25seSB3aGVuIGBjaGlsZCgpYCB3YXMgY2FsbGVkIHdpdGggcGFyYW1ldGVycyAod2l0aG91dFxuXSwgZnVuY3Rpb24gKCkgeyAgICAgICAgIC8vIGl0IHJldHVybnMgYW4gb2JqZWN0IGFuZCB0aGlzIG1ldGhvZCBpcyBub3QgZXhlY3V0ZWQpXG5cdF9fZGV0YWlsc19kaXNwbGF5KCB0aGlzLCBmYWxzZSApO1xuXHRyZXR1cm4gdGhpcztcbn0gKTtcblxuXG5fYXBpX3JlZ2lzdGVyKCBbXG5cdF9jaGlsZF9vYmorJy5yZW1vdmUoKScsXG5cdF9jaGlsZF9tdGgrJy5yZW1vdmUoKScgLy8gb25seSB3aGVuIGBjaGlsZCgpYCB3YXMgY2FsbGVkIHdpdGggcGFyYW1ldGVycyAod2l0aG91dFxuXSwgZnVuY3Rpb24gKCkgeyAgICAgICAgICAgLy8gaXQgcmV0dXJucyBhbiBvYmplY3QgYW5kIHRoaXMgbWV0aG9kIGlzIG5vdCBleGVjdXRlZClcblx0X19kZXRhaWxzX3JlbW92ZSggdGhpcyApO1xuXHRyZXR1cm4gdGhpcztcbn0gKTtcblxuXG5fYXBpX3JlZ2lzdGVyKCBfY2hpbGRfb2JqKycuaXNTaG93bigpJywgZnVuY3Rpb24gKCkge1xuXHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXG5cdGlmICggY3R4Lmxlbmd0aCAmJiB0aGlzLmxlbmd0aCAmJiBjdHhbMF0uYW9EYXRhWyB0aGlzWzBdIF0gKSB7XG5cdFx0Ly8gX2RldGFpbHNTaG93biBhcyBmYWxzZSBvciB1bmRlZmluZWQgd2lsbCBmYWxsIHRocm91Z2ggdG8gcmV0dXJuIGZhbHNlXG5cdFx0cmV0dXJuIGN0eFswXS5hb0RhdGFbIHRoaXNbMF0gXS5fZGV0YWlsc1Nob3cgfHwgZmFsc2U7XG5cdH1cblx0cmV0dXJuIGZhbHNlO1xufSApO1xuXG5cblxuLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG4gKiBDb2x1bW5zXG4gKlxuICoge2ludGVnZXJ9ICAgICAgICAgICAtIGNvbHVtbiBpbmRleCAoPj0wIGNvdW50IGZyb20gbGVmdCwgPDAgY291bnQgZnJvbSByaWdodClcbiAqIFwie2ludGVnZXJ9OnZpc0lkeFwiICAtIHZpc2libGUgY29sdW1uIGluZGV4IChpLmUuIHRyYW5zbGF0ZSB0byBjb2x1bW4gaW5kZXgpICAoPj0wIGNvdW50IGZyb20gbGVmdCwgPDAgY291bnQgZnJvbSByaWdodClcbiAqIFwie2ludGVnZXJ9OnZpc2libGVcIiAtIGFsaWFzIGZvciB7aW50ZWdlcn06dmlzSWR4ICAoPj0wIGNvdW50IGZyb20gbGVmdCwgPDAgY291bnQgZnJvbSByaWdodClcbiAqIFwie3N0cmluZ306bmFtZVwiICAgICAtIGNvbHVtbiBuYW1lXG4gKiBcIntzdHJpbmd9XCIgICAgICAgICAgLSBqUXVlcnkgc2VsZWN0b3Igb24gY29sdW1uIGhlYWRlciBub2Rlc1xuICpcbiAqL1xuXG4vLyBjYW4gYmUgYW4gYXJyYXkgb2YgdGhlc2UgaXRlbXMsIGNvbW1hIHNlcGFyYXRlZCBsaXN0LCBvciBhbiBhcnJheSBvZiBjb21tYVxuLy8gc2VwYXJhdGVkIGxpc3RzXG5cbnZhciBfX3JlX2NvbHVtbl9zZWxlY3RvciA9IC9eKFteOl0rKT86KG5hbWV8dGl0bGV8dmlzSWR4fHZpc2libGUpJC87XG5cblxuLy8gcjEgYW5kIHIyIGFyZSByZWR1bmRhbnQgLSBidXQgaXQgbWVhbnMgdGhhdCB0aGUgcGFyYW1ldGVycyBtYXRjaCBmb3IgdGhlXG4vLyBpdGVyYXRvciBjYWxsYmFjayBpbiBjb2x1bW5zKCkuZGF0YSgpXG52YXIgX19jb2x1bW5EYXRhID0gZnVuY3Rpb24gKCBzZXR0aW5ncywgY29sdW1uLCByMSwgcjIsIHJvd3MsIHR5cGUgKSB7XG5cdHZhciBhID0gW107XG5cdGZvciAoIHZhciByb3c9MCwgaWVuPXJvd3MubGVuZ3RoIDsgcm93PGllbiA7IHJvdysrICkge1xuXHRcdGEucHVzaCggX2ZuR2V0Q2VsbERhdGEoIHNldHRpbmdzLCByb3dzW3Jvd10sIGNvbHVtbiwgdHlwZSApICk7XG5cdH1cblx0cmV0dXJuIGE7XG59O1xuXG5cbnZhciBfX2NvbHVtbl9oZWFkZXIgPSBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb2x1bW4sIHJvdyApIHtcblx0dmFyIGhlYWRlciA9IHNldHRpbmdzLmFvSGVhZGVyO1xuXHR2YXIgdGl0bGVSb3cgPSBzZXR0aW5ncy50aXRsZVJvdztcblx0dmFyIHRhcmdldCA9IG51bGw7XG5cblx0aWYgKHJvdyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0dGFyZ2V0ID0gcm93O1xuXHR9XG5cdGVsc2UgaWYgKHRpdGxlUm93ID09PSB0cnVlKSB7IC8vIGxlZ2FjeSBvcmRlckNlbGxzVG9wIHN1cHBvcnRcblx0XHR0YXJnZXQgPSAwO1xuXHR9XG5cdGVsc2UgaWYgKHRpdGxlUm93ID09PSBmYWxzZSkge1xuXHRcdHRhcmdldCA9IGhlYWRlci5sZW5ndGggLSAxO1xuXHR9XG5cdGVsc2UgaWYgKHRpdGxlUm93ICE9PSBudWxsKSB7XG5cdFx0dGFyZ2V0ID0gdGl0bGVSb3c7XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gQXV0b21hdGljIC0gZmluZCB0aGUgX2xhc3RfIHVuaXF1ZSBjZWxsIGZyb20gdGhlIHRvcCB0aGF0IGlzIG5vdCBlbXB0eSAobGFzdCBmb3Jcblx0XHQvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSlcblx0XHRmb3IgKHZhciBpPTAgOyBpPGhlYWRlci5sZW5ndGggOyBpKyspIHtcblx0XHRcdGlmIChoZWFkZXJbaV1bY29sdW1uXS51bmlxdWUgJiYgJCgnc3Bhbi5kdC1jb2x1bW4tdGl0bGUnLCBoZWFkZXJbaV1bY29sdW1uXS5jZWxsKS50ZXh0KCkpIHtcblx0XHRcdFx0dGFyZ2V0ID0gaTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAodGFyZ2V0ID09PSBudWxsKSB7XG5cdFx0XHR0YXJnZXQgPSAwO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBoZWFkZXJbdGFyZ2V0XVtjb2x1bW5dLmNlbGw7XG59O1xuXG52YXIgX19jb2x1bW5faGVhZGVyX2NlbGxzID0gZnVuY3Rpb24gKGhlYWRlcikge1xuXHR2YXIgb3V0ID0gW107XG5cblx0Zm9yICh2YXIgaT0wIDsgaTxoZWFkZXIubGVuZ3RoIDsgaSsrKSB7XG5cdFx0Zm9yICh2YXIgaj0wIDsgajxoZWFkZXJbaV0ubGVuZ3RoIDsgaisrKSB7XG5cdFx0XHR2YXIgY2VsbCA9IGhlYWRlcltpXVtqXS5jZWxsO1xuXG5cdFx0XHRpZiAoIW91dC5pbmNsdWRlcyhjZWxsKSkge1xuXHRcdFx0XHRvdXQucHVzaChjZWxsKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gb3V0O1xufVxuXG52YXIgX19jb2x1bW5fc2VsZWN0b3IgPSBmdW5jdGlvbiAoIHNldHRpbmdzLCBzZWxlY3Rvciwgb3B0cyApXG57XG5cdHZhclxuXHRcdGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnMsXG5cdFx0bmFtZXMsIHRpdGxlcyxcblx0XHRub2RlcyA9IF9fY29sdW1uX2hlYWRlcl9jZWxscyhzZXR0aW5ncy5hb0hlYWRlcik7XG5cdFxuXHR2YXIgcnVuID0gZnVuY3Rpb24gKCBzICkge1xuXHRcdHZhciBzZWxJbnQgPSBfaW50VmFsKCBzICk7XG5cblx0XHQvLyBTZWxlY3RvciAtIGFsbFxuXHRcdGlmICggcyA9PT0gJycgKSB7XG5cdFx0XHRyZXR1cm4gX3JhbmdlKCBjb2x1bW5zLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIFNlbGVjdG9yIC0gaW5kZXhcblx0XHRpZiAoIHNlbEludCAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiBbIHNlbEludCA+PSAwID9cblx0XHRcdFx0c2VsSW50IDogLy8gQ291bnQgZnJvbSBsZWZ0XG5cdFx0XHRcdGNvbHVtbnMubGVuZ3RoICsgc2VsSW50IC8vIENvdW50IGZyb20gcmlnaHQgKCsgYmVjYXVzZSBpdHMgYSBuZWdhdGl2ZSB2YWx1ZSlcblx0XHRcdF07XG5cdFx0fVxuXG5cdFx0Ly8gU2VsZWN0b3IgPSBmdW5jdGlvblxuXHRcdGlmICggdHlwZW9mIHMgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHR2YXIgcm93cyA9IF9zZWxlY3Rvcl9yb3dfaW5kZXhlcyggc2V0dGluZ3MsIG9wdHMgKTtcblxuXHRcdFx0cmV0dXJuIGNvbHVtbnMubWFwKGZ1bmN0aW9uIChjb2wsIGlkeCkge1xuXHRcdFx0XHRyZXR1cm4gcyhcblx0XHRcdFx0XHRcdGlkeCxcblx0XHRcdFx0XHRcdF9fY29sdW1uRGF0YSggc2V0dGluZ3MsIGlkeCwgMCwgMCwgcm93cyApLFxuXHRcdFx0XHRcdFx0X19jb2x1bW5faGVhZGVyKCBzZXR0aW5ncywgaWR4IClcblx0XHRcdFx0XHQpID8gaWR4IDogbnVsbDtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdC8vIGpRdWVyeSBvciBzdHJpbmcgc2VsZWN0b3Jcblx0XHR2YXIgbWF0Y2ggPSB0eXBlb2YgcyA9PT0gJ3N0cmluZycgP1xuXHRcdFx0cy5tYXRjaCggX19yZV9jb2x1bW5fc2VsZWN0b3IgKSA6XG5cdFx0XHQnJztcblxuXHRcdGlmICggbWF0Y2ggKSB7XG5cdFx0XHRzd2l0Y2goIG1hdGNoWzJdICkge1xuXHRcdFx0XHRjYXNlICd2aXNJZHgnOlxuXHRcdFx0XHRjYXNlICd2aXNpYmxlJzpcblx0XHRcdFx0XHQvLyBTZWxlY3RvciBpcyBhIGNvbHVtbiBpbmRleFxuXHRcdFx0XHRcdGlmIChtYXRjaFsxXSAmJiBtYXRjaFsxXS5tYXRjaCgvXlxcZCskLykpIHtcblx0XHRcdFx0XHRcdHZhciBpZHggPSBwYXJzZUludCggbWF0Y2hbMV0sIDEwICk7XG5cblx0XHRcdFx0XHRcdC8vIFZpc2libGUgaW5kZXggZ2l2ZW4sIGNvbnZlcnQgdG8gY29sdW1uIGluZGV4XG5cdFx0XHRcdFx0XHRpZiAoIGlkeCA8IDAgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIENvdW50aW5nIGZyb20gdGhlIHJpZ2h0XG5cdFx0XHRcdFx0XHRcdHZhciB2aXNDb2x1bW5zID0gY29sdW1ucy5tYXAoIGZ1bmN0aW9uIChjb2wsaSkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBjb2wuYlZpc2libGUgPyBpIDogbnVsbDtcblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gWyB2aXNDb2x1bW5zWyB2aXNDb2x1bW5zLmxlbmd0aCArIGlkeCBdIF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvLyBDb3VudGluZyBmcm9tIHRoZSBsZWZ0XG5cdFx0XHRcdFx0XHRyZXR1cm4gWyBfZm5WaXNpYmxlVG9Db2x1bW5JbmRleCggc2V0dGluZ3MsIGlkeCApIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHJldHVybiBjb2x1bW5zLm1hcCggZnVuY3Rpb24gKGNvbCwgaWR4KSB7XG5cdFx0XHRcdFx0XHQvLyBOb3QgdmlzaWJsZSwgY2FuJ3QgbWF0Y2hcblx0XHRcdFx0XHRcdGlmICghIGNvbC5iVmlzaWJsZSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gU2VsZWN0b3Jcblx0XHRcdFx0XHRcdGlmIChtYXRjaFsxXSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gJChub2Rlc1tpZHhdKS5maWx0ZXIobWF0Y2hbMV0pLmxlbmd0aCA+IDAgPyBpZHggOiBudWxsO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBgOnZpc2libGVgIG9uIGl0cyBvd25cblx0XHRcdFx0XHRcdHJldHVybiBpZHg7XG5cdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdGNhc2UgJ25hbWUnOlxuXHRcdFx0XHRcdC8vIERvbid0IGdldCBuYW1lcywgdW5sZXNzIG5lZWRlZCwgYW5kIG9ubHkgZ2V0IG9uY2UgaWYgaXQgaXNcblx0XHRcdFx0XHRpZiAoIW5hbWVzKSB7XG5cdFx0XHRcdFx0XHRuYW1lcyA9IF9wbHVjayggY29sdW1ucywgJ3NOYW1lJyApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIG1hdGNoIGJ5IG5hbWUuIGBuYW1lc2AgaXMgY29sdW1uIGluZGV4IGNvbXBsZXRlIGFuZCBpbiBvcmRlclxuXHRcdFx0XHRcdHJldHVybiBuYW1lcy5tYXAoIGZ1bmN0aW9uIChuYW1lLCBpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbmFtZSA9PT0gbWF0Y2hbMV0gPyBpIDogbnVsbDtcblx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0Y2FzZSAndGl0bGUnOlxuXHRcdFx0XHRcdGlmICghdGl0bGVzKSB7XG5cdFx0XHRcdFx0XHR0aXRsZXMgPSBfcGx1Y2soIGNvbHVtbnMsICdzVGl0bGUnICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gbWF0Y2ggYnkgY29sdW1uIHRpdGxlXG5cdFx0XHRcdFx0cmV0dXJuIHRpdGxlcy5tYXAoIGZ1bmN0aW9uICh0aXRsZSwgaSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRpdGxlID09PSBtYXRjaFsxXSA/IGkgOiBudWxsO1xuXHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDZWxsIGluIHRoZSB0YWJsZSBib2R5XG5cdFx0aWYgKCBzLm5vZGVOYW1lICYmIHMuX0RUX0NlbGxJbmRleCApIHtcblx0XHRcdHJldHVybiBbIHMuX0RUX0NlbGxJbmRleC5jb2x1bW4gXTtcblx0XHR9XG5cblx0XHQvLyBqUXVlcnkgc2VsZWN0b3Igb24gdGhlIFRIIGVsZW1lbnRzIGZvciB0aGUgY29sdW1uc1xuXHRcdHZhciBqcVJlc3VsdCA9ICQoIG5vZGVzIClcblx0XHRcdC5maWx0ZXIoIHMgKVxuXHRcdFx0Lm1hcCggZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gX2ZuQ29sdW1uc0Zyb21IZWFkZXIoIHRoaXMgKTsgLy8gYG5vZGVzYCBpcyBjb2x1bW4gaW5kZXggY29tcGxldGUgYW5kIGluIG9yZGVyXG5cdFx0XHR9IClcblx0XHRcdC50b0FycmF5KClcblx0XHRcdC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG5cdFx0XHRcdHJldHVybiBhIC0gYjtcblx0XHRcdH0pO1xuXG5cdFx0aWYgKCBqcVJlc3VsdC5sZW5ndGggfHwgISBzLm5vZGVOYW1lICkge1xuXHRcdFx0cmV0dXJuIGpxUmVzdWx0O1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSBhIG5vZGUgd2hpY2ggbWlnaHQgaGF2ZSBhIGBkdC1jb2x1bW5gIGRhdGEgYXR0cmlidXRlLCBvciBiZVxuXHRcdC8vIGEgY2hpbGQgb3Igc3VjaCBhbiBlbGVtZW50XG5cdFx0dmFyIGhvc3QgPSAkKHMpLmNsb3Nlc3QoJypbZGF0YS1kdC1jb2x1bW5dJyk7XG5cdFx0cmV0dXJuIGhvc3QubGVuZ3RoID9cblx0XHRcdFsgaG9zdC5kYXRhKCdkdC1jb2x1bW4nKSBdIDpcblx0XHRcdFtdO1xuXHR9O1xuXG5cdHZhciBzZWxlY3RlZCA9IF9zZWxlY3Rvcl9ydW4oICdjb2x1bW4nLCBzZWxlY3RvciwgcnVuLCBzZXR0aW5ncywgb3B0cyApO1xuXG5cdHJldHVybiBvcHRzLmNvbHVtbk9yZGVyICYmIG9wdHMuY29sdW1uT3JkZXIgPT09ICdpbmRleCdcblx0XHQ/IHNlbGVjdGVkLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgLSBiOyB9KVxuXHRcdDogc2VsZWN0ZWQ7IC8vIGltcGxpZWRcbn07XG5cblxudmFyIF9fc2V0Q29sdW1uVmlzID0gZnVuY3Rpb24gKCBzZXR0aW5ncywgY29sdW1uLCB2aXMgKSB7XG5cdHZhclxuXHRcdGNvbHMgPSBzZXR0aW5ncy5hb0NvbHVtbnMsXG5cdFx0Y29sICA9IGNvbHNbIGNvbHVtbiBdLFxuXHRcdGRhdGEgPSBzZXR0aW5ncy5hb0RhdGEsXG5cdFx0Y2VsbHMsIGksIGllbiwgdHI7XG5cblx0Ly8gR2V0XG5cdGlmICggdmlzID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cmV0dXJuIGNvbC5iVmlzaWJsZTtcblx0fVxuXG5cdC8vIFNldFxuXHQvLyBObyBjaGFuZ2Vcblx0aWYgKCBjb2wuYlZpc2libGUgPT09IHZpcyApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRpZiAoIHZpcyApIHtcblx0XHQvLyBJbnNlcnQgY29sdW1uXG5cdFx0Ly8gTmVlZCB0byBkZWNpZGUgaWYgd2Ugc2hvdWxkIHVzZSBhcHBlbmRDaGlsZCBvciBpbnNlcnRCZWZvcmVcblx0XHR2YXIgaW5zZXJ0QmVmb3JlID0gX3BsdWNrKGNvbHMsICdiVmlzaWJsZScpLmluZGV4T2YodHJ1ZSwgY29sdW1uKzEpO1xuXG5cdFx0Zm9yICggaT0wLCBpZW49ZGF0YS5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdGlmIChkYXRhW2ldKSB7XG5cdFx0XHRcdHRyID0gZGF0YVtpXS5uVHI7XG5cdFx0XHRcdGNlbGxzID0gZGF0YVtpXS5hbkNlbGxzO1xuXG5cdFx0XHRcdGlmICggdHIgKSB7XG5cdFx0XHRcdFx0Ly8gaW5zZXJ0QmVmb3JlIGNhbiBhY3QgbGlrZSBhcHBlbmRDaGlsZCBpZiAybmQgYXJnIGlzIG51bGxcblx0XHRcdFx0XHR0ci5pbnNlcnRCZWZvcmUoIGNlbGxzWyBjb2x1bW4gXSwgY2VsbHNbIGluc2VydEJlZm9yZSBdIHx8IG51bGwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRlbHNlIHtcblx0XHQvLyBSZW1vdmUgY29sdW1uXG5cdFx0JCggX3BsdWNrKCBzZXR0aW5ncy5hb0RhdGEsICdhbkNlbGxzJywgY29sdW1uICkgKS5kZXRhY2goKTtcblx0fVxuXG5cdC8vIENvbW1vbiBhY3Rpb25zXG5cdGNvbC5iVmlzaWJsZSA9IHZpcztcblxuXHRfY29sR3JvdXAoc2V0dGluZ3MpO1xuXHRcblx0cmV0dXJuIHRydWU7XG59O1xuXG5cbl9hcGlfcmVnaXN0ZXIoICdjb2x1bW5zKCknLCBmdW5jdGlvbiAoIHNlbGVjdG9yLCBvcHRzICkge1xuXHQvLyBhcmd1bWVudCBzaGlmdGluZ1xuXHRpZiAoIHNlbGVjdG9yID09PSB1bmRlZmluZWQgKSB7XG5cdFx0c2VsZWN0b3IgPSAnJztcblx0fVxuXHRlbHNlIGlmICggJC5pc1BsYWluT2JqZWN0KCBzZWxlY3RvciApICkge1xuXHRcdG9wdHMgPSBzZWxlY3Rvcjtcblx0XHRzZWxlY3RvciA9ICcnO1xuXHR9XG5cblx0b3B0cyA9IF9zZWxlY3Rvcl9vcHRzKCBvcHRzICk7XG5cblx0dmFyIGluc3QgPSB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdHJldHVybiBfX2NvbHVtbl9zZWxlY3Rvciggc2V0dGluZ3MsIHNlbGVjdG9yLCBvcHRzICk7XG5cdH0sIDEgKTtcblxuXHQvLyBXYW50IGFyZ3VtZW50IHNoaWZ0aW5nIGhlcmUgYW5kIGluIF9yb3dfc2VsZWN0b3I/XG5cdGluc3Quc2VsZWN0b3IuY29scyA9IHNlbGVjdG9yO1xuXHRpbnN0LnNlbGVjdG9yLm9wdHMgPSBvcHRzO1xuXG5cdHJldHVybiBpbnN0O1xufSApO1xuXG5fYXBpX3JlZ2lzdGVyUGx1cmFsKCAnY29sdW1ucygpLmhlYWRlcigpJywgJ2NvbHVtbigpLmhlYWRlcigpJywgZnVuY3Rpb24gKCByb3cgKSB7XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY29sdW1uJywgZnVuY3Rpb24gKHNldHRpbmdzLCBjb2x1bW4pIHtcblx0XHRyZXR1cm4gX19jb2x1bW5faGVhZGVyKHNldHRpbmdzLCBjb2x1bW4sIHJvdyk7XG5cdH0sIDEgKTtcbn0gKTtcblxuX2FwaV9yZWdpc3RlclBsdXJhbCggJ2NvbHVtbnMoKS5mb290ZXIoKScsICdjb2x1bW4oKS5mb290ZXIoKScsIGZ1bmN0aW9uICggcm93ICkge1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ2NvbHVtbicsIGZ1bmN0aW9uICggc2V0dGluZ3MsIGNvbHVtbiApIHtcblx0XHR2YXIgZm9vdGVyID0gc2V0dGluZ3MuYW9Gb290ZXI7XG5cblx0XHRpZiAoISBmb290ZXIubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRyZXR1cm4gc2V0dGluZ3MuYW9Gb290ZXJbcm93ICE9PSB1bmRlZmluZWQgPyByb3cgOiAwXVtjb2x1bW5dLmNlbGw7XG5cdH0sIDEgKTtcbn0gKTtcblxuX2FwaV9yZWdpc3RlclBsdXJhbCggJ2NvbHVtbnMoKS5kYXRhKCknLCAnY29sdW1uKCkuZGF0YSgpJywgZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ2NvbHVtbi1yb3dzJywgX19jb2x1bW5EYXRhLCAxICk7XG59ICk7XG5cbl9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjb2x1bW5zKCkucmVuZGVyKCknLCAnY29sdW1uKCkucmVuZGVyKCknLCBmdW5jdGlvbiAoIHR5cGUgKSB7XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY29sdW1uLXJvd3MnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb2x1bW4sIGksIGosIHJvd3MgKSB7XG5cdFx0cmV0dXJuIF9fY29sdW1uRGF0YSggc2V0dGluZ3MsIGNvbHVtbiwgaSwgaiwgcm93cywgdHlwZSApO1xuXHR9LCAxICk7XG59ICk7XG5cbl9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjb2x1bW5zKCkuZGF0YVNyYygpJywgJ2NvbHVtbigpLmRhdGFTcmMoKScsIGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjb2x1bW4nLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb2x1bW4gKSB7XG5cdFx0cmV0dXJuIHNldHRpbmdzLmFvQ29sdW1uc1tjb2x1bW5dLm1EYXRhO1xuXHR9LCAxICk7XG59ICk7XG5cbl9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjb2x1bW5zKCkuY2FjaGUoKScsICdjb2x1bW4oKS5jYWNoZSgpJywgZnVuY3Rpb24gKCB0eXBlICkge1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ2NvbHVtbi1yb3dzJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgY29sdW1uLCBpLCBqLCByb3dzICkge1xuXHRcdHJldHVybiBfcGx1Y2tfb3JkZXIoIHNldHRpbmdzLmFvRGF0YSwgcm93cyxcblx0XHRcdHR5cGUgPT09ICdzZWFyY2gnID8gJ19hRmlsdGVyRGF0YScgOiAnX2FTb3J0RGF0YScsIGNvbHVtblxuXHRcdCk7XG5cdH0sIDEgKTtcbn0gKTtcblxuX2FwaV9yZWdpc3RlclBsdXJhbCggJ2NvbHVtbnMoKS5pbml0KCknLCAnY29sdW1uKCkuaW5pdCgpJywgZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ2NvbHVtbicsIGZ1bmN0aW9uICggc2V0dGluZ3MsIGNvbHVtbiApIHtcblx0XHRyZXR1cm4gc2V0dGluZ3MuYW9Db2x1bW5zW2NvbHVtbl07XG5cdH0sIDEgKTtcbn0gKTtcblxuX2FwaV9yZWdpc3RlclBsdXJhbCggJ2NvbHVtbnMoKS5uYW1lcygpJywgJ2NvbHVtbigpLm5hbWUoKScsIGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjb2x1bW4nLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb2x1bW4gKSB7XG5cdFx0cmV0dXJuIHNldHRpbmdzLmFvQ29sdW1uc1tjb2x1bW5dLnNOYW1lO1xuXHR9LCAxICk7XG59ICk7XG5cbl9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjb2x1bW5zKCkubm9kZXMoKScsICdjb2x1bW4oKS5ub2RlcygpJywgZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ2NvbHVtbi1yb3dzJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgY29sdW1uLCBpLCBqLCByb3dzICkge1xuXHRcdHJldHVybiBfcGx1Y2tfb3JkZXIoIHNldHRpbmdzLmFvRGF0YSwgcm93cywgJ2FuQ2VsbHMnLCBjb2x1bW4gKSA7XG5cdH0sIDEgKTtcbn0gKTtcblxuX2FwaV9yZWdpc3RlclBsdXJhbCggJ2NvbHVtbnMoKS50aXRsZXMoKScsICdjb2x1bW4oKS50aXRsZSgpJywgZnVuY3Rpb24gKHRpdGxlLCByb3cpIHtcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjb2x1bW4nLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb2x1bW4gKSB7XG5cdFx0Ly8gQXJndW1lbnQgc2hpZnRpbmdcblx0XHRpZiAodHlwZW9mIHRpdGxlID09PSAnbnVtYmVyJykge1xuXHRcdFx0cm93ID0gdGl0bGU7XG5cdFx0XHR0aXRsZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHR2YXIgc3BhbiA9ICQoJ3NwYW4uZHQtY29sdW1uLXRpdGxlJywgdGhpcy5jb2x1bW4oY29sdW1uKS5oZWFkZXIocm93KSk7XG5cblx0XHRpZiAodGl0bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0c3Bhbi5odG1sKHRpdGxlKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdHJldHVybiBzcGFuLmh0bWwoKTtcblx0fSwgMSApO1xufSApO1xuXG5fYXBpX3JlZ2lzdGVyUGx1cmFsKCAnY29sdW1ucygpLnR5cGVzKCknLCAnY29sdW1uKCkudHlwZSgpJywgZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ2NvbHVtbicsIGZ1bmN0aW9uICggc2V0dGluZ3MsIGNvbHVtbiApIHtcblx0XHR2YXIgdHlwZSA9IHNldHRpbmdzLmFvQ29sdW1uc1tjb2x1bW5dLnNUeXBlO1xuXG5cdFx0Ly8gSWYgdGhlIHR5cGUgd2FzIGludmFsaWRhdGVkLCB0aGVuIHJlc29sdmUgaXQuIFRoaXMgYWN0dWFsbHkgZG9lc1xuXHRcdC8vIGFsbCBjb2x1bW5zIGF0IHRoZSBtb21lbnQuIFdvdWxkIG9ubHkgaGFwcGVuIG9uY2UgaWYgZ2V0dGluZyBhbGxcblx0XHQvLyBjb2x1bW4ncyBkYXRhIHR5cGVzLlxuXHRcdGlmICghIHR5cGUpIHtcblx0XHRcdF9mbkNvbHVtblR5cGVzKHNldHRpbmdzKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHlwZTtcblx0fSwgMSApO1xufSApO1xuXG5fYXBpX3JlZ2lzdGVyUGx1cmFsKCAnY29sdW1ucygpLnZpc2libGUoKScsICdjb2x1bW4oKS52aXNpYmxlKCknLCBmdW5jdGlvbiAoIHZpcywgY2FsYyApIHtcblx0dmFyIHRoYXQgPSB0aGlzO1xuXHR2YXIgY2hhbmdlZCA9IFtdO1xuXHR2YXIgcmV0ID0gdGhpcy5pdGVyYXRvciggJ2NvbHVtbicsIGZ1bmN0aW9uICggc2V0dGluZ3MsIGNvbHVtbiApIHtcblx0XHRpZiAoIHZpcyA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuIHNldHRpbmdzLmFvQ29sdW1uc1sgY29sdW1uIF0uYlZpc2libGU7XG5cdFx0fSAvLyBlbHNlXG5cdFx0XG5cdFx0aWYgKF9fc2V0Q29sdW1uVmlzKCBzZXR0aW5ncywgY29sdW1uLCB2aXMgKSkge1xuXHRcdFx0Y2hhbmdlZC5wdXNoKGNvbHVtbik7XG5cdFx0fVxuXHR9ICk7XG5cblx0Ly8gR3JvdXAgdGhlIGNvbHVtbiB2aXNpYmlsaXR5IGNoYW5nZXNcblx0aWYgKCB2aXMgIT09IHVuZGVmaW5lZCApIHtcblx0XHR0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdFx0Ly8gUmVkcmF3IHRoZSBoZWFkZXIgYWZ0ZXIgY2hhbmdlc1xuXHRcdFx0X2ZuRHJhd0hlYWQoIHNldHRpbmdzLCBzZXR0aW5ncy5hb0hlYWRlciApO1xuXHRcdFx0X2ZuRHJhd0hlYWQoIHNldHRpbmdzLCBzZXR0aW5ncy5hb0Zvb3RlciApO1xuXHRcblx0XHRcdC8vIFVwZGF0ZSBjb2xzcGFuIGZvciBubyByZWNvcmRzIGRpc3BsYXkuIENoaWxkIHJvd3MgYW5kIGV4dGVuc2lvbnMgd2lsbCB1c2UgdGhlaXIgb3duXG5cdFx0XHQvLyBsaXN0ZW5lcnMgdG8gZG8gdGhpcyAtIG9ubHkgbmVlZCB0byB1cGRhdGUgdGhlIGVtcHR5IHRhYmxlIGl0ZW0gaGVyZVxuXHRcdFx0aWYgKCAhIHNldHRpbmdzLmFpRGlzcGxheS5sZW5ndGggKSB7XG5cdFx0XHRcdCQoc2V0dGluZ3MublRCb2R5KS5maW5kKCd0ZFtjb2xzcGFuXScpLmF0dHIoJ2NvbHNwYW4nLCBfZm5WaXNibGVDb2x1bW5zKHNldHRpbmdzKSk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0X2ZuU2F2ZVN0YXRlKCBzZXR0aW5ncyApO1xuXG5cdFx0XHQvLyBTZWNvbmQgbG9vcCBvbmNlIHRoZSBmaXJzdCBpcyBkb25lIGZvciBldmVudHNcblx0XHRcdHRoYXQuaXRlcmF0b3IoICdjb2x1bW4nLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb2x1bW4gKSB7XG5cdFx0XHRcdGlmIChjaGFuZ2VkLmluY2x1ZGVzKGNvbHVtbikpIHtcblx0XHRcdFx0XHRfZm5DYWxsYmFja0ZpcmUoIHNldHRpbmdzLCBudWxsLCAnY29sdW1uLXZpc2liaWxpdHknLCBbc2V0dGluZ3MsIGNvbHVtbiwgdmlzLCBjYWxjXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cblx0XHRcdGlmICggY2hhbmdlZC5sZW5ndGggJiYgKGNhbGMgPT09IHVuZGVmaW5lZCB8fCBjYWxjKSApIHtcblx0XHRcdFx0dGhhdC5jb2x1bW5zLmFkanVzdCgpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn0gKTtcblxuX2FwaV9yZWdpc3RlclBsdXJhbCggJ2NvbHVtbnMoKS53aWR0aHMoKScsICdjb2x1bW4oKS53aWR0aCgpJywgZnVuY3Rpb24gKCkge1xuXHQvLyBJbmplY3RzIGEgZmFrZSByb3cgaW50byB0aGUgdGFibGUgZm9yIGp1c3QgYSBtb21lbnQgc28gdGhlIHdpZHRocyBjYW5cblx0Ly8gYmUgcmVhZCwgcmVnYXJkbGVzcyBvZiBjb2xzcGFuIGluIHRoZSBoZWFkZXIgYW5kIHJvd3MgYmVpbmcgcHJlc2VudCBpblxuXHQvLyB0aGUgYm9keVxuXHR2YXIgY29sdW1ucyA9IHRoaXMuY29sdW1ucygnOnZpc2libGUnKS5jb3VudCgpO1xuXHR2YXIgcm93ID0gJCgnPHRyPicpLmh0bWwoJzx0ZD4nICsgQXJyYXkoY29sdW1ucykuam9pbignPC90ZD48dGQ+JykgKyAnPC90ZD4nKTtcblxuXHQkKHRoaXMudGFibGUoKS5ib2R5KCkpLmFwcGVuZChyb3cpO1xuXG5cdHZhciB3aWR0aHMgPSByb3cuY2hpbGRyZW4oKS5tYXAoZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAkKHRoaXMpLm91dGVyV2lkdGgoKTtcblx0fSk7XG5cblx0cm93LnJlbW92ZSgpO1xuXHRcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjb2x1bW4nLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb2x1bW4gKSB7XG5cdFx0dmFyIHZpc0lkeCA9IF9mbkNvbHVtbkluZGV4VG9WaXNpYmxlKCBzZXR0aW5ncywgY29sdW1uICk7XG5cblx0XHRyZXR1cm4gdmlzSWR4ICE9PSBudWxsID8gd2lkdGhzW3Zpc0lkeF0gOiAwO1xuXHR9LCAxKTtcbn0gKTtcblxuX2FwaV9yZWdpc3RlclBsdXJhbCggJ2NvbHVtbnMoKS5pbmRleGVzKCknLCAnY29sdW1uKCkuaW5kZXgoKScsIGZ1bmN0aW9uICggdHlwZSApIHtcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjb2x1bW4nLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb2x1bW4gKSB7XG5cdFx0cmV0dXJuIHR5cGUgPT09ICd2aXNpYmxlJyA/XG5cdFx0XHRfZm5Db2x1bW5JbmRleFRvVmlzaWJsZSggc2V0dGluZ3MsIGNvbHVtbiApIDpcblx0XHRcdGNvbHVtbjtcblx0fSwgMSApO1xufSApO1xuXG5fYXBpX3JlZ2lzdGVyKCAnY29sdW1ucy5hZGp1c3QoKScsIGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0Ly8gRm9yY2UgYSBjb2x1bW4gc2l6aW5nIHRvIGhhcHBlbiB3aXRoIGEgbWFudWFsIGNhbGwgLSBvdGhlcndpc2UgaXQgY2FuIHNraXBcblx0XHQvLyBpZiB0aGUgc2l6ZSBoYXNuJ3QgY2hhbmdlZFxuXHRcdHNldHRpbmdzLmNvbnRhaW5lcldpZHRoID0gLTE7XG5cblx0XHRfZm5BZGp1c3RDb2x1bW5TaXppbmcoIHNldHRpbmdzICk7XG5cdH0sIDEgKTtcbn0gKTtcblxuX2FwaV9yZWdpc3RlciggJ2NvbHVtbi5pbmRleCgpJywgZnVuY3Rpb24gKCB0eXBlLCBpZHggKSB7XG5cdGlmICggdGhpcy5jb250ZXh0Lmxlbmd0aCAhPT0gMCApIHtcblx0XHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0WzBdO1xuXG5cdFx0aWYgKCB0eXBlID09PSAnZnJvbVZpc2libGUnIHx8IHR5cGUgPT09ICd0b0RhdGEnICkge1xuXHRcdFx0cmV0dXJuIF9mblZpc2libGVUb0NvbHVtbkluZGV4KCBjdHgsIGlkeCApO1xuXHRcdH1cblx0XHRlbHNlIGlmICggdHlwZSA9PT0gJ2Zyb21EYXRhJyB8fCB0eXBlID09PSAndG9WaXNpYmxlJyApIHtcblx0XHRcdHJldHVybiBfZm5Db2x1bW5JbmRleFRvVmlzaWJsZSggY3R4LCBpZHggKTtcblx0XHR9XG5cdH1cbn0gKTtcblxuX2FwaV9yZWdpc3RlciggJ2NvbHVtbigpJywgZnVuY3Rpb24gKCBzZWxlY3Rvciwgb3B0cyApIHtcblx0cmV0dXJuIF9zZWxlY3Rvcl9maXJzdCggdGhpcy5jb2x1bW5zKCBzZWxlY3Rvciwgb3B0cyApICk7XG59ICk7XG5cbnZhciBfX2NlbGxfc2VsZWN0b3IgPSBmdW5jdGlvbiAoIHNldHRpbmdzLCBzZWxlY3Rvciwgb3B0cyApXG57XG5cdHZhciBkYXRhID0gc2V0dGluZ3MuYW9EYXRhO1xuXHR2YXIgcm93cyA9IF9zZWxlY3Rvcl9yb3dfaW5kZXhlcyggc2V0dGluZ3MsIG9wdHMgKTtcblx0dmFyIGNlbGxzID0gX3JlbW92ZUVtcHR5KCBfcGx1Y2tfb3JkZXIoIGRhdGEsIHJvd3MsICdhbkNlbGxzJyApICk7XG5cdHZhciBhbGxDZWxscyA9ICQoX2ZsYXR0ZW4oIFtdLCBjZWxscyApKTtcblx0dmFyIHJvdztcblx0dmFyIGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnMubGVuZ3RoO1xuXHR2YXIgYSwgaSwgaWVuLCBqLCBvLCBob3N0O1xuXG5cdHZhciBydW4gPSBmdW5jdGlvbiAoIHMgKSB7XG5cdFx0dmFyIGZuU2VsZWN0b3IgPSB0eXBlb2YgcyA9PT0gJ2Z1bmN0aW9uJztcblxuXHRcdGlmICggcyA9PT0gbnVsbCB8fCBzID09PSB1bmRlZmluZWQgfHwgZm5TZWxlY3RvciApIHtcblx0XHRcdC8vIEFsbCBjZWxscyBhbmQgZnVuY3Rpb24gc2VsZWN0b3JzXG5cdFx0XHRhID0gW107XG5cblx0XHRcdGZvciAoIGk9MCwgaWVuPXJvd3MubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdHJvdyA9IHJvd3NbaV07XG5cblx0XHRcdFx0Zm9yICggaj0wIDsgajxjb2x1bW5zIDsgaisrICkge1xuXHRcdFx0XHRcdG8gPSB7XG5cdFx0XHRcdFx0XHRyb3c6IHJvdyxcblx0XHRcdFx0XHRcdGNvbHVtbjogalxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRpZiAoIGZuU2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHQvLyBTZWxlY3RvciAtIGZ1bmN0aW9uXG5cdFx0XHRcdFx0XHRob3N0ID0gZGF0YVsgcm93IF07XG5cblx0XHRcdFx0XHRcdGlmICggcyggbywgX2ZuR2V0Q2VsbERhdGEoc2V0dGluZ3MsIHJvdywgaiksIGhvc3QuYW5DZWxscyA/IGhvc3QuYW5DZWxsc1tqXSA6IG51bGwgKSApIHtcblx0XHRcdFx0XHRcdFx0YS5wdXNoKCBvICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gU2VsZWN0b3IgLSBhbGxcblx0XHRcdFx0XHRcdGEucHVzaCggbyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYTtcblx0XHR9XG5cdFx0XG5cdFx0Ly8gU2VsZWN0b3IgLSBpbmRleFxuXHRcdGlmICggJC5pc1BsYWluT2JqZWN0KCBzICkgKSB7XG5cdFx0XHQvLyBWYWxpZCBjZWxsIGluZGV4IGFuZCBpdHMgaW4gdGhlIGFycmF5IG9mIHNlbGVjdGFibGUgcm93c1xuXHRcdFx0cmV0dXJuIHMuY29sdW1uICE9PSB1bmRlZmluZWQgJiYgcy5yb3cgIT09IHVuZGVmaW5lZCAmJiByb3dzLmluZGV4T2Yocy5yb3cpICE9PSAtMSA/XG5cdFx0XHRcdFtzXSA6XG5cdFx0XHRcdFtdO1xuXHRcdH1cblxuXHRcdC8vIFNlbGVjdG9yIC0galF1ZXJ5IGZpbHRlcmVkIGNlbGxzXG5cdFx0dmFyIGpxUmVzdWx0ID0gYWxsQ2VsbHNcblx0XHRcdC5maWx0ZXIoIHMgKVxuXHRcdFx0Lm1hcCggZnVuY3Rpb24gKGksIGVsKSB7XG5cdFx0XHRcdHJldHVybiB7IC8vIHVzZSBhIG5ldyBvYmplY3QsIGluIGNhc2Ugc29tZW9uZSBjaGFuZ2VzIHRoZSB2YWx1ZXNcblx0XHRcdFx0XHRyb3c6ICAgIGVsLl9EVF9DZWxsSW5kZXgucm93LFxuXHRcdFx0XHRcdGNvbHVtbjogZWwuX0RUX0NlbGxJbmRleC5jb2x1bW5cblx0XHRcdFx0fTtcblx0XHRcdH0gKVxuXHRcdFx0LnRvQXJyYXkoKTtcblxuXHRcdGlmICgganFSZXN1bHQubGVuZ3RoIHx8ICEgcy5ub2RlTmFtZSApIHtcblx0XHRcdHJldHVybiBqcVJlc3VsdDtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2UgdGhlIHNlbGVjdG9yIGlzIGEgbm9kZSwgYW5kIHRoZXJlIGlzIG9uZSBsYXN0IG9wdGlvbiAtIHRoZVxuXHRcdC8vIGVsZW1lbnQgbWlnaHQgYmUgYSBjaGlsZCBvZiBhbiBlbGVtZW50IHdoaWNoIGhhcyBkdC1yb3cgYW5kIGR0LWNvbHVtblxuXHRcdC8vIGRhdGEgYXR0cmlidXRlc1xuXHRcdGhvc3QgPSAkKHMpLmNsb3Nlc3QoJypbZGF0YS1kdC1yb3ddJyk7XG5cdFx0cmV0dXJuIGhvc3QubGVuZ3RoID9cblx0XHRcdFsge1xuXHRcdFx0XHRyb3c6IGhvc3QuZGF0YSgnZHQtcm93JyksXG5cdFx0XHRcdGNvbHVtbjogaG9zdC5kYXRhKCdkdC1jb2x1bW4nKVxuXHRcdFx0fSBdIDpcblx0XHRcdFtdO1xuXHR9O1xuXG5cdHJldHVybiBfc2VsZWN0b3JfcnVuKCAnY2VsbCcsIHNlbGVjdG9yLCBydW4sIHNldHRpbmdzLCBvcHRzICk7XG59O1xuXG5cblxuXG5fYXBpX3JlZ2lzdGVyKCAnY2VsbHMoKScsIGZ1bmN0aW9uICggcm93U2VsZWN0b3IsIGNvbHVtblNlbGVjdG9yLCBvcHRzICkge1xuXHQvLyBBcmd1bWVudCBzaGlmdGluZ1xuXHRpZiAoICQuaXNQbGFpbk9iamVjdCggcm93U2VsZWN0b3IgKSApIHtcblx0XHQvLyBJbmRleGVzXG5cdFx0aWYgKCByb3dTZWxlY3Rvci5yb3cgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdC8vIFNlbGVjdG9yIG9wdGlvbnMgaW4gZmlyc3QgcGFyYW1ldGVyXG5cdFx0XHRvcHRzID0gcm93U2VsZWN0b3I7XG5cdFx0XHRyb3dTZWxlY3RvciA9IG51bGw7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gQ2VsbCBpbmRleCBvYmplY3RzIGluIGZpcnN0IHBhcmFtZXRlclxuXHRcdFx0b3B0cyA9IGNvbHVtblNlbGVjdG9yO1xuXHRcdFx0Y29sdW1uU2VsZWN0b3IgPSBudWxsO1xuXHRcdH1cblx0fVxuXHRpZiAoICQuaXNQbGFpbk9iamVjdCggY29sdW1uU2VsZWN0b3IgKSApIHtcblx0XHRvcHRzID0gY29sdW1uU2VsZWN0b3I7XG5cdFx0Y29sdW1uU2VsZWN0b3IgPSBudWxsO1xuXHR9XG5cblx0Ly8gQ2VsbCBzZWxlY3RvclxuXHRpZiAoIGNvbHVtblNlbGVjdG9yID09PSBudWxsIHx8IGNvbHVtblNlbGVjdG9yID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0XHRyZXR1cm4gX19jZWxsX3NlbGVjdG9yKCBzZXR0aW5ncywgcm93U2VsZWN0b3IsIF9zZWxlY3Rvcl9vcHRzKCBvcHRzICkgKTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBUaGUgZGVmYXVsdCBidWlsdCBpbiBvcHRpb25zIG5lZWQgdG8gYXBwbHkgdG8gcm93IGFuZCBjb2x1bW5zXG5cdHZhciBpbnRlcm5hbE9wdHMgPSBvcHRzID8ge1xuXHRcdHBhZ2U6IG9wdHMucGFnZSxcblx0XHRvcmRlcjogb3B0cy5vcmRlcixcblx0XHRzZWFyY2g6IG9wdHMuc2VhcmNoXG5cdH0gOiB7fTtcblxuXHQvLyBSb3cgKyBjb2x1bW4gc2VsZWN0b3Jcblx0dmFyIGNvbHVtbnMgPSB0aGlzLmNvbHVtbnMoIGNvbHVtblNlbGVjdG9yLCBpbnRlcm5hbE9wdHMgKTtcblx0dmFyIHJvd3MgPSB0aGlzLnJvd3MoIHJvd1NlbGVjdG9yLCBpbnRlcm5hbE9wdHMgKTtcblx0dmFyIGksIGllbiwgaiwgamVuO1xuXG5cdHZhciBjZWxsc05vT3B0cyA9IHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MsIGlkeCApIHtcblx0XHR2YXIgYSA9IFtdO1xuXG5cdFx0Zm9yICggaT0wLCBpZW49cm93c1tpZHhdLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0Zm9yICggaj0wLCBqZW49Y29sdW1uc1tpZHhdLmxlbmd0aCA7IGo8amVuIDsgaisrICkge1xuXHRcdFx0XHRhLnB1c2goIHtcblx0XHRcdFx0XHRyb3c6ICAgIHJvd3NbaWR4XVtpXSxcblx0XHRcdFx0XHRjb2x1bW46IGNvbHVtbnNbaWR4XVtqXVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGE7XG5cdH0sIDEgKTtcblxuXHQvLyBUaGVyZSBpcyBjdXJyZW50bHkgb25seSBvbmUgZXh0ZW5zaW9uIHdoaWNoIHVzZXMgYSBjZWxsIHNlbGVjdG9yIGV4dGVuc2lvblxuXHQvLyBJdCBpcyBhIF9tYWpvcl8gcGVyZm9ybWFuY2UgZHJhZyB0byBydW4gdGhpcyBpZiBpdCBpc24ndCBuZWVkZWQsIHNvIHRoaXMgaXNcblx0Ly8gYW4gZXh0ZW5zaW9uIHNwZWNpZmljIGNoZWNrIGF0IHRoZSBtb21lbnRcblx0dmFyIGNlbGxzID0gb3B0cyAmJiBvcHRzLnNlbGVjdGVkID9cblx0XHR0aGlzLmNlbGxzKCBjZWxsc05vT3B0cywgb3B0cyApIDpcblx0XHRjZWxsc05vT3B0cztcblxuXHQkLmV4dGVuZCggY2VsbHMuc2VsZWN0b3IsIHtcblx0XHRjb2xzOiBjb2x1bW5TZWxlY3Rvcixcblx0XHRyb3dzOiByb3dTZWxlY3Rvcixcblx0XHRvcHRzOiBvcHRzXG5cdH0gKTtcblxuXHRyZXR1cm4gY2VsbHM7XG59ICk7XG5cblxuX2FwaV9yZWdpc3RlclBsdXJhbCggJ2NlbGxzKCkubm9kZXMoKScsICdjZWxsKCkubm9kZSgpJywgZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ2NlbGwnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCByb3csIGNvbHVtbiApIHtcblx0XHR2YXIgZGF0YSA9IHNldHRpbmdzLmFvRGF0YVsgcm93IF07XG5cblx0XHRyZXR1cm4gZGF0YSAmJiBkYXRhLmFuQ2VsbHMgP1xuXHRcdFx0ZGF0YS5hbkNlbGxzWyBjb2x1bW4gXSA6XG5cdFx0XHR1bmRlZmluZWQ7XG5cdH0sIDEgKTtcbn0gKTtcblxuXG5fYXBpX3JlZ2lzdGVyKCAnY2VsbHMoKS5kYXRhKCknLCBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY2VsbCcsIGZ1bmN0aW9uICggc2V0dGluZ3MsIHJvdywgY29sdW1uICkge1xuXHRcdHJldHVybiBfZm5HZXRDZWxsRGF0YSggc2V0dGluZ3MsIHJvdywgY29sdW1uICk7XG5cdH0sIDEgKTtcbn0gKTtcblxuXG5fYXBpX3JlZ2lzdGVyUGx1cmFsKCAnY2VsbHMoKS5jYWNoZSgpJywgJ2NlbGwoKS5jYWNoZSgpJywgZnVuY3Rpb24gKCB0eXBlICkge1xuXHR0eXBlID0gdHlwZSA9PT0gJ3NlYXJjaCcgPyAnX2FGaWx0ZXJEYXRhJyA6ICdfYVNvcnREYXRhJztcblxuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ2NlbGwnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCByb3csIGNvbHVtbiApIHtcblx0XHRyZXR1cm4gc2V0dGluZ3MuYW9EYXRhWyByb3cgXVsgdHlwZSBdWyBjb2x1bW4gXTtcblx0fSwgMSApO1xufSApO1xuXG5cbl9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjZWxscygpLnJlbmRlcigpJywgJ2NlbGwoKS5yZW5kZXIoKScsIGZ1bmN0aW9uICggdHlwZSApIHtcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjZWxsJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgcm93LCBjb2x1bW4gKSB7XG5cdFx0cmV0dXJuIF9mbkdldENlbGxEYXRhKCBzZXR0aW5ncywgcm93LCBjb2x1bW4sIHR5cGUgKTtcblx0fSwgMSApO1xufSApO1xuXG5cbl9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjZWxscygpLmluZGV4ZXMoKScsICdjZWxsKCkuaW5kZXgoKScsIGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjZWxsJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgcm93LCBjb2x1bW4gKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHJvdzogcm93LFxuXHRcdFx0Y29sdW1uOiBjb2x1bW4sXG5cdFx0XHRjb2x1bW5WaXNpYmxlOiBfZm5Db2x1bW5JbmRleFRvVmlzaWJsZSggc2V0dGluZ3MsIGNvbHVtbiApXG5cdFx0fTtcblx0fSwgMSApO1xufSApO1xuXG5cbl9hcGlfcmVnaXN0ZXJQbHVyYWwoICdjZWxscygpLmludmFsaWRhdGUoKScsICdjZWxsKCkuaW52YWxpZGF0ZSgpJywgZnVuY3Rpb24gKCBzcmMgKSB7XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY2VsbCcsIGZ1bmN0aW9uICggc2V0dGluZ3MsIHJvdywgY29sdW1uICkge1xuXHRcdF9mbkludmFsaWRhdGUoIHNldHRpbmdzLCByb3csIHNyYywgY29sdW1uICk7XG5cdH0gKTtcbn0gKTtcblxuXG5cbl9hcGlfcmVnaXN0ZXIoICdjZWxsKCknLCBmdW5jdGlvbiAoIHJvd1NlbGVjdG9yLCBjb2x1bW5TZWxlY3Rvciwgb3B0cyApIHtcblx0cmV0dXJuIF9zZWxlY3Rvcl9maXJzdCggdGhpcy5jZWxscyggcm93U2VsZWN0b3IsIGNvbHVtblNlbGVjdG9yLCBvcHRzICkgKTtcbn0gKTtcblxuXG5fYXBpX3JlZ2lzdGVyKCAnY2VsbCgpLmRhdGEoKScsIGZ1bmN0aW9uICggZGF0YSApIHtcblx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblx0dmFyIGNlbGwgPSB0aGlzWzBdO1xuXG5cdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdC8vIEdldFxuXHRcdHJldHVybiBjdHgubGVuZ3RoICYmIGNlbGwubGVuZ3RoID9cblx0XHRcdF9mbkdldENlbGxEYXRhKCBjdHhbMF0sIGNlbGxbMF0ucm93LCBjZWxsWzBdLmNvbHVtbiApIDpcblx0XHRcdHVuZGVmaW5lZDtcblx0fVxuXG5cdC8vIFNldFxuXHRfZm5TZXRDZWxsRGF0YSggY3R4WzBdLCBjZWxsWzBdLnJvdywgY2VsbFswXS5jb2x1bW4sIGRhdGEgKTtcblx0X2ZuSW52YWxpZGF0ZSggY3R4WzBdLCBjZWxsWzBdLnJvdywgJ2RhdGEnLCBjZWxsWzBdLmNvbHVtbiApO1xuXG5cdHJldHVybiB0aGlzO1xufSApO1xuXG5cblxuLyoqXG4gKiBHZXQgY3VycmVudCBvcmRlcmluZyAoc29ydGluZykgdGhhdCBoYXMgYmVlbiBhcHBsaWVkIHRvIHRoZSB0YWJsZS5cbiAqXG4gKiBAcmV0dXJucyB7YXJyYXl9IDJEIGFycmF5IGNvbnRhaW5pbmcgdGhlIHNvcnRpbmcgaW5mb3JtYXRpb24gZm9yIHRoZSBmaXJzdFxuICogICB0YWJsZSBpbiB0aGUgY3VycmVudCBjb250ZXh0LiBFYWNoIGVsZW1lbnQgaW4gdGhlIHBhcmVudCBhcnJheSByZXByZXNlbnRzXG4gKiAgIGEgY29sdW1uIGJlaW5nIHNvcnRlZCB1cG9uIChpLmUuIG11bHRpLXNvcnRpbmcgd2l0aCB0d28gY29sdW1ucyB3b3VsZCBoYXZlXG4gKiAgIDIgaW5uZXIgYXJyYXlzKS4gVGhlIGlubmVyIGFycmF5cyBtYXkgaGF2ZSAyIG9yIDMgZWxlbWVudHMuIFRoZSBmaXJzdCBpc1xuICogICB0aGUgY29sdW1uIGluZGV4IHRoYXQgdGhlIHNvcnRpbmcgY29uZGl0aW9uIGFwcGxpZXMgdG8sIHRoZSBzZWNvbmQgaXMgdGhlXG4gKiAgIGRpcmVjdGlvbiBvZiB0aGUgc29ydCAoYGRlc2NgIG9yIGBhc2NgKSBhbmQsIG9wdGlvbmFsbHksIHRoZSB0aGlyZCBpcyB0aGVcbiAqICAgaW5kZXggb2YgdGhlIHNvcnRpbmcgb3JkZXIgZnJvbSB0aGUgYGNvbHVtbi5zb3J0aW5nYCBpbml0aWFsaXNhdGlvbiBhcnJheS5cbiAqLy8qKlxuICogU2V0IHRoZSBvcmRlcmluZyBmb3IgdGhlIHRhYmxlLlxuICpcbiAqIEBwYXJhbSB7aW50ZWdlcn0gb3JkZXIgQ29sdW1uIGluZGV4IHRvIHNvcnQgdXBvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXJlY3Rpb24gRGlyZWN0aW9uIG9mIHRoZSBzb3J0IHRvIGJlIGFwcGxpZWQgKGBhc2NgIG9yIGBkZXNjYClcbiAqIEByZXR1cm5zIHtEYXRhVGFibGVzLkFwaX0gdGhpc1xuICovLyoqXG4gKiBTZXQgdGhlIG9yZGVyaW5nIGZvciB0aGUgdGFibGUuXG4gKlxuICogQHBhcmFtIHthcnJheX0gb3JkZXIgMUQgYXJyYXkgb2Ygc29ydGluZyBpbmZvcm1hdGlvbiB0byBiZSBhcHBsaWVkLlxuICogQHBhcmFtIHthcnJheX0gWy4uLl0gT3B0aW9uYWwgYWRkaXRpb25hbCBzb3J0aW5nIGNvbmRpdGlvbnNcbiAqIEByZXR1cm5zIHtEYXRhVGFibGVzLkFwaX0gdGhpc1xuICovLyoqXG4gKiBTZXQgdGhlIG9yZGVyaW5nIGZvciB0aGUgdGFibGUuXG4gKlxuICogQHBhcmFtIHthcnJheX0gb3JkZXIgMkQgYXJyYXkgb2Ygc29ydGluZyBpbmZvcm1hdGlvbiB0byBiZSBhcHBsaWVkLlxuICogQHJldHVybnMge0RhdGFUYWJsZXMuQXBpfSB0aGlzXG4gKi9cbl9hcGlfcmVnaXN0ZXIoICdvcmRlcigpJywgZnVuY3Rpb24gKCBvcmRlciwgZGlyICkge1xuXHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcblxuXHRpZiAoIG9yZGVyID09PSB1bmRlZmluZWQgKSB7XG5cdFx0Ly8gZ2V0XG5cdFx0cmV0dXJuIGN0eC5sZW5ndGggIT09IDAgP1xuXHRcdFx0Y3R4WzBdLmFhU29ydGluZyA6XG5cdFx0XHR1bmRlZmluZWQ7XG5cdH1cblxuXHQvLyBzZXRcblx0aWYgKCB0eXBlb2Ygb3JkZXIgPT09ICdudW1iZXInICkge1xuXHRcdC8vIFNpbXBsZSBjb2x1bW4gLyBkaXJlY3Rpb24gcGFzc2VkIGluXG5cdFx0b3JkZXIgPSBbIFsgb3JkZXIsIGRpciBdIF07XG5cdH1cblx0ZWxzZSBpZiAoIGFyZ3MubGVuZ3RoID4gMSApIHtcblx0XHQvLyBBcmd1bWVudHMgcGFzc2VkIGluIChsaXN0IG9mIDFEIGFycmF5cylcblx0XHRvcmRlciA9IGFyZ3M7XG5cdH1cblx0Ly8gb3RoZXJ3aXNlIGEgMkQgYXJyYXkgd2FzIHBhc3NlZCBpblxuXG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdHZhciByZXNvbHZlZCA9IFtdO1xuXHRcdF9mblNvcnRSZXNvbHZlKHNldHRpbmdzLCByZXNvbHZlZCwgb3JkZXIpO1xuXG5cdFx0c2V0dGluZ3MuYWFTb3J0aW5nID0gcmVzb2x2ZWQ7XG5cdH0gKTtcbn0gKTtcblxuXG4vKipcbiAqIEF0dGFjaCBhIHNvcnQgbGlzdGVuZXIgdG8gYW4gZWxlbWVudCBmb3IgYSBnaXZlbiBjb2x1bW5cbiAqXG4gKiBAcGFyYW0ge25vZGV8alF1ZXJ5fHN0cmluZ30gbm9kZSBJZGVudGlmaWVyIGZvciB0aGUgZWxlbWVudChzKSB0byBhdHRhY2ggdGhlXG4gKiAgIGxpc3RlbmVyIHRvLiBUaGlzIGNhbiB0YWtlIHRoZSBmb3JtIG9mIGEgc2luZ2xlIERPTSBub2RlLCBhIGpRdWVyeVxuICogICBjb2xsZWN0aW9uIG9mIG5vZGVzIG9yIGEgalF1ZXJ5IHNlbGVjdG9yIHdoaWNoIHdpbGwgaWRlbnRpZnkgdGhlIG5vZGUocykuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IGNvbHVtbiB0aGUgY29sdW1uIHRoYXQgYSBjbGljayBvbiB0aGlzIG5vZGUgd2lsbCBzb3J0IG9uXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIGNhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gc29ydCBpcyBydW5cbiAqIEByZXR1cm5zIHtEYXRhVGFibGVzLkFwaX0gdGhpc1xuICovXG5fYXBpX3JlZ2lzdGVyKCAnb3JkZXIubGlzdGVuZXIoKScsIGZ1bmN0aW9uICggbm9kZSwgY29sdW1uLCBjYWxsYmFjayApIHtcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0X2ZuU29ydEF0dGFjaExpc3RlbmVyKHNldHRpbmdzLCBub2RlLCB7fSwgY29sdW1uLCBjYWxsYmFjayk7XG5cdH0gKTtcbn0gKTtcblxuXG5fYXBpX3JlZ2lzdGVyKCAnb3JkZXIuZml4ZWQoKScsIGZ1bmN0aW9uICggc2V0ICkge1xuXHRpZiAoICEgc2V0ICkge1xuXHRcdHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG5cdFx0dmFyIGZpeGVkID0gY3R4Lmxlbmd0aCA/XG5cdFx0XHRjdHhbMF0uYWFTb3J0aW5nRml4ZWQgOlxuXHRcdFx0dW5kZWZpbmVkO1xuXG5cdFx0cmV0dXJuIEFycmF5LmlzQXJyYXkoIGZpeGVkICkgP1xuXHRcdFx0eyBwcmU6IGZpeGVkIH0gOlxuXHRcdFx0Zml4ZWQ7XG5cdH1cblxuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRzZXR0aW5ncy5hYVNvcnRpbmdGaXhlZCA9ICQuZXh0ZW5kKCB0cnVlLCB7fSwgc2V0ICk7XG5cdH0gKTtcbn0gKTtcblxuXG4vLyBPcmRlciBieSB0aGUgc2VsZWN0ZWQgY29sdW1uKHMpXG5fYXBpX3JlZ2lzdGVyKCBbXG5cdCdjb2x1bW5zKCkub3JkZXIoKScsXG5cdCdjb2x1bW4oKS5vcmRlcigpJ1xuXSwgZnVuY3Rpb24gKCBkaXIgKSB7XG5cdHZhciB0aGF0ID0gdGhpcztcblxuXHRpZiAoICEgZGlyICkge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAnY29sdW1uJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgaWR4ICkge1xuXHRcdFx0dmFyIHNvcnQgPSBfZm5Tb3J0RmxhdHRlbiggc2V0dGluZ3MgKTtcblxuXHRcdFx0Zm9yICggdmFyIGk9MCwgaWVuPXNvcnQubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdGlmICggc29ydFtpXS5jb2wgPT09IGlkeCApIHtcblx0XHRcdFx0XHRyZXR1cm4gc29ydFtpXS5kaXI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fSwgMSApO1xuXHR9XG5cdGVsc2Uge1xuXHRcdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBpICkge1xuXHRcdFx0c2V0dGluZ3MuYWFTb3J0aW5nID0gdGhhdFtpXS5tYXAoIGZ1bmN0aW9uIChjb2wpIHtcblx0XHRcdFx0cmV0dXJuIFsgY29sLCBkaXIgXTtcblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuX2FwaV9yZWdpc3RlclBsdXJhbCgnY29sdW1ucygpLm9yZGVyYWJsZSgpJywgJ2NvbHVtbigpLm9yZGVyYWJsZSgpJywgZnVuY3Rpb24gKCBkaXJlY3Rpb25zICkge1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ2NvbHVtbicsIGZ1bmN0aW9uICggc2V0dGluZ3MsIGlkeCApIHtcblx0XHR2YXIgY29sID0gc2V0dGluZ3MuYW9Db2x1bW5zW2lkeF07XG5cblx0XHRyZXR1cm4gZGlyZWN0aW9ucyA/XG5cdFx0XHRjb2wuYXNTb3J0aW5nIDpcblx0XHRcdGNvbC5iU29ydGFibGU7XG5cdH0sIDEgKTtcbn0gKTtcblxuXG5fYXBpX3JlZ2lzdGVyKCAncHJvY2Vzc2luZygpJywgZnVuY3Rpb24gKCBzaG93ICkge1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBjdHggKSB7XG5cdFx0X2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoIGN0eCwgc2hvdyApO1xuXHR9ICk7XG59ICk7XG5cblxuX2FwaV9yZWdpc3RlciggJ3NlYXJjaCgpJywgZnVuY3Rpb24gKCBpbnB1dCwgcmVnZXgsIHNtYXJ0LCBjYXNlSW5zZW4gKSB7XG5cdHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG5cblx0aWYgKCBpbnB1dCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdC8vIGdldFxuXHRcdHJldHVybiBjdHgubGVuZ3RoICE9PSAwID9cblx0XHRcdGN0eFswXS5vUHJldmlvdXNTZWFyY2guc2VhcmNoIDpcblx0XHRcdHVuZGVmaW5lZDtcblx0fVxuXG5cdC8vIHNldFxuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRpZiAoICEgc2V0dGluZ3Mub0ZlYXR1cmVzLmJGaWx0ZXIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKHR5cGVvZiByZWdleCA9PT0gJ29iamVjdCcpIHtcblx0XHRcdC8vIE5ldyBzdHlsZSBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIHNlYXJjaCBidWlsZGVyXG5cdFx0XHRfZm5GaWx0ZXJDb21wbGV0ZSggc2V0dGluZ3MsICQuZXh0ZW5kKCBzZXR0aW5ncy5vUHJldmlvdXNTZWFyY2gsIHJlZ2V4LCB7XG5cdFx0XHRcdHNlYXJjaDogaW5wdXRcblx0XHRcdH0gKSApO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIENvbXBhdCBmb3IgdGhlIG9sZCBvcHRpb25zXG5cdFx0XHRfZm5GaWx0ZXJDb21wbGV0ZSggc2V0dGluZ3MsICQuZXh0ZW5kKCBzZXR0aW5ncy5vUHJldmlvdXNTZWFyY2gsIHtcblx0XHRcdFx0c2VhcmNoOiBpbnB1dCxcblx0XHRcdFx0cmVnZXg6ICByZWdleCA9PT0gbnVsbCA/IGZhbHNlIDogcmVnZXgsXG5cdFx0XHRcdHNtYXJ0OiAgc21hcnQgPT09IG51bGwgPyB0cnVlICA6IHNtYXJ0LFxuXHRcdFx0XHRjYXNlSW5zZW5zaXRpdmU6IGNhc2VJbnNlbiA9PT0gbnVsbCA/IHRydWUgOiBjYXNlSW5zZW5cblx0XHRcdH0gKSApO1xuXHRcdH1cblx0fSApO1xufSApO1xuXG5fYXBpX3JlZ2lzdGVyKCAnc2VhcmNoLmZpeGVkKCknLCBmdW5jdGlvbiAoIG5hbWUsIHNlYXJjaCApIHtcblx0dmFyIHJldCA9IHRoaXMuaXRlcmF0b3IoIHRydWUsICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0dmFyIGZpeGVkID0gc2V0dGluZ3Muc2VhcmNoRml4ZWQ7XG5cblx0XHRpZiAoISBuYW1lKSB7XG5cdFx0XHRyZXR1cm4gT2JqZWN0LmtleXMoZml4ZWQpO1xuXHRcdH1cblx0XHRlbHNlIGlmIChzZWFyY2ggPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIGZpeGVkW25hbWVdO1xuXHRcdH1cblx0XHRlbHNlIGlmIChzZWFyY2ggPT09IG51bGwpIHtcblx0XHRcdGRlbGV0ZSBmaXhlZFtuYW1lXTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRmaXhlZFtuYW1lXSA9IHNlYXJjaDtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSApO1xuXG5cdHJldHVybiBuYW1lICE9PSB1bmRlZmluZWQgJiYgc2VhcmNoID09PSB1bmRlZmluZWRcblx0XHQ/IHJldFswXVxuXHRcdDogcmV0O1xufSApO1xuXG5fYXBpX3JlZ2lzdGVyUGx1cmFsKFxuXHQnY29sdW1ucygpLnNlYXJjaCgpJyxcblx0J2NvbHVtbigpLnNlYXJjaCgpJyxcblx0ZnVuY3Rpb24gKCBpbnB1dCwgcmVnZXgsIHNtYXJ0LCBjYXNlSW5zZW4gKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICdjb2x1bW4nLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb2x1bW4gKSB7XG5cdFx0XHR2YXIgcHJlU2VhcmNoID0gc2V0dGluZ3MuYW9QcmVTZWFyY2hDb2xzO1xuXG5cdFx0XHRpZiAoIGlucHV0ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdC8vIGdldFxuXHRcdFx0XHRyZXR1cm4gcHJlU2VhcmNoWyBjb2x1bW4gXS5zZWFyY2g7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHNldFxuXHRcdFx0aWYgKCAhIHNldHRpbmdzLm9GZWF0dXJlcy5iRmlsdGVyICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0eXBlb2YgcmVnZXggPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdC8vIE5ldyBzdHlsZSBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIHNlYXJjaCBidWlsZGVyXG5cdFx0XHRcdCQuZXh0ZW5kKCBwcmVTZWFyY2hbIGNvbHVtbiBdLCByZWdleCwge1xuXHRcdFx0XHRcdHNlYXJjaDogaW5wdXRcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdC8vIE9sZCBzdHlsZSAod2l0aCBub3QgYWxsIG9wdGlvbnMgYXZhaWxhYmxlKVxuXHRcdFx0XHQkLmV4dGVuZCggcHJlU2VhcmNoWyBjb2x1bW4gXSwge1xuXHRcdFx0XHRcdHNlYXJjaDogaW5wdXQsXG5cdFx0XHRcdFx0cmVnZXg6ICByZWdleCA9PT0gbnVsbCA/IGZhbHNlIDogcmVnZXgsXG5cdFx0XHRcdFx0c21hcnQ6ICBzbWFydCA9PT0gbnVsbCA/IHRydWUgIDogc21hcnQsXG5cdFx0XHRcdFx0Y2FzZUluc2Vuc2l0aXZlOiBjYXNlSW5zZW4gPT09IG51bGwgPyB0cnVlIDogY2FzZUluc2VuXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0X2ZuRmlsdGVyQ29tcGxldGUoIHNldHRpbmdzLCBzZXR0aW5ncy5vUHJldmlvdXNTZWFyY2ggKTtcblx0XHR9ICk7XG5cdH1cbik7XG5cbl9hcGlfcmVnaXN0ZXIoW1xuXHRcdCdjb2x1bW5zKCkuc2VhcmNoLmZpeGVkKCknLFxuXHRcdCdjb2x1bW4oKS5zZWFyY2guZml4ZWQoKSdcblx0XSxcblx0ZnVuY3Rpb24gKCBuYW1lLCBzZWFyY2ggKSB7XG5cdFx0dmFyIHJldCA9IHRoaXMuaXRlcmF0b3IoIHRydWUsICdjb2x1bW4nLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb2xJZHggKSB7XG5cdFx0XHR2YXIgZml4ZWQgPSBzZXR0aW5ncy5hb0NvbHVtbnNbY29sSWR4XS5zZWFyY2hGaXhlZDtcblxuXHRcdFx0aWYgKCEgbmFtZSkge1xuXHRcdFx0XHRyZXR1cm4gT2JqZWN0LmtleXMoZml4ZWQpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAoc2VhcmNoID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0cmV0dXJuIGZpeGVkW25hbWVdIHx8IG51bGw7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChzZWFyY2ggPT09IG51bGwpIHtcblx0XHRcdFx0ZGVsZXRlIGZpeGVkW25hbWVdO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGZpeGVkW25hbWVdID0gc2VhcmNoO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9ICk7XG5cblx0XHRyZXR1cm4gbmFtZSAhPT0gdW5kZWZpbmVkICYmIHNlYXJjaCA9PT0gdW5kZWZpbmVkXG5cdFx0XHQ/IHJldFswXVxuXHRcdFx0OiByZXQ7XG5cdH1cbik7XG4vKlxuICogU3RhdGUgQVBJIG1ldGhvZHNcbiAqL1xuXG5fYXBpX3JlZ2lzdGVyKCAnc3RhdGUoKScsIGZ1bmN0aW9uICggc2V0LCBpZ25vcmVUaW1lICkge1xuXHQvLyBnZXR0ZXJcblx0aWYgKCAhIHNldCApIHtcblx0XHRyZXR1cm4gdGhpcy5jb250ZXh0Lmxlbmd0aCA/XG5cdFx0XHR0aGlzLmNvbnRleHRbMF0ub1NhdmVkU3RhdGUgOlxuXHRcdFx0bnVsbDtcblx0fVxuXG5cdHZhciBzZXRNdXRhdGUgPSAkLmV4dGVuZCggdHJ1ZSwge30sIHNldCApO1xuXG5cdC8vIHNldHRlclxuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRpZiAoIGlnbm9yZVRpbWUgIT09IGZhbHNlICkge1xuXHRcdFx0c2V0TXV0YXRlLnRpbWUgPSArbmV3IERhdGUoKSArIDEwMDtcblx0XHR9XG5cblx0XHRfZm5JbXBsZW1lbnRTdGF0ZSggc2V0dGluZ3MsIHNldE11dGF0ZSwgZnVuY3Rpb24oKXt9ICk7XG5cdH0gKTtcbn0gKTtcblxuXG5fYXBpX3JlZ2lzdGVyKCAnc3RhdGUuY2xlYXIoKScsIGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0Ly8gU2F2ZSBhbiBlbXB0eSBvYmplY3Rcblx0XHRzZXR0aW5ncy5mblN0YXRlU2F2ZUNhbGxiYWNrLmNhbGwoIHNldHRpbmdzLm9JbnN0YW5jZSwgc2V0dGluZ3MsIHt9ICk7XG5cdH0gKTtcbn0gKTtcblxuXG5fYXBpX3JlZ2lzdGVyKCAnc3RhdGUubG9hZGVkKCknLCBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLmNvbnRleHQubGVuZ3RoID9cblx0XHR0aGlzLmNvbnRleHRbMF0ub0xvYWRlZFN0YXRlIDpcblx0XHRudWxsO1xufSApO1xuXG5cbl9hcGlfcmVnaXN0ZXIoICdzdGF0ZS5zYXZlKCknLCBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdF9mblNhdmVTdGF0ZSggc2V0dGluZ3MgKTtcblx0fSApO1xufSApO1xuXG4vLyBDYW4gYmUgYXNzaWduZWQgaW4gRGF0ZVRhYmxlLnVzZSgpIC0gbm90ZSBsdXhvbiBhbmQgbW9tZW50IHZhcnMgYXJlIGluIGhlbHBlcnMuanNcbnZhciBfX2Jvb3RzdHJhcDtcbnZhciBfX2ZvdW5kYXRpb247XG5cbi8qKlxuICogU2V0IHRoZSBsaWJyYXJpZXMgdGhhdCBEYXRhVGFibGVzIHVzZXMsIG9yIHRoZSBnbG9iYWwgb2JqZWN0cy5cbiAqIE5vdGUgdGhhdCB0aGUgYXJndW1lbnRzIGNhbiBiZSBlaXRoZXIgd2F5IGFyb3VuZCAobGVnYWN5IHN1cHBvcnQpXG4gKiBhbmQgdGhlIHNlY29uZCBpcyBvcHRpb25hbC4gU2VlIGRvY3MuXG4gKi9cbkRhdGFUYWJsZS51c2UgPSBmdW5jdGlvbiAoYXJnMSwgYXJnMikge1xuXHQvLyBSZXZlcnNlIGFyZ3VtZW50cyBmb3IgbGVnYWN5IHN1cHBvcnRcblx0dmFyIG1vZHVsZSA9IHR5cGVvZiBhcmcxID09PSAnc3RyaW5nJ1xuXHRcdD8gYXJnMlxuXHRcdDogYXJnMTtcblx0dmFyIHR5cGUgPSB0eXBlb2YgYXJnMiA9PT0gJ3N0cmluZydcblx0XHQ/IGFyZzJcblx0XHQ6IGFyZzE7XG5cblx0Ly8gR2V0dGVyXG5cdGlmIChtb2R1bGUgPT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcblx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdGNhc2UgJ2xpYic6XG5cdFx0XHRjYXNlICdqcSc6XG5cdFx0XHRcdHJldHVybiAkO1xuXG5cdFx0XHRjYXNlICd3aW4nOlxuXHRcdFx0XHRyZXR1cm4gd2luZG93O1xuXG5cdFx0XHRjYXNlICdkYXRldGltZSc6XG5cdFx0XHRcdHJldHVybiBEYXRhVGFibGUuRGF0ZVRpbWU7XG5cblx0XHRcdGNhc2UgJ2x1eG9uJzpcblx0XHRcdFx0cmV0dXJuIF9fbHV4b247XG5cblx0XHRcdGNhc2UgJ21vbWVudCc6XG5cdFx0XHRcdHJldHVybiBfX21vbWVudDtcblxuXHRcdFx0Y2FzZSAnYm9vdHN0cmFwJzpcblx0XHRcdFx0Ly8gVXNlIGxvY2FsIGlmIHNldCwgb3RoZXJ3aXNlIHRyeSB3aW5kb3csIHdoaWNoIGNvdWxkIGJlIHVuZGVmaW5lZFxuXHRcdFx0XHRyZXR1cm4gX19ib290c3RyYXAgfHwgd2luZG93LmJvb3RzdHJhcDtcblxuXHRcdFx0Y2FzZSAnZm91bmRhdGlvbic6XG5cdFx0XHRcdC8vIERpdHRvXG5cdFx0XHRcdHJldHVybiBfX2ZvdW5kYXRpb24gfHwgd2luZG93LkZvdW5kYXRpb247XG5cblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0fVxuXG5cdC8vIFNldHRlclxuXHRpZiAodHlwZSA9PT0gJ2xpYicgfHwgdHlwZSA9PT0gJ2pxJyB8fCAobW9kdWxlICYmIG1vZHVsZS5mbiAmJiBtb2R1bGUuZm4uanF1ZXJ5KSkge1xuXHRcdCQgPSBtb2R1bGU7XG5cdH1cblx0ZWxzZSBpZiAodHlwZSA9PT0gJ3dpbicgfHwgKG1vZHVsZSAmJiBtb2R1bGUuZG9jdW1lbnQpKSB7XG5cdFx0d2luZG93ID0gbW9kdWxlO1xuXHRcdGRvY3VtZW50ID0gbW9kdWxlLmRvY3VtZW50O1xuXHR9XG5cdGVsc2UgaWYgKHR5cGUgPT09ICdkYXRldGltZScgfHwgKG1vZHVsZSAmJiBtb2R1bGUudHlwZSA9PT0gJ0RhdGVUaW1lJykpIHtcblx0XHREYXRhVGFibGUuRGF0ZVRpbWUgPSBtb2R1bGU7XG5cdH1cblx0ZWxzZSBpZiAodHlwZSA9PT0gJ2x1eG9uJyB8fCAobW9kdWxlICYmIG1vZHVsZS5GaXhlZE9mZnNldFpvbmUpKSB7XG5cdFx0X19sdXhvbiA9IG1vZHVsZTtcblx0fVxuXHRlbHNlIGlmICh0eXBlID09PSAnbW9tZW50JyB8fCAobW9kdWxlICYmIG1vZHVsZS5pc01vbWVudCkpIHtcblx0XHRfX21vbWVudCA9IG1vZHVsZTtcblx0fVxuXHRlbHNlIGlmICh0eXBlID09PSAnYm9vdHN0cmFwJyB8fCAobW9kdWxlICYmIG1vZHVsZS5Nb2RhbCAmJiBtb2R1bGUuTW9kYWwuTkFNRSA9PT0gJ21vZGFsJykpXG5cdHtcblx0XHQvLyBUaGlzIGlzIGN1cnJlbnRseSBmb3IgQlM1IG9ubHkuIEJTMy80IGF0dGFjaCB0byBqUXVlcnksIHNvIG5vIG5lZWQgdG8gdXNlIGAudXNlKClgXG5cdFx0X19ib290c3RyYXAgPSBtb2R1bGU7XG5cdH1cblx0ZWxzZSBpZiAodHlwZSA9PT0gJ2ZvdW5kYXRpb24nIHx8IChtb2R1bGUgJiYgbW9kdWxlLlJldmVhbCkpIHtcblx0XHRfX2ZvdW5kYXRpb24gPSBtb2R1bGU7XG5cdH1cbn1cblxuLyoqXG4gKiBDb21tb25KUyBmYWN0b3J5IGZ1bmN0aW9uIHBhc3MgdGhyb3VnaC4gVGhpcyB3aWxsIGNoZWNrIGlmIHRoZSBhcmd1bWVudHNcbiAqIGdpdmVuIGFyZSBhIHdpbmRvdyBvYmplY3Qgb3IgYSBqUXVlcnkgb2JqZWN0LiBJZiBzbyB0aGV5IGFyZSBzZXRcbiAqIGFjY29yZGluZ2x5LlxuICogQHBhcmFtIHsqfSByb290IFdpbmRvd1xuICogQHBhcmFtIHsqfSBqcSBqUVVlcnlcbiAqIEByZXR1cm5zIHtib29sZWFufSBJbmRpY2F0b3JcbiAqL1xuRGF0YVRhYmxlLmZhY3RvcnkgPSBmdW5jdGlvbiAocm9vdCwganEpIHtcblx0dmFyIGlzID0gZmFsc2U7XG5cblx0Ly8gVGVzdCBpZiB0aGUgZmlyc3QgcGFyYW1ldGVyIGlzIGEgd2luZG93IG9iamVjdFxuXHRpZiAocm9vdCAmJiByb290LmRvY3VtZW50KSB7XG5cdFx0d2luZG93ID0gcm9vdDtcblx0XHRkb2N1bWVudCA9IHJvb3QuZG9jdW1lbnQ7XG5cdH1cblxuXHQvLyBUZXN0IGlmIHRoZSBzZWNvbmQgcGFyYW1ldGVyIGlzIGEgalF1ZXJ5IG9iamVjdFxuXHRpZiAoanEgJiYganEuZm4gJiYganEuZm4uanF1ZXJ5KSB7XG5cdFx0JCA9IGpxO1xuXHRcdGlzID0gdHJ1ZTtcblx0fVxuXG5cdHJldHVybiBpcztcbn1cblxuLyoqXG4gKiBQcm92aWRlIGEgY29tbW9uIG1ldGhvZCBmb3IgcGx1Zy1pbnMgdG8gY2hlY2sgdGhlIHZlcnNpb24gb2YgRGF0YVRhYmxlcyBiZWluZ1xuICogdXNlZCwgaW4gb3JkZXIgdG8gZW5zdXJlIGNvbXBhdGliaWxpdHkuXG4gKlxuICogIEBwYXJhbSB7c3RyaW5nfSB2ZXJzaW9uIFZlcnNpb24gc3RyaW5nIHRvIGNoZWNrIGZvciwgaW4gdGhlIGZvcm1hdCBcIlguWS5aXCIuXG4gKiAgICBOb3RlIHRoYXQgdGhlIGZvcm1hdHMgXCJYXCIgYW5kIFwiWC5ZXCIgYXJlIGFsc28gYWNjZXB0YWJsZS5cbiAqICBAcGFyYW0ge3N0cmluZ30gW3ZlcnNpb24yPWN1cnJlbnQgRGF0YVRhYmxlcyB2ZXJzaW9uXSBBcyBhYm92ZSwgYnV0IG9wdGlvbmFsLlxuICogICBJZiBub3QgZ2l2ZW4gdGhlIGN1cnJlbnQgRGF0YVRhYmxlcyB2ZXJzaW9uIHdpbGwgYmUgdXNlZC5cbiAqICBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGlzIHZlcnNpb24gb2YgRGF0YVRhYmxlcyBpcyBncmVhdGVyIG9yIGVxdWFsIHRvXG4gKiAgICB0aGUgcmVxdWlyZWQgdmVyc2lvbiwgb3IgZmFsc2UgaWYgdGhpcyB2ZXJzaW9uIG9mIERhdGFUYWxlcyBpcyBub3RcbiAqICAgIHN1aXRhYmxlXG4gKiAgQHN0YXRpY1xuICogIEBkdG9wdCBBUEktU3RhdGljXG4gKlxuICogIEBleGFtcGxlXG4gKiAgICBhbGVydCggJC5mbi5kYXRhVGFibGUudmVyc2lvbkNoZWNrKCAnMS45LjAnICkgKTtcbiAqL1xuRGF0YVRhYmxlLnZlcnNpb25DaGVjayA9IGZ1bmN0aW9uKCB2ZXJzaW9uLCB2ZXJzaW9uMiApXG57XG5cdHZhciBhVGhpcyA9IHZlcnNpb24yID9cblx0XHR2ZXJzaW9uMi5zcGxpdCgnLicpIDpcblx0XHREYXRhVGFibGUudmVyc2lvbi5zcGxpdCgnLicpO1xuXHR2YXIgYVRoYXQgPSB2ZXJzaW9uLnNwbGl0KCcuJyk7XG5cdHZhciBpVGhpcywgaVRoYXQ7XG5cblx0Zm9yICggdmFyIGk9MCwgaUxlbj1hVGhhdC5sZW5ndGggOyBpPGlMZW4gOyBpKysgKSB7XG5cdFx0aVRoaXMgPSBwYXJzZUludCggYVRoaXNbaV0sIDEwICkgfHwgMDtcblx0XHRpVGhhdCA9IHBhcnNlSW50KCBhVGhhdFtpXSwgMTAgKSB8fCAwO1xuXG5cdFx0Ly8gUGFydHMgYXJlIHRoZSBzYW1lLCBrZWVwIGNvbXBhcmluZ1xuXHRcdGlmIChpVGhpcyA9PT0gaVRoYXQpIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdC8vIFBhcnRzIGFyZSBkaWZmZXJlbnQsIHJldHVybiBpbW1lZGlhdGVseVxuXHRcdHJldHVybiBpVGhpcyA+IGlUaGF0O1xuXHR9XG5cblx0cmV0dXJuIHRydWU7XG59O1xuXG5cbi8qKlxuICogQ2hlY2sgaWYgYSBgPHRhYmxlPmAgbm9kZSBpcyBhIERhdGFUYWJsZSB0YWJsZSBhbHJlYWR5IG9yIG5vdC5cbiAqXG4gKiAgQHBhcmFtIHtub2RlfGpxdWVyeXxzdHJpbmd9IHRhYmxlIFRhYmxlIG5vZGUsIGpRdWVyeSBvYmplY3Qgb3IgalF1ZXJ5XG4gKiAgICAgIHNlbGVjdG9yIGZvciB0aGUgdGFibGUgdG8gdGVzdC4gTm90ZSB0aGF0IGlmIG1vcmUgdGhhbiBtb3JlIHRoYW4gb25lXG4gKiAgICAgIHRhYmxlIGlzIHBhc3NlZCBvbiwgb25seSB0aGUgZmlyc3Qgd2lsbCBiZSBjaGVja2VkXG4gKiAgQHJldHVybnMge2Jvb2xlYW59IHRydWUgdGhlIHRhYmxlIGdpdmVuIGlzIGEgRGF0YVRhYmxlLCBvciBmYWxzZSBvdGhlcndpc2VcbiAqICBAc3RhdGljXG4gKiAgQGR0b3B0IEFQSS1TdGF0aWNcbiAqXG4gKiAgQGV4YW1wbGVcbiAqICAgIGlmICggISAkLmZuLkRhdGFUYWJsZS5pc0RhdGFUYWJsZSggJyNleGFtcGxlJyApICkge1xuICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuICogICAgfVxuICovXG5EYXRhVGFibGUuaXNEYXRhVGFibGUgPSBmdW5jdGlvbiAoIHRhYmxlIClcbntcblx0dmFyIHQgPSAkKHRhYmxlKS5nZXQoMCk7XG5cdHZhciBpcyA9IGZhbHNlO1xuXG5cdGlmICggdGFibGUgaW5zdGFuY2VvZiBEYXRhVGFibGUuQXBpICkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0JC5lYWNoKCBEYXRhVGFibGUuc2V0dGluZ3MsIGZ1bmN0aW9uIChpLCBvKSB7XG5cdFx0dmFyIGhlYWQgPSBvLm5TY3JvbGxIZWFkID8gJCgndGFibGUnLCBvLm5TY3JvbGxIZWFkKVswXSA6IG51bGw7XG5cdFx0dmFyIGZvb3QgPSBvLm5TY3JvbGxGb290ID8gJCgndGFibGUnLCBvLm5TY3JvbGxGb290KVswXSA6IG51bGw7XG5cblx0XHRpZiAoIG8ublRhYmxlID09PSB0IHx8IGhlYWQgPT09IHQgfHwgZm9vdCA9PT0gdCApIHtcblx0XHRcdGlzID0gdHJ1ZTtcblx0XHR9XG5cdH0gKTtcblxuXHRyZXR1cm4gaXM7XG59O1xuXG5cbi8qKlxuICogR2V0IGFsbCBEYXRhVGFibGUgdGFibGVzIHRoYXQgaGF2ZSBiZWVuIGluaXRpYWxpc2VkIC0gb3B0aW9uYWxseSB5b3UgY2FuXG4gKiBzZWxlY3QgdG8gZ2V0IG9ubHkgY3VycmVudGx5IHZpc2libGUgdGFibGVzLlxuICpcbiAqICBAcGFyYW0ge2Jvb2xlYW59IFt2aXNpYmxlPWZhbHNlXSBGbGFnIHRvIGluZGljYXRlIGlmIHlvdSB3YW50IGFsbCAoZGVmYXVsdClcbiAqICAgIG9yIHZpc2libGUgdGFibGVzIG9ubHkuXG4gKiAgQHJldHVybnMge2FycmF5fSBBcnJheSBvZiBgdGFibGVgIG5vZGVzIChub3QgRGF0YVRhYmxlIGluc3RhbmNlcykgd2hpY2ggYXJlXG4gKiAgICBEYXRhVGFibGVzXG4gKiAgQHN0YXRpY1xuICogIEBkdG9wdCBBUEktU3RhdGljXG4gKlxuICogIEBleGFtcGxlXG4gKiAgICAkLmVhY2goICQuZm4uZGF0YVRhYmxlLnRhYmxlcyh0cnVlKSwgZnVuY3Rpb24gKCkge1xuICogICAgICAkKHRhYmxlKS5EYXRhVGFibGUoKS5jb2x1bW5zLmFkanVzdCgpO1xuICogICAgfSApO1xuICovXG5EYXRhVGFibGUudGFibGVzID0gZnVuY3Rpb24gKCB2aXNpYmxlIClcbntcblx0dmFyIGFwaSA9IGZhbHNlO1xuXG5cdGlmICggJC5pc1BsYWluT2JqZWN0KCB2aXNpYmxlICkgKSB7XG5cdFx0YXBpID0gdmlzaWJsZS5hcGk7XG5cdFx0dmlzaWJsZSA9IHZpc2libGUudmlzaWJsZTtcblx0fVxuXG5cdHZhciBhID0gRGF0YVRhYmxlLnNldHRpbmdzXG5cdFx0LmZpbHRlciggZnVuY3Rpb24gKG8pIHtcblx0XHRcdHJldHVybiAhdmlzaWJsZSB8fCAodmlzaWJsZSAmJiAkKG8ublRhYmxlKS5pcygnOnZpc2libGUnKSkgXG5cdFx0XHRcdD8gdHJ1ZVxuXHRcdFx0XHQ6IGZhbHNlO1xuXHRcdH0gKVxuXHRcdC5tYXAoIGZ1bmN0aW9uIChvKSB7XG5cdFx0XHRyZXR1cm4gby5uVGFibGU7XG5cdFx0fSk7XG5cblx0cmV0dXJuIGFwaSA/XG5cdFx0bmV3IF9BcGkoIGEgKSA6XG5cdFx0YTtcbn07XG5cblxuLyoqXG4gKiBDb252ZXJ0IGZyb20gY2FtZWwgY2FzZSBwYXJhbWV0ZXJzIHRvIEh1bmdhcmlhbiBub3RhdGlvbi4gVGhpcyBpcyBtYWRlIHB1YmxpY1xuICogZm9yIHRoZSBleHRlbnNpb25zIHRvIHByb3ZpZGUgdGhlIHNhbWUgYWJpbGl0eSBhcyBEYXRhVGFibGVzIGNvcmUgdG8gYWNjZXB0XG4gKiBlaXRoZXIgdGhlIDEuOSBzdHlsZSBIdW5nYXJpYW4gbm90YXRpb24sIG9yIHRoZSAxLjEwKyBzdHlsZSBjYW1lbENhc2VcbiAqIHBhcmFtZXRlcnMuXG4gKlxuICogIEBwYXJhbSB7b2JqZWN0fSBzcmMgVGhlIG1vZGVsIG9iamVjdCB3aGljaCBob2xkcyBhbGwgcGFyYW1ldGVycyB0aGF0IGNhbiBiZVxuICogICAgbWFwcGVkLlxuICogIEBwYXJhbSB7b2JqZWN0fSB1c2VyIFRoZSBvYmplY3QgdG8gY29udmVydCBmcm9tIGNhbWVsIGNhc2UgdG8gSHVuZ2FyaWFuLlxuICogIEBwYXJhbSB7Ym9vbGVhbn0gZm9yY2UgV2hlbiBzZXQgdG8gYHRydWVgLCBwcm9wZXJ0aWVzIHdoaWNoIGFscmVhZHkgaGF2ZSBhXG4gKiAgICBIdW5nYXJpYW4gdmFsdWUgaW4gdGhlIGB1c2VyYCBvYmplY3Qgd2lsbCBiZSBvdmVyd3JpdHRlbi4gT3RoZXJ3aXNlIHRoZXlcbiAqICAgIHdvbid0IGJlLlxuICovXG5EYXRhVGFibGUuY2FtZWxUb0h1bmdhcmlhbiA9IF9mbkNhbWVsVG9IdW5nYXJpYW47XG5cblxuXG4vKipcbiAqXG4gKi9cbl9hcGlfcmVnaXN0ZXIoICckKCknLCBmdW5jdGlvbiAoIHNlbGVjdG9yLCBvcHRzICkge1xuXHR2YXJcblx0XHRyb3dzICAgPSB0aGlzLnJvd3MoIG9wdHMgKS5ub2RlcygpLCAvLyBHZXQgYWxsIHJvd3Ncblx0XHRqcVJvd3MgPSAkKHJvd3MpO1xuXG5cdHJldHVybiAkKCBbXS5jb25jYXQoXG5cdFx0anFSb3dzLmZpbHRlciggc2VsZWN0b3IgKS50b0FycmF5KCksXG5cdFx0anFSb3dzLmZpbmQoIHNlbGVjdG9yICkudG9BcnJheSgpXG5cdCkgKTtcbn0gKTtcblxuXG4vLyBqUXVlcnkgZnVuY3Rpb25zIHRvIG9wZXJhdGUgb24gdGhlIHRhYmxlc1xuJC5lYWNoKCBbICdvbicsICdvbmUnLCAnb2ZmJyBdLCBmdW5jdGlvbiAoaSwga2V5KSB7XG5cdF9hcGlfcmVnaXN0ZXIoIGtleSsnKCknLCBmdW5jdGlvbiAoIC8qIGV2ZW50LCBoYW5kbGVyICovICkge1xuXHRcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuXHRcdC8vIEFkZCB0aGUgYGR0YCBuYW1lc3BhY2UgYXV0b21hdGljYWxseSBpZiBpdCBpc24ndCBhbHJlYWR5IHByZXNlbnRcblx0XHRhcmdzWzBdID0gYXJnc1swXS5zcGxpdCggL1xccy8gKS5tYXAoIGZ1bmN0aW9uICggZSApIHtcblx0XHRcdHJldHVybiAhIGUubWF0Y2goL1xcLmR0XFxiLykgP1xuXHRcdFx0XHRlKycuZHQnIDpcblx0XHRcdFx0ZTtcblx0XHRcdH0gKS5qb2luKCAnICcgKTtcblxuXHRcdHZhciBpbnN0ID0gJCggdGhpcy50YWJsZXMoKS5ub2RlcygpICk7XG5cdFx0aW5zdFtrZXldLmFwcGx5KCBpbnN0LCBhcmdzICk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0gKTtcbn0gKTtcblxuXG5fYXBpX3JlZ2lzdGVyKCAnY2xlYXIoKScsIGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0X2ZuQ2xlYXJUYWJsZSggc2V0dGluZ3MgKTtcblx0fSApO1xufSApO1xuXG5cbl9hcGlfcmVnaXN0ZXIoICdlcnJvcigpJywgZnVuY3Rpb24gKG1zZykge1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRfZm5Mb2coIHNldHRpbmdzLCAwLCBtc2cgKTtcblx0fSApO1xufSApO1xuXG5cbl9hcGlfcmVnaXN0ZXIoICdzZXR0aW5ncygpJywgZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gbmV3IF9BcGkoIHRoaXMuY29udGV4dCwgdGhpcy5jb250ZXh0ICk7XG59ICk7XG5cblxuX2FwaV9yZWdpc3RlciggJ2luaXQoKScsIGZ1bmN0aW9uICgpIHtcblx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblx0cmV0dXJuIGN0eC5sZW5ndGggPyBjdHhbMF0ub0luaXQgOiBudWxsO1xufSApO1xuXG5cbl9hcGlfcmVnaXN0ZXIoICdkYXRhKCknLCBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLml0ZXJhdG9yKCAndGFibGUnLCBmdW5jdGlvbiAoIHNldHRpbmdzICkge1xuXHRcdHJldHVybiBfcGx1Y2soIHNldHRpbmdzLmFvRGF0YSwgJ19hRGF0YScgKTtcblx0fSApLmZsYXR0ZW4oKTtcbn0gKTtcblxuXG5fYXBpX3JlZ2lzdGVyKCAndHJpZ2dlcigpJywgZnVuY3Rpb24gKCBuYW1lLCBhcmdzLCBidWJibGVzICkge1xuXHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ3RhYmxlJywgZnVuY3Rpb24gKCBzZXR0aW5ncyApIHtcblx0XHRyZXR1cm4gX2ZuQ2FsbGJhY2tGaXJlKCBzZXR0aW5ncywgbnVsbCwgbmFtZSwgYXJncywgYnViYmxlcyApO1xuXHR9ICkuZmxhdHRlbigpO1xufSApO1xuXG5cbl9hcGlfcmVnaXN0ZXIoICdyZWFkeSgpJywgZnVuY3Rpb24gKCBmbiApIHtcblx0dmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblxuXHQvLyBHZXQgc3RhdHVzIG9mIGZpcnN0IHRhYmxlXG5cdGlmICghIGZuKSB7XG5cdFx0cmV0dXJuIGN0eC5sZW5ndGhcblx0XHRcdD8gKGN0eFswXS5fYkluaXRDb21wbGV0ZSB8fCBmYWxzZSlcblx0XHRcdDogbnVsbDtcblx0fVxuXG5cdC8vIEZ1bmN0aW9uIHRvIHJ1biBlaXRoZXIgb25jZSB0aGUgdGFibGUgYmVjb21lcyByZWFkeSBvclxuXHQvLyBpbW1lZGlhdGVseSBpZiBpdCBpcyBhbHJlYWR5IHJlYWR5LlxuXHRyZXR1cm4gdGhpcy50YWJsZXMoKS5ldmVyeShmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGFwaSA9IHRoaXM7XG5cblx0XHRpZiAodGhpcy5jb250ZXh0WzBdLl9iSW5pdENvbXBsZXRlKSB7XG5cdFx0XHRmbi5jYWxsKGFwaSk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dGhpcy5vbignaW5pdC5kdC5EVCcsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Zm4uY2FsbChhcGkpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9ICk7XG59ICk7XG5cblxuX2FwaV9yZWdpc3RlciggJ2Rlc3Ryb3koKScsIGZ1bmN0aW9uICggcmVtb3ZlICkge1xuXHRyZW1vdmUgPSByZW1vdmUgfHwgZmFsc2U7XG5cblx0cmV0dXJuIHRoaXMuaXRlcmF0b3IoICd0YWJsZScsIGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0dmFyIGNsYXNzZXMgICA9IHNldHRpbmdzLm9DbGFzc2VzO1xuXHRcdHZhciB0YWJsZSAgICAgPSBzZXR0aW5ncy5uVGFibGU7XG5cdFx0dmFyIHRib2R5ICAgICA9IHNldHRpbmdzLm5UQm9keTtcblx0XHR2YXIgdGhlYWQgICAgID0gc2V0dGluZ3MublRIZWFkO1xuXHRcdHZhciB0Zm9vdCAgICAgPSBzZXR0aW5ncy5uVEZvb3Q7XG5cdFx0dmFyIGpxVGFibGUgICA9ICQodGFibGUpO1xuXHRcdHZhciBqcVRib2R5ICAgPSAkKHRib2R5KTtcblx0XHR2YXIganFXcmFwcGVyID0gJChzZXR0aW5ncy5uVGFibGVXcmFwcGVyKTtcblx0XHR2YXIgcm93cyAgICAgID0gc2V0dGluZ3MuYW9EYXRhLm1hcCggZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIgPyByLm5UciA6IG51bGw7IH0gKTtcblx0XHR2YXIgb3JkZXJDbGFzc2VzID0gY2xhc3Nlcy5vcmRlcjtcblxuXHRcdC8vIEZsYWcgdG8gbm90ZSB0aGF0IHRoZSB0YWJsZSBpcyBjdXJyZW50bHkgYmVpbmcgZGVzdHJveWVkIC0gbm8gYWN0aW9uXG5cdFx0Ly8gc2hvdWxkIGJlIHRha2VuXG5cdFx0c2V0dGluZ3MuYkRlc3Ryb3lpbmcgPSB0cnVlO1xuXG5cdFx0Ly8gRmlyZSBvZmYgdGhlIGRlc3Ryb3kgY2FsbGJhY2tzIGZvciBwbHVnLWlucyBldGNcblx0XHRfZm5DYWxsYmFja0ZpcmUoIHNldHRpbmdzLCBcImFvRGVzdHJveUNhbGxiYWNrXCIsIFwiZGVzdHJveVwiLCBbc2V0dGluZ3NdLCB0cnVlICk7XG5cblx0XHQvLyBJZiBub3QgYmVpbmcgcmVtb3ZlZCBmcm9tIHRoZSBkb2N1bWVudCwgbWFrZSBhbGwgY29sdW1ucyB2aXNpYmxlXG5cdFx0aWYgKCAhIHJlbW92ZSApIHtcblx0XHRcdG5ldyBfQXBpKCBzZXR0aW5ncyApLmNvbHVtbnMoKS52aXNpYmxlKCB0cnVlICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ29udGFpbmVyIHdpZHRoIGNoYW5nZSBsaXN0ZW5lclxuXHRcdGlmIChzZXR0aW5ncy5yZXNpemVPYnNlcnZlcikge1xuXHRcdFx0c2V0dGluZ3MucmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuXHRcdH1cblxuXHRcdC8vIEJsaXR6IGFsbCBgRFRgIG5hbWVzcGFjZWQgZXZlbnRzICh0aGVzZSBhcmUgaW50ZXJuYWwgZXZlbnRzLCB0aGVcblx0XHQvLyBsb3dlcmNhc2UsIGBkdGAgZXZlbnRzIGFyZSB1c2VyIHN1YnNjcmliZWQgYW5kIHRoZXkgYXJlIHJlc3BvbnNpYmxlXG5cdFx0Ly8gZm9yIHJlbW92aW5nIHRoZW1cblx0XHRqcVdyYXBwZXIub2ZmKCcuRFQnKS5maW5kKCc6bm90KHRib2R5ICopJykub2ZmKCcuRFQnKTtcblx0XHQkKHdpbmRvdykub2ZmKCcuRFQtJytzZXR0aW5ncy5zSW5zdGFuY2UpO1xuXG5cdFx0Ly8gV2hlbiBzY3JvbGxpbmcgd2UgaGFkIHRvIGJyZWFrIHRoZSB0YWJsZSB1cCAtIHJlc3RvcmUgaXRcblx0XHRpZiAoIHRhYmxlICE9IHRoZWFkLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRqcVRhYmxlLmNoaWxkcmVuKCd0aGVhZCcpLmRldGFjaCgpO1xuXHRcdFx0anFUYWJsZS5hcHBlbmQoIHRoZWFkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0Zm9vdCAmJiB0YWJsZSAhPSB0Zm9vdC5wYXJlbnROb2RlICkge1xuXHRcdFx0anFUYWJsZS5jaGlsZHJlbigndGZvb3QnKS5kZXRhY2goKTtcblx0XHRcdGpxVGFibGUuYXBwZW5kKCB0Zm9vdCApO1xuXHRcdH1cblxuXHRcdC8vIENsZWFuIHVwIHRoZSBoZWFkZXIgLyBmb290ZXJcblx0XHRjbGVhbkhlYWRlcih0aGVhZCwgJ2hlYWRlcicpO1xuXHRcdGNsZWFuSGVhZGVyKHRmb290LCAnZm9vdGVyJyk7XG5cdFx0c2V0dGluZ3MuY29sZ3JvdXAucmVtb3ZlKCk7XG5cblx0XHRzZXR0aW5ncy5hYVNvcnRpbmcgPSBbXTtcblx0XHRzZXR0aW5ncy5hYVNvcnRpbmdGaXhlZCA9IFtdO1xuXHRcdF9mblNvcnRpbmdDbGFzc2VzKCBzZXR0aW5ncyApO1xuXG5cdFx0JChqcVRhYmxlKS5maW5kKCd0aCwgdGQnKS5yZW1vdmVDbGFzcyhcblx0XHRcdCQubWFwKERhdGFUYWJsZS5leHQudHlwZS5jbGFzc05hbWUsIGZ1bmN0aW9uICh2KSB7XG5cdFx0XHRcdHJldHVybiB2O1xuXHRcdFx0fSkuam9pbignICcpXG5cdFx0KTtcblxuXHRcdCQoJ3RoLCB0ZCcsIHRoZWFkKVxuXHRcdFx0LnJlbW92ZUNsYXNzKFxuXHRcdFx0XHRvcmRlckNsYXNzZXMubm9uZSArICcgJyArXG5cdFx0XHRcdG9yZGVyQ2xhc3Nlcy5jYW5Bc2MgKyAnICcgK1xuXHRcdFx0XHRvcmRlckNsYXNzZXMuY2FuRGVzYyArICcgJyArXG5cdFx0XHRcdG9yZGVyQ2xhc3Nlcy5pc0FzYyArICcgJyArXG5cdFx0XHRcdG9yZGVyQ2xhc3Nlcy5pc0Rlc2Ncblx0XHRcdClcblx0XHRcdC5jc3MoJ3dpZHRoJywgJycpXG5cdFx0XHQucmVtb3ZlQXR0cignYXJpYS1zb3J0Jyk7XG5cblx0XHQvLyBBZGQgdGhlIFRSIGVsZW1lbnRzIGJhY2sgaW50byB0aGUgdGFibGUgaW4gdGhlaXIgb3JpZ2luYWwgb3JkZXJcblx0XHRqcVRib2R5LmNoaWxkcmVuKCkuZGV0YWNoKCk7XG5cdFx0anFUYm9keS5hcHBlbmQoIHJvd3MgKTtcblxuXHRcdHZhciBvcmlnID0gc2V0dGluZ3MublRhYmxlV3JhcHBlci5wYXJlbnROb2RlO1xuXHRcdHZhciBpbnNlcnRCZWZvcmUgPSBzZXR0aW5ncy5uVGFibGVXcmFwcGVyLm5leHRTaWJsaW5nO1xuXG5cdFx0Ly8gUmVtb3ZlIHRoZSBEYXRhVGFibGVzIGdlbmVyYXRlZCBub2RlcywgZXZlbnRzIGFuZCBjbGFzc2VzXG5cdFx0dmFyIHJlbW92ZWRNZXRob2QgPSByZW1vdmUgPyAncmVtb3ZlJyA6ICdkZXRhY2gnO1xuXHRcdGpxVGFibGVbIHJlbW92ZWRNZXRob2QgXSgpO1xuXHRcdGpxV3JhcHBlclsgcmVtb3ZlZE1ldGhvZCBdKCk7XG5cblx0XHQvLyBJZiB3ZSBuZWVkIHRvIHJlYXR0YWNoIHRoZSB0YWJsZSB0byB0aGUgZG9jdW1lbnRcblx0XHRpZiAoICEgcmVtb3ZlICYmIG9yaWcgKSB7XG5cdFx0XHQvLyBpbnNlcnRCZWZvcmUgYWN0cyBsaWtlIGFwcGVuZENoaWxkIGlmICFhcmdbMV1cblx0XHRcdG9yaWcuaW5zZXJ0QmVmb3JlKCB0YWJsZSwgaW5zZXJ0QmVmb3JlICk7XG5cblx0XHRcdC8vIFJlc3RvcmUgdGhlIHdpZHRoIG9mIHRoZSBvcmlnaW5hbCB0YWJsZSAtIHdhcyByZWFkIGZyb20gdGhlIHN0eWxlIHByb3BlcnR5LFxuXHRcdFx0Ly8gc28gd2UgY2FuIHJlc3RvcmUgZGlyZWN0bHkgdG8gdGhhdFxuXHRcdFx0anFUYWJsZVxuXHRcdFx0XHQuY3NzKCAnd2lkdGgnLCBzZXR0aW5ncy5zRGVzdHJveVdpZHRoIClcblx0XHRcdFx0LnJlbW92ZUNsYXNzKCBjbGFzc2VzLnRhYmxlICk7XG5cdFx0fVxuXG5cdFx0LyogUmVtb3ZlIHRoZSBzZXR0aW5ncyBvYmplY3QgZnJvbSB0aGUgc2V0dGluZ3MgYXJyYXkgKi9cblx0XHR2YXIgaWR4ID0gRGF0YVRhYmxlLnNldHRpbmdzLmluZGV4T2Yoc2V0dGluZ3MpO1xuXHRcdGlmICggaWR4ICE9PSAtMSApIHtcblx0XHRcdERhdGFUYWJsZS5zZXR0aW5ncy5zcGxpY2UoIGlkeCwgMSApO1xuXHRcdH1cblx0fSApO1xufSApO1xuXG5cbi8vIEFkZCB0aGUgYGV2ZXJ5KClgIG1ldGhvZCBmb3Igcm93cywgY29sdW1ucyBhbmQgY2VsbHMgaW4gYSBjb21wYWN0IGZvcm1cbiQuZWFjaCggWyAnY29sdW1uJywgJ3JvdycsICdjZWxsJyBdLCBmdW5jdGlvbiAoIGksIHR5cGUgKSB7XG5cdF9hcGlfcmVnaXN0ZXIoIHR5cGUrJ3MoKS5ldmVyeSgpJywgZnVuY3Rpb24gKCBmbiApIHtcblx0XHR2YXIgb3B0cyA9IHRoaXMuc2VsZWN0b3Iub3B0cztcblx0XHR2YXIgYXBpID0gdGhpcztcblx0XHR2YXIgaW5zdDtcblx0XHR2YXIgY291bnRlciA9IDA7XG5cblx0XHRyZXR1cm4gdGhpcy5pdGVyYXRvciggJ2V2ZXJ5JywgZnVuY3Rpb24gKCBzZXR0aW5ncywgc2VsZWN0ZWRJZHgsIHRhYmxlSWR4ICkge1xuXHRcdFx0aW5zdCA9IGFwaVsgdHlwZSBdKHNlbGVjdGVkSWR4LCBvcHRzKTtcblxuXHRcdFx0aWYgKHR5cGUgPT09ICdjZWxsJykge1xuXHRcdFx0XHRmbi5jYWxsKGluc3QsIGluc3RbMF1bMF0ucm93LCBpbnN0WzBdWzBdLmNvbHVtbiwgdGFibGVJZHgsIGNvdW50ZXIpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGZuLmNhbGwoaW5zdCwgc2VsZWN0ZWRJZHgsIHRhYmxlSWR4LCBjb3VudGVyKTtcblx0XHRcdH1cblxuXHRcdFx0Y291bnRlcisrO1xuXHRcdH0gKTtcblx0fSApO1xufSApO1xuXG5cbi8vIGkxOG4gbWV0aG9kIGZvciBleHRlbnNpb25zIHRvIGJlIGFibGUgdG8gdXNlIHRoZSBsYW5ndWFnZSBvYmplY3QgZnJvbSB0aGVcbi8vIERhdGFUYWJsZVxuX2FwaV9yZWdpc3RlciggJ2kxOG4oKScsIGZ1bmN0aW9uICggdG9rZW4sIGRlZiwgcGx1cmFsICkge1xuXHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0WzBdO1xuXHR2YXIgcmVzb2x2ZWQgPSBfZm5HZXRPYmplY3REYXRhRm4oIHRva2VuICkoIGN0eC5vTGFuZ3VhZ2UgKTtcblxuXHRpZiAoIHJlc29sdmVkID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cmVzb2x2ZWQgPSBkZWY7XG5cdH1cblxuXHRpZiAoICQuaXNQbGFpbk9iamVjdCggcmVzb2x2ZWQgKSApIHtcblx0XHRyZXNvbHZlZCA9IHBsdXJhbCAhPT0gdW5kZWZpbmVkICYmIHJlc29sdmVkWyBwbHVyYWwgXSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdHJlc29sdmVkWyBwbHVyYWwgXSA6XG5cdFx0XHRyZXNvbHZlZC5fO1xuXHR9XG5cblx0cmV0dXJuIHR5cGVvZiByZXNvbHZlZCA9PT0gJ3N0cmluZydcblx0XHQ/IHJlc29sdmVkLnJlcGxhY2UoICclZCcsIHBsdXJhbCApIC8vIG5iOiBwbHVyYWwgbWlnaHQgYmUgdW5kZWZpbmVkLFxuXHRcdDogcmVzb2x2ZWQ7XG59ICk7XG5cbi8vIE5lZWRlZCBmb3IgaGVhZGVyIGFuZCBmb290ZXIsIHNvIHB1bGxlZCBpbnRvIGl0cyBvd24gZnVuY3Rpb25cbmZ1bmN0aW9uIGNsZWFuSGVhZGVyKG5vZGUsIGNsYXNzTmFtZSkge1xuXHQkKG5vZGUpLmZpbmQoJ3NwYW4uZHQtY29sdW1uLW9yZGVyJykucmVtb3ZlKCk7XG5cdCQobm9kZSkuZmluZCgnc3Bhbi5kdC1jb2x1bW4tdGl0bGUnKS5lYWNoKGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgdGl0bGUgPSAkKHRoaXMpLmh0bWwoKTtcblx0XHQkKHRoaXMpLnBhcmVudCgpLnBhcmVudCgpLmFwcGVuZCh0aXRsZSk7XG5cdFx0JCh0aGlzKS5yZW1vdmUoKTtcblx0fSk7XG5cdCQobm9kZSkuZmluZCgnZGl2LmR0LWNvbHVtbi0nICsgY2xhc3NOYW1lKS5yZW1vdmUoKTtcblxuXHQkKCd0aCwgdGQnLCBub2RlKS5yZW1vdmVBdHRyKCdkYXRhLWR0LWNvbHVtbicpO1xufVxuXG4vKipcbiAqIFZlcnNpb24gc3RyaW5nIGZvciBwbHVnLWlucyB0byBjaGVjayBjb21wYXRpYmlsaXR5LiBBbGxvd2VkIGZvcm1hdCBpc1xuICogYGEuYi5jLWRgIHdoZXJlOiBhOmludCwgYjppbnQsIGM6aW50LCBkOnN0cmluZyhkZXZ8YmV0YXxhbHBoYSkuIGBkYCBpcyB1c2VkXG4gKiBvbmx5IGZvciBub24tcmVsZWFzZSBidWlsZHMuIFNlZSBodHRwczovL3NlbXZlci5vcmcvIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICogIEBtZW1iZXJcbiAqICBAdHlwZSBzdHJpbmdcbiAqICBAZGVmYXVsdCBWZXJzaW9uIG51bWJlclxuICovXG5EYXRhVGFibGUudmVyc2lvbiA9IFwiMi4zLjFcIjtcblxuLyoqXG4gKiBQcml2YXRlIGRhdGEgc3RvcmUsIGNvbnRhaW5pbmcgYWxsIG9mIHRoZSBzZXR0aW5ncyBvYmplY3RzIHRoYXQgYXJlXG4gKiBjcmVhdGVkIGZvciB0aGUgdGFibGVzIG9uIGEgZ2l2ZW4gcGFnZS5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlIGBEYXRhVGFibGUuc2V0dGluZ3NgIG9iamVjdCBpcyBhbGlhc2VkIHRvXG4gKiBgalF1ZXJ5LmZuLmRhdGFUYWJsZUV4dGAgdGhyb3VnaCB3aGljaCBpdCBtYXkgYmUgYWNjZXNzZWQgYW5kXG4gKiBtYW5pcHVsYXRlZCwgb3IgYGpRdWVyeS5mbi5kYXRhVGFibGUuc2V0dGluZ3NgLlxuICogIEBtZW1iZXJcbiAqICBAdHlwZSBhcnJheVxuICogIEBkZWZhdWx0IFtdXG4gKiAgQHByaXZhdGVcbiAqL1xuRGF0YVRhYmxlLnNldHRpbmdzID0gW107XG5cbi8qKlxuICogT2JqZWN0IG1vZGVscyBjb250YWluZXIsIGZvciB0aGUgdmFyaW91cyBtb2RlbHMgdGhhdCBEYXRhVGFibGVzIGhhc1xuICogYXZhaWxhYmxlIHRvIGl0LiBUaGVzZSBtb2RlbHMgZGVmaW5lIHRoZSBvYmplY3RzIHRoYXQgYXJlIHVzZWQgdG8gaG9sZFxuICogdGhlIGFjdGl2ZSBzdGF0ZSBhbmQgY29uZmlndXJhdGlvbiBvZiB0aGUgdGFibGUuXG4gKiAgQG5hbWVzcGFjZVxuICovXG5EYXRhVGFibGUubW9kZWxzID0ge307XG5cblxuXG4vKipcbiAqIFRlbXBsYXRlIG9iamVjdCBmb3IgdGhlIHdheSBpbiB3aGljaCBEYXRhVGFibGVzIGhvbGRzIGluZm9ybWF0aW9uIGFib3V0XG4gKiBzZWFyY2ggaW5mb3JtYXRpb24gZm9yIHRoZSBnbG9iYWwgZmlsdGVyIGFuZCBpbmRpdmlkdWFsIGNvbHVtbiBmaWx0ZXJzLlxuICogIEBuYW1lc3BhY2VcbiAqL1xuRGF0YVRhYmxlLm1vZGVscy5vU2VhcmNoID0ge1xuXHQvKipcblx0ICogRmxhZyB0byBpbmRpY2F0ZSBpZiB0aGUgZmlsdGVyaW5nIHNob3VsZCBiZSBjYXNlIGluc2Vuc2l0aXZlIG9yIG5vdFxuXHQgKi9cblx0XCJjYXNlSW5zZW5zaXRpdmVcIjogdHJ1ZSxcblxuXHQvKipcblx0ICogQXBwbGllZCBzZWFyY2ggdGVybVxuXHQgKi9cblx0XCJzZWFyY2hcIjogXCJcIixcblxuXHQvKipcblx0ICogRmxhZyB0byBpbmRpY2F0ZSBpZiB0aGUgc2VhcmNoIHRlcm0gc2hvdWxkIGJlIGludGVycHJldGVkIGFzIGFcblx0ICogcmVndWxhciBleHByZXNzaW9uICh0cnVlKSBvciBub3QgKGZhbHNlKSBhbmQgdGhlcmVmb3JlIGFuZCBzcGVjaWFsXG5cdCAqIHJlZ2V4IGNoYXJhY3RlcnMgZXNjYXBlZC5cblx0ICovXG5cdFwicmVnZXhcIjogZmFsc2UsXG5cblx0LyoqXG5cdCAqIEZsYWcgdG8gaW5kaWNhdGUgaWYgRGF0YVRhYmxlcyBpcyB0byB1c2UgaXRzIHNtYXJ0IGZpbHRlcmluZyBvciBub3QuXG5cdCAqL1xuXHRcInNtYXJ0XCI6IHRydWUsXG5cblx0LyoqXG5cdCAqIEZsYWcgdG8gaW5kaWNhdGUgaWYgRGF0YVRhYmxlcyBzaG91bGQgb25seSB0cmlnZ2VyIGEgc2VhcmNoIHdoZW5cblx0ICogdGhlIHJldHVybiBrZXkgaXMgcHJlc3NlZC5cblx0ICovXG5cdFwicmV0dXJuXCI6IGZhbHNlXG59O1xuXG5cblxuXG4vKipcbiAqIFRlbXBsYXRlIG9iamVjdCBmb3IgdGhlIHdheSBpbiB3aGljaCBEYXRhVGFibGVzIGhvbGRzIGluZm9ybWF0aW9uIGFib3V0XG4gKiBlYWNoIGluZGl2aWR1YWwgcm93LiBUaGlzIGlzIHRoZSBvYmplY3QgZm9ybWF0IHVzZWQgZm9yIHRoZSBzZXR0aW5nc1xuICogYW9EYXRhIGFycmF5LlxuICogIEBuYW1lc3BhY2VcbiAqL1xuRGF0YVRhYmxlLm1vZGVscy5vUm93ID0ge1xuXHQvKipcblx0ICogVFIgZWxlbWVudCBmb3IgdGhlIHJvd1xuXHQgKi9cblx0XCJuVHJcIjogbnVsbCxcblxuXHQvKipcblx0ICogQXJyYXkgb2YgVEQgZWxlbWVudHMgZm9yIGVhY2ggcm93LiBUaGlzIGlzIG51bGwgdW50aWwgdGhlIHJvdyBoYXMgYmVlblxuXHQgKiBjcmVhdGVkLlxuXHQgKi9cblx0XCJhbkNlbGxzXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIERhdGEgb2JqZWN0IGZyb20gdGhlIG9yaWdpbmFsIGRhdGEgc291cmNlIGZvciB0aGUgcm93LiBUaGlzIGlzIGVpdGhlclxuXHQgKiBhbiBhcnJheSBpZiB1c2luZyB0aGUgdHJhZGl0aW9uYWwgZm9ybSBvZiBEYXRhVGFibGVzLCBvciBhbiBvYmplY3QgaWZcblx0ICogdXNpbmcgbURhdGEgb3B0aW9ucy4gVGhlIGV4YWN0IHR5cGUgd2lsbCBkZXBlbmQgb24gdGhlIHBhc3NlZCBpblxuXHQgKiBkYXRhIGZyb20gdGhlIGRhdGEgc291cmNlLCBvciB3aWxsIGJlIGFuIGFycmF5IGlmIHVzaW5nIERPTSBhIGRhdGFcblx0ICogc291cmNlLlxuXHQgKi9cblx0XCJfYURhdGFcIjogW10sXG5cblx0LyoqXG5cdCAqIFNvcnRpbmcgZGF0YSBjYWNoZSAtIHRoaXMgYXJyYXkgaXMgb3N0ZW5zaWJseSB0aGUgc2FtZSBsZW5ndGggYXMgdGhlXG5cdCAqIG51bWJlciBvZiBjb2x1bW5zIChhbHRob3VnaCBlYWNoIGluZGV4IGlzIGdlbmVyYXRlZCBvbmx5IGFzIGl0IGlzXG5cdCAqIG5lZWRlZCksIGFuZCBob2xkcyB0aGUgZGF0YSB0aGF0IGlzIHVzZWQgZm9yIHNvcnRpbmcgZWFjaCBjb2x1bW4gaW4gdGhlXG5cdCAqIHJvdy4gV2UgZG8gdGhpcyBjYWNoZSBnZW5lcmF0aW9uIGF0IHRoZSBzdGFydCBvZiB0aGUgc29ydCBpbiBvcmRlciB0aGF0XG5cdCAqIHRoZSBmb3JtYXR0aW5nIG9mIHRoZSBzb3J0IGRhdGEgbmVlZCBiZSBkb25lIG9ubHkgb25jZSBmb3IgZWFjaCBjZWxsXG5cdCAqIHBlciBzb3J0LiBUaGlzIGFycmF5IHNob3VsZCBub3QgYmUgcmVhZCBmcm9tIG9yIHdyaXR0ZW4gdG8gYnkgYW55dGhpbmdcblx0ICogb3RoZXIgdGhhbiB0aGUgbWFzdGVyIHNvcnRpbmcgbWV0aG9kcy5cblx0ICovXG5cdFwiX2FTb3J0RGF0YVwiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBQZXIgY2VsbCBmaWx0ZXJpbmcgZGF0YSBjYWNoZS4gQXMgcGVyIHRoZSBzb3J0IGRhdGEgY2FjaGUsIHVzZWQgdG9cblx0ICogaW5jcmVhc2UgdGhlIHBlcmZvcm1hbmNlIG9mIHRoZSBmaWx0ZXJpbmcgaW4gRGF0YVRhYmxlc1xuXHQgKi9cblx0XCJfYUZpbHRlckRhdGFcIjogbnVsbCxcblxuXHQvKipcblx0ICogRmlsdGVyaW5nIGRhdGEgY2FjaGUuIFRoaXMgaXMgdGhlIHNhbWUgYXMgdGhlIGNlbGwgZmlsdGVyaW5nIGNhY2hlLCBidXRcblx0ICogaW4gdGhpcyBjYXNlIGEgc3RyaW5nIHJhdGhlciB0aGFuIGFuIGFycmF5LiBUaGlzIGlzIGVhc2lseSBjb21wdXRlZCB3aXRoXG5cdCAqIGEgam9pbiBvbiBgX2FGaWx0ZXJEYXRhYCwgYnV0IGlzIHByb3ZpZGVkIGFzIGEgY2FjaGUgc28gdGhlIGpvaW4gaXNuJ3Rcblx0ICogbmVlZGVkIG9uIGV2ZXJ5IHNlYXJjaCAobWVtb3J5IHRyYWRlZCBmb3IgcGVyZm9ybWFuY2UpXG5cdCAqL1xuXHRcIl9zRmlsdGVyUm93XCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIERlbm90ZSBpZiB0aGUgb3JpZ2luYWwgZGF0YSBzb3VyY2Ugd2FzIGZyb20gdGhlIERPTSwgb3IgdGhlIGRhdGEgc291cmNlXG5cdCAqIG9iamVjdC4gVGhpcyBpcyB1c2VkIGZvciBpbnZhbGlkYXRpbmcgZGF0YSwgc28gRGF0YVRhYmxlcyBjYW5cblx0ICogYXV0b21hdGljYWxseSByZWFkIGRhdGEgZnJvbSB0aGUgb3JpZ2luYWwgc291cmNlLCB1bmxlc3MgdW5pbnN0cnVjdGVkXG5cdCAqIG90aGVyd2lzZS5cblx0ICovXG5cdFwic3JjXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIEluZGV4IGluIHRoZSBhb0RhdGEgYXJyYXkuIFRoaXMgc2F2ZXMgYW4gaW5kZXhPZiBsb29rdXAgd2hlbiB3ZSBoYXZlIHRoZVxuXHQgKiBvYmplY3QsIGJ1dCB3YW50IHRvIGtub3cgdGhlIGluZGV4XG5cdCAqL1xuXHRcImlkeFwiOiAtMSxcblxuXHQvKipcblx0ICogQ2FjaGVkIGRpc3BsYXkgdmFsdWVcblx0ICovXG5cdGRpc3BsYXlEYXRhOiBudWxsXG59O1xuXG5cbi8qKlxuICogVGVtcGxhdGUgb2JqZWN0IGZvciB0aGUgY29sdW1uIGluZm9ybWF0aW9uIG9iamVjdCBpbiBEYXRhVGFibGVzLiBUaGlzIG9iamVjdFxuICogaXMgaGVsZCBpbiB0aGUgc2V0dGluZ3MgYW9Db2x1bW5zIGFycmF5IGFuZCBjb250YWlucyBhbGwgdGhlIGluZm9ybWF0aW9uIHRoYXRcbiAqIERhdGFUYWJsZXMgbmVlZHMgYWJvdXQgZWFjaCBpbmRpdmlkdWFsIGNvbHVtbi5cbiAqXG4gKiBOb3RlIHRoYXQgdGhpcyBvYmplY3QgaXMgcmVsYXRlZCB0byB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbn1cbiAqIGJ1dCB0aGlzIG9uZSBpcyB0aGUgaW50ZXJuYWwgZGF0YSBzdG9yZSBmb3IgRGF0YVRhYmxlcydzIGNhY2hlIG9mIGNvbHVtbnMuXG4gKiBJdCBzaG91bGQgTk9UIGJlIG1hbmlwdWxhdGVkIG91dHNpZGUgb2YgRGF0YVRhYmxlcy4gQW55IGNvbmZpZ3VyYXRpb24gc2hvdWxkXG4gKiBiZSBkb25lIHRocm91Z2ggdGhlIGluaXRpYWxpc2F0aW9uIG9wdGlvbnMuXG4gKiAgQG5hbWVzcGFjZVxuICovXG5EYXRhVGFibGUubW9kZWxzLm9Db2x1bW4gPSB7XG5cdC8qKlxuXHQgKiBDb2x1bW4gaW5kZXguXG5cdCAqL1xuXHRcImlkeFwiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBBIGxpc3Qgb2YgdGhlIGNvbHVtbnMgdGhhdCBzb3J0aW5nIHNob3VsZCBvY2N1ciBvbiB3aGVuIHRoaXMgY29sdW1uXG5cdCAqIGlzIHNvcnRlZC4gVGhhdCB0aGlzIHByb3BlcnR5IGlzIGFuIGFycmF5IGFsbG93cyBtdWx0aS1jb2x1bW4gc29ydGluZ1xuXHQgKiB0byBiZSBkZWZpbmVkIGZvciBhIGNvbHVtbiAoZm9yIGV4YW1wbGUgZmlyc3QgbmFtZSAvIGxhc3QgbmFtZSBjb2x1bW5zXG5cdCAqIHdvdWxkIGJlbmVmaXQgZnJvbSB0aGlzKS4gVGhlIHZhbHVlcyBhcmUgaW50ZWdlcnMgcG9pbnRpbmcgdG8gdGhlXG5cdCAqIGNvbHVtbnMgdG8gYmUgc29ydGVkIG9uICh0eXBpY2FsbHkgaXQgd2lsbCBiZSBhIHNpbmdsZSBpbnRlZ2VyIHBvaW50aW5nXG5cdCAqIGF0IGl0c2VsZiwgYnV0IHRoYXQgZG9lc24ndCBuZWVkIHRvIGJlIHRoZSBjYXNlKS5cblx0ICovXG5cdFwiYURhdGFTb3J0XCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIERlZmluZSB0aGUgc29ydGluZyBkaXJlY3Rpb25zIHRoYXQgYXJlIGFwcGxpZWQgdG8gdGhlIGNvbHVtbiwgaW4gc2VxdWVuY2Vcblx0ICogYXMgdGhlIGNvbHVtbiBpcyByZXBlYXRlZGx5IHNvcnRlZCB1cG9uIC0gaS5lLiB0aGUgZmlyc3QgdmFsdWUgaXMgdXNlZFxuXHQgKiBhcyB0aGUgc29ydGluZyBkaXJlY3Rpb24gd2hlbiB0aGUgY29sdW1uIGlmIGZpcnN0IHNvcnRlZCAoY2xpY2tlZCBvbikuXG5cdCAqIFNvcnQgaXQgYWdhaW4gKGNsaWNrIGFnYWluKSBhbmQgaXQgd2lsbCBtb3ZlIG9uIHRvIHRoZSBuZXh0IGluZGV4LlxuXHQgKiBSZXBlYXQgdW50aWwgbG9vcC5cblx0ICovXG5cdFwiYXNTb3J0aW5nXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIEZsYWcgdG8gaW5kaWNhdGUgaWYgdGhlIGNvbHVtbiBpcyBzZWFyY2hhYmxlLCBhbmQgdGh1cyBzaG91bGQgYmUgaW5jbHVkZWRcblx0ICogaW4gdGhlIGZpbHRlcmluZyBvciBub3QuXG5cdCAqL1xuXHRcImJTZWFyY2hhYmxlXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIEZsYWcgdG8gaW5kaWNhdGUgaWYgdGhlIGNvbHVtbiBpcyBzb3J0YWJsZSBvciBub3QuXG5cdCAqL1xuXHRcImJTb3J0YWJsZVwiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBGbGFnIHRvIGluZGljYXRlIGlmIHRoZSBjb2x1bW4gaXMgY3VycmVudGx5IHZpc2libGUgaW4gdGhlIHRhYmxlIG9yIG5vdFxuXHQgKi9cblx0XCJiVmlzaWJsZVwiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBTdG9yZSBmb3IgbWFudWFsIHR5cGUgYXNzaWdubWVudCB1c2luZyB0aGUgYGNvbHVtbi50eXBlYCBvcHRpb24uIFRoaXNcblx0ICogaXMgaGVsZCBpbiBzdG9yZSBzbyB3ZSBjYW4gbWFuaXB1bGF0ZSB0aGUgY29sdW1uJ3MgYHNUeXBlYCBwcm9wZXJ0eS5cblx0ICovXG5cdFwiX3NNYW51YWxUeXBlXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIEZsYWcgdG8gaW5kaWNhdGUgaWYgSFRNTDUgZGF0YSBhdHRyaWJ1dGVzIHNob3VsZCBiZSB1c2VkIGFzIHRoZSBkYXRhXG5cdCAqIHNvdXJjZSBmb3IgZmlsdGVyaW5nIG9yIHNvcnRpbmcuIFRydWUgaXMgZWl0aGVyIGFyZS5cblx0ICovXG5cdFwiX2JBdHRyU3JjXCI6IGZhbHNlLFxuXG5cdC8qKlxuXHQgKiBEZXZlbG9wZXIgZGVmaW5hYmxlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW5ldmVyIGEgY2VsbCBpcyBjcmVhdGVkIChBamF4IHNvdXJjZSxcblx0ICogZXRjKSBvciBwcm9jZXNzZWQgZm9yIGlucHV0IChET00gc291cmNlKS4gVGhpcyBjYW4gYmUgdXNlZCBhcyBhIGNvbXBsaW1lbnQgdG8gbVJlbmRlclxuXHQgKiBhbGxvd2luZyB5b3UgdG8gbW9kaWZ5IHRoZSBET00gZWxlbWVudCAoYWRkIGJhY2tncm91bmQgY29sb3VyIGZvciBleGFtcGxlKSB3aGVuIHRoZVxuXHQgKiBlbGVtZW50IGlzIGF2YWlsYWJsZS5cblx0ICovXG5cdFwiZm5DcmVhdGVkQ2VsbFwiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBGdW5jdGlvbiB0byBnZXQgZGF0YSBmcm9tIGEgY2VsbCBpbiBhIGNvbHVtbi4gWW91IHNob3VsZCA8Yj5uZXZlcjwvYj5cblx0ICogYWNjZXNzIGRhdGEgZGlyZWN0bHkgdGhyb3VnaCBfYURhdGEgaW50ZXJuYWxseSBpbiBEYXRhVGFibGVzIC0gYWx3YXlzIHVzZVxuXHQgKiB0aGUgbWV0aG9kIGF0dGFjaGVkIHRvIHRoaXMgcHJvcGVydHkuIEl0IGFsbG93cyBtRGF0YSB0byBmdW5jdGlvbiBhc1xuXHQgKiByZXF1aXJlZC4gVGhpcyBmdW5jdGlvbiBpcyBhdXRvbWF0aWNhbGx5IGFzc2lnbmVkIGJ5IHRoZSBjb2x1bW5cblx0ICogaW5pdGlhbGlzYXRpb24gbWV0aG9kXG5cdCAqL1xuXHRcImZuR2V0RGF0YVwiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBGdW5jdGlvbiB0byBzZXQgZGF0YSBmb3IgYSBjZWxsIGluIHRoZSBjb2x1bW4uIFlvdSBzaG91bGQgPGI+bmV2ZXI8L2I+XG5cdCAqIHNldCB0aGUgZGF0YSBkaXJlY3RseSB0byBfYURhdGEgaW50ZXJuYWxseSBpbiBEYXRhVGFibGVzIC0gYWx3YXlzIHVzZVxuXHQgKiB0aGlzIG1ldGhvZC4gSXQgYWxsb3dzIG1EYXRhIHRvIGZ1bmN0aW9uIGFzIHJlcXVpcmVkLiBUaGlzIGZ1bmN0aW9uXG5cdCAqIGlzIGF1dG9tYXRpY2FsbHkgYXNzaWduZWQgYnkgdGhlIGNvbHVtbiBpbml0aWFsaXNhdGlvbiBtZXRob2Rcblx0ICovXG5cdFwiZm5TZXREYXRhXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIFByb3BlcnR5IHRvIHJlYWQgdGhlIHZhbHVlIGZvciB0aGUgY2VsbHMgaW4gdGhlIGNvbHVtbiBmcm9tIHRoZSBkYXRhXG5cdCAqIHNvdXJjZSBhcnJheSAvIG9iamVjdC4gSWYgbnVsbCwgdGhlbiB0aGUgZGVmYXVsdCBjb250ZW50IGlzIHVzZWQsIGlmIGFcblx0ICogZnVuY3Rpb24gaXMgZ2l2ZW4gdGhlbiB0aGUgcmV0dXJuIGZyb20gdGhlIGZ1bmN0aW9uIGlzIHVzZWQuXG5cdCAqL1xuXHRcIm1EYXRhXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIFBhcnRuZXIgcHJvcGVydHkgdG8gbURhdGEgd2hpY2ggaXMgdXNlZCAob25seSB3aGVuIGRlZmluZWQpIHRvIGdldFxuXHQgKiB0aGUgZGF0YSAtIGkuZS4gaXQgaXMgYmFzaWNhbGx5IHRoZSBzYW1lIGFzIG1EYXRhLCBidXQgd2l0aG91dCB0aGVcblx0ICogJ3NldCcgb3B0aW9uLCBhbmQgYWxzbyB0aGUgZGF0YSBmZWQgdG8gaXQgaXMgdGhlIHJlc3VsdCBmcm9tIG1EYXRhLlxuXHQgKiBUaGlzIGlzIHRoZSByZW5kZXJpbmcgbWV0aG9kIHRvIG1hdGNoIHRoZSBkYXRhIG1ldGhvZCBvZiBtRGF0YS5cblx0ICovXG5cdFwibVJlbmRlclwiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBUaGUgY2xhc3MgdG8gYXBwbHkgdG8gYWxsIFREIGVsZW1lbnRzIGluIHRoZSB0YWJsZSdzIFRCT0RZIGZvciB0aGUgY29sdW1uXG5cdCAqL1xuXHRcInNDbGFzc1wiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBXaGVuIERhdGFUYWJsZXMgY2FsY3VsYXRlcyB0aGUgY29sdW1uIHdpZHRocyB0byBhc3NpZ24gdG8gZWFjaCBjb2x1bW4sXG5cdCAqIGl0IGZpbmRzIHRoZSBsb25nZXN0IHN0cmluZyBpbiBlYWNoIGNvbHVtbiBhbmQgdGhlbiBjb25zdHJ1Y3RzIGFcblx0ICogdGVtcG9yYXJ5IHRhYmxlIGFuZCByZWFkcyB0aGUgd2lkdGhzIGZyb20gdGhhdC4gVGhlIHByb2JsZW0gd2l0aCB0aGlzXG5cdCAqIGlzIHRoYXQgXCJtbW1cIiBpcyBtdWNoIHdpZGVyIHRoZW4gXCJpaWlpXCIsIGJ1dCB0aGUgbGF0dGVyIGlzIGEgbG9uZ2VyXG5cdCAqIHN0cmluZyAtIHRodXMgdGhlIGNhbGN1bGF0aW9uIGNhbiBnbyB3cm9uZyAoZG9pbmcgaXQgcHJvcGVybHkgYW5kIHB1dHRpbmdcblx0ICogaXQgaW50byBhbiBET00gb2JqZWN0IGFuZCBtZWFzdXJpbmcgdGhhdCBpcyBob3JyaWJseSghKSBzbG93KS4gVGh1cyBhc1xuXHQgKiBhIFwid29yayBhcm91bmRcIiB3ZSBwcm92aWRlIHRoaXMgb3B0aW9uLiBJdCB3aWxsIGFwcGVuZCBpdHMgdmFsdWUgdG8gdGhlXG5cdCAqIHRleHQgdGhhdCBpcyBmb3VuZCB0byBiZSB0aGUgbG9uZ2VzdCBzdHJpbmcgZm9yIHRoZSBjb2x1bW4gLSBpLmUuIHBhZGRpbmcuXG5cdCAqL1xuXHRcInNDb250ZW50UGFkZGluZ1wiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBBbGxvd3MgYSBkZWZhdWx0IHZhbHVlIHRvIGJlIGdpdmVuIGZvciBhIGNvbHVtbidzIGRhdGEsIGFuZCB3aWxsIGJlIHVzZWRcblx0ICogd2hlbmV2ZXIgYSBudWxsIGRhdGEgc291cmNlIGlzIGVuY291bnRlcmVkICh0aGlzIGNhbiBiZSBiZWNhdXNlIG1EYXRhXG5cdCAqIGlzIHNldCB0byBudWxsLCBvciBiZWNhdXNlIHRoZSBkYXRhIHNvdXJjZSBpdHNlbGYgaXMgbnVsbCkuXG5cdCAqL1xuXHRcInNEZWZhdWx0Q29udGVudFwiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBOYW1lIGZvciB0aGUgY29sdW1uLCBhbGxvd2luZyByZWZlcmVuY2UgdG8gdGhlIGNvbHVtbiBieSBuYW1lIGFzIHdlbGwgYXNcblx0ICogYnkgaW5kZXggKG5lZWRzIGEgbG9va3VwIHRvIHdvcmsgYnkgbmFtZSkuXG5cdCAqL1xuXHRcInNOYW1lXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIEN1c3RvbSBzb3J0aW5nIGRhdGEgdHlwZSAtIGRlZmluZXMgd2hpY2ggb2YgdGhlIGF2YWlsYWJsZSBwbHVnLWlucyBpblxuXHQgKiBhZm5Tb3J0RGF0YSB0aGUgY3VzdG9tIHNvcnRpbmcgd2lsbCB1c2UgLSBpZiBhbnkgaXMgZGVmaW5lZC5cblx0ICovXG5cdFwic1NvcnREYXRhVHlwZVwiOiAnc3RkJyxcblxuXHQvKipcblx0ICogQ2xhc3MgdG8gYmUgYXBwbGllZCB0byB0aGUgaGVhZGVyIGVsZW1lbnQgd2hlbiBzb3J0aW5nIG9uIHRoaXMgY29sdW1uXG5cdCAqL1xuXHRcInNTb3J0aW5nQ2xhc3NcIjogbnVsbCxcblxuXHQvKipcblx0ICogVGl0bGUgb2YgdGhlIGNvbHVtbiAtIHdoYXQgaXMgc2VlbiBpbiB0aGUgVEggZWxlbWVudCAoblRoKS5cblx0ICovXG5cdFwic1RpdGxlXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIENvbHVtbiBzb3J0aW5nIGFuZCBmaWx0ZXJpbmcgdHlwZVxuXHQgKi9cblx0XCJzVHlwZVwiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBXaWR0aCBvZiB0aGUgY29sdW1uXG5cdCAqL1xuXHRcInNXaWR0aFwiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBXaWR0aCBvZiB0aGUgY29sdW1uIHdoZW4gaXQgd2FzIGZpcnN0IFwiZW5jb3VudGVyZWRcIlxuXHQgKi9cblx0XCJzV2lkdGhPcmlnXCI6IG51bGwsXG5cblx0LyoqIENhY2hlZCBzdHJpbmcgd2hpY2ggaXMgdGhlIGxvbmdlc3QgaW4gdGhlIGNvbHVtbiAqL1xuXHRtYXhMZW5TdHJpbmc6IG51bGwsXG5cblx0LyoqXG5cdCAqIFN0b3JlIGZvciBuYW1lZCBzZWFyY2hlc1xuXHQgKi9cblx0c2VhcmNoRml4ZWQ6IG51bGxcbn07XG5cblxuLypcbiAqIERldmVsb3BlciBub3RlOiBUaGUgcHJvcGVydGllcyBvZiB0aGUgb2JqZWN0IGJlbG93IGFyZSBnaXZlbiBpbiBIdW5nYXJpYW5cbiAqIG5vdGF0aW9uLCB0aGF0IHdhcyB1c2VkIGFzIHRoZSBpbnRlcmZhY2UgZm9yIERhdGFUYWJsZXMgcHJpb3IgdG8gdjEuMTAsIGhvd2V2ZXJcbiAqIGZyb20gdjEuMTAgb253YXJkcyB0aGUgcHJpbWFyeSBpbnRlcmZhY2UgaXMgY2FtZWwgY2FzZS4gSW4gb3JkZXIgdG8gYXZvaWRcbiAqIGJyZWFraW5nIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHV0dGVybHkgd2l0aCB0aGlzIGNoYW5nZSwgdGhlIEh1bmdhcmlhblxuICogdmVyc2lvbiBpcyBzdGlsbCwgaW50ZXJuYWxseSB0aGUgcHJpbWFyeSBpbnRlcmZhY2UsIGJ1dCBpcyBpcyBub3QgZG9jdW1lbnRlZFxuICogLSBoZW5jZSB0aGUgQG5hbWUgdGFncyBpbiBlYWNoIGRvYyBjb21tZW50LiBUaGlzIGFsbG93cyBhIEphdmFzY3JpcHQgZnVuY3Rpb25cbiAqIHRvIGNyZWF0ZSBhIG1hcCBmcm9tIEh1bmdhcmlhbiBub3RhdGlvbiB0byBjYW1lbCBjYXNlIChnb2luZyB0aGUgb3RoZXIgZGlyZWN0aW9uXG4gKiB3b3VsZCByZXF1aXJlIGVhY2ggcHJvcGVydHkgdG8gYmUgbGlzdGVkLCB3aGljaCB3b3VsZCBhZGQgYXJvdW5kIDNLIHRvIHRoZSBzaXplXG4gKiBvZiBEYXRhVGFibGVzLCB3aGlsZSB0aGlzIG1ldGhvZCBpcyBhYm91dCBhIDAuNUsgaGl0KS5cbiAqXG4gKiBVbHRpbWF0ZWx5IHRoaXMgZG9lcyBwYXZlIHRoZSB3YXkgZm9yIEh1bmdhcmlhbiBub3RhdGlvbiB0byBiZSBkcm9wcGVkXG4gKiBjb21wbGV0ZWx5LCBidXQgdGhhdCBpcyBhIG1hc3NpdmUgYW1vdW50IG9mIHdvcmsgYW5kIHdpbGwgYnJlYWsgY3VycmVudFxuICogaW5zdGFsbHMgKHRoZXJlZm9yZSBpcyBvbi1ob2xkIHVudGlsIHYyKS5cbiAqL1xuXG4vKipcbiAqIEluaXRpYWxpc2F0aW9uIG9wdGlvbnMgdGhhdCBjYW4gYmUgZ2l2ZW4gdG8gRGF0YVRhYmxlcyBhdCBpbml0aWFsaXNhdGlvblxuICogdGltZS5cbiAqICBAbmFtZXNwYWNlXG4gKi9cbkRhdGFUYWJsZS5kZWZhdWx0cyA9IHtcblx0LyoqXG5cdCAqIEFuIGFycmF5IG9mIGRhdGEgdG8gdXNlIGZvciB0aGUgdGFibGUsIHBhc3NlZCBpbiBhdCBpbml0aWFsaXNhdGlvbiB3aGljaFxuXHQgKiB3aWxsIGJlIHVzZWQgaW4gcHJlZmVyZW5jZSB0byBhbnkgZGF0YSB3aGljaCBpcyBhbHJlYWR5IGluIHRoZSBET00uIFRoaXMgaXNcblx0ICogcGFydGljdWxhcmx5IHVzZWZ1bCBmb3IgY29uc3RydWN0aW5nIHRhYmxlcyBwdXJlbHkgaW4gSmF2YXNjcmlwdCwgZm9yXG5cdCAqIGV4YW1wbGUgd2l0aCBhIGN1c3RvbSBBamF4IGNhbGwuXG5cdCAqL1xuXHRcImFhRGF0YVwiOiBudWxsLFxuXG5cblx0LyoqXG5cdCAqIElmIG9yZGVyaW5nIGlzIGVuYWJsZWQsIHRoZW4gRGF0YVRhYmxlcyB3aWxsIHBlcmZvcm0gYSBmaXJzdCBwYXNzIHNvcnQgb25cblx0ICogaW5pdGlhbGlzYXRpb24uIFlvdSBjYW4gZGVmaW5lIHdoaWNoIGNvbHVtbihzKSB0aGUgc29ydCBpcyBwZXJmb3JtZWRcblx0ICogdXBvbiwgYW5kIHRoZSBzb3J0aW5nIGRpcmVjdGlvbiwgd2l0aCB0aGlzIHZhcmlhYmxlLiBUaGUgYHNvcnRpbmdgIGFycmF5XG5cdCAqIHNob3VsZCBjb250YWluIGFuIGFycmF5IGZvciBlYWNoIGNvbHVtbiB0byBiZSBzb3J0ZWQgaW5pdGlhbGx5IGNvbnRhaW5pbmdcblx0ICogdGhlIGNvbHVtbidzIGluZGV4IGFuZCBhIGRpcmVjdGlvbiBzdHJpbmcgKCdhc2MnIG9yICdkZXNjJykuXG5cdCAqL1xuXHRcImFhU29ydGluZ1wiOiBbWzAsJ2FzYyddXSxcblxuXG5cdC8qKlxuXHQgKiBUaGlzIHBhcmFtZXRlciBpcyBiYXNpY2FsbHkgaWRlbnRpY2FsIHRvIHRoZSBgc29ydGluZ2AgcGFyYW1ldGVyLCBidXRcblx0ICogY2Fubm90IGJlIG92ZXJyaWRkZW4gYnkgdXNlciBpbnRlcmFjdGlvbiB3aXRoIHRoZSB0YWJsZS4gV2hhdCB0aGlzIG1lYW5zXG5cdCAqIGlzIHRoYXQgeW91IGNvdWxkIGhhdmUgYSBjb2x1bW4gKHZpc2libGUgb3IgaGlkZGVuKSB3aGljaCB0aGUgc29ydGluZ1xuXHQgKiB3aWxsIGFsd2F5cyBiZSBmb3JjZWQgb24gZmlyc3QgLSBhbnkgc29ydGluZyBhZnRlciB0aGF0IChmcm9tIHRoZSB1c2VyKVxuXHQgKiB3aWxsIHRoZW4gYmUgcGVyZm9ybWVkIGFzIHJlcXVpcmVkLiBUaGlzIGNhbiBiZSB1c2VmdWwgZm9yIGdyb3VwaW5nIHJvd3Ncblx0ICogdG9nZXRoZXIuXG5cdCAqL1xuXHRcImFhU29ydGluZ0ZpeGVkXCI6IFtdLFxuXG5cblx0LyoqXG5cdCAqIERhdGFUYWJsZXMgY2FuIGJlIGluc3RydWN0ZWQgdG8gbG9hZCBkYXRhIHRvIGRpc3BsYXkgaW4gdGhlIHRhYmxlIGZyb20gYVxuXHQgKiBBamF4IHNvdXJjZS4gVGhpcyBvcHRpb24gZGVmaW5lcyBob3cgdGhhdCBBamF4IGNhbGwgaXMgbWFkZSBhbmQgd2hlcmUgdG8uXG5cdCAqXG5cdCAqIFRoZSBgYWpheGAgcHJvcGVydHkgaGFzIHRocmVlIGRpZmZlcmVudCBtb2RlcyBvZiBvcGVyYXRpb24sIGRlcGVuZGluZyBvblxuXHQgKiBob3cgaXQgaXMgZGVmaW5lZC4gVGhlc2UgYXJlOlxuXHQgKlxuXHQgKiAqIGBzdHJpbmdgIC0gU2V0IHRoZSBVUkwgZnJvbSB3aGVyZSB0aGUgZGF0YSBzaG91bGQgYmUgbG9hZGVkIGZyb20uXG5cdCAqICogYG9iamVjdGAgLSBEZWZpbmUgcHJvcGVydGllcyBmb3IgYGpRdWVyeS5hamF4YC5cblx0ICogKiBgZnVuY3Rpb25gIC0gQ3VzdG9tIGRhdGEgZ2V0IGZ1bmN0aW9uXG5cdCAqXG5cdCAqIGBzdHJpbmdgXG5cdCAqIC0tLS0tLS0tXG5cdCAqXG5cdCAqIEFzIGEgc3RyaW5nLCB0aGUgYGFqYXhgIHByb3BlcnR5IHNpbXBseSBkZWZpbmVzIHRoZSBVUkwgZnJvbSB3aGljaFxuXHQgKiBEYXRhVGFibGVzIHdpbGwgbG9hZCBkYXRhLlxuXHQgKlxuXHQgKiBgb2JqZWN0YFxuXHQgKiAtLS0tLS0tLVxuXHQgKlxuXHQgKiBBcyBhbiBvYmplY3QsIHRoZSBwYXJhbWV0ZXJzIGluIHRoZSBvYmplY3QgYXJlIHBhc3NlZCB0b1xuXHQgKiBbalF1ZXJ5LmFqYXhdKGh0dHBzOi8vYXBpLmpxdWVyeS5jb20valF1ZXJ5LmFqYXgvKSBhbGxvd2luZyBmaW5lIGNvbnRyb2xcblx0ICogb2YgdGhlIEFqYXggcmVxdWVzdC4gRGF0YVRhYmxlcyBoYXMgYSBudW1iZXIgb2YgZGVmYXVsdCBwYXJhbWV0ZXJzIHdoaWNoXG5cdCAqIHlvdSBjYW4gb3ZlcnJpZGUgdXNpbmcgdGhpcyBvcHRpb24uIFBsZWFzZSByZWZlciB0byB0aGUgalF1ZXJ5XG5cdCAqIGRvY3VtZW50YXRpb24gZm9yIGEgZnVsbCBkZXNjcmlwdGlvbiBvZiB0aGUgb3B0aW9ucyBhdmFpbGFibGUsIGFsdGhvdWdoXG5cdCAqIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVycyBwcm92aWRlIGFkZGl0aW9uYWwgb3B0aW9ucyBpbiBEYXRhVGFibGVzIG9yXG5cdCAqIHJlcXVpcmUgc3BlY2lhbCBjb25zaWRlcmF0aW9uOlxuXHQgKlxuXHQgKiAqIGBkYXRhYCAtIEFzIHdpdGggalF1ZXJ5LCBgZGF0YWAgY2FuIGJlIHByb3ZpZGVkIGFzIGFuIG9iamVjdCwgYnV0IGl0XG5cdCAqICAgY2FuIGFsc28gYmUgdXNlZCBhcyBhIGZ1bmN0aW9uIHRvIG1hbmlwdWxhdGUgdGhlIGRhdGEgRGF0YVRhYmxlcyBzZW5kc1xuXHQgKiAgIHRvIHRoZSBzZXJ2ZXIuIFRoZSBmdW5jdGlvbiB0YWtlcyBhIHNpbmdsZSBwYXJhbWV0ZXIsIGFuIG9iamVjdCBvZlxuXHQgKiAgIHBhcmFtZXRlcnMgd2l0aCB0aGUgdmFsdWVzIHRoYXQgRGF0YVRhYmxlcyBoYXMgcmVhZGllZCBmb3Igc2VuZGluZy4gQW5cblx0ICogICBvYmplY3QgbWF5IGJlIHJldHVybmVkIHdoaWNoIHdpbGwgYmUgbWVyZ2VkIGludG8gdGhlIERhdGFUYWJsZXNcblx0ICogICBkZWZhdWx0cywgb3IgeW91IGNhbiBhZGQgdGhlIGl0ZW1zIHRvIHRoZSBvYmplY3QgdGhhdCB3YXMgcGFzc2VkIGluIGFuZFxuXHQgKiAgIG5vdCByZXR1cm4gYW55dGhpbmcgZnJvbSB0aGUgZnVuY3Rpb24uIFRoaXMgc3VwZXJzZWRlcyBgZm5TZXJ2ZXJQYXJhbXNgXG5cdCAqICAgZnJvbSBEYXRhVGFibGVzIDEuOS0uXG5cdCAqXG5cdCAqICogYGRhdGFTcmNgIC0gQnkgZGVmYXVsdCBEYXRhVGFibGVzIHdpbGwgbG9vayBmb3IgdGhlIHByb3BlcnR5IGBkYXRhYCAob3Jcblx0ICogICBgYWFEYXRhYCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIERhdGFUYWJsZXMgMS45LSkgd2hlbiBvYnRhaW5pbmcgZGF0YVxuXHQgKiAgIGZyb20gYW4gQWpheCBzb3VyY2Ugb3IgZm9yIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcgLSB0aGlzIHBhcmFtZXRlclxuXHQgKiAgIGFsbG93cyB0aGF0IHByb3BlcnR5IHRvIGJlIGNoYW5nZWQuIFlvdSBjYW4gdXNlIEphdmFzY3JpcHQgZG90dGVkXG5cdCAqICAgb2JqZWN0IG5vdGF0aW9uIHRvIGdldCBhIGRhdGEgc291cmNlIGZvciBtdWx0aXBsZSBsZXZlbHMgb2YgbmVzdGluZywgb3Jcblx0ICogICBpdCBteSBiZSB1c2VkIGFzIGEgZnVuY3Rpb24uIEFzIGEgZnVuY3Rpb24gaXQgdGFrZXMgYSBzaW5nbGUgcGFyYW1ldGVyLFxuXHQgKiAgIHRoZSBKU09OIHJldHVybmVkIGZyb20gdGhlIHNlcnZlciwgd2hpY2ggY2FuIGJlIG1hbmlwdWxhdGVkIGFzXG5cdCAqICAgcmVxdWlyZWQsIHdpdGggdGhlIHJldHVybmVkIHZhbHVlIGJlaW5nIHRoYXQgdXNlZCBieSBEYXRhVGFibGVzIGFzIHRoZVxuXHQgKiAgIGRhdGEgc291cmNlIGZvciB0aGUgdGFibGUuXG5cdCAqXG5cdCAqICogYHN1Y2Nlc3NgIC0gU2hvdWxkIG5vdCBiZSBvdmVycmlkZGVuIGl0IGlzIHVzZWQgaW50ZXJuYWxseSBpblxuXHQgKiAgIERhdGFUYWJsZXMuIFRvIG1hbmlwdWxhdGUgLyB0cmFuc2Zvcm0gdGhlIGRhdGEgcmV0dXJuZWQgYnkgdGhlIHNlcnZlclxuXHQgKiAgIHVzZSBgYWpheC5kYXRhU3JjYCwgb3IgdXNlIGBhamF4YCBhcyBhIGZ1bmN0aW9uIChzZWUgYmVsb3cpLlxuXHQgKlxuXHQgKiBgZnVuY3Rpb25gXG5cdCAqIC0tLS0tLS0tLS1cblx0ICpcblx0ICogQXMgYSBmdW5jdGlvbiwgbWFraW5nIHRoZSBBamF4IGNhbGwgaXMgbGVmdCB1cCB0byB5b3Vyc2VsZiBhbGxvd2luZ1xuXHQgKiBjb21wbGV0ZSBjb250cm9sIG9mIHRoZSBBamF4IHJlcXVlc3QuIEluZGVlZCwgaWYgZGVzaXJlZCwgYSBtZXRob2Qgb3RoZXJcblx0ICogdGhhbiBBamF4IGNvdWxkIGJlIHVzZWQgdG8gb2J0YWluIHRoZSByZXF1aXJlZCBkYXRhLCBzdWNoIGFzIFdlYiBzdG9yYWdlXG5cdCAqIG9yIGFuIEFJUiBkYXRhYmFzZS5cblx0ICpcblx0ICogVGhlIGZ1bmN0aW9uIGlzIGdpdmVuIGZvdXIgcGFyYW1ldGVycyBhbmQgbm8gcmV0dXJuIGlzIHJlcXVpcmVkLiBUaGVcblx0ICogcGFyYW1ldGVycyBhcmU6XG5cdCAqXG5cdCAqIDEuIF9vYmplY3RfIC0gRGF0YSB0byBzZW5kIHRvIHRoZSBzZXJ2ZXJcblx0ICogMi4gX2Z1bmN0aW9uXyAtIENhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgbXVzdCBiZSBleGVjdXRlZCB3aGVuIHRoZSByZXF1aXJlZFxuXHQgKiAgICBkYXRhIGhhcyBiZWVuIG9idGFpbmVkLiBUaGF0IGRhdGEgc2hvdWxkIGJlIHBhc3NlZCBpbnRvIHRoZSBjYWxsYmFja1xuXHQgKiAgICBhcyB0aGUgb25seSBwYXJhbWV0ZXJcblx0ICogMy4gX29iamVjdF8gLSBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdCBmb3IgdGhlIHRhYmxlXG5cdCAqL1xuXHRcImFqYXhcIjogbnVsbCxcblxuXG5cdC8qKlxuXHQgKiBUaGlzIHBhcmFtZXRlciBhbGxvd3MgeW91IHRvIHJlYWRpbHkgc3BlY2lmeSB0aGUgZW50cmllcyBpbiB0aGUgbGVuZ3RoIGRyb3Bcblx0ICogZG93biBtZW51IHRoYXQgRGF0YVRhYmxlcyBzaG93cyB3aGVuIHBhZ2luYXRpb24gaXMgZW5hYmxlZC4gSXQgY2FuIGJlXG5cdCAqIGVpdGhlciBhIDFEIGFycmF5IG9mIG9wdGlvbnMgd2hpY2ggd2lsbCBiZSB1c2VkIGZvciBib3RoIHRoZSBkaXNwbGF5ZWRcblx0ICogb3B0aW9uIGFuZCB0aGUgdmFsdWUsIG9yIGEgMkQgYXJyYXkgd2hpY2ggd2lsbCB1c2UgdGhlIGFycmF5IGluIHRoZSBmaXJzdFxuXHQgKiBwb3NpdGlvbiBhcyB0aGUgdmFsdWUsIGFuZCB0aGUgYXJyYXkgaW4gdGhlIHNlY29uZCBwb3NpdGlvbiBhcyB0aGVcblx0ICogZGlzcGxheWVkIG9wdGlvbnMgKHVzZWZ1bCBmb3IgbGFuZ3VhZ2Ugc3RyaW5ncyBzdWNoIGFzICdBbGwnKS5cblx0ICpcblx0ICogTm90ZSB0aGF0IHRoZSBgcGFnZUxlbmd0aGAgcHJvcGVydHkgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHNldCB0byB0aGVcblx0ICogZmlyc3QgdmFsdWUgZ2l2ZW4gaW4gdGhpcyBhcnJheSwgdW5sZXNzIGBwYWdlTGVuZ3RoYCBpcyBhbHNvIHByb3ZpZGVkLlxuXHQgKi9cblx0XCJhTGVuZ3RoTWVudVwiOiBbIDEwLCAyNSwgNTAsIDEwMCBdLFxuXG5cblx0LyoqXG5cdCAqIFRoZSBgY29sdW1uc2Agb3B0aW9uIGluIHRoZSBpbml0aWFsaXNhdGlvbiBwYXJhbWV0ZXIgYWxsb3dzIHlvdSB0byBkZWZpbmVcblx0ICogZGV0YWlscyBhYm91dCB0aGUgd2F5IGluZGl2aWR1YWwgY29sdW1ucyBiZWhhdmUuIEZvciBhIGZ1bGwgbGlzdCBvZlxuXHQgKiBjb2x1bW4gb3B0aW9ucyB0aGF0IGNhbiBiZSBzZXQsIHBsZWFzZSBzZWVcblx0ICoge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW59LiBOb3RlIHRoYXQgaWYgeW91IHVzZSBgY29sdW1uc2AgdG9cblx0ICogZGVmaW5lIHlvdXIgY29sdW1ucywgeW91IG11c3QgaGF2ZSBhbiBlbnRyeSBpbiB0aGUgYXJyYXkgZm9yIGV2ZXJ5IHNpbmdsZVxuXHQgKiBjb2x1bW4gdGhhdCB5b3UgaGF2ZSBpbiB5b3VyIHRhYmxlICh0aGVzZSBjYW4gYmUgbnVsbCBpZiB5b3UgZG9uJ3Qgd2hpY2hcblx0ICogdG8gc3BlY2lmeSBhbnkgb3B0aW9ucykuXG5cdCAqL1xuXHRcImFvQ29sdW1uc1wiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBWZXJ5IHNpbWlsYXIgdG8gYGNvbHVtbnNgLCBgY29sdW1uRGVmc2AgYWxsb3dzIHlvdSB0byB0YXJnZXQgYSBzcGVjaWZpY1xuXHQgKiBjb2x1bW4sIG11bHRpcGxlIGNvbHVtbnMsIG9yIGFsbCBjb2x1bW5zLCB1c2luZyB0aGUgYHRhcmdldHNgIHByb3BlcnR5IG9mXG5cdCAqIGVhY2ggb2JqZWN0IGluIHRoZSBhcnJheS4gVGhpcyBhbGxvd3MgZ3JlYXQgZmxleGliaWxpdHkgd2hlbiBjcmVhdGluZ1xuXHQgKiB0YWJsZXMsIGFzIHRoZSBgY29sdW1uRGVmc2AgYXJyYXlzIGNhbiBiZSBvZiBhbnkgbGVuZ3RoLCB0YXJnZXRpbmcgdGhlXG5cdCAqIGNvbHVtbnMgeW91IHNwZWNpZmljYWxseSB3YW50LiBgY29sdW1uRGVmc2AgbWF5IHVzZSBhbnkgb2YgdGhlIGNvbHVtblxuXHQgKiBvcHRpb25zIGF2YWlsYWJsZToge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW59LCBidXQgaXQgX211c3RfXG5cdCAqIGhhdmUgYHRhcmdldHNgIGRlZmluZWQgaW4gZWFjaCBvYmplY3QgaW4gdGhlIGFycmF5LiBWYWx1ZXMgaW4gdGhlIGB0YXJnZXRzYFxuXHQgKiBhcnJheSBtYXkgYmU6XG5cdCAqICAgPHVsPlxuXHQgKiAgICAgPGxpPmEgc3RyaW5nIC0gY2xhc3MgbmFtZSB3aWxsIGJlIG1hdGNoZWQgb24gdGhlIFRIIGZvciB0aGUgY29sdW1uPC9saT5cblx0ICogICAgIDxsaT4wIG9yIGEgcG9zaXRpdmUgaW50ZWdlciAtIGNvbHVtbiBpbmRleCBjb3VudGluZyBmcm9tIHRoZSBsZWZ0PC9saT5cblx0ICogICAgIDxsaT5hIG5lZ2F0aXZlIGludGVnZXIgLSBjb2x1bW4gaW5kZXggY291bnRpbmcgZnJvbSB0aGUgcmlnaHQ8L2xpPlxuXHQgKiAgICAgPGxpPnRoZSBzdHJpbmcgXCJfYWxsXCIgLSBhbGwgY29sdW1ucyAoaS5lLiBhc3NpZ24gYSBkZWZhdWx0KTwvbGk+XG5cdCAqICAgPC91bD5cblx0ICovXG5cdFwiYW9Db2x1bW5EZWZzXCI6IG51bGwsXG5cblxuXHQvKipcblx0ICogQmFzaWNhbGx5IHRoZSBzYW1lIGFzIGBzZWFyY2hgLCB0aGlzIHBhcmFtZXRlciBkZWZpbmVzIHRoZSBpbmRpdmlkdWFsIGNvbHVtblxuXHQgKiBmaWx0ZXJpbmcgc3RhdGUgYXQgaW5pdGlhbGlzYXRpb24gdGltZS4gVGhlIGFycmF5IG11c3QgYmUgb2YgdGhlIHNhbWUgc2l6ZVxuXHQgKiBhcyB0aGUgbnVtYmVyIG9mIGNvbHVtbnMsIGFuZCBlYWNoIGVsZW1lbnQgYmUgYW4gb2JqZWN0IHdpdGggdGhlIHBhcmFtZXRlcnNcblx0ICogYHNlYXJjaGAgYW5kIGBlc2NhcGVSZWdleGAgKHRoZSBsYXR0ZXIgaXMgb3B0aW9uYWwpLiAnbnVsbCcgaXMgYWxzb1xuXHQgKiBhY2NlcHRlZCBhbmQgdGhlIGRlZmF1bHQgd2lsbCBiZSB1c2VkLlxuXHQgKi9cblx0XCJhb1NlYXJjaENvbHNcIjogW10sXG5cblxuXHQvKipcblx0ICogRW5hYmxlIG9yIGRpc2FibGUgYXV0b21hdGljIGNvbHVtbiB3aWR0aCBjYWxjdWxhdGlvbi4gVGhpcyBjYW4gYmUgZGlzYWJsZWRcblx0ICogYXMgYW4gb3B0aW1pc2F0aW9uIChpdCB0YWtlcyBzb21lIHRpbWUgdG8gY2FsY3VsYXRlIHRoZSB3aWR0aHMpIGlmIHRoZVxuXHQgKiB0YWJsZXMgd2lkdGhzIGFyZSBwYXNzZWQgaW4gdXNpbmcgYGNvbHVtbnNgLlxuXHQgKi9cblx0XCJiQXV0b1dpZHRoXCI6IHRydWUsXG5cblxuXHQvKipcblx0ICogRGVmZXJyZWQgcmVuZGVyaW5nIGNhbiBwcm92aWRlIERhdGFUYWJsZXMgd2l0aCBhIGh1Z2Ugc3BlZWQgYm9vc3Qgd2hlbiB5b3Vcblx0ICogYXJlIHVzaW5nIGFuIEFqYXggb3IgSlMgZGF0YSBzb3VyY2UgZm9yIHRoZSB0YWJsZS4gVGhpcyBvcHRpb24sIHdoZW4gc2V0IHRvXG5cdCAqIHRydWUsIHdpbGwgY2F1c2UgRGF0YVRhYmxlcyB0byBkZWZlciB0aGUgY3JlYXRpb24gb2YgdGhlIHRhYmxlIGVsZW1lbnRzIGZvclxuXHQgKiBlYWNoIHJvdyB1bnRpbCB0aGV5IGFyZSBuZWVkZWQgZm9yIGEgZHJhdyAtIHNhdmluZyBhIHNpZ25pZmljYW50IGFtb3VudCBvZlxuXHQgKiB0aW1lLlxuXHQgKi9cblx0XCJiRGVmZXJSZW5kZXJcIjogdHJ1ZSxcblxuXG5cdC8qKlxuXHQgKiBSZXBsYWNlIGEgRGF0YVRhYmxlIHdoaWNoIG1hdGNoZXMgdGhlIGdpdmVuIHNlbGVjdG9yIGFuZCByZXBsYWNlIGl0IHdpdGhcblx0ICogb25lIHdoaWNoIGhhcyB0aGUgcHJvcGVydGllcyBvZiB0aGUgbmV3IGluaXRpYWxpc2F0aW9uIG9iamVjdCBwYXNzZWQuIElmIG5vXG5cdCAqIHRhYmxlIG1hdGNoZXMgdGhlIHNlbGVjdG9yLCB0aGVuIHRoZSBuZXcgRGF0YVRhYmxlIHdpbGwgYmUgY29uc3RydWN0ZWQgYXNcblx0ICogcGVyIG5vcm1hbC5cblx0ICovXG5cdFwiYkRlc3Ryb3lcIjogZmFsc2UsXG5cblxuXHQvKipcblx0ICogRW5hYmxlIG9yIGRpc2FibGUgZmlsdGVyaW5nIG9mIGRhdGEuIEZpbHRlcmluZyBpbiBEYXRhVGFibGVzIGlzIFwic21hcnRcIiBpblxuXHQgKiB0aGF0IGl0IGFsbG93cyB0aGUgZW5kIHVzZXIgdG8gaW5wdXQgbXVsdGlwbGUgd29yZHMgKHNwYWNlIHNlcGFyYXRlZCkgYW5kXG5cdCAqIHdpbGwgbWF0Y2ggYSByb3cgY29udGFpbmluZyB0aG9zZSB3b3JkcywgZXZlbiBpZiBub3QgaW4gdGhlIG9yZGVyIHRoYXQgd2FzXG5cdCAqIHNwZWNpZmllZCAodGhpcyBhbGxvdyBtYXRjaGluZyBhY3Jvc3MgbXVsdGlwbGUgY29sdW1ucykuIE5vdGUgdGhhdCBpZiB5b3Vcblx0ICogd2lzaCB0byB1c2UgZmlsdGVyaW5nIGluIERhdGFUYWJsZXMgdGhpcyBtdXN0IHJlbWFpbiAndHJ1ZScgLSB0byByZW1vdmUgdGhlXG5cdCAqIGRlZmF1bHQgZmlsdGVyaW5nIGlucHV0IGJveCBhbmQgcmV0YWluIGZpbHRlcmluZyBhYmlsaXRpZXMsIHBsZWFzZSB1c2Vcblx0ICoge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0cy5kb219LlxuXHQgKi9cblx0XCJiRmlsdGVyXCI6IHRydWUsXG5cblx0LyoqXG5cdCAqIFVzZWQgb25seSBmb3IgY29tcGF0aWJsaXR5IHdpdGggRFQxXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqL1xuXHRcImJJbmZvXCI6IHRydWUsXG5cblx0LyoqXG5cdCAqIFVzZWQgb25seSBmb3IgY29tcGF0aWJsaXR5IHdpdGggRFQxXG5cdCAqIEBkZXByZWNhdGVkXG5cdCAqL1xuXHRcImJMZW5ndGhDaGFuZ2VcIjogdHJ1ZSxcblxuXHQvKipcblx0ICogRW5hYmxlIG9yIGRpc2FibGUgcGFnaW5hdGlvbi5cblx0ICovXG5cdFwiYlBhZ2luYXRlXCI6IHRydWUsXG5cblxuXHQvKipcblx0ICogRW5hYmxlIG9yIGRpc2FibGUgdGhlIGRpc3BsYXkgb2YgYSAncHJvY2Vzc2luZycgaW5kaWNhdG9yIHdoZW4gdGhlIHRhYmxlIGlzXG5cdCAqIGJlaW5nIHByb2Nlc3NlZCAoZS5nLiBhIHNvcnQpLiBUaGlzIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIHRhYmxlcyB3aXRoXG5cdCAqIGxhcmdlIGFtb3VudHMgb2YgZGF0YSB3aGVyZSBpdCBjYW4gdGFrZSBhIG5vdGljZWFibGUgYW1vdW50IG9mIHRpbWUgdG8gc29ydFxuXHQgKiB0aGUgZW50cmllcy5cblx0ICovXG5cdFwiYlByb2Nlc3NpbmdcIjogZmFsc2UsXG5cblxuXHQvKipcblx0ICogUmV0cmlldmUgdGhlIERhdGFUYWJsZXMgb2JqZWN0IGZvciB0aGUgZ2l2ZW4gc2VsZWN0b3IuIE5vdGUgdGhhdCBpZiB0aGVcblx0ICogdGFibGUgaGFzIGFscmVhZHkgYmVlbiBpbml0aWFsaXNlZCwgdGhpcyBwYXJhbWV0ZXIgd2lsbCBjYXVzZSBEYXRhVGFibGVzXG5cdCAqIHRvIHNpbXBseSByZXR1cm4gdGhlIG9iamVjdCB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gc2V0IHVwIC0gaXQgd2lsbCBub3QgdGFrZVxuXHQgKiBhY2NvdW50IG9mIGFueSBjaGFuZ2VzIHlvdSBtaWdodCBoYXZlIG1hZGUgdG8gdGhlIGluaXRpYWxpc2F0aW9uIG9iamVjdFxuXHQgKiBwYXNzZWQgdG8gRGF0YVRhYmxlcyAoc2V0dGluZyB0aGlzIHBhcmFtZXRlciB0byB0cnVlIGlzIGFuIGFja25vd2xlZGdlbWVudFxuXHQgKiB0aGF0IHlvdSB1bmRlcnN0YW5kIHRoaXMpLiBgZGVzdHJveWAgY2FuIGJlIHVzZWQgdG8gcmVpbml0aWFsaXNlIGEgdGFibGUgaWZcblx0ICogeW91IG5lZWQuXG5cdCAqL1xuXHRcImJSZXRyaWV2ZVwiOiBmYWxzZSxcblxuXG5cdC8qKlxuXHQgKiBXaGVuIHZlcnRpY2FsICh5KSBzY3JvbGxpbmcgaXMgZW5hYmxlZCwgRGF0YVRhYmxlcyB3aWxsIGZvcmNlIHRoZSBoZWlnaHQgb2Zcblx0ICogdGhlIHRhYmxlJ3Mgdmlld3BvcnQgdG8gdGhlIGdpdmVuIGhlaWdodCBhdCBhbGwgdGltZXMgKHVzZWZ1bCBmb3IgbGF5b3V0KS5cblx0ICogSG93ZXZlciwgdGhpcyBjYW4gbG9vayBvZGQgd2hlbiBmaWx0ZXJpbmcgZGF0YSBkb3duIHRvIGEgc21hbGwgZGF0YSBzZXQsXG5cdCAqIGFuZCB0aGUgZm9vdGVyIGlzIGxlZnQgXCJmbG9hdGluZ1wiIGZ1cnRoZXIgZG93bi4gVGhpcyBwYXJhbWV0ZXIgKHdoZW5cblx0ICogZW5hYmxlZCkgd2lsbCBjYXVzZSBEYXRhVGFibGVzIHRvIGNvbGxhcHNlIHRoZSB0YWJsZSdzIHZpZXdwb3J0IGRvd24gd2hlblxuXHQgKiB0aGUgcmVzdWx0IHNldCB3aWxsIGZpdCB3aXRoaW4gdGhlIGdpdmVuIFkgaGVpZ2h0LlxuXHQgKi9cblx0XCJiU2Nyb2xsQ29sbGFwc2VcIjogZmFsc2UsXG5cblxuXHQvKipcblx0ICogQ29uZmlndXJlIERhdGFUYWJsZXMgdG8gdXNlIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcuIE5vdGUgdGhhdCB0aGVcblx0ICogYGFqYXhgIHBhcmFtZXRlciBtdXN0IGFsc28gYmUgZ2l2ZW4gaW4gb3JkZXIgdG8gZ2l2ZSBEYXRhVGFibGVzIGFcblx0ICogc291cmNlIHRvIG9idGFpbiB0aGUgcmVxdWlyZWQgZGF0YSBmb3IgZWFjaCBkcmF3LlxuXHQgKi9cblx0XCJiU2VydmVyU2lkZVwiOiBmYWxzZSxcblxuXG5cdC8qKlxuXHQgKiBFbmFibGUgb3IgZGlzYWJsZSBzb3J0aW5nIG9mIGNvbHVtbnMuIFNvcnRpbmcgb2YgaW5kaXZpZHVhbCBjb2x1bW5zIGNhbiBiZVxuXHQgKiBkaXNhYmxlZCBieSB0aGUgYHNvcnRhYmxlYCBvcHRpb24gZm9yIGVhY2ggY29sdW1uLlxuXHQgKi9cblx0XCJiU29ydFwiOiB0cnVlLFxuXG5cblx0LyoqXG5cdCAqIEVuYWJsZSBvciBkaXNwbGF5IERhdGFUYWJsZXMnIGFiaWxpdHkgdG8gc29ydCBtdWx0aXBsZSBjb2x1bW5zIGF0IHRoZVxuXHQgKiBzYW1lIHRpbWUgKGFjdGl2YXRlZCBieSBzaGlmdC1jbGljayBieSB0aGUgdXNlcikuXG5cdCAqL1xuXHRcImJTb3J0TXVsdGlcIjogdHJ1ZSxcblxuXG5cdC8qKlxuXHQgKiBBbGxvd3MgY29udHJvbCBvdmVyIHdoZXRoZXIgRGF0YVRhYmxlcyBzaG91bGQgdXNlIHRoZSB0b3AgKHRydWUpIHVuaXF1ZVxuXHQgKiBjZWxsIHRoYXQgaXMgZm91bmQgZm9yIGEgc2luZ2xlIGNvbHVtbiwgb3IgdGhlIGJvdHRvbSAoZmFsc2UgLSBkZWZhdWx0KS5cblx0ICogVGhpcyBpcyB1c2VmdWwgd2hlbiB1c2luZyBjb21wbGV4IGhlYWRlcnMuXG5cdCAqL1xuXHRcImJTb3J0Q2VsbHNUb3BcIjogbnVsbCxcblxuXG5cdC8qKiBTcGVjaWZ5IHdoaWNoIHJvdyBpcyB0aGUgdGl0bGUgcm93IGluIHRoZSBoZWFkZXIuIFJlcGxhY2VtZW50IGZvciBiU29ydENlbGxzVG9wICovXG5cdHRpdGxlUm93OiBudWxsLFxuXG5cblx0LyoqXG5cdCAqIEVuYWJsZSBvciBkaXNhYmxlIHRoZSBhZGRpdGlvbiBvZiB0aGUgY2xhc3NlcyBgc29ydGluZ1xcXzFgLCBgc29ydGluZ1xcXzJgIGFuZFxuXHQgKiBgc29ydGluZ1xcXzNgIHRvIHRoZSBjb2x1bW5zIHdoaWNoIGFyZSBjdXJyZW50bHkgYmVpbmcgc29ydGVkIG9uLiBUaGlzIGlzXG5cdCAqIHByZXNlbnRlZCBhcyBhIGZlYXR1cmUgc3dpdGNoIGFzIGl0IGNhbiBpbmNyZWFzZSBwcm9jZXNzaW5nIHRpbWUgKHdoaWxlXG5cdCAqIGNsYXNzZXMgYXJlIHJlbW92ZWQgYW5kIGFkZGVkKSBzbyBmb3IgbGFyZ2UgZGF0YSBzZXRzIHlvdSBtaWdodCB3YW50IHRvXG5cdCAqIHR1cm4gdGhpcyBvZmYuXG5cdCAqL1xuXHRcImJTb3J0Q2xhc3Nlc1wiOiB0cnVlLFxuXG5cblx0LyoqXG5cdCAqIEVuYWJsZSBvciBkaXNhYmxlIHN0YXRlIHNhdmluZy4gV2hlbiBlbmFibGVkIEhUTUw1IGBsb2NhbFN0b3JhZ2VgIHdpbGwgYmVcblx0ICogdXNlZCB0byBzYXZlIHRhYmxlIGRpc3BsYXkgaW5mb3JtYXRpb24gc3VjaCBhcyBwYWdpbmF0aW9uIGluZm9ybWF0aW9uLFxuXHQgKiBkaXNwbGF5IGxlbmd0aCwgZmlsdGVyaW5nIGFuZCBzb3J0aW5nLiBBcyBzdWNoIHdoZW4gdGhlIGVuZCB1c2VyIHJlbG9hZHNcblx0ICogdGhlIHBhZ2UgdGhlIGRpc3BsYXkgZGlzcGxheSB3aWxsIG1hdGNoIHdoYXQgdGh5IGhhZCBwcmV2aW91c2x5IHNldCB1cC5cblx0ICovXG5cdFwiYlN0YXRlU2F2ZVwiOiBmYWxzZSxcblxuXG5cdC8qKlxuXHQgKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuIGEgVFIgZWxlbWVudCBpcyBjcmVhdGVkIChhbmQgYWxsIFREIGNoaWxkXG5cdCAqIGVsZW1lbnRzIGhhdmUgYmVlbiBpbnNlcnRlZCksIG9yIHJlZ2lzdGVyZWQgaWYgdXNpbmcgYSBET00gc291cmNlLCBhbGxvd2luZ1xuXHQgKiBtYW5pcHVsYXRpb24gb2YgdGhlIFRSIGVsZW1lbnQgKGFkZGluZyBjbGFzc2VzIGV0YykuXG5cdCAqL1xuXHRcImZuQ3JlYXRlZFJvd1wiOiBudWxsLFxuXG5cblx0LyoqXG5cdCAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGV2ZXJ5ICdkcmF3JyBldmVudCwgYW5kIGFsbG93cyB5b3UgdG9cblx0ICogZHluYW1pY2FsbHkgbW9kaWZ5IGFueSBhc3BlY3QgeW91IHdhbnQgYWJvdXQgdGhlIGNyZWF0ZWQgRE9NLlxuXHQgKi9cblx0XCJmbkRyYXdDYWxsYmFja1wiOiBudWxsLFxuXG5cblx0LyoqXG5cdCAqIElkZW50aWNhbCB0byBmbkhlYWRlckNhbGxiYWNrKCkgYnV0IGZvciB0aGUgdGFibGUgZm9vdGVyIHRoaXMgZnVuY3Rpb25cblx0ICogYWxsb3dzIHlvdSB0byBtb2RpZnkgdGhlIHRhYmxlIGZvb3RlciBvbiBldmVyeSAnZHJhdycgZXZlbnQuXG5cdCAqL1xuXHRcImZuRm9vdGVyQ2FsbGJhY2tcIjogbnVsbCxcblxuXG5cdC8qKlxuXHQgKiBXaGVuIHJlbmRlcmluZyBsYXJnZSBudW1iZXJzIGluIHRoZSBpbmZvcm1hdGlvbiBlbGVtZW50IGZvciB0aGUgdGFibGVcblx0ICogKGkuZS4gXCJTaG93aW5nIDEgdG8gMTAgb2YgNTcgZW50cmllc1wiKSBEYXRhVGFibGVzIHdpbGwgcmVuZGVyIGxhcmdlIG51bWJlcnNcblx0ICogdG8gaGF2ZSBhIGNvbW1hIHNlcGFyYXRvciBmb3IgdGhlICd0aG91c2FuZHMnIHVuaXRzIChlLmcuIDEgbWlsbGlvbiBpc1xuXHQgKiByZW5kZXJlZCBhcyBcIjEsMDAwLDAwMFwiKSB0byBoZWxwIHJlYWRhYmlsaXR5IGZvciB0aGUgZW5kIHVzZXIuIFRoaXNcblx0ICogZnVuY3Rpb24gd2lsbCBvdmVycmlkZSB0aGUgZGVmYXVsdCBtZXRob2QgRGF0YVRhYmxlcyB1c2VzLlxuXHQgKi9cblx0XCJmbkZvcm1hdE51bWJlclwiOiBmdW5jdGlvbiAoIHRvRm9ybWF0ICkge1xuXHRcdHJldHVybiB0b0Zvcm1hdC50b1N0cmluZygpLnJlcGxhY2UoXG5cdFx0XHQvXFxCKD89KFxcZHszfSkrKD8hXFxkKSkvZyxcblx0XHRcdHRoaXMub0xhbmd1YWdlLnNUaG91c2FuZHNcblx0XHQpO1xuXHR9LFxuXG5cblx0LyoqXG5cdCAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGV2ZXJ5ICdkcmF3JyBldmVudCwgYW5kIGFsbG93cyB5b3UgdG9cblx0ICogZHluYW1pY2FsbHkgbW9kaWZ5IHRoZSBoZWFkZXIgcm93LiBUaGlzIGNhbiBiZSB1c2VkIHRvIGNhbGN1bGF0ZSBhbmRcblx0ICogZGlzcGxheSB1c2VmdWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHRhYmxlLlxuXHQgKi9cblx0XCJmbkhlYWRlckNhbGxiYWNrXCI6IG51bGwsXG5cblxuXHQvKipcblx0ICogVGhlIGluZm9ybWF0aW9uIGVsZW1lbnQgY2FuIGJlIHVzZWQgdG8gY29udmV5IGluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50XG5cdCAqIHN0YXRlIG9mIHRoZSB0YWJsZS4gQWx0aG91Z2ggdGhlIGludGVybmF0aW9uYWxpc2F0aW9uIG9wdGlvbnMgcHJlc2VudGVkIGJ5XG5cdCAqIERhdGFUYWJsZXMgYXJlIHF1aXRlIGNhcGFibGUgb2YgZGVhbGluZyB3aXRoIG1vc3QgY3VzdG9taXNhdGlvbnMsIHRoZXJlIG1heVxuXHQgKiBiZSB0aW1lcyB3aGVyZSB5b3Ugd2lzaCB0byBjdXN0b21pc2UgdGhlIHN0cmluZyBmdXJ0aGVyLiBUaGlzIGNhbGxiYWNrXG5cdCAqIGFsbG93cyB5b3UgdG8gZG8gZXhhY3RseSB0aGF0LlxuXHQgKi9cblx0XCJmbkluZm9DYWxsYmFja1wiOiBudWxsLFxuXG5cblx0LyoqXG5cdCAqIENhbGxlZCB3aGVuIHRoZSB0YWJsZSBoYXMgYmVlbiBpbml0aWFsaXNlZC4gTm9ybWFsbHkgRGF0YVRhYmxlcyB3aWxsXG5cdCAqIGluaXRpYWxpc2Ugc2VxdWVudGlhbGx5IGFuZCB0aGVyZSB3aWxsIGJlIG5vIG5lZWQgZm9yIHRoaXMgZnVuY3Rpb24sXG5cdCAqIGhvd2V2ZXIsIHRoaXMgZG9lcyBub3QgaG9sZCB0cnVlIHdoZW4gdXNpbmcgZXh0ZXJuYWwgbGFuZ3VhZ2UgaW5mb3JtYXRpb25cblx0ICogc2luY2UgdGhhdCBpcyBvYnRhaW5lZCB1c2luZyBhbiBhc3luYyBYSFIgY2FsbC5cblx0ICovXG5cdFwiZm5Jbml0Q29tcGxldGVcIjogbnVsbCxcblxuXG5cdC8qKlxuXHQgKiBDYWxsZWQgYXQgdGhlIHZlcnkgc3RhcnQgb2YgZWFjaCB0YWJsZSBkcmF3IGFuZCBjYW4gYmUgdXNlZCB0byBjYW5jZWwgdGhlXG5cdCAqIGRyYXcgYnkgcmV0dXJuaW5nIGZhbHNlLCBhbnkgb3RoZXIgcmV0dXJuIChpbmNsdWRpbmcgdW5kZWZpbmVkKSByZXN1bHRzIGluXG5cdCAqIHRoZSBmdWxsIGRyYXcgb2NjdXJyaW5nKS5cblx0ICovXG5cdFwiZm5QcmVEcmF3Q2FsbGJhY2tcIjogbnVsbCxcblxuXG5cdC8qKlxuXHQgKiBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gJ3Bvc3QgcHJvY2VzcycgZWFjaCByb3cgYWZ0ZXIgaXQgaGF2ZSBiZWVuXG5cdCAqIGdlbmVyYXRlZCBmb3IgZWFjaCB0YWJsZSBkcmF3LCBidXQgYmVmb3JlIGl0IGlzIHJlbmRlcmVkIG9uIHNjcmVlbi4gVGhpc1xuXHQgKiBmdW5jdGlvbiBtaWdodCBiZSB1c2VkIGZvciBzZXR0aW5nIHRoZSByb3cgY2xhc3MgbmFtZSBldGMuXG5cdCAqL1xuXHRcImZuUm93Q2FsbGJhY2tcIjogbnVsbCxcblxuXG5cdC8qKlxuXHQgKiBMb2FkIHRoZSB0YWJsZSBzdGF0ZS4gV2l0aCB0aGlzIGZ1bmN0aW9uIHlvdSBjYW4gZGVmaW5lIGZyb20gd2hlcmUsIGFuZCBob3csIHRoZVxuXHQgKiBzdGF0ZSBvZiBhIHRhYmxlIGlzIGxvYWRlZC4gQnkgZGVmYXVsdCBEYXRhVGFibGVzIHdpbGwgbG9hZCBmcm9tIGBsb2NhbFN0b3JhZ2VgXG5cdCAqIGJ1dCB5b3UgbWlnaHQgd2lzaCB0byB1c2UgYSBzZXJ2ZXItc2lkZSBkYXRhYmFzZSBvciBjb29raWVzLlxuXHQgKi9cblx0XCJmblN0YXRlTG9hZENhbGxiYWNrXCI6IGZ1bmN0aW9uICggc2V0dGluZ3MgKSB7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBKU09OLnBhcnNlKFxuXHRcdFx0XHQoc2V0dGluZ3MuaVN0YXRlRHVyYXRpb24gPT09IC0xID8gc2Vzc2lvblN0b3JhZ2UgOiBsb2NhbFN0b3JhZ2UpLmdldEl0ZW0oXG5cdFx0XHRcdFx0J0RhdGFUYWJsZXNfJytzZXR0aW5ncy5zSW5zdGFuY2UrJ18nK2xvY2F0aW9uLnBhdGhuYW1lXG5cdFx0XHRcdClcblx0XHRcdCk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0cmV0dXJuIHt9O1xuXHRcdH1cblx0fSxcblxuXG5cdC8qKlxuXHQgKiBDYWxsYmFjayB3aGljaCBhbGxvd3MgbW9kaWZpY2F0aW9uIG9mIHRoZSBzYXZlZCBzdGF0ZSBwcmlvciB0byBsb2FkaW5nIHRoYXQgc3RhdGUuXG5cdCAqIFRoaXMgY2FsbGJhY2sgaXMgY2FsbGVkIHdoZW4gdGhlIHRhYmxlIGlzIGxvYWRpbmcgc3RhdGUgZnJvbSB0aGUgc3RvcmVkIGRhdGEsIGJ1dFxuXHQgKiBwcmlvciB0byB0aGUgc2V0dGluZ3Mgb2JqZWN0IGJlaW5nIG1vZGlmaWVkIGJ5IHRoZSBzYXZlZCBzdGF0ZS4gTm90ZSB0aGF0IGZvclxuXHQgKiBwbHVnLWluIGF1dGhvcnMsIHlvdSBzaG91bGQgdXNlIHRoZSBgc3RhdGVMb2FkUGFyYW1zYCBldmVudCB0byBsb2FkIHBhcmFtZXRlcnMgZm9yXG5cdCAqIGEgcGx1Zy1pbi5cblx0ICovXG5cdFwiZm5TdGF0ZUxvYWRQYXJhbXNcIjogbnVsbCxcblxuXG5cdC8qKlxuXHQgKiBDYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBzdGF0ZSBoYXMgYmVlbiBsb2FkZWQgZnJvbSB0aGUgc3RhdGUgc2F2aW5nIG1ldGhvZFxuXHQgKiBhbmQgdGhlIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IGhhcyBiZWVuIG1vZGlmaWVkIGFzIGEgcmVzdWx0IG9mIHRoZSBsb2FkZWQgc3RhdGUuXG5cdCAqL1xuXHRcImZuU3RhdGVMb2FkZWRcIjogbnVsbCxcblxuXG5cdC8qKlxuXHQgKiBTYXZlIHRoZSB0YWJsZSBzdGF0ZS4gVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIGRlZmluZSB3aGVyZSBhbmQgaG93IHRoZSBzdGF0ZVxuXHQgKiBpbmZvcm1hdGlvbiBmb3IgdGhlIHRhYmxlIGlzIHN0b3JlZCBCeSBkZWZhdWx0IERhdGFUYWJsZXMgd2lsbCB1c2UgYGxvY2FsU3RvcmFnZWBcblx0ICogYnV0IHlvdSBtaWdodCB3aXNoIHRvIHVzZSBhIHNlcnZlci1zaWRlIGRhdGFiYXNlIG9yIGNvb2tpZXMuXG5cdCAqL1xuXHRcImZuU3RhdGVTYXZlQ2FsbGJhY2tcIjogZnVuY3Rpb24gKCBzZXR0aW5ncywgZGF0YSApIHtcblx0XHR0cnkge1xuXHRcdFx0KHNldHRpbmdzLmlTdGF0ZUR1cmF0aW9uID09PSAtMSA/IHNlc3Npb25TdG9yYWdlIDogbG9jYWxTdG9yYWdlKS5zZXRJdGVtKFxuXHRcdFx0XHQnRGF0YVRhYmxlc18nK3NldHRpbmdzLnNJbnN0YW5jZSsnXycrbG9jYXRpb24ucGF0aG5hbWUsXG5cdFx0XHRcdEpTT04uc3RyaW5naWZ5KCBkYXRhIClcblx0XHRcdCk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0Ly8gbm9vcFxuXHRcdH1cblx0fSxcblxuXG5cdC8qKlxuXHQgKiBDYWxsYmFjayB3aGljaCBhbGxvd3MgbW9kaWZpY2F0aW9uIG9mIHRoZSBzdGF0ZSB0byBiZSBzYXZlZC4gQ2FsbGVkIHdoZW4gdGhlIHRhYmxlXG5cdCAqIGhhcyBjaGFuZ2VkIHN0YXRlIGEgbmV3IHN0YXRlIHNhdmUgaXMgcmVxdWlyZWQuIFRoaXMgbWV0aG9kIGFsbG93cyBtb2RpZmljYXRpb24gb2Zcblx0ICogdGhlIHN0YXRlIHNhdmluZyBvYmplY3QgcHJpb3IgdG8gYWN0dWFsbHkgZG9pbmcgdGhlIHNhdmUsIGluY2x1ZGluZyBhZGRpdGlvbiBvclxuXHQgKiBvdGhlciBzdGF0ZSBwcm9wZXJ0aWVzIG9yIG1vZGlmaWNhdGlvbi4gTm90ZSB0aGF0IGZvciBwbHVnLWluIGF1dGhvcnMsIHlvdSBzaG91bGRcblx0ICogdXNlIHRoZSBgc3RhdGVTYXZlUGFyYW1zYCBldmVudCB0byBzYXZlIHBhcmFtZXRlcnMgZm9yIGEgcGx1Zy1pbi5cblx0ICovXG5cdFwiZm5TdGF0ZVNhdmVQYXJhbXNcIjogbnVsbCxcblxuXG5cdC8qKlxuXHQgKiBEdXJhdGlvbiBmb3Igd2hpY2ggdGhlIHNhdmVkIHN0YXRlIGluZm9ybWF0aW9uIGlzIGNvbnNpZGVyZWQgdmFsaWQuIEFmdGVyIHRoaXMgcGVyaW9kXG5cdCAqIGhhcyBlbGFwc2VkIHRoZSBzdGF0ZSB3aWxsIGJlIHJldHVybmVkIHRvIHRoZSBkZWZhdWx0LlxuXHQgKiBWYWx1ZSBpcyBnaXZlbiBpbiBzZWNvbmRzLlxuXHQgKi9cblx0XCJpU3RhdGVEdXJhdGlvblwiOiA3MjAwLFxuXG5cblx0LyoqXG5cdCAqIE51bWJlciBvZiByb3dzIHRvIGRpc3BsYXkgb24gYSBzaW5nbGUgcGFnZSB3aGVuIHVzaW5nIHBhZ2luYXRpb24uIElmXG5cdCAqIGZlYXR1cmUgZW5hYmxlZCAoYGxlbmd0aENoYW5nZWApIHRoZW4gdGhlIGVuZCB1c2VyIHdpbGwgYmUgYWJsZSB0byBvdmVycmlkZVxuXHQgKiB0aGlzIHRvIGEgY3VzdG9tIHNldHRpbmcgdXNpbmcgYSBwb3AtdXAgbWVudS5cblx0ICovXG5cdFwiaURpc3BsYXlMZW5ndGhcIjogMTAsXG5cblxuXHQvKipcblx0ICogRGVmaW5lIHRoZSBzdGFydGluZyBwb2ludCBmb3IgZGF0YSBkaXNwbGF5IHdoZW4gdXNpbmcgRGF0YVRhYmxlcyB3aXRoXG5cdCAqIHBhZ2luYXRpb24uIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciBpcyB0aGUgbnVtYmVyIG9mIHJlY29yZHMsIHJhdGhlciB0aGFuXG5cdCAqIHRoZSBwYWdlIG51bWJlciwgc28gaWYgeW91IGhhdmUgMTAgcmVjb3JkcyBwZXIgcGFnZSBhbmQgd2FudCB0byBzdGFydCBvblxuXHQgKiB0aGUgdGhpcmQgcGFnZSwgaXQgc2hvdWxkIGJlIFwiMjBcIi5cblx0ICovXG5cdFwiaURpc3BsYXlTdGFydFwiOiAwLFxuXG5cblx0LyoqXG5cdCAqIEJ5IGRlZmF1bHQgRGF0YVRhYmxlcyBhbGxvd3Mga2V5Ym9hcmQgbmF2aWdhdGlvbiBvZiB0aGUgdGFibGUgKHNvcnRpbmcsIHBhZ2luZyxcblx0ICogYW5kIGZpbHRlcmluZykgYnkgYWRkaW5nIGEgYHRhYmluZGV4YCBhdHRyaWJ1dGUgdG8gdGhlIHJlcXVpcmVkIGVsZW1lbnRzLiBUaGlzXG5cdCAqIGFsbG93cyB5b3UgdG8gdGFiIHRocm91Z2ggdGhlIGNvbnRyb2xzIGFuZCBwcmVzcyB0aGUgZW50ZXIga2V5IHRvIGFjdGl2YXRlIHRoZW0uXG5cdCAqIFRoZSB0YWJpbmRleCBpcyBkZWZhdWx0IDAsIG1lYW5pbmcgdGhhdCB0aGUgdGFiIGZvbGxvd3MgdGhlIGZsb3cgb2YgdGhlIGRvY3VtZW50LlxuXHQgKiBZb3UgY2FuIG92ZXJydWxlIHRoaXMgdXNpbmcgdGhpcyBwYXJhbWV0ZXIgaWYgeW91IHdpc2guIFVzZSBhIHZhbHVlIG9mIC0xIHRvXG5cdCAqIGRpc2FibGUgYnVpbHQtaW4ga2V5Ym9hcmQgbmF2aWdhdGlvbi5cblx0ICovXG5cdFwiaVRhYkluZGV4XCI6IDAsXG5cblxuXHQvKipcblx0ICogQ2xhc3NlcyB0aGF0IERhdGFUYWJsZXMgYXNzaWducyB0byB0aGUgdmFyaW91cyBjb21wb25lbnRzIGFuZCBmZWF0dXJlc1xuXHQgKiB0aGF0IGl0IGFkZHMgdG8gdGhlIEhUTUwgdGFibGUuIFRoaXMgYWxsb3dzIGNsYXNzZXMgdG8gYmUgY29uZmlndXJlZFxuXHQgKiBkdXJpbmcgaW5pdGlhbGlzYXRpb24gaW4gYWRkaXRpb24gdG8gdGhyb3VnaCB0aGUgc3RhdGljXG5cdCAqIHtAbGluayBEYXRhVGFibGUuZXh0Lm9TdGRDbGFzc2VzfSBvYmplY3QpLlxuXHQgKi9cblx0XCJvQ2xhc3Nlc1wiOiB7fSxcblxuXG5cdC8qKlxuXHQgKiBBbGwgc3RyaW5ncyB0aGF0IERhdGFUYWJsZXMgdXNlcyBpbiB0aGUgdXNlciBpbnRlcmZhY2UgdGhhdCBpdCBjcmVhdGVzXG5cdCAqIGFyZSBkZWZpbmVkIGluIHRoaXMgb2JqZWN0LCBhbGxvd2luZyB5b3UgdG8gbW9kaWZpZWQgdGhlbSBpbmRpdmlkdWFsbHkgb3Jcblx0ICogY29tcGxldGVseSByZXBsYWNlIHRoZW0gYWxsIGFzIHJlcXVpcmVkLlxuXHQgKi9cblx0XCJvTGFuZ3VhZ2VcIjoge1xuXHRcdC8qKlxuXHRcdCAqIFN0cmluZ3MgdGhhdCBhcmUgdXNlZCBmb3IgV0FJLUFSSUEgbGFiZWxzIGFuZCBjb250cm9scyBvbmx5ICh0aGVzZSBhcmUgbm90XG5cdFx0ICogYWN0dWFsbHkgdmlzaWJsZSBvbiB0aGUgcGFnZSwgYnV0IHdpbGwgYmUgcmVhZCBieSBzY3JlZW5yZWFkZXJzLCBhbmQgdGh1c1xuXHRcdCAqIG11c3QgYmUgaW50ZXJuYXRpb25hbGlzZWQgYXMgd2VsbCkuXG5cdFx0ICovXG5cdFx0XCJvQXJpYVwiOiB7XG5cdFx0XHQvKipcblx0XHRcdCAqIEFSSUEgbGFiZWwgdGhhdCBpcyBhZGRlZCB0byB0aGUgdGFibGUgaGVhZGVycyB3aGVuIHRoZSBjb2x1bW4gbWF5IGJlIHNvcnRlZFxuXHRcdFx0ICovXG5cdFx0XHRcIm9yZGVyYWJsZVwiOiBcIjogQWN0aXZhdGUgdG8gc29ydFwiLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEFSSUEgbGFiZWwgdGhhdCBpcyBhZGRlZCB0byB0aGUgdGFibGUgaGVhZGVycyB3aGVuIHRoZSBjb2x1bW4gaXMgY3VycmVudGx5IGJlaW5nIHNvcnRlZFxuXHRcdFx0ICovXG5cdFx0XHRcIm9yZGVyYWJsZVJldmVyc2VcIjogXCI6IEFjdGl2YXRlIHRvIGludmVydCBzb3J0aW5nXCIsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQVJJQSBsYWJlbCB0aGF0IGlzIGFkZGVkIHRvIHRoZSB0YWJsZSBoZWFkZXJzIHdoZW4gdGhlIGNvbHVtbiBpcyBjdXJyZW50bHkgYmVpbmcgXG5cdFx0XHQgKiBzb3J0ZWQgYW5kIG5leHQgc3RlcCBpcyB0byByZW1vdmUgc29ydGluZ1xuXHRcdFx0ICovXG5cdFx0XHRcIm9yZGVyYWJsZVJlbW92ZVwiOiBcIjogQWN0aXZhdGUgdG8gcmVtb3ZlIHNvcnRpbmdcIixcblxuXHRcdFx0cGFnaW5hdGU6IHtcblx0XHRcdFx0Zmlyc3Q6ICdGaXJzdCcsXG5cdFx0XHRcdGxhc3Q6ICdMYXN0Jyxcblx0XHRcdFx0bmV4dDogJ05leHQnLFxuXHRcdFx0XHRwcmV2aW91czogJ1ByZXZpb3VzJyxcblx0XHRcdFx0bnVtYmVyOiAnJ1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBQYWdpbmF0aW9uIHN0cmluZyB1c2VkIGJ5IERhdGFUYWJsZXMgZm9yIHRoZSBidWlsdC1pbiBwYWdpbmF0aW9uXG5cdFx0ICogY29udHJvbCB0eXBlcy5cblx0XHQgKi9cblx0XHRcIm9QYWdpbmF0ZVwiOiB7XG5cdFx0XHQvKipcblx0XHRcdCAqIExhYmVsIGFuZCBjaGFyYWN0ZXIgZm9yIGZpcnN0IHBhZ2UgYnV0dG9uICjCqylcblx0XHRcdCAqL1xuXHRcdFx0XCJzRmlyc3RcIjogXCJcXHUwMEFCXCIsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogTGFzdCBwYWdlIGJ1dHRvbiAowrspXG5cdFx0XHQgKi9cblx0XHRcdFwic0xhc3RcIjogXCJcXHUwMEJCXCIsXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogTmV4dCBwYWdlIGJ1dHRvbiAo4oC6KVxuXHRcdFx0ICovXG5cdFx0XHRcInNOZXh0XCI6IFwiXFx1MjAzQVwiLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFByZXZpb3VzIHBhZ2UgYnV0dG9uICjigLkpXG5cdFx0XHQgKi9cblx0XHRcdFwic1ByZXZpb3VzXCI6IFwiXFx1MjAzOVwiLFxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBQbHVyYWwgb2JqZWN0IGZvciB0aGUgZGF0YSB0eXBlIHRoZSB0YWJsZSBpcyBzaG93aW5nXG5cdFx0ICovXG5cdFx0ZW50cmllczoge1xuXHRcdFx0XzogXCJlbnRyaWVzXCIsXG5cdFx0XHQxOiBcImVudHJ5XCJcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUGFnZSBsZW5ndGggb3B0aW9uc1xuXHRcdCAqL1xuXHRcdGxlbmd0aExhYmVsczoge1xuXHRcdFx0Jy0xJzogJ0FsbCdcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBzdHJpbmcgaXMgc2hvd24gaW4gcHJlZmVyZW5jZSB0byBgemVyb1JlY29yZHNgIHdoZW4gdGhlIHRhYmxlIGlzXG5cdFx0ICogZW1wdHkgb2YgZGF0YSAocmVnYXJkbGVzcyBvZiBmaWx0ZXJpbmcpLiBOb3RlIHRoYXQgdGhpcyBpcyBhbiBvcHRpb25hbFxuXHRcdCAqIHBhcmFtZXRlciAtIGlmIGl0IGlzIG5vdCBnaXZlbiwgdGhlIHZhbHVlIG9mIGB6ZXJvUmVjb3Jkc2Agd2lsbCBiZSB1c2VkXG5cdFx0ICogaW5zdGVhZCAoZWl0aGVyIHRoZSBkZWZhdWx0IG9yIGdpdmVuIHZhbHVlKS5cblx0XHQgKi9cblx0XHRcInNFbXB0eVRhYmxlXCI6IFwiTm8gZGF0YSBhdmFpbGFibGUgaW4gdGFibGVcIixcblxuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBzdHJpbmcgZ2l2ZXMgaW5mb3JtYXRpb24gdG8gdGhlIGVuZCB1c2VyIGFib3V0IHRoZSBpbmZvcm1hdGlvblxuXHRcdCAqIHRoYXQgaXMgY3VycmVudCBvbiBkaXNwbGF5IG9uIHRoZSBwYWdlLiBUaGUgZm9sbG93aW5nIHRva2VucyBjYW4gYmVcblx0XHQgKiB1c2VkIGluIHRoZSBzdHJpbmcgYW5kIHdpbGwgYmUgZHluYW1pY2FsbHkgcmVwbGFjZWQgYXMgdGhlIHRhYmxlXG5cdFx0ICogZGlzcGxheSB1cGRhdGVzLiBUaGlzIHRva2VucyBjYW4gYmUgcGxhY2VkIGFueXdoZXJlIGluIHRoZSBzdHJpbmcsIG9yXG5cdFx0ICogcmVtb3ZlZCBhcyBuZWVkZWQgYnkgdGhlIGxhbmd1YWdlIHJlcXVpcmVzOlxuXHRcdCAqXG5cdFx0ICogKiBgXFxfU1RBUlRcXF9gIC0gRGlzcGxheSBpbmRleCBvZiB0aGUgZmlyc3QgcmVjb3JkIG9uIHRoZSBjdXJyZW50IHBhZ2Vcblx0XHQgKiAqIGBcXF9FTkRcXF9gIC0gRGlzcGxheSBpbmRleCBvZiB0aGUgbGFzdCByZWNvcmQgb24gdGhlIGN1cnJlbnQgcGFnZVxuXHRcdCAqICogYFxcX1RPVEFMXFxfYCAtIE51bWJlciBvZiByZWNvcmRzIGluIHRoZSB0YWJsZSBhZnRlciBmaWx0ZXJpbmdcblx0XHQgKiAqIGBcXF9NQVhcXF9gIC0gTnVtYmVyIG9mIHJlY29yZHMgaW4gdGhlIHRhYmxlIHdpdGhvdXQgZmlsdGVyaW5nXG5cdFx0ICogKiBgXFxfUEFHRVxcX2AgLSBDdXJyZW50IHBhZ2UgbnVtYmVyXG5cdFx0ICogKiBgXFxfUEFHRVNcXF9gIC0gVG90YWwgbnVtYmVyIG9mIHBhZ2VzIG9mIGRhdGEgaW4gdGhlIHRhYmxlXG5cdFx0ICovXG5cdFx0XCJzSW5mb1wiOiBcIlNob3dpbmcgX1NUQVJUXyB0byBfRU5EXyBvZiBfVE9UQUxfIF9FTlRSSUVTLVRPVEFMX1wiLFxuXG5cblx0XHQvKipcblx0XHQgKiBEaXNwbGF5IGluZm9ybWF0aW9uIHN0cmluZyBmb3Igd2hlbiB0aGUgdGFibGUgaXMgZW1wdHkuIFR5cGljYWxseSB0aGVcblx0XHQgKiBmb3JtYXQgb2YgdGhpcyBzdHJpbmcgc2hvdWxkIG1hdGNoIGBpbmZvYC5cblx0XHQgKi9cblx0XHRcInNJbmZvRW1wdHlcIjogXCJTaG93aW5nIDAgdG8gMCBvZiAwIF9FTlRSSUVTLVRPVEFMX1wiLFxuXG5cblx0XHQvKipcblx0XHQgKiBXaGVuIGEgdXNlciBmaWx0ZXJzIHRoZSBpbmZvcm1hdGlvbiBpbiBhIHRhYmxlLCB0aGlzIHN0cmluZyBpcyBhcHBlbmRlZFxuXHRcdCAqIHRvIHRoZSBpbmZvcm1hdGlvbiAoYGluZm9gKSB0byBnaXZlIGFuIGlkZWEgb2YgaG93IHN0cm9uZyB0aGUgZmlsdGVyaW5nXG5cdFx0ICogaXMuIFRoZSB2YXJpYWJsZSBfTUFYXyBpcyBkeW5hbWljYWxseSB1cGRhdGVkLlxuXHRcdCAqL1xuXHRcdFwic0luZm9GaWx0ZXJlZFwiOiBcIihmaWx0ZXJlZCBmcm9tIF9NQVhfIHRvdGFsIF9FTlRSSUVTLU1BWF8pXCIsXG5cblxuXHRcdC8qKlxuXHRcdCAqIElmIGNhbiBiZSB1c2VmdWwgdG8gYXBwZW5kIGV4dHJhIGluZm9ybWF0aW9uIHRvIHRoZSBpbmZvIHN0cmluZyBhdCB0aW1lcyxcblx0XHQgKiBhbmQgdGhpcyB2YXJpYWJsZSBkb2VzIGV4YWN0bHkgdGhhdC4gVGhpcyBpbmZvcm1hdGlvbiB3aWxsIGJlIGFwcGVuZGVkIHRvXG5cdFx0ICogdGhlIGBpbmZvYCAoYGluZm9FbXB0eWAgYW5kIGBpbmZvRmlsdGVyZWRgIGluIHdoYXRldmVyIGNvbWJpbmF0aW9uIHRoZXkgYXJlXG5cdFx0ICogYmVpbmcgdXNlZCkgYXQgYWxsIHRpbWVzLlxuXHRcdCAqL1xuXHRcdFwic0luZm9Qb3N0Rml4XCI6IFwiXCIsXG5cblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgZGVjaW1hbCBwbGFjZSBvcGVyYXRvciBpcyBhIGxpdHRsZSBkaWZmZXJlbnQgZnJvbSB0aGUgb3RoZXJcblx0XHQgKiBsYW5ndWFnZSBvcHRpb25zIHNpbmNlIERhdGFUYWJsZXMgZG9lc24ndCBvdXRwdXQgZmxvYXRpbmcgcG9pbnRcblx0XHQgKiBudW1iZXJzLCBzbyBpdCB3b24ndCBldmVyIHVzZSB0aGlzIGZvciBkaXNwbGF5IG9mIGEgbnVtYmVyLiBSYXRoZXIsXG5cdFx0ICogd2hhdCB0aGlzIHBhcmFtZXRlciBkb2VzIGlzIG1vZGlmeSB0aGUgc29ydCBtZXRob2RzIG9mIHRoZSB0YWJsZSBzb1xuXHRcdCAqIHRoYXQgbnVtYmVycyB3aGljaCBhcmUgaW4gYSBmb3JtYXQgd2hpY2ggaGFzIGEgY2hhcmFjdGVyIG90aGVyIHRoYW5cblx0XHQgKiBhIHBlcmlvZCAoYC5gKSBhcyBhIGRlY2ltYWwgcGxhY2Ugd2lsbCBiZSBzb3J0ZWQgbnVtZXJpY2FsbHkuXG5cdFx0ICpcblx0XHQgKiBOb3RlIHRoYXQgbnVtYmVycyB3aXRoIGRpZmZlcmVudCBkZWNpbWFsIHBsYWNlcyBjYW5ub3QgYmUgc2hvd24gaW5cblx0XHQgKiB0aGUgc2FtZSB0YWJsZSBhbmQgc3RpbGwgYmUgc29ydGFibGUsIHRoZSB0YWJsZSBtdXN0IGJlIGNvbnNpc3RlbnQuXG5cdFx0ICogSG93ZXZlciwgbXVsdGlwbGUgZGlmZmVyZW50IHRhYmxlcyBvbiB0aGUgcGFnZSBjYW4gdXNlIGRpZmZlcmVudFxuXHRcdCAqIGRlY2ltYWwgcGxhY2UgY2hhcmFjdGVycy5cblx0XHQgKi9cblx0XHRcInNEZWNpbWFsXCI6IFwiXCIsXG5cblxuXHRcdC8qKlxuXHRcdCAqIERhdGFUYWJsZXMgaGFzIGEgYnVpbGQgaW4gbnVtYmVyIGZvcm1hdHRlciAoYGZvcm1hdE51bWJlcmApIHdoaWNoIGlzXG5cdFx0ICogdXNlZCB0byBmb3JtYXQgbGFyZ2UgbnVtYmVycyB0aGF0IGFyZSB1c2VkIGluIHRoZSB0YWJsZSBpbmZvcm1hdGlvbi5cblx0XHQgKiBCeSBkZWZhdWx0IGEgY29tbWEgaXMgdXNlZCwgYnV0IHRoaXMgY2FuIGJlIHRyaXZpYWxseSBjaGFuZ2VkIHRvIGFueVxuXHRcdCAqIGNoYXJhY3RlciB5b3Ugd2lzaCB3aXRoIHRoaXMgcGFyYW1ldGVyLlxuXHRcdCAqL1xuXHRcdFwic1Rob3VzYW5kc1wiOiBcIixcIixcblxuXG5cdFx0LyoqXG5cdFx0ICogRGV0YWlsIHRoZSBhY3Rpb24gdGhhdCB3aWxsIGJlIHRha2VuIHdoZW4gdGhlIGRyb3AgZG93biBtZW51IGZvciB0aGVcblx0XHQgKiBwYWdpbmF0aW9uIGxlbmd0aCBvcHRpb24gaXMgY2hhbmdlZC4gVGhlICdfTUVOVV8nIHZhcmlhYmxlIGlzIHJlcGxhY2VkXG5cdFx0ICogd2l0aCBhIGRlZmF1bHQgc2VsZWN0IGxpc3Qgb2YgMTAsIDI1LCA1MCBhbmQgMTAwLCBhbmQgY2FuIGJlIHJlcGxhY2VkXG5cdFx0ICogd2l0aCBhIGN1c3RvbSBzZWxlY3QgYm94IGlmIHJlcXVpcmVkLlxuXHRcdCAqL1xuXHRcdFwic0xlbmd0aE1lbnVcIjogXCJfTUVOVV8gX0VOVFJJRVNfIHBlciBwYWdlXCIsXG5cblxuXHRcdC8qKlxuXHRcdCAqIFdoZW4gdXNpbmcgQWpheCBzb3VyY2VkIGRhdGEgYW5kIGR1cmluZyB0aGUgZmlyc3QgZHJhdyB3aGVuIERhdGFUYWJsZXMgaXNcblx0XHQgKiBnYXRoZXJpbmcgdGhlIGRhdGEsIHRoaXMgbWVzc2FnZSBpcyBzaG93biBpbiBhbiBlbXB0eSByb3cgaW4gdGhlIHRhYmxlIHRvXG5cdFx0ICogaW5kaWNhdGUgdG8gdGhlIGVuZCB1c2VyIHRoZSB0aGUgZGF0YSBpcyBiZWluZyBsb2FkZWQuIE5vdGUgdGhhdCB0aGlzXG5cdFx0ICogcGFyYW1ldGVyIGlzIG5vdCB1c2VkIHdoZW4gbG9hZGluZyBkYXRhIGJ5IHNlcnZlci1zaWRlIHByb2Nlc3NpbmcsIGp1c3Rcblx0XHQgKiBBamF4IHNvdXJjZWQgZGF0YSB3aXRoIGNsaWVudC1zaWRlIHByb2Nlc3NpbmcuXG5cdFx0ICovXG5cdFx0XCJzTG9hZGluZ1JlY29yZHNcIjogXCJMb2FkaW5nLi4uXCIsXG5cblxuXHRcdC8qKlxuXHRcdCAqIFRleHQgd2hpY2ggaXMgZGlzcGxheWVkIHdoZW4gdGhlIHRhYmxlIGlzIHByb2Nlc3NpbmcgYSB1c2VyIGFjdGlvblxuXHRcdCAqICh1c3VhbGx5IGEgc29ydCBjb21tYW5kIG9yIHNpbWlsYXIpLlxuXHRcdCAqL1xuXHRcdFwic1Byb2Nlc3NpbmdcIjogXCJcIixcblxuXG5cdFx0LyoqXG5cdFx0ICogRGV0YWlscyB0aGUgYWN0aW9ucyB0aGF0IHdpbGwgYmUgdGFrZW4gd2hlbiB0aGUgdXNlciB0eXBlcyBpbnRvIHRoZVxuXHRcdCAqIGZpbHRlcmluZyBpbnB1dCB0ZXh0IGJveC4gVGhlIHZhcmlhYmxlIFwiX0lOUFVUX1wiLCBpZiB1c2VkIGluIHRoZSBzdHJpbmcsXG5cdFx0ICogaXMgcmVwbGFjZWQgd2l0aCB0aGUgSFRNTCB0ZXh0IGJveCBmb3IgdGhlIGZpbHRlcmluZyBpbnB1dCBhbGxvd2luZ1xuXHRcdCAqIGNvbnRyb2wgb3ZlciB3aGVyZSBpdCBhcHBlYXJzIGluIHRoZSBzdHJpbmcuIElmIFwiX0lOUFVUX1wiIGlzIG5vdCBnaXZlblxuXHRcdCAqIHRoZW4gdGhlIGlucHV0IGJveCBpcyBhcHBlbmRlZCB0byB0aGUgc3RyaW5nIGF1dG9tYXRpY2FsbHkuXG5cdFx0ICovXG5cdFx0XCJzU2VhcmNoXCI6IFwiU2VhcmNoOlwiLFxuXG5cblx0XHQvKipcblx0XHQgKiBBc3NpZ24gYSBgcGxhY2Vob2xkZXJgIGF0dHJpYnV0ZSB0byB0aGUgc2VhcmNoIGBpbnB1dGAgZWxlbWVudFxuXHRcdCAqICBAdHlwZSBzdHJpbmdcblx0XHQgKiAgQGRlZmF1bHQgXG5cdFx0ICpcblx0XHQgKiAgQGR0b3B0IExhbmd1YWdlXG5cdFx0ICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5zZWFyY2hQbGFjZWhvbGRlclxuXHRcdCAqL1xuXHRcdFwic1NlYXJjaFBsYWNlaG9sZGVyXCI6IFwiXCIsXG5cblxuXHRcdC8qKlxuXHRcdCAqIEFsbCBvZiB0aGUgbGFuZ3VhZ2UgaW5mb3JtYXRpb24gY2FuIGJlIHN0b3JlZCBpbiBhIGZpbGUgb24gdGhlXG5cdFx0ICogc2VydmVyLXNpZGUsIHdoaWNoIERhdGFUYWJsZXMgd2lsbCBsb29rIHVwIGlmIHRoaXMgcGFyYW1ldGVyIGlzIHBhc3NlZC5cblx0XHQgKiBJdCBtdXN0IHN0b3JlIHRoZSBVUkwgb2YgdGhlIGxhbmd1YWdlIGZpbGUsIHdoaWNoIGlzIGluIGEgSlNPTiBmb3JtYXQsXG5cdFx0ICogYW5kIHRoZSBvYmplY3QgaGFzIHRoZSBzYW1lIHByb3BlcnRpZXMgYXMgdGhlIG9MYW5ndWFnZSBvYmplY3QgaW4gdGhlXG5cdFx0ICogaW5pdGlhbGlzZXIgb2JqZWN0IChpLmUuIHRoZSBhYm92ZSBwYXJhbWV0ZXJzKS4gUGxlYXNlIHJlZmVyIHRvIG9uZSBvZlxuXHRcdCAqIHRoZSBleGFtcGxlIGxhbmd1YWdlIGZpbGVzIHRvIHNlZSBob3cgdGhpcyB3b3JrcyBpbiBhY3Rpb24uXG5cdFx0ICovXG5cdFx0XCJzVXJsXCI6IFwiXCIsXG5cblxuXHRcdC8qKlxuXHRcdCAqIFRleHQgc2hvd24gaW5zaWRlIHRoZSB0YWJsZSByZWNvcmRzIHdoZW4gdGhlIGlzIG5vIGluZm9ybWF0aW9uIHRvIGJlXG5cdFx0ICogZGlzcGxheWVkIGFmdGVyIGZpbHRlcmluZy4gYGVtcHR5VGFibGVgIGlzIHNob3duIHdoZW4gdGhlcmUgaXMgc2ltcGx5IG5vXG5cdFx0ICogaW5mb3JtYXRpb24gaW4gdGhlIHRhYmxlIGF0IGFsbCAocmVnYXJkbGVzcyBvZiBmaWx0ZXJpbmcpLlxuXHRcdCAqL1xuXHRcdFwic1plcm9SZWNvcmRzXCI6IFwiTm8gbWF0Y2hpbmcgcmVjb3JkcyBmb3VuZFwiXG5cdH0sXG5cblxuXHQvKiogVGhlIGluaXRpYWwgZGF0YSBvcmRlciBpcyByZXZlcnNlZCB3aGVuIGBkZXNjYCBvcmRlcmluZyAqL1xuXHRvcmRlckRlc2NSZXZlcnNlOiB0cnVlLFxuXG5cblx0LyoqXG5cdCAqIFRoaXMgcGFyYW1ldGVyIGFsbG93cyB5b3UgdG8gaGF2ZSBkZWZpbmUgdGhlIGdsb2JhbCBmaWx0ZXJpbmcgc3RhdGUgYXRcblx0ICogaW5pdGlhbGlzYXRpb24gdGltZS4gQXMgYW4gb2JqZWN0IHRoZSBgc2VhcmNoYCBwYXJhbWV0ZXIgbXVzdCBiZVxuXHQgKiBkZWZpbmVkLCBidXQgYWxsIG90aGVyIHBhcmFtZXRlcnMgYXJlIG9wdGlvbmFsLiBXaGVuIGByZWdleGAgaXMgdHJ1ZSxcblx0ICogdGhlIHNlYXJjaCBzdHJpbmcgd2lsbCBiZSB0cmVhdGVkIGFzIGEgcmVndWxhciBleHByZXNzaW9uLCB3aGVuIGZhbHNlXG5cdCAqIChkZWZhdWx0KSBpdCB3aWxsIGJlIHRyZWF0ZWQgYXMgYSBzdHJhaWdodCBzdHJpbmcuIFdoZW4gYHNtYXJ0YFxuXHQgKiBEYXRhVGFibGVzIHdpbGwgdXNlIGl0J3Mgc21hcnQgZmlsdGVyaW5nIG1ldGhvZHMgKHRvIHdvcmQgbWF0Y2ggYXRcblx0ICogYW55IHBvaW50IGluIHRoZSBkYXRhKSwgd2hlbiBmYWxzZSB0aGlzIHdpbGwgbm90IGJlIGRvbmUuXG5cdCAqL1xuXHRcIm9TZWFyY2hcIjogJC5leHRlbmQoIHt9LCBEYXRhVGFibGUubW9kZWxzLm9TZWFyY2ggKSxcblxuXG5cdC8qKlxuXHQgKiBUYWJsZSBhbmQgY29udHJvbCBsYXlvdXQuIFRoaXMgcmVwbGFjZXMgdGhlIGxlZ2FjeSBgZG9tYCBvcHRpb24uXG5cdCAqL1xuXHRsYXlvdXQ6IHtcblx0XHR0b3BTdGFydDogJ3BhZ2VMZW5ndGgnLFxuXHRcdHRvcEVuZDogJ3NlYXJjaCcsXG5cdFx0Ym90dG9tU3RhcnQ6ICdpbmZvJyxcblx0XHRib3R0b21FbmQ6ICdwYWdpbmcnXG5cdH0sXG5cblxuXHQvKipcblx0ICogTGVnYWN5IERPTSBsYXlvdXQgb3B0aW9uXG5cdCAqL1xuXHRcInNEb21cIjogbnVsbCxcblxuXG5cdC8qKlxuXHQgKiBTZWFyY2ggZGVsYXkgb3B0aW9uLiBUaGlzIHdpbGwgdGhyb3R0bGUgZnVsbCB0YWJsZSBzZWFyY2hlcyB0aGF0IHVzZSB0aGVcblx0ICogRGF0YVRhYmxlcyBwcm92aWRlZCBzZWFyY2ggaW5wdXQgZWxlbWVudCAoaXQgZG9lcyBub3QgZWZmZWN0IGNhbGxzIHRvXG5cdCAqIGBkdC1hcGkgc2VhcmNoKClgLCBwcm92aWRpbmcgYSBkZWxheSBiZWZvcmUgdGhlIHNlYXJjaCBpcyBtYWRlLlxuXHQgKi9cblx0XCJzZWFyY2hEZWxheVwiOiBudWxsLFxuXG5cblx0LyoqXG5cdCAqIERhdGFUYWJsZXMgZmVhdHVyZXMgc2l4IGRpZmZlcmVudCBidWlsdC1pbiBvcHRpb25zIGZvciB0aGUgYnV0dG9ucyB0b1xuXHQgKiBkaXNwbGF5IGZvciBwYWdpbmF0aW9uIGNvbnRyb2w6XG5cdCAqXG5cdCAqICogYG51bWJlcnNgIC0gUGFnZSBudW1iZXIgYnV0dG9ucyBvbmx5XG5cdCAqICogYHNpbXBsZWAgLSAnUHJldmlvdXMnIGFuZCAnTmV4dCcgYnV0dG9ucyBvbmx5XG5cdCAqICogJ3NpbXBsZV9udW1iZXJzYCAtICdQcmV2aW91cycgYW5kICdOZXh0JyBidXR0b25zLCBwbHVzIHBhZ2UgbnVtYmVyc1xuXHQgKiAqIGBmdWxsYCAtICdGaXJzdCcsICdQcmV2aW91cycsICdOZXh0JyBhbmQgJ0xhc3QnIGJ1dHRvbnNcblx0ICogKiBgZnVsbF9udW1iZXJzYCAtICdGaXJzdCcsICdQcmV2aW91cycsICdOZXh0JyBhbmQgJ0xhc3QnIGJ1dHRvbnMsIHBsdXMgcGFnZSBudW1iZXJzXG5cdCAqICogYGZpcnN0X2xhc3RfbnVtYmVyc2AgLSAnRmlyc3QnIGFuZCAnTGFzdCcgYnV0dG9ucywgcGx1cyBwYWdlIG51bWJlcnNcblx0ICovXG5cdFwic1BhZ2luYXRpb25UeXBlXCI6IFwiXCIsXG5cblxuXHQvKipcblx0ICogRW5hYmxlIGhvcml6b250YWwgc2Nyb2xsaW5nLiBXaGVuIGEgdGFibGUgaXMgdG9vIHdpZGUgdG8gZml0IGludG8gYVxuXHQgKiBjZXJ0YWluIGxheW91dCwgb3IgeW91IGhhdmUgYSBsYXJnZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgdGFibGUsIHlvdVxuXHQgKiBjYW4gZW5hYmxlIHgtc2Nyb2xsaW5nIHRvIHNob3cgdGhlIHRhYmxlIGluIGEgdmlld3BvcnQsIHdoaWNoIGNhbiBiZVxuXHQgKiBzY3JvbGxlZC4gVGhpcyBwcm9wZXJ0eSBjYW4gYmUgYHRydWVgIHdoaWNoIHdpbGwgYWxsb3cgdGhlIHRhYmxlIHRvXG5cdCAqIHNjcm9sbCBob3Jpem9udGFsbHkgd2hlbiBuZWVkZWQsIG9yIGFueSBDU1MgdW5pdCwgb3IgYSBudW1iZXIgKGluIHdoaWNoXG5cdCAqIGNhc2UgaXQgd2lsbCBiZSB0cmVhdGVkIGFzIGEgcGl4ZWwgbWVhc3VyZW1lbnQpLiBTZXR0aW5nIGFzIHNpbXBseSBgdHJ1ZWBcblx0ICogaXMgcmVjb21tZW5kZWQuXG5cdCAqL1xuXHRcInNTY3JvbGxYXCI6IFwiXCIsXG5cblxuXHQvKipcblx0ICogVGhpcyBwcm9wZXJ0eSBjYW4gYmUgdXNlZCB0byBmb3JjZSBhIERhdGFUYWJsZSB0byB1c2UgbW9yZSB3aWR0aCB0aGFuIGl0XG5cdCAqIG1pZ2h0IG90aGVyd2lzZSBkbyB3aGVuIHgtc2Nyb2xsaW5nIGlzIGVuYWJsZWQuIEZvciBleGFtcGxlIGlmIHlvdSBoYXZlIGFcblx0ICogdGFibGUgd2hpY2ggcmVxdWlyZXMgdG8gYmUgd2VsbCBzcGFjZWQsIHRoaXMgcGFyYW1ldGVyIGlzIHVzZWZ1bCBmb3Jcblx0ICogXCJvdmVyLXNpemluZ1wiIHRoZSB0YWJsZSwgYW5kIHRodXMgZm9yY2luZyBzY3JvbGxpbmcuIFRoaXMgcHJvcGVydHkgY2FuIGJ5XG5cdCAqIGFueSBDU1MgdW5pdCwgb3IgYSBudW1iZXIgKGluIHdoaWNoIGNhc2UgaXQgd2lsbCBiZSB0cmVhdGVkIGFzIGEgcGl4ZWxcblx0ICogbWVhc3VyZW1lbnQpLlxuXHQgKi9cblx0XCJzU2Nyb2xsWElubmVyXCI6IFwiXCIsXG5cblxuXHQvKipcblx0ICogRW5hYmxlIHZlcnRpY2FsIHNjcm9sbGluZy4gVmVydGljYWwgc2Nyb2xsaW5nIHdpbGwgY29uc3RyYWluIHRoZSBEYXRhVGFibGVcblx0ICogdG8gdGhlIGdpdmVuIGhlaWdodCwgYW5kIGVuYWJsZSBzY3JvbGxpbmcgZm9yIGFueSBkYXRhIHdoaWNoIG92ZXJmbG93cyB0aGVcblx0ICogY3VycmVudCB2aWV3cG9ydC4gVGhpcyBjYW4gYmUgdXNlZCBhcyBhbiBhbHRlcm5hdGl2ZSB0byBwYWdpbmcgdG8gZGlzcGxheVxuXHQgKiBhIGxvdCBvZiBkYXRhIGluIGEgc21hbGwgYXJlYSAoYWx0aG91Z2ggcGFnaW5nIGFuZCBzY3JvbGxpbmcgY2FuIGJvdGggYmVcblx0ICogZW5hYmxlZCBhdCB0aGUgc2FtZSB0aW1lKS4gVGhpcyBwcm9wZXJ0eSBjYW4gYmUgYW55IENTUyB1bml0LCBvciBhIG51bWJlclxuXHQgKiAoaW4gd2hpY2ggY2FzZSBpdCB3aWxsIGJlIHRyZWF0ZWQgYXMgYSBwaXhlbCBtZWFzdXJlbWVudCkuXG5cdCAqL1xuXHRcInNTY3JvbGxZXCI6IFwiXCIsXG5cblxuXHQvKipcblx0ICogX19EZXByZWNhdGVkX18gVGhlIGZ1bmN0aW9uYWxpdHkgcHJvdmlkZWQgYnkgdGhpcyBwYXJhbWV0ZXIgaGFzIG5vdyBiZWVuXG5cdCAqIHN1cGVyc2VkZWQgYnkgdGhhdCBwcm92aWRlZCB0aHJvdWdoIGBhamF4YCwgd2hpY2ggc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cblx0ICpcblx0ICogU2V0IHRoZSBIVFRQIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gbWFrZSB0aGUgQWpheCBjYWxsIGZvciBzZXJ2ZXItc2lkZVxuXHQgKiBwcm9jZXNzaW5nIG9yIEFqYXggc291cmNlZCBkYXRhLlxuXHQgKi9cblx0XCJzU2VydmVyTWV0aG9kXCI6IFwiR0VUXCIsXG5cblxuXHQvKipcblx0ICogRGF0YVRhYmxlcyBtYWtlcyB1c2Ugb2YgcmVuZGVyZXJzIHdoZW4gZGlzcGxheWluZyBIVE1MIGVsZW1lbnRzIGZvclxuXHQgKiBhIHRhYmxlLiBUaGVzZSByZW5kZXJlcnMgY2FuIGJlIGFkZGVkIG9yIG1vZGlmaWVkIGJ5IHBsdWctaW5zIHRvXG5cdCAqIGdlbmVyYXRlIHN1aXRhYmxlIG1hcmstdXAgZm9yIGEgc2l0ZS4gRm9yIGV4YW1wbGUgdGhlIEJvb3RzdHJhcFxuXHQgKiBpbnRlZ3JhdGlvbiBwbHVnLWluIGZvciBEYXRhVGFibGVzIHVzZXMgYSBwYWdpbmcgYnV0dG9uIHJlbmRlcmVyIHRvXG5cdCAqIGRpc3BsYXkgcGFnaW5hdGlvbiBidXR0b25zIGluIHRoZSBtYXJrLXVwIHJlcXVpcmVkIGJ5IEJvb3RzdHJhcC5cblx0ICpcblx0ICogRm9yIGZ1cnRoZXIgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJlbmRlcmVycyBhdmFpbGFibGUgc2VlXG5cdCAqIERhdGFUYWJsZS5leHQucmVuZGVyZXJcblx0ICovXG5cdFwicmVuZGVyZXJcIjogbnVsbCxcblxuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIGRhdGEgcHJvcGVydHkgbmFtZSB0aGF0IERhdGFUYWJsZXMgc2hvdWxkIHVzZSB0byBnZXQgYSByb3cncyBpZFxuXHQgKiB0byBzZXQgYXMgdGhlIGBpZGAgcHJvcGVydHkgaW4gdGhlIG5vZGUuXG5cdCAqL1xuXHRcInJvd0lkXCI6IFwiRFRfUm93SWRcIixcblxuXG5cdC8qKlxuXHQgKiBDYXB0aW9uIHZhbHVlXG5cdCAqL1xuXHRcImNhcHRpb25cIjogbnVsbCxcblxuXG5cdC8qKlxuXHQgKiBGb3Igc2VydmVyLXNpZGUgcHJvY2Vzc2luZyAtIHVzZSB0aGUgZGF0YSBmcm9tIHRoZSBET00gZm9yIHRoZSBmaXJzdCBkcmF3XG5cdCAqL1xuXHRpRGVmZXJMb2FkaW5nOiBudWxsLFxuXG5cdC8qKiBFdmVudCBsaXN0ZW5lcnMgKi9cblx0b246IG51bGxcbn07XG5cbl9mbkh1bmdhcmlhbk1hcCggRGF0YVRhYmxlLmRlZmF1bHRzICk7XG5cblxuXG4vKlxuICogRGV2ZWxvcGVyIG5vdGUgLSBTZWUgbm90ZSBpbiBtb2RlbC5kZWZhdWx0cy5qcyBhYm91dCB0aGUgdXNlIG9mIEh1bmdhcmlhblxuICogbm90YXRpb24gYW5kIGNhbWVsIGNhc2UuXG4gKi9cblxuLyoqXG4gKiBDb2x1bW4gb3B0aW9ucyB0aGF0IGNhbiBiZSBnaXZlbiB0byBEYXRhVGFibGVzIGF0IGluaXRpYWxpc2F0aW9uIHRpbWUuXG4gKiAgQG5hbWVzcGFjZVxuICovXG5EYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uID0ge1xuXHQvKipcblx0ICogRGVmaW5lIHdoaWNoIGNvbHVtbihzKSBhbiBvcmRlciB3aWxsIG9jY3VyIG9uIGZvciB0aGlzIGNvbHVtbi4gVGhpc1xuXHQgKiBhbGxvd3MgYSBjb2x1bW4ncyBvcmRlcmluZyB0byB0YWtlIG11bHRpcGxlIGNvbHVtbnMgaW50byBhY2NvdW50IHdoZW5cblx0ICogZG9pbmcgYSBzb3J0IG9yIHVzZSB0aGUgZGF0YSBmcm9tIGEgZGlmZmVyZW50IGNvbHVtbi4gRm9yIGV4YW1wbGUgZmlyc3Rcblx0ICogbmFtZSAvIGxhc3QgbmFtZSBjb2x1bW5zIG1ha2Ugc2Vuc2UgdG8gZG8gYSBtdWx0aS1jb2x1bW4gc29ydCBvdmVyIHRoZVxuXHQgKiB0d28gY29sdW1ucy5cblx0ICovXG5cdFwiYURhdGFTb3J0XCI6IG51bGwsXG5cdFwiaURhdGFTb3J0XCI6IC0xLFxuXG5cdGFyaWFUaXRsZTogJycsXG5cblxuXHQvKipcblx0ICogWW91IGNhbiBjb250cm9sIHRoZSBkZWZhdWx0IG9yZGVyaW5nIGRpcmVjdGlvbiwgYW5kIGV2ZW4gYWx0ZXIgdGhlXG5cdCAqIGJlaGF2aW91ciBvZiB0aGUgc29ydCBoYW5kbGVyIChpLmUuIG9ubHkgYWxsb3cgYXNjZW5kaW5nIG9yZGVyaW5nIGV0Yylcblx0ICogdXNpbmcgdGhpcyBwYXJhbWV0ZXIuXG5cdCAqL1xuXHRcImFzU29ydGluZ1wiOiBbICdhc2MnLCAnZGVzYycsICcnIF0sXG5cblxuXHQvKipcblx0ICogRW5hYmxlIG9yIGRpc2FibGUgZmlsdGVyaW5nIG9uIHRoZSBkYXRhIGluIHRoaXMgY29sdW1uLlxuXHQgKi9cblx0XCJiU2VhcmNoYWJsZVwiOiB0cnVlLFxuXG5cblx0LyoqXG5cdCAqIEVuYWJsZSBvciBkaXNhYmxlIG9yZGVyaW5nIG9uIHRoaXMgY29sdW1uLlxuXHQgKi9cblx0XCJiU29ydGFibGVcIjogdHJ1ZSxcblxuXG5cdC8qKlxuXHQgKiBFbmFibGUgb3IgZGlzYWJsZSB0aGUgZGlzcGxheSBvZiB0aGlzIGNvbHVtbi5cblx0ICovXG5cdFwiYlZpc2libGVcIjogdHJ1ZSxcblxuXG5cdC8qKlxuXHQgKiBEZXZlbG9wZXIgZGVmaW5hYmxlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW5ldmVyIGEgY2VsbCBpcyBjcmVhdGVkIChBamF4IHNvdXJjZSxcblx0ICogZXRjKSBvciBwcm9jZXNzZWQgZm9yIGlucHV0IChET00gc291cmNlKS4gVGhpcyBjYW4gYmUgdXNlZCBhcyBhIGNvbXBsaW1lbnQgdG8gbVJlbmRlclxuXHQgKiBhbGxvd2luZyB5b3UgdG8gbW9kaWZ5IHRoZSBET00gZWxlbWVudCAoYWRkIGJhY2tncm91bmQgY29sb3VyIGZvciBleGFtcGxlKSB3aGVuIHRoZVxuXHQgKiBlbGVtZW50IGlzIGF2YWlsYWJsZS5cblx0ICovXG5cdFwiZm5DcmVhdGVkQ2VsbFwiOiBudWxsLFxuXG5cblx0LyoqXG5cdCAqIFRoaXMgcHJvcGVydHkgY2FuIGJlIHVzZWQgdG8gcmVhZCBkYXRhIGZyb20gYW55IGRhdGEgc291cmNlIHByb3BlcnR5LFxuXHQgKiBpbmNsdWRpbmcgZGVlcGx5IG5lc3RlZCBvYmplY3RzIC8gcHJvcGVydGllcy4gYGRhdGFgIGNhbiBiZSBnaXZlbiBpbiBhXG5cdCAqIG51bWJlciBvZiBkaWZmZXJlbnQgd2F5cyB3aGljaCBlZmZlY3QgaXRzIGJlaGF2aW91cjpcblx0ICpcblx0ICogKiBgaW50ZWdlcmAgLSB0cmVhdGVkIGFzIGFuIGFycmF5IGluZGV4IGZvciB0aGUgZGF0YSBzb3VyY2UuIFRoaXMgaXMgdGhlXG5cdCAqICAgZGVmYXVsdCB0aGF0IERhdGFUYWJsZXMgdXNlcyAoaW5jcmVtZW50YWxseSBpbmNyZWFzZWQgZm9yIGVhY2ggY29sdW1uKS5cblx0ICogKiBgc3RyaW5nYCAtIHJlYWQgYW4gb2JqZWN0IHByb3BlcnR5IGZyb20gdGhlIGRhdGEgc291cmNlLiBUaGVyZSBhcmVcblx0ICogICB0aHJlZSAnc3BlY2lhbCcgb3B0aW9ucyB0aGF0IGNhbiBiZSB1c2VkIGluIHRoZSBzdHJpbmcgdG8gYWx0ZXIgaG93XG5cdCAqICAgRGF0YVRhYmxlcyByZWFkcyB0aGUgZGF0YSBmcm9tIHRoZSBzb3VyY2Ugb2JqZWN0OlxuXHQgKiAgICAqIGAuYCAtIERvdHRlZCBKYXZhc2NyaXB0IG5vdGF0aW9uLiBKdXN0IGFzIHlvdSB1c2UgYSBgLmAgaW5cblx0ICogICAgICBKYXZhc2NyaXB0IHRvIHJlYWQgZnJvbSBuZXN0ZWQgb2JqZWN0cywgc28gdG8gY2FuIHRoZSBvcHRpb25zXG5cdCAqICAgICAgc3BlY2lmaWVkIGluIGBkYXRhYC4gRm9yIGV4YW1wbGU6IGBicm93c2VyLnZlcnNpb25gIG9yXG5cdCAqICAgICAgYGJyb3dzZXIubmFtZWAuIElmIHlvdXIgb2JqZWN0IHBhcmFtZXRlciBuYW1lIGNvbnRhaW5zIGEgcGVyaW9kLCB1c2Vcblx0ICogICAgICBgXFxcXGAgdG8gZXNjYXBlIGl0IC0gaS5lLiBgZmlyc3RcXFxcLm5hbWVgLlxuXHQgKiAgICAqIGBbXWAgLSBBcnJheSBub3RhdGlvbi4gRGF0YVRhYmxlcyBjYW4gYXV0b21hdGljYWxseSBjb21iaW5lIGRhdGFcblx0ICogICAgICBmcm9tIGFuZCBhcnJheSBzb3VyY2UsIGpvaW5pbmcgdGhlIGRhdGEgd2l0aCB0aGUgY2hhcmFjdGVycyBwcm92aWRlZFxuXHQgKiAgICAgIGJldHdlZW4gdGhlIHR3byBicmFja2V0cy4gRm9yIGV4YW1wbGU6IGBuYW1lWywgXWAgd291bGQgcHJvdmlkZSBhXG5cdCAqICAgICAgY29tbWEtc3BhY2Ugc2VwYXJhdGVkIGxpc3QgZnJvbSB0aGUgc291cmNlIGFycmF5LiBJZiBubyBjaGFyYWN0ZXJzXG5cdCAqICAgICAgYXJlIHByb3ZpZGVkIGJldHdlZW4gdGhlIGJyYWNrZXRzLCB0aGUgb3JpZ2luYWwgYXJyYXkgc291cmNlIGlzXG5cdCAqICAgICAgcmV0dXJuZWQuXG5cdCAqICAgICogYCgpYCAtIEZ1bmN0aW9uIG5vdGF0aW9uLiBBZGRpbmcgYCgpYCB0byB0aGUgZW5kIG9mIGEgcGFyYW1ldGVyIHdpbGxcblx0ICogICAgICBleGVjdXRlIGEgZnVuY3Rpb24gb2YgdGhlIG5hbWUgZ2l2ZW4uIEZvciBleGFtcGxlOiBgYnJvd3NlcigpYCBmb3IgYVxuXHQgKiAgICAgIHNpbXBsZSBmdW5jdGlvbiBvbiB0aGUgZGF0YSBzb3VyY2UsIGBicm93c2VyLnZlcnNpb24oKWAgZm9yIGFcblx0ICogICAgICBmdW5jdGlvbiBpbiBhIG5lc3RlZCBwcm9wZXJ0eSBvciBldmVuIGBicm93c2VyKCkudmVyc2lvbmAgdG8gZ2V0IGFuXG5cdCAqICAgICAgb2JqZWN0IHByb3BlcnR5IGlmIHRoZSBmdW5jdGlvbiBjYWxsZWQgcmV0dXJucyBhbiBvYmplY3QuIE5vdGUgdGhhdFxuXHQgKiAgICAgIGZ1bmN0aW9uIG5vdGF0aW9uIGlzIHJlY29tbWVuZGVkIGZvciB1c2UgaW4gYHJlbmRlcmAgcmF0aGVyIHRoYW5cblx0ICogICAgICBgZGF0YWAgYXMgaXQgaXMgbXVjaCBzaW1wbGVyIHRvIHVzZSBhcyBhIHJlbmRlcmVyLlxuXHQgKiAqIGBudWxsYCAtIHVzZSB0aGUgb3JpZ2luYWwgZGF0YSBzb3VyY2UgZm9yIHRoZSByb3cgcmF0aGVyIHRoYW4gcGx1Y2tpbmdcblx0ICogICBkYXRhIGRpcmVjdGx5IGZyb20gaXQuIFRoaXMgYWN0aW9uIGhhcyBlZmZlY3RzIG9uIHR3byBvdGhlclxuXHQgKiAgIGluaXRpYWxpc2F0aW9uIG9wdGlvbnM6XG5cdCAqICAgICogYGRlZmF1bHRDb250ZW50YCAtIFdoZW4gbnVsbCBpcyBnaXZlbiBhcyB0aGUgYGRhdGFgIG9wdGlvbiBhbmRcblx0ICogICAgICBgZGVmYXVsdENvbnRlbnRgIGlzIHNwZWNpZmllZCBmb3IgdGhlIGNvbHVtbiwgdGhlIHZhbHVlIGRlZmluZWQgYnlcblx0ICogICAgICBgZGVmYXVsdENvbnRlbnRgIHdpbGwgYmUgdXNlZCBmb3IgdGhlIGNlbGwuXG5cdCAqICAgICogYHJlbmRlcmAgLSBXaGVuIG51bGwgaXMgdXNlZCBmb3IgdGhlIGBkYXRhYCBvcHRpb24gYW5kIHRoZSBgcmVuZGVyYFxuXHQgKiAgICAgIG9wdGlvbiBpcyBzcGVjaWZpZWQgZm9yIHRoZSBjb2x1bW4sIHRoZSB3aG9sZSBkYXRhIHNvdXJjZSBmb3IgdGhlXG5cdCAqICAgICAgcm93IGlzIHVzZWQgZm9yIHRoZSByZW5kZXJlci5cblx0ICogKiBgZnVuY3Rpb25gIC0gdGhlIGZ1bmN0aW9uIGdpdmVuIHdpbGwgYmUgZXhlY3V0ZWQgd2hlbmV2ZXIgRGF0YVRhYmxlc1xuXHQgKiAgIG5lZWRzIHRvIHNldCBvciBnZXQgdGhlIGRhdGEgZm9yIGEgY2VsbCBpbiB0aGUgY29sdW1uLiBUaGUgZnVuY3Rpb25cblx0ICogICB0YWtlcyB0aHJlZSBwYXJhbWV0ZXJzOlxuXHQgKiAgICAqIFBhcmFtZXRlcnM6XG5cdCAqICAgICAgKiBge2FycmF5fG9iamVjdH1gIFRoZSBkYXRhIHNvdXJjZSBmb3IgdGhlIHJvd1xuXHQgKiAgICAgICogYHtzdHJpbmd9YCBUaGUgdHlwZSBjYWxsIGRhdGEgcmVxdWVzdGVkIC0gdGhpcyB3aWxsIGJlICdzZXQnIHdoZW5cblx0ICogICAgICAgIHNldHRpbmcgZGF0YSBvciAnZmlsdGVyJywgJ2Rpc3BsYXknLCAndHlwZScsICdzb3J0JyBvciB1bmRlZmluZWRcblx0ICogICAgICAgIHdoZW4gZ2F0aGVyaW5nIGRhdGEuIE5vdGUgdGhhdCB3aGVuIGB1bmRlZmluZWRgIGlzIGdpdmVuIGZvciB0aGVcblx0ICogICAgICAgIHR5cGUgRGF0YVRhYmxlcyBleHBlY3RzIHRvIGdldCB0aGUgcmF3IGRhdGEgZm9yIHRoZSBvYmplY3QgYmFjazxcblx0ICogICAgICAqIGB7Kn1gIERhdGEgdG8gc2V0IHdoZW4gdGhlIHNlY29uZCBwYXJhbWV0ZXIgaXMgJ3NldCcuXG5cdCAqICAgICogUmV0dXJuOlxuXHQgKiAgICAgICogVGhlIHJldHVybiB2YWx1ZSBmcm9tIHRoZSBmdW5jdGlvbiBpcyBub3QgcmVxdWlyZWQgd2hlbiAnc2V0JyBpc1xuXHQgKiAgICAgICAgdGhlIHR5cGUgb2YgY2FsbCwgYnV0IG90aGVyd2lzZSB0aGUgcmV0dXJuIGlzIHdoYXQgd2lsbCBiZSB1c2VkXG5cdCAqICAgICAgICBmb3IgdGhlIGRhdGEgcmVxdWVzdGVkLlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgYGRhdGFgIGlzIGEgZ2V0dGVyIGFuZCBzZXR0ZXIgb3B0aW9uLiBJZiB5b3UganVzdCByZXF1aXJlXG5cdCAqIGZvcm1hdHRpbmcgb2YgZGF0YSBmb3Igb3V0cHV0LCB5b3Ugd2lsbCBsaWtlbHkgd2FudCB0byB1c2UgYHJlbmRlcmAgd2hpY2hcblx0ICogaXMgc2ltcGx5IGEgZ2V0dGVyIGFuZCB0aHVzIHNpbXBsZXIgdG8gdXNlLlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgcHJpb3IgdG8gRGF0YVRhYmxlcyAxLjkuMiBgZGF0YWAgd2FzIGNhbGxlZCBgbURhdGFQcm9wYC4gVGhlXG5cdCAqIG5hbWUgY2hhbmdlIHJlZmxlY3RzIHRoZSBmbGV4aWJpbGl0eSBvZiB0aGlzIHByb3BlcnR5IGFuZCBpcyBjb25zaXN0ZW50XG5cdCAqIHdpdGggdGhlIG5hbWluZyBvZiBtUmVuZGVyLiBJZiAnbURhdGFQcm9wJyBpcyBnaXZlbiwgdGhlbiBpdCB3aWxsIHN0aWxsXG5cdCAqIGJlIHVzZWQgYnkgRGF0YVRhYmxlcywgYXMgaXQgYXV0b21hdGljYWxseSBtYXBzIHRoZSBvbGQgbmFtZSB0byB0aGUgbmV3XG5cdCAqIGlmIHJlcXVpcmVkLlxuXHQgKi9cblx0XCJtRGF0YVwiOiBudWxsLFxuXG5cblx0LyoqXG5cdCAqIFRoaXMgcHJvcGVydHkgaXMgdGhlIHJlbmRlcmluZyBwYXJ0bmVyIHRvIGBkYXRhYCBhbmQgaXQgaXMgc3VnZ2VzdGVkIHRoYXRcblx0ICogd2hlbiB5b3Ugd2FudCB0byBtYW5pcHVsYXRlIGRhdGEgZm9yIGRpc3BsYXkgKGluY2x1ZGluZyBmaWx0ZXJpbmcsXG5cdCAqIHNvcnRpbmcgZXRjKSB3aXRob3V0IGFsdGVyaW5nIHRoZSB1bmRlcmx5aW5nIGRhdGEgZm9yIHRoZSB0YWJsZSwgdXNlIHRoaXNcblx0ICogcHJvcGVydHkuIGByZW5kZXJgIGNhbiBiZSBjb25zaWRlcmVkIHRvIGJlIHRoZSB0aGUgcmVhZCBvbmx5IGNvbXBhbmlvbiB0b1xuXHQgKiBgZGF0YWAgd2hpY2ggaXMgcmVhZCAvIHdyaXRlICh0aGVuIGFzIHN1Y2ggbW9yZSBjb21wbGV4KS4gTGlrZSBgZGF0YWBcblx0ICogdGhpcyBvcHRpb24gY2FuIGJlIGdpdmVuIGluIGEgbnVtYmVyIG9mIGRpZmZlcmVudCB3YXlzIHRvIGVmZmVjdCBpdHNcblx0ICogYmVoYXZpb3VyOlxuXHQgKlxuXHQgKiAqIGBpbnRlZ2VyYCAtIHRyZWF0ZWQgYXMgYW4gYXJyYXkgaW5kZXggZm9yIHRoZSBkYXRhIHNvdXJjZS4gVGhpcyBpcyB0aGVcblx0ICogICBkZWZhdWx0IHRoYXQgRGF0YVRhYmxlcyB1c2VzIChpbmNyZW1lbnRhbGx5IGluY3JlYXNlZCBmb3IgZWFjaCBjb2x1bW4pLlxuXHQgKiAqIGBzdHJpbmdgIC0gcmVhZCBhbiBvYmplY3QgcHJvcGVydHkgZnJvbSB0aGUgZGF0YSBzb3VyY2UuIFRoZXJlIGFyZVxuXHQgKiAgIHRocmVlICdzcGVjaWFsJyBvcHRpb25zIHRoYXQgY2FuIGJlIHVzZWQgaW4gdGhlIHN0cmluZyB0byBhbHRlciBob3dcblx0ICogICBEYXRhVGFibGVzIHJlYWRzIHRoZSBkYXRhIGZyb20gdGhlIHNvdXJjZSBvYmplY3Q6XG5cdCAqICAgICogYC5gIC0gRG90dGVkIEphdmFzY3JpcHQgbm90YXRpb24uIEp1c3QgYXMgeW91IHVzZSBhIGAuYCBpblxuXHQgKiAgICAgIEphdmFzY3JpcHQgdG8gcmVhZCBmcm9tIG5lc3RlZCBvYmplY3RzLCBzbyB0byBjYW4gdGhlIG9wdGlvbnNcblx0ICogICAgICBzcGVjaWZpZWQgaW4gYGRhdGFgLiBGb3IgZXhhbXBsZTogYGJyb3dzZXIudmVyc2lvbmAgb3Jcblx0ICogICAgICBgYnJvd3Nlci5uYW1lYC4gSWYgeW91ciBvYmplY3QgcGFyYW1ldGVyIG5hbWUgY29udGFpbnMgYSBwZXJpb2QsIHVzZVxuXHQgKiAgICAgIGBcXFxcYCB0byBlc2NhcGUgaXQgLSBpLmUuIGBmaXJzdFxcXFwubmFtZWAuXG5cdCAqICAgICogYFtdYCAtIEFycmF5IG5vdGF0aW9uLiBEYXRhVGFibGVzIGNhbiBhdXRvbWF0aWNhbGx5IGNvbWJpbmUgZGF0YVxuXHQgKiAgICAgIGZyb20gYW5kIGFycmF5IHNvdXJjZSwgam9pbmluZyB0aGUgZGF0YSB3aXRoIHRoZSBjaGFyYWN0ZXJzIHByb3ZpZGVkXG5cdCAqICAgICAgYmV0d2VlbiB0aGUgdHdvIGJyYWNrZXRzLiBGb3IgZXhhbXBsZTogYG5hbWVbLCBdYCB3b3VsZCBwcm92aWRlIGFcblx0ICogICAgICBjb21tYS1zcGFjZSBzZXBhcmF0ZWQgbGlzdCBmcm9tIHRoZSBzb3VyY2UgYXJyYXkuIElmIG5vIGNoYXJhY3RlcnNcblx0ICogICAgICBhcmUgcHJvdmlkZWQgYmV0d2VlbiB0aGUgYnJhY2tldHMsIHRoZSBvcmlnaW5hbCBhcnJheSBzb3VyY2UgaXNcblx0ICogICAgICByZXR1cm5lZC5cblx0ICogICAgKiBgKClgIC0gRnVuY3Rpb24gbm90YXRpb24uIEFkZGluZyBgKClgIHRvIHRoZSBlbmQgb2YgYSBwYXJhbWV0ZXIgd2lsbFxuXHQgKiAgICAgIGV4ZWN1dGUgYSBmdW5jdGlvbiBvZiB0aGUgbmFtZSBnaXZlbi4gRm9yIGV4YW1wbGU6IGBicm93c2VyKClgIGZvciBhXG5cdCAqICAgICAgc2ltcGxlIGZ1bmN0aW9uIG9uIHRoZSBkYXRhIHNvdXJjZSwgYGJyb3dzZXIudmVyc2lvbigpYCBmb3IgYVxuXHQgKiAgICAgIGZ1bmN0aW9uIGluIGEgbmVzdGVkIHByb3BlcnR5IG9yIGV2ZW4gYGJyb3dzZXIoKS52ZXJzaW9uYCB0byBnZXQgYW5cblx0ICogICAgICBvYmplY3QgcHJvcGVydHkgaWYgdGhlIGZ1bmN0aW9uIGNhbGxlZCByZXR1cm5zIGFuIG9iamVjdC5cblx0ICogKiBgb2JqZWN0YCAtIHVzZSBkaWZmZXJlbnQgZGF0YSBmb3IgdGhlIGRpZmZlcmVudCBkYXRhIHR5cGVzIHJlcXVlc3RlZCBieVxuXHQgKiAgIERhdGFUYWJsZXMgKCdmaWx0ZXInLCAnZGlzcGxheScsICd0eXBlJyBvciAnc29ydCcpLiBUaGUgcHJvcGVydHkgbmFtZXNcblx0ICogICBvZiB0aGUgb2JqZWN0IGlzIHRoZSBkYXRhIHR5cGUgdGhlIHByb3BlcnR5IHJlZmVycyB0byBhbmQgdGhlIHZhbHVlIGNhblxuXHQgKiAgIGRlZmluZWQgdXNpbmcgYW4gaW50ZWdlciwgc3RyaW5nIG9yIGZ1bmN0aW9uIHVzaW5nIHRoZSBzYW1lIHJ1bGVzIGFzXG5cdCAqICAgYHJlbmRlcmAgbm9ybWFsbHkgZG9lcy4gTm90ZSB0aGF0IGFuIGBfYCBvcHRpb24gX211c3RfIGJlIHNwZWNpZmllZC5cblx0ICogICBUaGlzIGlzIHRoZSBkZWZhdWx0IHZhbHVlIHRvIHVzZSBpZiB5b3UgaGF2ZW4ndCBzcGVjaWZpZWQgYSB2YWx1ZSBmb3Jcblx0ICogICB0aGUgZGF0YSB0eXBlIHJlcXVlc3RlZCBieSBEYXRhVGFibGVzLlxuXHQgKiAqIGBmdW5jdGlvbmAgLSB0aGUgZnVuY3Rpb24gZ2l2ZW4gd2lsbCBiZSBleGVjdXRlZCB3aGVuZXZlciBEYXRhVGFibGVzXG5cdCAqICAgbmVlZHMgdG8gc2V0IG9yIGdldCB0aGUgZGF0YSBmb3IgYSBjZWxsIGluIHRoZSBjb2x1bW4uIFRoZSBmdW5jdGlvblxuXHQgKiAgIHRha2VzIHRocmVlIHBhcmFtZXRlcnM6XG5cdCAqICAgICogUGFyYW1ldGVyczpcblx0ICogICAgICAqIHthcnJheXxvYmplY3R9IFRoZSBkYXRhIHNvdXJjZSBmb3IgdGhlIHJvdyAoYmFzZWQgb24gYGRhdGFgKVxuXHQgKiAgICAgICoge3N0cmluZ30gVGhlIHR5cGUgY2FsbCBkYXRhIHJlcXVlc3RlZCAtIHRoaXMgd2lsbCBiZSAnZmlsdGVyJyxcblx0ICogICAgICAgICdkaXNwbGF5JywgJ3R5cGUnIG9yICdzb3J0Jy5cblx0ICogICAgICAqIHthcnJheXxvYmplY3R9IFRoZSBmdWxsIGRhdGEgc291cmNlIGZvciB0aGUgcm93IChub3QgYmFzZWQgb25cblx0ICogICAgICAgIGBkYXRhYClcblx0ICogICAgKiBSZXR1cm46XG5cdCAqICAgICAgKiBUaGUgcmV0dXJuIHZhbHVlIGZyb20gdGhlIGZ1bmN0aW9uIGlzIHdoYXQgd2lsbCBiZSB1c2VkIGZvciB0aGVcblx0ICogICAgICAgIGRhdGEgcmVxdWVzdGVkLlxuXHQgKi9cblx0XCJtUmVuZGVyXCI6IG51bGwsXG5cblxuXHQvKipcblx0ICogQ2hhbmdlIHRoZSBjZWxsIHR5cGUgY3JlYXRlZCBmb3IgdGhlIGNvbHVtbiAtIGVpdGhlciBURCBjZWxscyBvciBUSCBjZWxscy4gVGhpc1xuXHQgKiBjYW4gYmUgdXNlZnVsIGFzIFRIIGNlbGxzIGhhdmUgc2VtYW50aWMgbWVhbmluZyBpbiB0aGUgdGFibGUgYm9keSwgYWxsb3dpbmcgdGhlbVxuXHQgKiB0byBhY3QgYXMgYSBoZWFkZXIgZm9yIGEgcm93ICh5b3UgbWF5IHdpc2ggdG8gYWRkIHNjb3BlPSdyb3cnIHRvIHRoZSBUSCBlbGVtZW50cykuXG5cdCAqL1xuXHRcInNDZWxsVHlwZVwiOiBcInRkXCIsXG5cblxuXHQvKipcblx0ICogQ2xhc3MgdG8gZ2l2ZSB0byBlYWNoIGNlbGwgaW4gdGhpcyBjb2x1bW4uXG5cdCAqL1xuXHRcInNDbGFzc1wiOiBcIlwiLFxuXG5cdC8qKlxuXHQgKiBXaGVuIERhdGFUYWJsZXMgY2FsY3VsYXRlcyB0aGUgY29sdW1uIHdpZHRocyB0byBhc3NpZ24gdG8gZWFjaCBjb2x1bW4sXG5cdCAqIGl0IGZpbmRzIHRoZSBsb25nZXN0IHN0cmluZyBpbiBlYWNoIGNvbHVtbiBhbmQgdGhlbiBjb25zdHJ1Y3RzIGFcblx0ICogdGVtcG9yYXJ5IHRhYmxlIGFuZCByZWFkcyB0aGUgd2lkdGhzIGZyb20gdGhhdC4gVGhlIHByb2JsZW0gd2l0aCB0aGlzXG5cdCAqIGlzIHRoYXQgXCJtbW1cIiBpcyBtdWNoIHdpZGVyIHRoZW4gXCJpaWlpXCIsIGJ1dCB0aGUgbGF0dGVyIGlzIGEgbG9uZ2VyXG5cdCAqIHN0cmluZyAtIHRodXMgdGhlIGNhbGN1bGF0aW9uIGNhbiBnbyB3cm9uZyAoZG9pbmcgaXQgcHJvcGVybHkgYW5kIHB1dHRpbmdcblx0ICogaXQgaW50byBhbiBET00gb2JqZWN0IGFuZCBtZWFzdXJpbmcgdGhhdCBpcyBob3JyaWJseSghKSBzbG93KS4gVGh1cyBhc1xuXHQgKiBhIFwid29yayBhcm91bmRcIiB3ZSBwcm92aWRlIHRoaXMgb3B0aW9uLiBJdCB3aWxsIGFwcGVuZCBpdHMgdmFsdWUgdG8gdGhlXG5cdCAqIHRleHQgdGhhdCBpcyBmb3VuZCB0byBiZSB0aGUgbG9uZ2VzdCBzdHJpbmcgZm9yIHRoZSBjb2x1bW4gLSBpLmUuIHBhZGRpbmcuXG5cdCAqIEdlbmVyYWxseSB5b3Ugc2hvdWxkbid0IG5lZWQgdGhpcyFcblx0ICovXG5cdFwic0NvbnRlbnRQYWRkaW5nXCI6IFwiXCIsXG5cblxuXHQvKipcblx0ICogQWxsb3dzIGEgZGVmYXVsdCB2YWx1ZSB0byBiZSBnaXZlbiBmb3IgYSBjb2x1bW4ncyBkYXRhLCBhbmQgd2lsbCBiZSB1c2VkXG5cdCAqIHdoZW5ldmVyIGEgbnVsbCBkYXRhIHNvdXJjZSBpcyBlbmNvdW50ZXJlZCAodGhpcyBjYW4gYmUgYmVjYXVzZSBgZGF0YWBcblx0ICogaXMgc2V0IHRvIG51bGwsIG9yIGJlY2F1c2UgdGhlIGRhdGEgc291cmNlIGl0c2VsZiBpcyBudWxsKS5cblx0ICovXG5cdFwic0RlZmF1bHRDb250ZW50XCI6IG51bGwsXG5cblxuXHQvKipcblx0ICogVGhpcyBwYXJhbWV0ZXIgaXMgb25seSB1c2VkIGluIERhdGFUYWJsZXMnIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcuIEl0IGNhblxuXHQgKiBiZSBleGNlcHRpb25hbGx5IHVzZWZ1bCB0byBrbm93IHdoYXQgY29sdW1ucyBhcmUgYmVpbmcgZGlzcGxheWVkIG9uIHRoZVxuXHQgKiBjbGllbnQgc2lkZSwgYW5kIHRvIG1hcCB0aGVzZSB0byBkYXRhYmFzZSBmaWVsZHMuIFdoZW4gZGVmaW5lZCwgdGhlIG5hbWVzXG5cdCAqIGFsc28gYWxsb3cgRGF0YVRhYmxlcyB0byByZW9yZGVyIGluZm9ybWF0aW9uIGZyb20gdGhlIHNlcnZlciBpZiBpdCBjb21lc1xuXHQgKiBiYWNrIGluIGFuIHVuZXhwZWN0ZWQgb3JkZXIgKGkuZS4gaWYgeW91IHN3aXRjaCB5b3VyIGNvbHVtbnMgYXJvdW5kIG9uIHRoZVxuXHQgKiBjbGllbnQtc2lkZSwgeW91ciBzZXJ2ZXItc2lkZSBjb2RlIGRvZXMgbm90IGFsc28gbmVlZCB1cGRhdGluZykuXG5cdCAqL1xuXHRcInNOYW1lXCI6IFwiXCIsXG5cblxuXHQvKipcblx0ICogRGVmaW5lcyBhIGRhdGEgc291cmNlIHR5cGUgZm9yIHRoZSBvcmRlcmluZyB3aGljaCBjYW4gYmUgdXNlZCB0byByZWFkXG5cdCAqIHJlYWwtdGltZSBpbmZvcm1hdGlvbiBmcm9tIHRoZSB0YWJsZSAodXBkYXRpbmcgdGhlIGludGVybmFsbHkgY2FjaGVkXG5cdCAqIHZlcnNpb24pIHByaW9yIHRvIG9yZGVyaW5nLiBUaGlzIGFsbG93cyBvcmRlcmluZyB0byBvY2N1ciBvbiB1c2VyXG5cdCAqIGVkaXRhYmxlIGVsZW1lbnRzIHN1Y2ggYXMgZm9ybSBpbnB1dHMuXG5cdCAqL1xuXHRcInNTb3J0RGF0YVR5cGVcIjogXCJzdGRcIixcblxuXG5cdC8qKlxuXHQgKiBUaGUgdGl0bGUgb2YgdGhpcyBjb2x1bW4uXG5cdCAqL1xuXHRcInNUaXRsZVwiOiBudWxsLFxuXG5cblx0LyoqXG5cdCAqIFRoZSB0eXBlIGFsbG93cyB5b3UgdG8gc3BlY2lmeSBob3cgdGhlIGRhdGEgZm9yIHRoaXMgY29sdW1uIHdpbGwgYmVcblx0ICogb3JkZXJlZC4gRm91ciB0eXBlcyAoc3RyaW5nLCBudW1lcmljLCBkYXRlIGFuZCBodG1sICh3aGljaCB3aWxsIHN0cmlwXG5cdCAqIEhUTUwgdGFncyBiZWZvcmUgb3JkZXJpbmcpKSBhcmUgY3VycmVudGx5IGF2YWlsYWJsZS4gTm90ZSB0aGF0IG9ubHkgZGF0ZVxuXHQgKiBmb3JtYXRzIHVuZGVyc3Rvb2QgYnkgSmF2YXNjcmlwdCdzIERhdGUoKSBvYmplY3Qgd2lsbCBiZSBhY2NlcHRlZCBhcyB0eXBlXG5cdCAqIGRhdGUuIEZvciBleGFtcGxlOiBcIk1hciAyNiwgMjAwOCA1OjAzIFBNXCIuIE1heSB0YWtlIHRoZSB2YWx1ZXM6ICdzdHJpbmcnLFxuXHQgKiAnbnVtZXJpYycsICdkYXRlJyBvciAnaHRtbCcgKGJ5IGRlZmF1bHQpLiBGdXJ0aGVyIHR5cGVzIGNhbiBiZSBhZGRpbmdcblx0ICogdGhyb3VnaCBwbHVnLWlucy5cblx0ICovXG5cdFwic1R5cGVcIjogbnVsbCxcblxuXG5cdC8qKlxuXHQgKiBEZWZpbmluZyB0aGUgd2lkdGggb2YgdGhlIGNvbHVtbiwgdGhpcyBwYXJhbWV0ZXIgbWF5IHRha2UgYW55IENTUyB2YWx1ZVxuXHQgKiAoM2VtLCAyMHB4IGV0YykuIERhdGFUYWJsZXMgYXBwbGllcyAnc21hcnQnIHdpZHRocyB0byBjb2x1bW5zIHdoaWNoIGhhdmUgbm90XG5cdCAqIGJlZW4gZ2l2ZW4gYSBzcGVjaWZpYyB3aWR0aCB0aHJvdWdoIHRoaXMgaW50ZXJmYWNlIGVuc3VyaW5nIHRoYXQgdGhlIHRhYmxlXG5cdCAqIHJlbWFpbnMgcmVhZGFibGUuXG5cdCAqL1xuXHRcInNXaWR0aFwiOiBudWxsXG59O1xuXG5fZm5IdW5nYXJpYW5NYXAoIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4gKTtcblxuXG5cbi8qKlxuICogRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3QgLSB0aGlzIGhvbGRzIGFsbCB0aGUgaW5mb3JtYXRpb24gbmVlZGVkIGZvciBhXG4gKiBnaXZlbiB0YWJsZSwgaW5jbHVkaW5nIGNvbmZpZ3VyYXRpb24sIGRhdGEgYW5kIGN1cnJlbnQgYXBwbGljYXRpb24gb2YgdGhlXG4gKiB0YWJsZSBvcHRpb25zLiBEYXRhVGFibGVzIGRvZXMgbm90IGhhdmUgYSBzaW5nbGUgaW5zdGFuY2UgZm9yIGVhY2ggRGF0YVRhYmxlXG4gKiB3aXRoIHRoZSBzZXR0aW5ncyBhdHRhY2hlZCB0byB0aGF0IGluc3RhbmNlLCBidXQgcmF0aGVyIGluc3RhbmNlcyBvZiB0aGVcbiAqIERhdGFUYWJsZSBcImNsYXNzXCIgYXJlIGNyZWF0ZWQgb24tdGhlLWZseSBhcyBuZWVkZWQgKHR5cGljYWxseSBieSBhXG4gKiAkKCkuZGF0YVRhYmxlKCkgY2FsbCkgYW5kIHRoZSBzZXR0aW5ncyBvYmplY3QgaXMgdGhlbiBhcHBsaWVkIHRvIHRoYXRcbiAqIGluc3RhbmNlLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIG9iamVjdCBpcyByZWxhdGVkIHRvIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9IGJ1dCB0aGlzXG4gKiBvbmUgaXMgdGhlIGludGVybmFsIGRhdGEgc3RvcmUgZm9yIERhdGFUYWJsZXMncyBjYWNoZSBvZiBjb2x1bW5zLiBJdCBzaG91bGRcbiAqIE5PVCBiZSBtYW5pcHVsYXRlZCBvdXRzaWRlIG9mIERhdGFUYWJsZXMuIEFueSBjb25maWd1cmF0aW9uIHNob3VsZCBiZSBkb25lXG4gKiB0aHJvdWdoIHRoZSBpbml0aWFsaXNhdGlvbiBvcHRpb25zLlxuICovXG5EYXRhVGFibGUubW9kZWxzLm9TZXR0aW5ncyA9IHtcblx0LyoqXG5cdCAqIFByaW1hcnkgZmVhdHVyZXMgb2YgRGF0YVRhYmxlcyBhbmQgdGhlaXIgZW5hYmxlbWVudCBzdGF0ZS5cblx0ICovXG5cdFwib0ZlYXR1cmVzXCI6IHtcblxuXHRcdC8qKlxuXHRcdCAqIEZsYWcgdG8gc2F5IGlmIERhdGFUYWJsZXMgc2hvdWxkIGF1dG9tYXRpY2FsbHkgdHJ5IHRvIGNhbGN1bGF0ZSB0aGVcblx0XHQgKiBvcHRpbXVtIHRhYmxlIGFuZCBjb2x1bW5zIHdpZHRocyAodHJ1ZSkgb3Igbm90IChmYWxzZSkuXG5cdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdCAqL1xuXHRcdFwiYkF1dG9XaWR0aFwiOiBudWxsLFxuXG5cdFx0LyoqXG5cdFx0ICogRGVsYXkgdGhlIGNyZWF0aW9uIG9mIFRSIGFuZCBURCBlbGVtZW50cyB1bnRpbCB0aGV5IGFyZSBhY3R1YWxseVxuXHRcdCAqIG5lZWRlZCBieSBhIGRyaXZlbiBwYWdlIGRyYXcuIFRoaXMgY2FuIGdpdmUgYSBzaWduaWZpY2FudCBzcGVlZFxuXHRcdCAqIGluY3JlYXNlIGZvciBBamF4IHNvdXJjZSBhbmQgSmF2YXNjcmlwdCBzb3VyY2UgZGF0YSwgYnV0IG1ha2VzIG5vXG5cdFx0ICogZGlmZmVyZW5jZSBhdCBhbGwgZm9yIERPTSBhbmQgc2VydmVyLXNpZGUgcHJvY2Vzc2luZyB0YWJsZXMuXG5cdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdCAqL1xuXHRcdFwiYkRlZmVyUmVuZGVyXCI6IG51bGwsXG5cblx0XHQvKipcblx0XHQgKiBFbmFibGUgZmlsdGVyaW5nIG9uIHRoZSB0YWJsZSBvciBub3QuIE5vdGUgdGhhdCBpZiB0aGlzIGlzIGRpc2FibGVkXG5cdFx0ICogdGhlbiB0aGVyZSBpcyBubyBmaWx0ZXJpbmcgYXQgYWxsIG9uIHRoZSB0YWJsZSwgaW5jbHVkaW5nIGZuRmlsdGVyLlxuXHRcdCAqIFRvIGp1c3QgcmVtb3ZlIHRoZSBmaWx0ZXJpbmcgaW5wdXQgdXNlIHNEb20gYW5kIHJlbW92ZSB0aGUgJ2YnIG9wdGlvbi5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICovXG5cdFx0XCJiRmlsdGVyXCI6IG51bGwsXG5cblx0XHQvKipcblx0XHQgKiBVc2VkIG9ubHkgZm9yIGNvbXBhdGlibGl0eSB3aXRoIERUMVxuXHRcdCAqIEBkZXByZWNhdGVkXG5cdFx0ICovXG5cdFx0XCJiSW5mb1wiOiB0cnVlLFxuXG5cdFx0LyoqXG5cdFx0ICogVXNlZCBvbmx5IGZvciBjb21wYXRpYmxpdHkgd2l0aCBEVDFcblx0XHQgKiBAZGVwcmVjYXRlZFxuXHRcdCAqL1xuXHRcdFwiYkxlbmd0aENoYW5nZVwiOiB0cnVlLFxuXG5cdFx0LyoqXG5cdFx0ICogUGFnaW5hdGlvbiBlbmFibGVkIG9yIG5vdC4gTm90ZSB0aGF0IGlmIHRoaXMgaXMgZGlzYWJsZWQgdGhlbiBsZW5ndGhcblx0XHQgKiBjaGFuZ2luZyBtdXN0IGFsc28gYmUgZGlzYWJsZWQuXG5cdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdCAqL1xuXHRcdFwiYlBhZ2luYXRlXCI6IG51bGwsXG5cblx0XHQvKipcblx0XHQgKiBQcm9jZXNzaW5nIGluZGljYXRvciBlbmFibGUgZmxhZyB3aGVuZXZlciBEYXRhVGFibGVzIGlzIGVuYWN0aW5nIGFcblx0XHQgKiB1c2VyIHJlcXVlc3QgLSB0eXBpY2FsbHkgYW4gQWpheCByZXF1ZXN0IGZvciBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nLlxuXHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHQgKi9cblx0XHRcImJQcm9jZXNzaW5nXCI6IG51bGwsXG5cblx0XHQvKipcblx0XHQgKiBTZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIGVuYWJsZWQgZmxhZyAtIHdoZW4gZW5hYmxlZCBEYXRhVGFibGVzIHdpbGxcblx0XHQgKiBnZXQgYWxsIGRhdGEgZnJvbSB0aGUgc2VydmVyIGZvciBldmVyeSBkcmF3IC0gdGhlcmUgaXMgbm8gZmlsdGVyaW5nLFxuXHRcdCAqIHNvcnRpbmcgb3IgcGFnaW5nIGRvbmUgb24gdGhlIGNsaWVudC1zaWRlLlxuXHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHQgKi9cblx0XHRcImJTZXJ2ZXJTaWRlXCI6IG51bGwsXG5cblx0XHQvKipcblx0XHQgKiBTb3J0aW5nIGVuYWJsZW1lbnQgZmxhZy5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICovXG5cdFx0XCJiU29ydFwiOiBudWxsLFxuXG5cdFx0LyoqXG5cdFx0ICogTXVsdGktY29sdW1uIHNvcnRpbmdcblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICovXG5cdFx0XCJiU29ydE11bHRpXCI6IG51bGwsXG5cblx0XHQvKipcblx0XHQgKiBBcHBseSBhIGNsYXNzIHRvIHRoZSBjb2x1bW5zIHdoaWNoIGFyZSBiZWluZyBzb3J0ZWQgdG8gcHJvdmlkZSBhXG5cdFx0ICogdmlzdWFsIGhpZ2hsaWdodCBvciBub3QuIFRoaXMgY2FuIHNsb3cgdGhpbmdzIGRvd24gd2hlbiBlbmFibGVkIHNpbmNlXG5cdFx0ICogdGhlcmUgaXMgYSBsb3Qgb2YgRE9NIGludGVyYWN0aW9uLlxuXHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHQgKi9cblx0XHRcImJTb3J0Q2xhc3Nlc1wiOiBudWxsLFxuXG5cdFx0LyoqXG5cdFx0ICogU3RhdGUgc2F2aW5nIGVuYWJsZW1lbnQgZmxhZy5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICovXG5cdFx0XCJiU3RhdGVTYXZlXCI6IG51bGxcblx0fSxcblxuXG5cdC8qKlxuXHQgKiBTY3JvbGxpbmcgc2V0dGluZ3MgZm9yIGEgdGFibGUuXG5cdCAqL1xuXHRcIm9TY3JvbGxcIjoge1xuXHRcdC8qKlxuXHRcdCAqIFdoZW4gdGhlIHRhYmxlIGlzIHNob3J0ZXIgaW4gaGVpZ2h0IHRoYW4gc1Njcm9sbFksIGNvbGxhcHNlIHRoZVxuXHRcdCAqIHRhYmxlIGNvbnRhaW5lciBkb3duIHRvIHRoZSBoZWlnaHQgb2YgdGhlIHRhYmxlICh3aGVuIHRydWUpLlxuXHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHQgKi9cblx0XHRcImJDb2xsYXBzZVwiOiBudWxsLFxuXG5cdFx0LyoqXG5cdFx0ICogV2lkdGggb2YgdGhlIHNjcm9sbGJhciBmb3IgdGhlIHdlYi1icm93c2VyJ3MgcGxhdGZvcm0uIENhbGN1bGF0ZWRcblx0XHQgKiBkdXJpbmcgdGFibGUgaW5pdGlhbGlzYXRpb24uXG5cdFx0ICovXG5cdFx0XCJpQmFyV2lkdGhcIjogMCxcblxuXHRcdC8qKlxuXHRcdCAqIFZpZXdwb3J0IHdpZHRoIGZvciBob3Jpem9udGFsIHNjcm9sbGluZy4gSG9yaXpvbnRhbCBzY3JvbGxpbmcgaXNcblx0XHQgKiBkaXNhYmxlZCBpZiBhbiBlbXB0eSBzdHJpbmcuXG5cdFx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHRcdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHRcdCAqL1xuXHRcdFwic1hcIjogbnVsbCxcblxuXHRcdC8qKlxuXHRcdCAqIFdpZHRoIHRvIGV4cGFuZCB0aGUgdGFibGUgdG8gd2hlbiB1c2luZyB4LXNjcm9sbGluZy4gVHlwaWNhbGx5IHlvdVxuXHRcdCAqIHNob3VsZCBub3QgbmVlZCB0byB1c2UgdGhpcy5cblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdFx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdFx0ICogIEBkZXByZWNhdGVkXG5cdFx0ICovXG5cdFx0XCJzWElubmVyXCI6IG51bGwsXG5cblx0XHQvKipcblx0XHQgKiBWaWV3cG9ydCBoZWlnaHQgZm9yIHZlcnRpY2FsIHNjcm9sbGluZy4gVmVydGljYWwgc2Nyb2xsaW5nIGlzIGRpc2FibGVkXG5cdFx0ICogaWYgYW4gZW1wdHkgc3RyaW5nLlxuXHRcdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0XHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0XHQgKi9cblx0XHRcInNZXCI6IG51bGxcblx0fSxcblxuXHQvKipcblx0ICogTGFuZ3VhZ2UgaW5mb3JtYXRpb24gZm9yIHRoZSB0YWJsZS5cblx0ICovXG5cdFwib0xhbmd1YWdlXCI6IHtcblx0XHQvKipcblx0XHQgKiBJbmZvcm1hdGlvbiBjYWxsYmFjayBmdW5jdGlvbi4gU2VlXG5cdFx0ICoge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0cy5mbkluZm9DYWxsYmFja31cblx0XHQgKi9cblx0XHRcImZuSW5mb0NhbGxiYWNrXCI6IG51bGxcblx0fSxcblxuXHQvKipcblx0ICogQnJvd3NlciBzdXBwb3J0IHBhcmFtZXRlcnNcblx0ICovXG5cdFwib0Jyb3dzZXJcIjoge1xuXHRcdC8qKlxuXHRcdCAqIERldGVybWluZSBpZiB0aGUgdmVydGljYWwgc2Nyb2xsYmFyIGlzIG9uIHRoZSByaWdodCBvciBsZWZ0IG9mIHRoZVxuXHRcdCAqIHNjcm9sbGluZyBjb250YWluZXIgLSBuZWVkZWQgZm9yIHJ0bCBsYW5ndWFnZSBsYXlvdXQsIGFsdGhvdWdoIG5vdFxuXHRcdCAqIGFsbCBicm93c2VycyBtb3ZlIHRoZSBzY3JvbGxiYXIgKFNhZmFyaSkuXG5cdFx0ICovXG5cdFx0XCJiU2Nyb2xsYmFyTGVmdFwiOiBmYWxzZSxcblxuXHRcdC8qKlxuXHRcdCAqIEJyb3dzZXIgc2Nyb2xsYmFyIHdpZHRoXG5cdFx0ICovXG5cdFx0XCJiYXJXaWR0aFwiOiAwXG5cdH0sXG5cblxuXHRcImFqYXhcIjogbnVsbCxcblxuXG5cdC8qKlxuXHQgKiBBcnJheSByZWZlcmVuY2luZyB0aGUgbm9kZXMgd2hpY2ggYXJlIHVzZWQgZm9yIHRoZSBmZWF0dXJlcy4gVGhlXG5cdCAqIHBhcmFtZXRlcnMgb2YgdGhpcyBvYmplY3QgbWF0Y2ggd2hhdCBpcyBhbGxvd2VkIGJ5IHNEb20gLSBpLmUuXG5cdCAqICAgPHVsPlxuXHQgKiAgICAgPGxpPidsJyAtIExlbmd0aCBjaGFuZ2luZzwvbGk+XG5cdCAqICAgICA8bGk+J2YnIC0gRmlsdGVyaW5nIGlucHV0PC9saT5cblx0ICogICAgIDxsaT4ndCcgLSBUaGUgdGFibGUhPC9saT5cblx0ICogICAgIDxsaT4naScgLSBJbmZvcm1hdGlvbjwvbGk+XG5cdCAqICAgICA8bGk+J3AnIC0gUGFnaW5hdGlvbjwvbGk+XG5cdCAqICAgICA8bGk+J3InIC0gcFJvY2Vzc2luZzwvbGk+XG5cdCAqICAgPC91bD5cblx0ICovXG5cdFwiYWFuRmVhdHVyZXNcIjogW10sXG5cblx0LyoqXG5cdCAqIFN0b3JlIGRhdGEgaW5mb3JtYXRpb24gLSBzZWUge0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1Jvd30gZm9yIGRldGFpbGVkXG5cdCAqIGluZm9ybWF0aW9uLlxuXHQgKi9cblx0XCJhb0RhdGFcIjogW10sXG5cblx0LyoqXG5cdCAqIEFycmF5IG9mIGluZGV4ZXMgd2hpY2ggYXJlIGluIHRoZSBjdXJyZW50IGRpc3BsYXkgKGFmdGVyIGZpbHRlcmluZyBldGMpXG5cdCAqL1xuXHRcImFpRGlzcGxheVwiOiBbXSxcblxuXHQvKipcblx0ICogQXJyYXkgb2YgaW5kZXhlcyBmb3IgZGlzcGxheSAtIG5vIGZpbHRlcmluZ1xuXHQgKi9cblx0XCJhaURpc3BsYXlNYXN0ZXJcIjogW10sXG5cblx0LyoqXG5cdCAqIE1hcCBvZiByb3cgaWRzIHRvIGRhdGEgaW5kZXhlc1xuXHQgKi9cblx0XCJhSWRzXCI6IHt9LFxuXG5cdC8qKlxuXHQgKiBTdG9yZSBpbmZvcm1hdGlvbiBhYm91dCBlYWNoIGNvbHVtbiB0aGF0IGlzIGluIHVzZVxuXHQgKi9cblx0XCJhb0NvbHVtbnNcIjogW10sXG5cblx0LyoqXG5cdCAqIFN0b3JlIGluZm9ybWF0aW9uIGFib3V0IHRoZSB0YWJsZSdzIGhlYWRlclxuXHQgKi9cblx0XCJhb0hlYWRlclwiOiBbXSxcblxuXHQvKipcblx0ICogU3RvcmUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHRhYmxlJ3MgZm9vdGVyXG5cdCAqL1xuXHRcImFvRm9vdGVyXCI6IFtdLFxuXG5cdC8qKlxuXHQgKiBTdG9yZSB0aGUgYXBwbGllZCBnbG9iYWwgc2VhcmNoIGluZm9ybWF0aW9uIGluIGNhc2Ugd2Ugd2FudCB0byBmb3JjZSBhXG5cdCAqIHJlc2VhcmNoIG9yIGNvbXBhcmUgdGhlIG9sZCBzZWFyY2ggdG8gYSBuZXcgb25lLlxuXHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHQgKi9cblx0XCJvUHJldmlvdXNTZWFyY2hcIjoge30sXG5cblx0LyoqXG5cdCAqIFN0b3JlIGZvciBuYW1lZCBzZWFyY2hlc1xuXHQgKi9cblx0c2VhcmNoRml4ZWQ6IHt9LFxuXG5cdC8qKlxuXHQgKiBTdG9yZSB0aGUgYXBwbGllZCBzZWFyY2ggZm9yIGVhY2ggY29sdW1uIC0gc2VlXG5cdCAqIHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZWFyY2h9IGZvciB0aGUgZm9ybWF0IHRoYXQgaXMgdXNlZCBmb3IgdGhlXG5cdCAqIGZpbHRlcmluZyBpbmZvcm1hdGlvbiBmb3IgZWFjaCBjb2x1bW4uXG5cdCAqL1xuXHRcImFvUHJlU2VhcmNoQ29sc1wiOiBbXSxcblxuXHQvKipcblx0ICogU29ydGluZyB0aGF0IGlzIGFwcGxpZWQgdG8gdGhlIHRhYmxlLiBOb3RlIHRoYXQgdGhlIGlubmVyIGFycmF5cyBhcmVcblx0ICogdXNlZCBpbiB0aGUgZm9sbG93aW5nIG1hbm5lcjpcblx0ICogPHVsPlxuXHQgKiAgIDxsaT5JbmRleCAwIC0gY29sdW1uIG51bWJlcjwvbGk+XG5cdCAqICAgPGxpPkluZGV4IDEgLSBjdXJyZW50IHNvcnRpbmcgZGlyZWN0aW9uPC9saT5cblx0ICogPC91bD5cblx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0ICovXG5cdFwiYWFTb3J0aW5nXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIFNvcnRpbmcgdGhhdCBpcyBhbHdheXMgYXBwbGllZCB0byB0aGUgdGFibGUgKGkuZS4gcHJlZml4ZWQgaW4gZnJvbnQgb2Zcblx0ICogYWFTb3J0aW5nKS5cblx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0ICovXG5cdFwiYWFTb3J0aW5nRml4ZWRcIjogW10sXG5cblx0LyoqXG5cdCAqIElmIHJlc3RvcmluZyBhIHRhYmxlIC0gd2Ugc2hvdWxkIHJlc3RvcmUgaXRzIHdpZHRoXG5cdCAqL1xuXHRcInNEZXN0cm95V2lkdGhcIjogMCxcblxuXHQvKipcblx0ICogQ2FsbGJhY2sgZnVuY3Rpb25zIGFycmF5IGZvciBldmVyeSB0aW1lIGEgcm93IGlzIGluc2VydGVkIChpLmUuIG9uIGEgZHJhdykuXG5cdCAqL1xuXHRcImFvUm93Q2FsbGJhY2tcIjogW10sXG5cblx0LyoqXG5cdCAqIENhbGxiYWNrIGZ1bmN0aW9ucyBmb3IgdGhlIGhlYWRlciBvbiBlYWNoIGRyYXcuXG5cdCAqL1xuXHRcImFvSGVhZGVyQ2FsbGJhY2tcIjogW10sXG5cblx0LyoqXG5cdCAqIENhbGxiYWNrIGZ1bmN0aW9uIGZvciB0aGUgZm9vdGVyIG9uIGVhY2ggZHJhdy5cblx0ICovXG5cdFwiYW9Gb290ZXJDYWxsYmFja1wiOiBbXSxcblxuXHQvKipcblx0ICogQXJyYXkgb2YgY2FsbGJhY2sgZnVuY3Rpb25zIGZvciBkcmF3IGNhbGxiYWNrIGZ1bmN0aW9uc1xuXHQgKi9cblx0XCJhb0RyYXdDYWxsYmFja1wiOiBbXSxcblxuXHQvKipcblx0ICogQXJyYXkgb2YgY2FsbGJhY2sgZnVuY3Rpb25zIGZvciByb3cgY3JlYXRlZCBmdW5jdGlvblxuXHQgKi9cblx0XCJhb1Jvd0NyZWF0ZWRDYWxsYmFja1wiOiBbXSxcblxuXHQvKipcblx0ICogQ2FsbGJhY2sgZnVuY3Rpb25zIGZvciBqdXN0IGJlZm9yZSB0aGUgdGFibGUgaXMgcmVkcmF3bi4gQSByZXR1cm4gb2Zcblx0ICogZmFsc2Ugd2lsbCBiZSB1c2VkIHRvIGNhbmNlbCB0aGUgZHJhdy5cblx0ICovXG5cdFwiYW9QcmVEcmF3Q2FsbGJhY2tcIjogW10sXG5cblx0LyoqXG5cdCAqIENhbGxiYWNrIGZ1bmN0aW9ucyBmb3Igd2hlbiB0aGUgdGFibGUgaGFzIGJlZW4gaW5pdGlhbGlzZWQuXG5cdCAqL1xuXHRcImFvSW5pdENvbXBsZXRlXCI6IFtdLFxuXG5cblx0LyoqXG5cdCAqIENhbGxiYWNrcyBmb3IgbW9kaWZ5aW5nIHRoZSBzZXR0aW5ncyB0byBiZSBzdG9yZWQgZm9yIHN0YXRlIHNhdmluZywgcHJpb3IgdG9cblx0ICogc2F2aW5nIHN0YXRlLlxuXHQgKi9cblx0XCJhb1N0YXRlU2F2ZVBhcmFtc1wiOiBbXSxcblxuXHQvKipcblx0ICogQ2FsbGJhY2tzIGZvciBtb2RpZnlpbmcgdGhlIHNldHRpbmdzIHRoYXQgaGF2ZSBiZWVuIHN0b3JlZCBmb3Igc3RhdGUgc2F2aW5nXG5cdCAqIHByaW9yIHRvIHVzaW5nIHRoZSBzdG9yZWQgdmFsdWVzIHRvIHJlc3RvcmUgdGhlIHN0YXRlLlxuXHQgKi9cblx0XCJhb1N0YXRlTG9hZFBhcmFtc1wiOiBbXSxcblxuXHQvKipcblx0ICogQ2FsbGJhY2tzIGZvciBvcGVyYXRpbmcgb24gdGhlIHNldHRpbmdzIG9iamVjdCBvbmNlIHRoZSBzYXZlZCBzdGF0ZSBoYXMgYmVlblxuXHQgKiBsb2FkZWRcblx0ICovXG5cdFwiYW9TdGF0ZUxvYWRlZFwiOiBbXSxcblxuXHQvKipcblx0ICogQ2FjaGUgdGhlIHRhYmxlIElEIGZvciBxdWljayBhY2Nlc3Ncblx0ICovXG5cdFwic1RhYmxlSWRcIjogXCJcIixcblxuXHQvKipcblx0ICogVGhlIFRBQkxFIG5vZGUgZm9yIHRoZSBtYWluIHRhYmxlXG5cdCAqL1xuXHRcIm5UYWJsZVwiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBQZXJtYW5lbnQgcmVmIHRvIHRoZSB0aGVhZCBlbGVtZW50XG5cdCAqL1xuXHRcIm5USGVhZFwiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBQZXJtYW5lbnQgcmVmIHRvIHRoZSB0Zm9vdCBlbGVtZW50IC0gaWYgaXQgZXhpc3RzXG5cdCAqL1xuXHRcIm5URm9vdFwiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBQZXJtYW5lbnQgcmVmIHRvIHRoZSB0Ym9keSBlbGVtZW50XG5cdCAqL1xuXHRcIm5UQm9keVwiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBDYWNoZSB0aGUgd3JhcHBlciBub2RlIChjb250YWlucyBhbGwgRGF0YVRhYmxlcyBjb250cm9sbGVkIGVsZW1lbnRzKVxuXHQgKi9cblx0XCJuVGFibGVXcmFwcGVyXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIEluZGljYXRlIGlmIGFsbCByZXF1aXJlZCBpbmZvcm1hdGlvbiBoYXMgYmVlbiByZWFkIGluXG5cdCAqL1xuXHRcImJJbml0aWFsaXNlZFwiOiBmYWxzZSxcblxuXHQvKipcblx0ICogSW5mb3JtYXRpb24gYWJvdXQgb3BlbiByb3dzLiBFYWNoIG9iamVjdCBpbiB0aGUgYXJyYXkgaGFzIHRoZSBwYXJhbWV0ZXJzXG5cdCAqICduVHInIGFuZCAnblBhcmVudCdcblx0ICovXG5cdFwiYW9PcGVuUm93c1wiOiBbXSxcblxuXHQvKipcblx0ICogRGljdGF0ZSB0aGUgcG9zaXRpb25pbmcgb2YgRGF0YVRhYmxlcycgY29udHJvbCBlbGVtZW50cyAtIHNlZVxuXHQgKiB7QGxpbmsgRGF0YVRhYmxlLm1vZGVsLm9Jbml0LnNEb219LlxuXHQgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG5cdCAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuXHQgKi9cblx0XCJzRG9tXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIFNlYXJjaCBkZWxheSAoaW4gbVMpXG5cdCAqL1xuXHRcInNlYXJjaERlbGF5XCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIFdoaWNoIHR5cGUgb2YgcGFnaW5hdGlvbiBzaG91bGQgYmUgdXNlZC5cblx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0ICovXG5cdFwic1BhZ2luYXRpb25UeXBlXCI6IFwidHdvX2J1dHRvblwiLFxuXG5cdC8qKlxuXHQgKiBOdW1iZXIgb2YgcGFnaW5nIGNvbnRyb2xzIG9uIHRoZSBwYWdlLiBPbmx5IHVzZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cdCAqL1xuXHRwYWdpbmdDb250cm9sczogMCxcblxuXHQvKipcblx0ICogVGhlIHN0YXRlIGR1cmF0aW9uIChmb3IgYHN0YXRlU2F2ZWApIGluIHNlY29uZHMuXG5cdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdCAqL1xuXHRcImlTdGF0ZUR1cmF0aW9uXCI6IDAsXG5cblx0LyoqXG5cdCAqIEFycmF5IG9mIGNhbGxiYWNrIGZ1bmN0aW9ucyBmb3Igc3RhdGUgc2F2aW5nLiBFYWNoIGFycmF5IGVsZW1lbnQgaXMgYW5cblx0ICogb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuXHQgKiAgIDx1bD5cblx0ICogICAgIDxsaT5mdW5jdGlvbjpmbiAtIGZ1bmN0aW9uIHRvIGNhbGwuIFRha2VzIHR3byBwYXJhbWV0ZXJzLCBvU2V0dGluZ3Ncblx0ICogICAgICAgYW5kIHRoZSBKU09OIHN0cmluZyB0byBzYXZlIHRoYXQgaGFzIGJlZW4gdGh1cyBmYXIgY3JlYXRlZC4gUmV0dXJuc1xuXHQgKiAgICAgICBhIEpTT04gc3RyaW5nIHRvIGJlIGluc2VydGVkIGludG8gYSBqc29uIG9iamVjdFxuXHQgKiAgICAgICAoaS5lLiAnXCJwYXJhbVwiOiBbIDAsIDEsIDJdJyk8L2xpPlxuXHQgKiAgICAgPGxpPnN0cmluZzpzTmFtZSAtIG5hbWUgb2YgY2FsbGJhY2s8L2xpPlxuXHQgKiAgIDwvdWw+XG5cdCAqL1xuXHRcImFvU3RhdGVTYXZlXCI6IFtdLFxuXG5cdC8qKlxuXHQgKiBBcnJheSBvZiBjYWxsYmFjayBmdW5jdGlvbnMgZm9yIHN0YXRlIGxvYWRpbmcuIEVhY2ggYXJyYXkgZWxlbWVudCBpcyBhblxuXHQgKiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG5cdCAqICAgPHVsPlxuXHQgKiAgICAgPGxpPmZ1bmN0aW9uOmZuIC0gZnVuY3Rpb24gdG8gY2FsbC4gVGFrZXMgdHdvIHBhcmFtZXRlcnMsIG9TZXR0aW5nc1xuXHQgKiAgICAgICBhbmQgdGhlIG9iamVjdCBzdG9yZWQuIE1heSByZXR1cm4gZmFsc2UgdG8gY2FuY2VsIHN0YXRlIGxvYWRpbmc8L2xpPlxuXHQgKiAgICAgPGxpPnN0cmluZzpzTmFtZSAtIG5hbWUgb2YgY2FsbGJhY2s8L2xpPlxuXHQgKiAgIDwvdWw+XG5cdCAqL1xuXHRcImFvU3RhdGVMb2FkXCI6IFtdLFxuXG5cdC8qKlxuXHQgKiBTdGF0ZSB0aGF0IHdhcyBzYXZlZC4gVXNlZnVsIGZvciBiYWNrIHJlZmVyZW5jZVxuXHQgKi9cblx0XCJvU2F2ZWRTdGF0ZVwiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBTdGF0ZSB0aGF0IHdhcyBsb2FkZWQuIFVzZWZ1bCBmb3IgYmFjayByZWZlcmVuY2Vcblx0ICovXG5cdFwib0xvYWRlZFN0YXRlXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIE5vdGUgaWYgZHJhdyBzaG91bGQgYmUgYmxvY2tlZCB3aGlsZSBnZXR0aW5nIGRhdGFcblx0ICovXG5cdFwiYkFqYXhEYXRhR2V0XCI6IHRydWUsXG5cblx0LyoqXG5cdCAqIFRoZSBsYXN0IGpRdWVyeSBYSFIgb2JqZWN0IHRoYXQgd2FzIHVzZWQgZm9yIHNlcnZlci1zaWRlIGRhdGEgZ2F0aGVyaW5nLlxuXHQgKiBUaGlzIGNhbiBiZSB1c2VkIGZvciB3b3JraW5nIHdpdGggdGhlIFhIUiBpbmZvcm1hdGlvbiBpbiBvbmUgb2YgdGhlXG5cdCAqIGNhbGxiYWNrc1xuXHQgKi9cblx0XCJqcVhIUlwiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBKU09OIHJldHVybmVkIGZyb20gdGhlIHNlcnZlciBpbiB0aGUgbGFzdCBBamF4IHJlcXVlc3Rcblx0ICovXG5cdFwianNvblwiOiB1bmRlZmluZWQsXG5cblx0LyoqXG5cdCAqIERhdGEgc3VibWl0dGVkIGFzIHBhcnQgb2YgdGhlIGxhc3QgQWpheCByZXF1ZXN0XG5cdCAqL1xuXHRcIm9BamF4RGF0YVwiOiB1bmRlZmluZWQsXG5cblx0LyoqXG5cdCAqIFNlbmQgdGhlIFhIUiBIVFRQIG1ldGhvZCAtIEdFVCBvciBQT1NUIChjb3VsZCBiZSBQVVQgb3IgREVMRVRFIGlmXG5cdCAqIHJlcXVpcmVkKS5cblx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0ICovXG5cdFwic1NlcnZlck1ldGhvZFwiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBGb3JtYXQgbnVtYmVycyBmb3IgZGlzcGxheS5cblx0ICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuXHQgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cblx0ICovXG5cdFwiZm5Gb3JtYXROdW1iZXJcIjogbnVsbCxcblxuXHQvKipcblx0ICogTGlzdCBvZiBvcHRpb25zIHRoYXQgY2FuIGJlIHVzZWQgZm9yIHRoZSB1c2VyIHNlbGVjdGFibGUgbGVuZ3RoIG1lbnUuXG5cdCAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cblx0ICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG5cdCAqL1xuXHRcImFMZW5ndGhNZW51XCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIENvdW50ZXIgZm9yIHRoZSBkcmF3cyB0aGF0IHRoZSB0YWJsZSBkb2VzLiBBbHNvIHVzZWQgYXMgYSB0cmFja2VyIGZvclxuXHQgKiBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nXG5cdCAqL1xuXHRcImlEcmF3XCI6IDAsXG5cblx0LyoqXG5cdCAqIEluZGljYXRlIGlmIGEgcmVkcmF3IGlzIGJlaW5nIGRvbmUgLSB1c2VmdWwgZm9yIEFqYXhcblx0ICovXG5cdFwiYkRyYXdpbmdcIjogZmFsc2UsXG5cblx0LyoqXG5cdCAqIERyYXcgaW5kZXggKGlEcmF3KSBvZiB0aGUgbGFzdCBlcnJvciB3aGVuIHBhcnNpbmcgdGhlIHJldHVybmVkIGRhdGFcblx0ICovXG5cdFwiaURyYXdFcnJvclwiOiAtMSxcblxuXHQvKipcblx0ICogUGFnaW5nIGRpc3BsYXkgbGVuZ3RoXG5cdCAqL1xuXHRcIl9pRGlzcGxheUxlbmd0aFwiOiAxMCxcblxuXHQvKipcblx0ICogUGFnaW5nIHN0YXJ0IHBvaW50IC0gYWlEaXNwbGF5IGluZGV4XG5cdCAqL1xuXHRcIl9pRGlzcGxheVN0YXJ0XCI6IDAsXG5cblx0LyoqXG5cdCAqIFNlcnZlci1zaWRlIHByb2Nlc3NpbmcgLSBudW1iZXIgb2YgcmVjb3JkcyBpbiB0aGUgcmVzdWx0IHNldFxuXHQgKiAoaS5lLiBiZWZvcmUgZmlsdGVyaW5nKSwgVXNlIGZuUmVjb3Jkc1RvdGFsIHJhdGhlciB0aGFuXG5cdCAqIHRoaXMgcHJvcGVydHkgdG8gZ2V0IHRoZSB2YWx1ZSBvZiB0aGUgbnVtYmVyIG9mIHJlY29yZHMsIHJlZ2FyZGxlc3Mgb2Zcblx0ICogdGhlIHNlcnZlci1zaWRlIHByb2Nlc3Npbmcgc2V0dGluZy5cblx0ICovXG5cdFwiX2lSZWNvcmRzVG90YWxcIjogMCxcblxuXHQvKipcblx0ICogU2VydmVyLXNpZGUgcHJvY2Vzc2luZyAtIG51bWJlciBvZiByZWNvcmRzIGluIHRoZSBjdXJyZW50IGRpc3BsYXkgc2V0XG5cdCAqIChpLmUuIGFmdGVyIGZpbHRlcmluZykuIFVzZSBmblJlY29yZHNEaXNwbGF5IHJhdGhlciB0aGFuXG5cdCAqIHRoaXMgcHJvcGVydHkgdG8gZ2V0IHRoZSB2YWx1ZSBvZiB0aGUgbnVtYmVyIG9mIHJlY29yZHMsIHJlZ2FyZGxlc3Mgb2Zcblx0ICogdGhlIHNlcnZlci1zaWRlIHByb2Nlc3Npbmcgc2V0dGluZy5cblx0ICovXG5cdFwiX2lSZWNvcmRzRGlzcGxheVwiOiAwLFxuXG5cdC8qKlxuXHQgKiBUaGUgY2xhc3NlcyB0byB1c2UgZm9yIHRoZSB0YWJsZVxuXHQgKi9cblx0XCJvQ2xhc3Nlc1wiOiB7fSxcblxuXHQvKipcblx0ICogRmxhZyBhdHRhY2hlZCB0byB0aGUgc2V0dGluZ3Mgb2JqZWN0IHNvIHlvdSBjYW4gY2hlY2sgaW4gdGhlIGRyYXdcblx0ICogY2FsbGJhY2sgaWYgZmlsdGVyaW5nIGhhcyBiZWVuIGRvbmUgaW4gdGhlIGRyYXcuIERlcHJlY2F0ZWQgaW4gZmF2b3VyIG9mXG5cdCAqIGV2ZW50cy5cblx0ICogIEBkZXByZWNhdGVkXG5cdCAqL1xuXHRcImJGaWx0ZXJlZFwiOiBmYWxzZSxcblxuXHQvKipcblx0ICogRmxhZyBhdHRhY2hlZCB0byB0aGUgc2V0dGluZ3Mgb2JqZWN0IHNvIHlvdSBjYW4gY2hlY2sgaW4gdGhlIGRyYXdcblx0ICogY2FsbGJhY2sgaWYgc29ydGluZyBoYXMgYmVlbiBkb25lIGluIHRoZSBkcmF3LiBEZXByZWNhdGVkIGluIGZhdm91ciBvZlxuXHQgKiBldmVudHMuXG5cdCAqICBAZGVwcmVjYXRlZFxuXHQgKi9cblx0XCJiU29ydGVkXCI6IGZhbHNlLFxuXG5cdC8qKlxuXHQgKiBJbmRpY2F0ZSB0aGF0IGlmIG11bHRpcGxlIHJvd3MgYXJlIGluIHRoZSBoZWFkZXIgYW5kIHRoZXJlIGlzIG1vcmUgdGhhblxuXHQgKiBvbmUgdW5pcXVlIGNlbGwgcGVyIGNvbHVtbi4gUmVwbGFjZWQgYnkgdGl0bGVSb3dcblx0ICovXG5cdFwiYlNvcnRDZWxsc1RvcFwiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXNhdGlvbiBvYmplY3QgdGhhdCBpcyB1c2VkIGZvciB0aGUgdGFibGVcblx0ICovXG5cdFwib0luaXRcIjogbnVsbCxcblxuXHQvKipcblx0ICogRGVzdHJveSBjYWxsYmFjayBmdW5jdGlvbnMgLSBmb3IgcGx1Zy1pbnMgdG8gYXR0YWNoIHRoZW1zZWx2ZXMgdG8gdGhlXG5cdCAqIGRlc3Ryb3kgc28gdGhleSBjYW4gY2xlYW4gdXAgbWFya3VwIGFuZCBldmVudHMuXG5cdCAqL1xuXHRcImFvRGVzdHJveUNhbGxiYWNrXCI6IFtdLFxuXG5cblx0LyoqXG5cdCAqIEdldCB0aGUgbnVtYmVyIG9mIHJlY29yZHMgaW4gdGhlIGN1cnJlbnQgcmVjb3JkIHNldCwgYmVmb3JlIGZpbHRlcmluZ1xuXHQgKi9cblx0XCJmblJlY29yZHNUb3RhbFwiOiBmdW5jdGlvbiAoKVxuXHR7XG5cdFx0cmV0dXJuIF9mbkRhdGFTb3VyY2UoIHRoaXMgKSA9PSAnc3NwJyA/XG5cdFx0XHR0aGlzLl9pUmVjb3Jkc1RvdGFsICogMSA6XG5cdFx0XHR0aGlzLmFpRGlzcGxheU1hc3Rlci5sZW5ndGg7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCB0aGUgbnVtYmVyIG9mIHJlY29yZHMgaW4gdGhlIGN1cnJlbnQgcmVjb3JkIHNldCwgYWZ0ZXIgZmlsdGVyaW5nXG5cdCAqL1xuXHRcImZuUmVjb3Jkc0Rpc3BsYXlcIjogZnVuY3Rpb24gKClcblx0e1xuXHRcdHJldHVybiBfZm5EYXRhU291cmNlKCB0aGlzICkgPT0gJ3NzcCcgP1xuXHRcdFx0dGhpcy5faVJlY29yZHNEaXNwbGF5ICogMSA6XG5cdFx0XHR0aGlzLmFpRGlzcGxheS5sZW5ndGg7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCB0aGUgZGlzcGxheSBlbmQgcG9pbnQgLSBhaURpc3BsYXkgaW5kZXhcblx0ICovXG5cdFwiZm5EaXNwbGF5RW5kXCI6IGZ1bmN0aW9uICgpXG5cdHtcblx0XHR2YXJcblx0XHRcdGxlbiAgICAgID0gdGhpcy5faURpc3BsYXlMZW5ndGgsXG5cdFx0XHRzdGFydCAgICA9IHRoaXMuX2lEaXNwbGF5U3RhcnQsXG5cdFx0XHRjYWxjICAgICA9IHN0YXJ0ICsgbGVuLFxuXHRcdFx0cmVjb3JkcyAgPSB0aGlzLmFpRGlzcGxheS5sZW5ndGgsXG5cdFx0XHRmZWF0dXJlcyA9IHRoaXMub0ZlYXR1cmVzLFxuXHRcdFx0cGFnaW5hdGUgPSBmZWF0dXJlcy5iUGFnaW5hdGU7XG5cblx0XHRpZiAoIGZlYXR1cmVzLmJTZXJ2ZXJTaWRlICkge1xuXHRcdFx0cmV0dXJuIHBhZ2luYXRlID09PSBmYWxzZSB8fCBsZW4gPT09IC0xID9cblx0XHRcdFx0c3RhcnQgKyByZWNvcmRzIDpcblx0XHRcdFx0TWF0aC5taW4oIHN0YXJ0K2xlbiwgdGhpcy5faVJlY29yZHNEaXNwbGF5ICk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0cmV0dXJuICEgcGFnaW5hdGUgfHwgY2FsYz5yZWNvcmRzIHx8IGxlbj09PS0xID9cblx0XHRcdFx0cmVjb3JkcyA6XG5cdFx0XHRcdGNhbGM7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBUaGUgRGF0YVRhYmxlcyBvYmplY3QgZm9yIHRoaXMgdGFibGVcblx0ICovXG5cdFwib0luc3RhbmNlXCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIFVuaXF1ZSBpZGVudGlmaWVyIGZvciBlYWNoIGluc3RhbmNlIG9mIHRoZSBEYXRhVGFibGVzIG9iamVjdC4gSWYgdGhlcmVcblx0ICogaXMgYW4gSUQgb24gdGhlIHRhYmxlIG5vZGUsIHRoZW4gaXQgdGFrZXMgdGhhdCB2YWx1ZSwgb3RoZXJ3aXNlIGFuXG5cdCAqIGluY3JlbWVudGluZyBpbnRlcm5hbCBjb3VudGVyIGlzIHVzZWQuXG5cdCAqL1xuXHRcInNJbnN0YW5jZVwiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiB0YWJpbmRleCBhdHRyaWJ1dGUgdmFsdWUgdGhhdCBpcyBhZGRlZCB0byBEYXRhVGFibGVzIGNvbnRyb2wgZWxlbWVudHMsIGFsbG93aW5nXG5cdCAqIGtleWJvYXJkIG5hdmlnYXRpb24gb2YgdGhlIHRhYmxlIGFuZCBpdHMgY29udHJvbHMuXG5cdCAqL1xuXHRcImlUYWJJbmRleFwiOiAwLFxuXG5cdC8qKlxuXHQgKiBESVYgY29udGFpbmVyIGZvciB0aGUgZm9vdGVyIHNjcm9sbGluZyB0YWJsZSBpZiBzY3JvbGxpbmdcblx0ICovXG5cdFwiblNjcm9sbEhlYWRcIjogbnVsbCxcblxuXHQvKipcblx0ICogRElWIGNvbnRhaW5lciBmb3IgdGhlIGZvb3RlciBzY3JvbGxpbmcgdGFibGUgaWYgc2Nyb2xsaW5nXG5cdCAqL1xuXHRcIm5TY3JvbGxGb290XCI6IG51bGwsXG5cblx0LyoqXG5cdCAqIExhc3QgYXBwbGllZCBzb3J0XG5cdCAqL1xuXHRcImFMYXN0U29ydFwiOiBbXSxcblxuXHQvKipcblx0ICogU3RvcmVkIHBsdWctaW4gaW5zdGFuY2VzXG5cdCAqL1xuXHRcIm9QbHVnaW5zXCI6IHt9LFxuXG5cdC8qKlxuXHQgKiBGdW5jdGlvbiB1c2VkIHRvIGdldCBhIHJvdydzIGlkIGZyb20gdGhlIHJvdydzIGRhdGFcblx0ICovXG5cdFwicm93SWRGblwiOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBEYXRhIGxvY2F0aW9uIHdoZXJlIHRvIHN0b3JlIGEgcm93J3MgaWRcblx0ICovXG5cdFwicm93SWRcIjogbnVsbCxcblxuXHRjYXB0aW9uOiAnJyxcblxuXHRjYXB0aW9uTm9kZTogbnVsbCxcblxuXHRjb2xncm91cDogbnVsbCxcblxuXHQvKiogRGVsYXkgbG9hZGluZyBvZiBkYXRhICovXG5cdGRlZmVyTG9hZGluZzogbnVsbCxcblxuXHQvKiogQWxsb3cgYXV0byB0eXBlIGRldGVjdGlvbiAqL1xuXHR0eXBlRGV0ZWN0OiB0cnVlLFxuXG5cdC8qKiBSZXNpemVPYnNlcnZlciBmb3IgdGhlIGNvbnRhaW5lciBkaXYgKi9cblx0cmVzaXplT2JzZXJ2ZXI6IG51bGwsXG5cblx0LyoqIEtlZXAgYSByZWNvcmQgb2YgdGhlIGxhc3Qgc2l6ZSBvZiB0aGUgY29udGFpbmVyLCBzbyB3ZSBjYW4gc2tpcCBkdXBsaWNhdGVzICovXG5cdGNvbnRhaW5lcldpZHRoOiAtMSxcblxuXHQvKiogUmV2ZXJzZSB0aGUgaW5pdGlhbCBvcmRlciBvZiB0aGUgZGF0YSBzZXQgb24gZGVzYyBvcmRlcmluZyAqL1xuXHRvcmRlckRlc2NSZXZlcnNlOiBudWxsLFxuXG5cdC8qKiBTaG93IC8gaGlkZSBvcmRlcmluZyBpbmRpY2F0b3JzIGluIGhlYWRlcnMgKi9cblx0b3JkZXJJbmRpY2F0b3JzOiB0cnVlLFxuXG5cdC8qKiBEZWZhdWx0IG9yZGVyaW5nIGxpc3RlbmVyICovXG5cdG9yZGVySGFuZGxlcjogdHJ1ZSxcblxuXHQvKiogVGl0bGUgcm93IGluZGljYXRvciAqL1xuXHR0aXRsZVJvdzogbnVsbFxufTtcblxuLyoqXG4gKiBFeHRlbnNpb24gb2JqZWN0IGZvciBEYXRhVGFibGVzIHRoYXQgaXMgdXNlZCB0byBwcm92aWRlIGFsbCBleHRlbnNpb25cbiAqIG9wdGlvbnMuXG4gKlxuICogTm90ZSB0aGF0IHRoZSBgRGF0YVRhYmxlLmV4dGAgb2JqZWN0IGlzIGF2YWlsYWJsZSB0aHJvdWdoXG4gKiBgalF1ZXJ5LmZuLmRhdGFUYWJsZS5leHRgIHdoZXJlIGl0IG1heSBiZSBhY2Nlc3NlZCBhbmQgbWFuaXB1bGF0ZWQuIEl0IGlzXG4gKiBhbHNvIGFsaWFzZWQgdG8gYGpRdWVyeS5mbi5kYXRhVGFibGVFeHRgIGZvciBoaXN0b3JpYyByZWFzb25zLlxuICogIEBuYW1lc3BhY2VcbiAqICBAZXh0ZW5kcyBEYXRhVGFibGUubW9kZWxzLmV4dFxuICovXG5cblxudmFyIGV4dFBhZ2luYXRpb24gPSBEYXRhVGFibGUuZXh0LnBhZ2VyO1xuXG4vLyBQYWdpbmcgYnV0dG9ucyBjb25maWd1cmF0aW9uXG4kLmV4dGVuZCggZXh0UGFnaW5hdGlvbiwge1xuXHRzaW1wbGU6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gWyAncHJldmlvdXMnLCAnbmV4dCcgXTtcblx0fSxcblxuXHRmdWxsOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIFsgJ2ZpcnN0JywgJ3ByZXZpb3VzJywgJ25leHQnLCAnbGFzdCcgXTtcblx0fSxcblxuXHRudW1iZXJzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIFsgJ251bWJlcnMnIF07XG5cdH0sXG5cblx0c2ltcGxlX251bWJlcnM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gWyAncHJldmlvdXMnLCAnbnVtYmVycycsICduZXh0JyBdO1xuXHR9LFxuXG5cdGZ1bGxfbnVtYmVyczogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBbICdmaXJzdCcsICdwcmV2aW91cycsICdudW1iZXJzJywgJ25leHQnLCAnbGFzdCcgXTtcblx0fSxcblxuXHRmaXJzdF9sYXN0OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIFsnZmlyc3QnLCAnbGFzdCddO1xuXHR9LFxuXG5cdGZpcnN0X2xhc3RfbnVtYmVyczogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBbJ2ZpcnN0JywgJ251bWJlcnMnLCAnbGFzdCddO1xuXHR9LFxuXG5cdC8vIEZvciB0ZXN0aW5nIGFuZCBwbHVnLWlucyB0byB1c2Vcblx0X251bWJlcnM6IF9wYWdpbmdOdW1iZXJzLFxuXG5cdC8vIE51bWJlciBvZiBudW1iZXIgYnV0dG9ucyAtIGxlZ2FjeSwgdXNlIGBudW1iZXJzYCBvcHRpb24gZm9yIHBhZ2luZyBmZWF0dXJlXG5cdG51bWJlcnNfbGVuZ3RoOiA3XG59ICk7XG5cblxuJC5leHRlbmQoIHRydWUsIERhdGFUYWJsZS5leHQucmVuZGVyZXIsIHtcblx0cGFnaW5nQnV0dG9uOiB7XG5cdFx0XzogZnVuY3Rpb24gKHNldHRpbmdzLCBidXR0b25UeXBlLCBjb250ZW50LCBhY3RpdmUsIGRpc2FibGVkKSB7XG5cdFx0XHR2YXIgY2xhc3NlcyA9IHNldHRpbmdzLm9DbGFzc2VzLnBhZ2luZztcblx0XHRcdHZhciBidG5DbGFzc2VzID0gW2NsYXNzZXMuYnV0dG9uXTtcblx0XHRcdHZhciBidG47XG5cblx0XHRcdGlmIChhY3RpdmUpIHtcblx0XHRcdFx0YnRuQ2xhc3Nlcy5wdXNoKGNsYXNzZXMuYWN0aXZlKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGRpc2FibGVkKSB7XG5cdFx0XHRcdGJ0bkNsYXNzZXMucHVzaChjbGFzc2VzLmRpc2FibGVkKVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoYnV0dG9uVHlwZSA9PT0gJ2VsbGlwc2lzJykge1xuXHRcdFx0XHRidG4gPSAkKCc8c3BhbiBjbGFzcz1cImVsbGlwc2lzXCI+PC9zcGFuPicpLmh0bWwoY29udGVudClbMF07XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0YnRuID0gJCgnPGJ1dHRvbj4nLCB7XG5cdFx0XHRcdFx0Y2xhc3M6IGJ0bkNsYXNzZXMuam9pbignICcpLFxuXHRcdFx0XHRcdHJvbGU6ICdsaW5rJyxcblx0XHRcdFx0XHR0eXBlOiAnYnV0dG9uJ1xuXHRcdFx0XHR9KS5odG1sKGNvbnRlbnQpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkaXNwbGF5OiBidG4sXG5cdFx0XHRcdGNsaWNrZXI6IGJ0blxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRwYWdpbmdDb250YWluZXI6IHtcblx0XHRfOiBmdW5jdGlvbiAoc2V0dGluZ3MsIGJ1dHRvbnMpIHtcblx0XHRcdC8vIE5vIHdyYXBwaW5nIGVsZW1lbnQgLSBqdXN0IGFwcGVuZCBkaXJlY3RseSB0byB0aGUgaG9zdFxuXHRcdFx0cmV0dXJuIGJ1dHRvbnM7XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIENvbW1vbiBmdW5jdGlvbiB0byByZW1vdmUgbmV3IGxpbmVzLCBzdHJpcCBIVE1MIGFuZCBkaWFjcml0aWMgY29udHJvbFxudmFyIF9maWx0ZXJTdHJpbmcgPSBmdW5jdGlvbiAoc3RyaXBIdG1sLCBub3JtYWxpemUpIHtcblx0cmV0dXJuIGZ1bmN0aW9uIChzdHIpIHtcblx0XHRpZiAoX2VtcHR5KHN0cikgfHwgdHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcblx0XHRcdHJldHVybiBzdHI7XG5cdFx0fVxuXG5cdFx0c3RyID0gc3RyLnJlcGxhY2UoIF9yZV9uZXdfbGluZXMsIFwiIFwiICk7XG5cblx0XHRpZiAoc3RyaXBIdG1sKSB7XG5cdFx0XHRzdHIgPSBfc3RyaXBIdG1sKHN0cik7XG5cdFx0fVxuXG5cdFx0aWYgKG5vcm1hbGl6ZSkge1xuXHRcdFx0c3RyID0gX25vcm1hbGl6ZShzdHIsIGZhbHNlKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gc3RyO1xuXHR9O1xufVxuXG4vKlxuICogUHVibGljIGhlbHBlciBmdW5jdGlvbnMuIFRoZXNlIGFyZW4ndCB1c2VkIGludGVybmFsbHkgYnkgRGF0YVRhYmxlcywgb3JcbiAqIGNhbGxlZCBieSBhbnkgb2YgdGhlIG9wdGlvbnMgcGFzc2VkIGludG8gRGF0YVRhYmxlcywgYnV0IHRoZXkgY2FuIGJlIHVzZWRcbiAqIGV4dGVybmFsbHkgYnkgZGV2ZWxvcGVycyB3b3JraW5nIHdpdGggRGF0YVRhYmxlcy4gVGhleSBhcmUgaGVscGVyIGZ1bmN0aW9uc1xuICogdG8gbWFrZSB3b3JraW5nIHdpdGggRGF0YVRhYmxlcyBhIGxpdHRsZSBiaXQgZWFzaWVyLlxuICovXG5cbi8qKlxuICogQ29tbW9uIGxvZ2ljIGZvciBtb21lbnQsIGx1eG9uIG9yIGEgZGF0ZSBhY3Rpb24uXG4gKlxuICogSGFwcGVucyBhZnRlciBfX21sZE9iaiwgc28gZG9uJ3QgbmVlZCB0byBjYWxsIGByZXNvbHZlV2luZG93c0xpYnNgIGFnYWluXG4gKi9cbmZ1bmN0aW9uIF9fbWxkKCBkdExpYiwgbW9tZW50Rm4sIGx1eG9uRm4sIGRhdGVGbiwgYXJnMSApIHtcblx0aWYgKF9fbW9tZW50KSB7XG5cdFx0cmV0dXJuIGR0TGliW21vbWVudEZuXSggYXJnMSApO1xuXHR9XG5cdGVsc2UgaWYgKF9fbHV4b24pIHtcblx0XHRyZXR1cm4gZHRMaWJbbHV4b25Gbl0oIGFyZzEgKTtcblx0fVxuXHRcblx0cmV0dXJuIGRhdGVGbiA/IGR0TGliW2RhdGVGbl0oIGFyZzEgKSA6IGR0TGliO1xufVxuXG5cbnZhciBfX21sV2FybmluZyA9IGZhbHNlO1xudmFyIF9fbHV4b247IC8vIENhbiBiZSBhc3NpZ25lZCBpbiBEYXRlVGFibGUudXNlKClcbnZhciBfX21vbWVudDsgLy8gQ2FuIGJlIGFzc2lnbmVkIGluIERhdGVUYWJsZS51c2UoKVxuXG4vKipcbiAqIFxuICovXG5mdW5jdGlvbiByZXNvbHZlV2luZG93TGlicygpIHtcblx0aWYgKHdpbmRvdy5sdXhvbiAmJiAhIF9fbHV4b24pIHtcblx0XHRfX2x1eG9uID0gd2luZG93Lmx1eG9uO1xuXHR9XG5cdFxuXHRpZiAod2luZG93Lm1vbWVudCAmJiAhIF9fbW9tZW50KSB7XG5cdFx0X19tb21lbnQgPSB3aW5kb3cubW9tZW50O1xuXHR9XG59XG5cbmZ1bmN0aW9uIF9fbWxkT2JqIChkLCBmb3JtYXQsIGxvY2FsZSkge1xuXHR2YXIgZHQ7XG5cblx0cmVzb2x2ZVdpbmRvd0xpYnMoKTtcblxuXHRpZiAoX19tb21lbnQpIHtcblx0XHRkdCA9IF9fbW9tZW50LnV0YyggZCwgZm9ybWF0LCBsb2NhbGUsIHRydWUgKTtcblxuXHRcdGlmICghIGR0LmlzVmFsaWQoKSkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9XG5cdGVsc2UgaWYgKF9fbHV4b24pIHtcblx0XHRkdCA9IGZvcm1hdCAmJiB0eXBlb2YgZCA9PT0gJ3N0cmluZydcblx0XHRcdD8gX19sdXhvbi5EYXRlVGltZS5mcm9tRm9ybWF0KCBkLCBmb3JtYXQgKVxuXHRcdFx0OiBfX2x1eG9uLkRhdGVUaW1lLmZyb21JU08oIGQgKTtcblxuXHRcdGlmICghIGR0LmlzVmFsaWQpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdGR0ID0gZHQuc2V0TG9jYWxlKGxvY2FsZSk7XG5cdH1cblx0ZWxzZSBpZiAoISBmb3JtYXQpIHtcblx0XHQvLyBObyBmb3JtYXQgZ2l2ZW4sIG11c3QgYmUgSVNPXG5cdFx0ZHQgPSBuZXcgRGF0ZShkKTtcblx0fVxuXHRlbHNlIHtcblx0XHRpZiAoISBfX21sV2FybmluZykge1xuXHRcdFx0YWxlcnQoJ0RhdGFUYWJsZXMgd2FybmluZzogRm9ybWF0dGVkIGRhdGUgd2l0aG91dCBNb21lbnQuanMgb3IgTHV4b24gLSBodHRwczovL2RhdGF0YWJsZXMubmV0L3RuLzE3Jyk7XG5cdFx0fVxuXG5cdFx0X19tbFdhcm5pbmcgPSB0cnVlO1xuXHR9XG5cblx0cmV0dXJuIGR0O1xufVxuXG4vLyBXcmFwcGVyIGZvciBkYXRlLCBkYXRldGltZSBhbmQgdGltZSB3aGljaCBhbGwgb3BlcmF0ZSB0aGUgc2FtZSB3YXkgd2l0aCB0aGUgZXhjZXB0aW9uIG9mXG4vLyB0aGUgb3V0cHV0IHN0cmluZyBmb3IgYXV0byBsb2NhbGUgc3VwcG9ydFxuZnVuY3Rpb24gX19tbEhlbHBlciAobG9jYWxlU3RyaW5nKSB7XG5cdHJldHVybiBmdW5jdGlvbiAoIGZyb20sIHRvLCBsb2NhbGUsIGRlZiApIHtcblx0XHQvLyBMdXhvbiBhbmQgTW9tZW50IHN1cHBvcnRcblx0XHQvLyBBcmd1bWVudCBzaGlmdGluZ1xuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA9PT0gMCApIHtcblx0XHRcdGxvY2FsZSA9ICdlbic7XG5cdFx0XHR0byA9IG51bGw7IC8vIG1lYW5zIHRvTG9jYWxlU3RyaW5nXG5cdFx0XHRmcm9tID0gbnVsbDsgLy8gbWVhbnMgaXNvODYwMVxuXHRcdH1cblx0XHRlbHNlIGlmICggYXJndW1lbnRzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdGxvY2FsZSA9ICdlbic7XG5cdFx0XHR0byA9IGZyb207XG5cdFx0XHRmcm9tID0gbnVsbDtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoIGFyZ3VtZW50cy5sZW5ndGggPT09IDIgKSB7XG5cdFx0XHRsb2NhbGUgPSB0bztcblx0XHRcdHRvID0gZnJvbTtcblx0XHRcdGZyb20gPSBudWxsO1xuXHRcdH1cblxuXHRcdHZhciB0eXBlTmFtZSA9ICdkYXRldGltZScgKyAodG8gPyAnLScgKyB0byA6ICcnKTtcblxuXHRcdC8vIEFkZCB0eXBlIGRldGVjdGlvbiBhbmQgc29ydGluZyBzcGVjaWZpYyB0byB0aGlzIGRhdGUgZm9ybWF0IC0gd2UgbmVlZCB0byBiZSBhYmxlIHRvIGlkZW50aWZ5XG5cdFx0Ly8gZGF0ZSB0eXBlIGNvbHVtbnMgYXMgc3VjaCwgcmF0aGVyIHRoYW4gYXMgbnVtYmVycyBpbiBleHRlbnNpb25zLiBIZW5jZSB0aGUgbmVlZCBmb3IgdGhpcy5cblx0XHRpZiAoISBEYXRhVGFibGUuZXh0LnR5cGUub3JkZXJbdHlwZU5hbWUgKyAnLXByZSddKSB7XG5cdFx0XHREYXRhVGFibGUudHlwZSh0eXBlTmFtZSwge1xuXHRcdFx0XHRkZXRlY3Q6IGZ1bmN0aW9uIChkKSB7XG5cdFx0XHRcdFx0Ly8gVGhlIHJlbmRlcmVyIHdpbGwgZ2l2ZSB0aGUgdmFsdWUgdG8gdHlwZSBkZXRlY3QgYXMgdGhlIHR5cGUhXG5cdFx0XHRcdFx0cmV0dXJuIGQgPT09IHR5cGVOYW1lID8gdHlwZU5hbWUgOiBmYWxzZTtcblx0XHRcdFx0fSxcblx0XHRcdFx0b3JkZXI6IHtcblx0XHRcdFx0XHRwcmU6IGZ1bmN0aW9uIChkKSB7XG5cdFx0XHRcdFx0XHQvLyBUaGUgcmVuZGVyZXIgZ2l2ZXMgdXMgTW9tZW50LCBMdXhvbiBvciBEYXRlIG9iZWN0cyBmb3IgdGhlIHNvcnRpbmcsIGFsbCBvZiB3aGljaCBoYXZlIGFcblx0XHRcdFx0XHRcdC8vIGB2YWx1ZU9mYCB3aGljaCBnaXZlcyBtaWxsaXNlY29uZHMgZXBvY2hcblx0XHRcdFx0XHRcdHJldHVybiBkLnZhbHVlT2YoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGNsYXNzTmFtZTogJ2R0LXJpZ2h0J1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBkLCB0eXBlICkge1xuXHRcdFx0Ly8gQWxsb3cgZm9yIGEgZGVmYXVsdCB2YWx1ZVxuXHRcdFx0aWYgKGQgPT09IG51bGwgfHwgZCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdGlmIChkZWYgPT09ICctLW5vdycpIHtcblx0XHRcdFx0XHQvLyBXZSB0cmVhdCBldmVyeXRoaW5nIGFzIFVUQyBmdXJ0aGVyIGRvd24sIHNvIG5vIGNoYW5nZXMgYXJlXG5cdFx0XHRcdFx0Ly8gbWFkZSwgYXMgc3VjaCBuZWVkIHRvIGdldCB0aGUgbG9jYWwgZGF0ZSAvIHRpbWUgYXMgaWYgaXQgd2VyZVxuXHRcdFx0XHRcdC8vIFVUQ1xuXHRcdFx0XHRcdHZhciBsb2NhbCA9IG5ldyBEYXRlKCk7XG5cdFx0XHRcdFx0ZCA9IG5ldyBEYXRlKCBEYXRlLlVUQyhcblx0XHRcdFx0XHRcdGxvY2FsLmdldEZ1bGxZZWFyKCksIGxvY2FsLmdldE1vbnRoKCksIGxvY2FsLmdldERhdGUoKSxcblx0XHRcdFx0XHRcdGxvY2FsLmdldEhvdXJzKCksIGxvY2FsLmdldE1pbnV0ZXMoKSwgbG9jYWwuZ2V0U2Vjb25kcygpXG5cdFx0XHRcdFx0KSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGQgPSAnJztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAodHlwZSA9PT0gJ3R5cGUnKSB7XG5cdFx0XHRcdC8vIFR5cGluZyB1c2VzIHRoZSB0eXBlIG5hbWUgZm9yIGZhc3QgbWF0Y2hpbmdcblx0XHRcdFx0cmV0dXJuIHR5cGVOYW1lO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZCA9PT0gJycpIHtcblx0XHRcdFx0cmV0dXJuIHR5cGUgIT09ICdzb3J0J1xuXHRcdFx0XHRcdD8gJydcblx0XHRcdFx0XHQ6IF9fbWxkT2JqKCcwMDAwLTAxLTAxIDAwOjAwOjAwJywgbnVsbCwgbG9jYWxlKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2hvcnRjdXQuIElmIGBmcm9tYCBhbmQgYHRvYCBhcmUgdGhlIHNhbWUsIHdlIGFyZSB1c2luZyB0aGUgcmVuZGVyZXIgdG9cblx0XHRcdC8vIGZvcm1hdCBmb3Igb3JkZXJpbmcsIG5vdCBkaXNwbGF5IC0gaXRzIGFscmVhZHkgaW4gdGhlIGRpc3BsYXkgZm9ybWF0LlxuXHRcdFx0aWYgKCB0byAhPT0gbnVsbCAmJiBmcm9tID09PSB0byAmJiB0eXBlICE9PSAnc29ydCcgJiYgdHlwZSAhPT0gJ3R5cGUnICYmICEgKGQgaW5zdGFuY2VvZiBEYXRlKSApIHtcblx0XHRcdFx0cmV0dXJuIGQ7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBkdCA9IF9fbWxkT2JqKGQsIGZyb20sIGxvY2FsZSk7XG5cblx0XHRcdGlmIChkdCA9PT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm4gZDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHR5cGUgPT09ICdzb3J0Jykge1xuXHRcdFx0XHRyZXR1cm4gZHQ7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHZhciBmb3JtYXR0ZWQgPSB0byA9PT0gbnVsbFxuXHRcdFx0XHQ/IF9fbWxkKGR0LCAndG9EYXRlJywgJ3RvSlNEYXRlJywgJycpW2xvY2FsZVN0cmluZ10oKVxuXHRcdFx0XHQ6IF9fbWxkKGR0LCAnZm9ybWF0JywgJ3RvRm9ybWF0JywgJ3RvSVNPU3RyaW5nJywgdG8pO1xuXG5cdFx0XHQvLyBYU1MgcHJvdGVjdGlvblxuXHRcdFx0cmV0dXJuIHR5cGUgPT09ICdkaXNwbGF5JyA/XG5cdFx0XHRcdF9lc2NhcGVIdG1sKCBmb3JtYXR0ZWQgKSA6XG5cdFx0XHRcdGZvcm1hdHRlZDtcblx0XHR9O1xuXHR9XG59XG5cbi8vIEJhc2VkIG9uIGxvY2FsZSwgZGV0ZXJtaW5lIHN0YW5kYXJkIG51bWJlciBmb3JtYXR0aW5nXG4vLyBGYWxsYmFjayBmb3IgbGVnYWN5IGJyb3dzZXJzIGlzIFVTIEVuZ2xpc2hcbnZhciBfX3Rob3VzYW5kcyA9ICcsJztcbnZhciBfX2RlY2ltYWwgPSAnLic7XG5cbmlmICh3aW5kb3cuSW50bCAhPT0gdW5kZWZpbmVkKSB7XG5cdHRyeSB7XG5cdFx0dmFyIG51bSA9IG5ldyBJbnRsLk51bWJlckZvcm1hdCgpLmZvcm1hdFRvUGFydHMoMTAwMDAwLjEpO1xuXHRcblx0XHRmb3IgKHZhciBpPTAgOyBpPG51bS5sZW5ndGggOyBpKyspIHtcblx0XHRcdGlmIChudW1baV0udHlwZSA9PT0gJ2dyb3VwJykge1xuXHRcdFx0XHRfX3Rob3VzYW5kcyA9IG51bVtpXS52YWx1ZTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKG51bVtpXS50eXBlID09PSAnZGVjaW1hbCcpIHtcblx0XHRcdFx0X19kZWNpbWFsID0gbnVtW2ldLnZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRjYXRjaCAoZSkge1xuXHRcdC8vIG5vb3Bcblx0fVxufVxuXG4vLyBGb3JtYXR0ZWQgZGF0ZSB0aW1lIGRldGVjdGlvbiAtIHVzZSBieSBkZWNsYXJpbmcgdGhlIGZvcm1hdHMgeW91IGFyZSBnb2luZyB0byB1c2VcbkRhdGFUYWJsZS5kYXRldGltZSA9IGZ1bmN0aW9uICggZm9ybWF0LCBsb2NhbGUgKSB7XG5cdHZhciB0eXBlTmFtZSA9ICdkYXRldGltZS0nICsgZm9ybWF0O1xuXG5cdGlmICghIGxvY2FsZSkge1xuXHRcdGxvY2FsZSA9ICdlbic7XG5cdH1cblxuXHRpZiAoISBEYXRhVGFibGUuZXh0LnR5cGUub3JkZXJbdHlwZU5hbWVdKSB7XG5cdFx0RGF0YVRhYmxlLnR5cGUodHlwZU5hbWUsIHtcblx0XHRcdGRldGVjdDogZnVuY3Rpb24gKGQpIHtcblx0XHRcdFx0dmFyIGR0ID0gX19tbGRPYmooZCwgZm9ybWF0LCBsb2NhbGUpO1xuXHRcdFx0XHRyZXR1cm4gZCA9PT0gJycgfHwgZHQgPyB0eXBlTmFtZSA6IGZhbHNlO1xuXHRcdFx0fSxcblx0XHRcdG9yZGVyOiB7XG5cdFx0XHRcdHByZTogZnVuY3Rpb24gKGQpIHtcblx0XHRcdFx0XHRyZXR1cm4gX19tbGRPYmooZCwgZm9ybWF0LCBsb2NhbGUpIHx8IDA7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRjbGFzc05hbWU6ICdkdC1yaWdodCdcblx0XHR9KTtcblx0fVxufVxuXG4vKipcbiAqIEhlbHBlcnMgZm9yIGBjb2x1bW5zLnJlbmRlcmAuXG4gKlxuICogVGhlIG9wdGlvbnMgZGVmaW5lZCBoZXJlIGNhbiBiZSB1c2VkIHdpdGggdGhlIGBjb2x1bW5zLnJlbmRlcmAgaW5pdGlhbGlzYXRpb25cbiAqIG9wdGlvbiB0byBwcm92aWRlIGEgZGlzcGxheSByZW5kZXJlci4gVGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgYXJlIGRlZmluZWQ6XG4gKlxuICogKiBgbW9tZW50YCAtIFVzZXMgdGhlIE1vbWVudEpTIGxpYnJhcnkgdG8gY29udmVydCBmcm9tIGEgZ2l2ZW4gZm9ybWF0IGludG8gYW5vdGhlci5cbiAqIFRoaXMgcmVuZGVyZXIgaGFzIHRocmVlIG92ZXJsb2FkczpcbiAqICAgKiAxIHBhcmFtZXRlcjpcbiAqICAgICAqIGBzdHJpbmdgIC0gRm9ybWF0IHRvIGNvbnZlcnQgdG8gKGFzc3VtZXMgaW5wdXQgaXMgSVNPODYwMSBhbmQgbG9jYWxlIGlzIGBlbmApXG4gKiAgICogMiBwYXJhbWV0ZXJzOlxuICogICAgICogYHN0cmluZ2AgLSBGb3JtYXQgdG8gY29udmVydCBmcm9tXG4gKiAgICAgKiBgc3RyaW5nYCAtIEZvcm1hdCB0byBjb252ZXJ0IHRvLiBBc3N1bWVzIGBlbmAgbG9jYWxlXG4gKiAgICogMyBwYXJhbWV0ZXJzOlxuICogICAgICogYHN0cmluZ2AgLSBGb3JtYXQgdG8gY29udmVydCBmcm9tXG4gKiAgICAgKiBgc3RyaW5nYCAtIEZvcm1hdCB0byBjb252ZXJ0IHRvXG4gKiAgICAgKiBgc3RyaW5nYCAtIExvY2FsZVxuICogKiBgbnVtYmVyYCAtIFdpbGwgZm9ybWF0IG51bWVyaWMgZGF0YSAoZGVmaW5lZCBieSBgY29sdW1ucy5kYXRhYCkgZm9yXG4gKiAgIGRpc3BsYXksIHJldGFpbmluZyB0aGUgb3JpZ2luYWwgdW5mb3JtYXR0ZWQgZGF0YSBmb3Igc29ydGluZyBhbmQgZmlsdGVyaW5nLlxuICogICBJdCB0YWtlcyA1IHBhcmFtZXRlcnM6XG4gKiAgICogYHN0cmluZ2AgLSBUaG91c2FuZHMgZ3JvdXBpbmcgc2VwYXJhdG9yXG4gKiAgICogYHN0cmluZ2AgLSBEZWNpbWFsIHBvaW50IGluZGljYXRvclxuICogICAqIGBpbnRlZ2VyYCAtIE51bWJlciBvZiBkZWNpbWFsIHBvaW50cyB0byBzaG93XG4gKiAgICogYHN0cmluZ2AgKG9wdGlvbmFsKSAtIFByZWZpeC5cbiAqICAgKiBgc3RyaW5nYCAob3B0aW9uYWwpIC0gUG9zdGZpeCAoL3N1ZmZpeCkuXG4gKiAqIGB0ZXh0YCAtIEVzY2FwZSBIVE1MIHRvIGhlbHAgcHJldmVudCBYU1MgYXR0YWNrcy4gSXQgaGFzIG5vIG9wdGlvbmFsXG4gKiAgIHBhcmFtZXRlcnMuXG4gKlxuICogQGV4YW1wbGVcbiAqICAgLy8gQ29sdW1uIGRlZmluaXRpb24gdXNpbmcgdGhlIG51bWJlciByZW5kZXJlclxuICogICB7XG4gKiAgICAgZGF0YTogXCJzYWxhcnlcIixcbiAqICAgICByZW5kZXI6ICQuZm4uZGF0YVRhYmxlLnJlbmRlci5udW1iZXIoICdcXCcnLCAnLicsIDAsICckJyApXG4gKiAgIH1cbiAqXG4gKiBAbmFtZXNwYWNlXG4gKi9cbkRhdGFUYWJsZS5yZW5kZXIgPSB7XG5cdGRhdGU6IF9fbWxIZWxwZXIoJ3RvTG9jYWxlRGF0ZVN0cmluZycpLFxuXHRkYXRldGltZTogX19tbEhlbHBlcigndG9Mb2NhbGVTdHJpbmcnKSxcblx0dGltZTogX19tbEhlbHBlcigndG9Mb2NhbGVUaW1lU3RyaW5nJyksXG5cdG51bWJlcjogZnVuY3Rpb24gKCB0aG91c2FuZHMsIGRlY2ltYWwsIHByZWNpc2lvbiwgcHJlZml4LCBwb3N0Zml4ICkge1xuXHRcdC8vIEF1dG8gbG9jYWxlIGRldGVjdGlvblxuXHRcdGlmICh0aG91c2FuZHMgPT09IG51bGwgfHwgdGhvdXNhbmRzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHRob3VzYW5kcyA9IF9fdGhvdXNhbmRzO1xuXHRcdH1cblxuXHRcdGlmIChkZWNpbWFsID09PSBudWxsIHx8IGRlY2ltYWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0ZGVjaW1hbCA9IF9fZGVjaW1hbDtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0ZGlzcGxheTogZnVuY3Rpb24gKCBkICkge1xuXHRcdFx0XHRpZiAoIHR5cGVvZiBkICE9PSAnbnVtYmVyJyAmJiB0eXBlb2YgZCAhPT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoZCA9PT0gJycgfHwgZCA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdHJldHVybiBkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIG5lZ2F0aXZlID0gZCA8IDAgPyAnLScgOiAnJztcblx0XHRcdFx0dmFyIGZsbyA9IHBhcnNlRmxvYXQoIGQgKTtcblx0XHRcdFx0dmFyIGFicyA9IE1hdGguYWJzKGZsbyk7XG5cblx0XHRcdFx0Ly8gU2NpZW50aWZpYyBub3RhdGlvbiBmb3IgbGFyZ2UgYW5kIHNtYWxsIG51bWJlcnNcblx0XHRcdFx0aWYgKGFicyA+PSAxMDAwMDAwMDAwMDAgfHwgKGFicyA8IDAuMDAwMSAmJiBhYnMgIT09IDApICkge1xuXHRcdFx0XHRcdHZhciBleHAgPSBmbG8udG9FeHBvbmVudGlhbChwcmVjaXNpb24pLnNwbGl0KC9lXFwrPy8pO1xuXHRcdFx0XHRcdHJldHVybiBleHBbMF0gKyAnIHggMTA8c3VwPicgKyBleHBbMV0gKyAnPC9zdXA+Jztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIE5hTiB0aGVuIHRoZXJlIGlzbid0IG11Y2ggZm9ybWF0dGluZyB0aGF0IHdlIGNhbiBkbyAtIGp1c3Rcblx0XHRcdFx0Ly8gcmV0dXJuIGltbWVkaWF0ZWx5LCBlc2NhcGluZyBhbnkgSFRNTCAodGhpcyB3YXMgc3VwcG9zZWQgdG9cblx0XHRcdFx0Ly8gYmUgYSBudW1iZXIgYWZ0ZXIgYWxsKVxuXHRcdFx0XHRpZiAoIGlzTmFOKCBmbG8gKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gX2VzY2FwZUh0bWwoIGQgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZsbyA9IGZsby50b0ZpeGVkKCBwcmVjaXNpb24gKTtcblx0XHRcdFx0ZCA9IE1hdGguYWJzKCBmbG8gKTtcblxuXHRcdFx0XHR2YXIgaW50UGFydCA9IHBhcnNlSW50KCBkLCAxMCApO1xuXHRcdFx0XHR2YXIgZmxvYXRQYXJ0ID0gcHJlY2lzaW9uID9cblx0XHRcdFx0XHRkZWNpbWFsKyhkIC0gaW50UGFydCkudG9GaXhlZCggcHJlY2lzaW9uICkuc3Vic3RyaW5nKCAyICk6XG5cdFx0XHRcdFx0Jyc7XG5cblx0XHRcdFx0Ly8gSWYgemVybywgdGhlbiBjYW4ndCBoYXZlIGEgbmVnYXRpdmUgcHJlZml4XG5cdFx0XHRcdGlmIChpbnRQYXJ0ID09PSAwICYmIHBhcnNlRmxvYXQoZmxvYXRQYXJ0KSA9PT0gMCkge1xuXHRcdFx0XHRcdG5lZ2F0aXZlID0gJyc7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbmVnYXRpdmUgKyAocHJlZml4fHwnJykgK1xuXHRcdFx0XHRcdGludFBhcnQudG9TdHJpbmcoKS5yZXBsYWNlKFxuXHRcdFx0XHRcdFx0L1xcQig/PShcXGR7M30pKyg/IVxcZCkpL2csIHRob3VzYW5kc1xuXHRcdFx0XHRcdCkgK1xuXHRcdFx0XHRcdGZsb2F0UGFydCArXG5cdFx0XHRcdFx0KHBvc3RmaXh8fCcnKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9LFxuXG5cdHRleHQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZGlzcGxheTogX2VzY2FwZUh0bWwsXG5cdFx0XHRmaWx0ZXI6IF9lc2NhcGVIdG1sXG5cdFx0fTtcblx0fVxufTtcblxuXG52YXIgX2V4dFR5cGVzID0gRGF0YVRhYmxlLmV4dC50eXBlO1xuXG4vLyBHZXQgLyBzZXQgdHlwZVxuRGF0YVRhYmxlLnR5cGUgPSBmdW5jdGlvbiAobmFtZSwgcHJvcCwgdmFsKSB7XG5cdGlmICghIHByb3ApIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0Y2xhc3NOYW1lOiBfZXh0VHlwZXMuY2xhc3NOYW1lW25hbWVdLFxuXHRcdFx0ZGV0ZWN0OiBfZXh0VHlwZXMuZGV0ZWN0LmZpbmQoZnVuY3Rpb24gKGZuKSB7XG5cdFx0XHRcdHJldHVybiBmbi5fbmFtZSA9PT0gbmFtZTtcblx0XHRcdH0pLFxuXHRcdFx0b3JkZXI6IHtcblx0XHRcdFx0cHJlOiBfZXh0VHlwZXMub3JkZXJbbmFtZSArICctcHJlJ10sXG5cdFx0XHRcdGFzYzogX2V4dFR5cGVzLm9yZGVyW25hbWUgKyAnLWFzYyddLFxuXHRcdFx0XHRkZXNjOiBfZXh0VHlwZXMub3JkZXJbbmFtZSArICctZGVzYyddXG5cdFx0XHR9LFxuXHRcdFx0cmVuZGVyOiBfZXh0VHlwZXMucmVuZGVyW25hbWVdLFxuXHRcdFx0c2VhcmNoOiBfZXh0VHlwZXMuc2VhcmNoW25hbWVdXG5cdFx0fTtcblx0fVxuXG5cdHZhciBzZXRQcm9wID0gZnVuY3Rpb24ocHJvcCwgcHJvcFZhbCkge1xuXHRcdF9leHRUeXBlc1twcm9wXVtuYW1lXSA9IHByb3BWYWw7XG5cdH07XG5cdHZhciBzZXREZXRlY3QgPSBmdW5jdGlvbiAoZGV0ZWN0KSB7XG5cdFx0Ly8gYGRldGVjdGAgY2FuIGJlIGEgZnVuY3Rpb24gb3IgYW4gb2JqZWN0IC0gd2Ugc2V0IGEgbmFtZVxuXHRcdC8vIHByb3BlcnR5IGZvciBlaXRoZXIgLSB0aGF0IGlzIHVzZWQgZm9yIHRoZSBkZXRlY3Rpb25cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZGV0ZWN0LCBcIl9uYW1lXCIsIHt2YWx1ZTogbmFtZX0pO1xuXG5cdFx0dmFyIGlkeCA9IF9leHRUeXBlcy5kZXRlY3QuZmluZEluZGV4KGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHRyZXR1cm4gaXRlbS5fbmFtZSA9PT0gbmFtZTtcblx0XHR9KTtcblxuXHRcdGlmIChpZHggPT09IC0xKSB7XG5cdFx0XHRfZXh0VHlwZXMuZGV0ZWN0LnVuc2hpZnQoZGV0ZWN0KTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRfZXh0VHlwZXMuZGV0ZWN0LnNwbGljZShpZHgsIDEsIGRldGVjdCk7XG5cdFx0fVxuXHR9O1xuXHR2YXIgc2V0T3JkZXIgPSBmdW5jdGlvbiAob2JqKSB7XG5cdFx0X2V4dFR5cGVzLm9yZGVyW25hbWUgKyAnLXByZSddID0gb2JqLnByZTsgLy8gY2FuIGJlIHVuZGVmaW5lZFxuXHRcdF9leHRUeXBlcy5vcmRlcltuYW1lICsgJy1hc2MnXSA9IG9iai5hc2M7IC8vIGNhbiBiZSB1bmRlZmluZWRcblx0XHRfZXh0VHlwZXMub3JkZXJbbmFtZSArICctZGVzYyddID0gb2JqLmRlc2M7IC8vIGNhbiBiZSB1bmRlZmluZWRcblx0fTtcblxuXHQvLyBwcm9wIGlzIG9wdGlvbmFsXG5cdGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHZhbCA9IHByb3A7XG5cdFx0cHJvcCA9IG51bGw7XG5cdH1cblxuXHRpZiAocHJvcCA9PT0gJ2NsYXNzTmFtZScpIHtcblx0XHRzZXRQcm9wKCdjbGFzc05hbWUnLCB2YWwpO1xuXHR9XG5cdGVsc2UgaWYgKHByb3AgPT09ICdkZXRlY3QnKSB7XG5cdFx0c2V0RGV0ZWN0KHZhbCk7XG5cdH1cblx0ZWxzZSBpZiAocHJvcCA9PT0gJ29yZGVyJykge1xuXHRcdHNldE9yZGVyKHZhbCk7XG5cdH1cblx0ZWxzZSBpZiAocHJvcCA9PT0gJ3JlbmRlcicpIHtcblx0XHRzZXRQcm9wKCdyZW5kZXInLCB2YWwpO1xuXHR9XG5cdGVsc2UgaWYgKHByb3AgPT09ICdzZWFyY2gnKSB7XG5cdFx0c2V0UHJvcCgnc2VhcmNoJywgdmFsKTtcblx0fVxuXHRlbHNlIGlmICghIHByb3ApIHtcblx0XHRpZiAodmFsLmNsYXNzTmFtZSkge1xuXHRcdFx0c2V0UHJvcCgnY2xhc3NOYW1lJywgdmFsLmNsYXNzTmFtZSk7XG5cdFx0fVxuXG5cdFx0aWYgKHZhbC5kZXRlY3QgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0c2V0RGV0ZWN0KHZhbC5kZXRlY3QpO1xuXHRcdH1cblxuXHRcdGlmICh2YWwub3JkZXIpIHtcblx0XHRcdHNldE9yZGVyKHZhbC5vcmRlcik7XG5cdFx0fVxuXG5cdFx0aWYgKHZhbC5yZW5kZXIgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0c2V0UHJvcCgncmVuZGVyJywgdmFsLnJlbmRlcik7XG5cdFx0fVxuXG5cdFx0aWYgKHZhbC5zZWFyY2ggIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0c2V0UHJvcCgnc2VhcmNoJywgdmFsLnNlYXJjaCk7XG5cdFx0fVxuXHR9XG59XG5cbi8vIEdldCBhIGxpc3Qgb2YgdHlwZXNcbkRhdGFUYWJsZS50eXBlcyA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIF9leHRUeXBlcy5kZXRlY3QubWFwKGZ1bmN0aW9uIChmbikge1xuXHRcdHJldHVybiBmbi5fbmFtZTtcblx0fSk7XG59O1xuXG52YXIgX19kaWFjcml0aWNTb3J0ID0gZnVuY3Rpb24gKGEsIGIpIHtcblx0YSA9IGEgIT09IG51bGwgJiYgYSAhPT0gdW5kZWZpbmVkID8gYS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkgOiAnJztcblx0YiA9IGIgIT09IG51bGwgJiYgYiAhPT0gdW5kZWZpbmVkID8gYi50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkgOiAnJztcblxuXHQvLyBDaGVja2VkIGZvciBgbmF2aWdhdG9yLmxhbmd1YWdlc2Agc3VwcG9ydCBpbiBgb25lT2ZgIHNvIHRoaXMgY29kZSBjYW4ndCBleGVjdXRlIGluIG9sZFxuXHQvLyBTYWZhcmkgYW5kIHRodXMgY2FuIGRpc2FibGUgdGhpcyBjaGVja1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGF0L2NvbXBhdFxuXHRyZXR1cm4gYS5sb2NhbGVDb21wYXJlKGIsIG5hdmlnYXRvci5sYW5ndWFnZXNbMF0gfHwgbmF2aWdhdG9yLmxhbmd1YWdlLCB7XG5cdFx0bnVtZXJpYzogdHJ1ZSxcblx0XHRpZ25vcmVQdW5jdHVhdGlvbjogdHJ1ZSxcblx0fSk7XG59XG5cbnZhciBfX2RpYWNyaXRpY0h0bWxTb3J0ID0gZnVuY3Rpb24gKGEsIGIpIHtcblx0YSA9IF9zdHJpcEh0bWwoYSk7XG5cdGIgPSBfc3RyaXBIdG1sKGIpO1xuXG5cdHJldHVybiBfX2RpYWNyaXRpY1NvcnQoYSwgYik7XG59XG5cbi8vXG4vLyBCdWlsdCBpbiBkYXRhIHR5cGVzXG4vL1xuXG5EYXRhVGFibGUudHlwZSgnc3RyaW5nJywge1xuXHRkZXRlY3Q6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gJ3N0cmluZyc7XG5cdH0sXG5cdG9yZGVyOiB7XG5cdFx0cHJlOiBmdW5jdGlvbiAoIGEgKSB7XG5cdFx0XHQvLyBUaGlzIGlzIGEgbGl0dGxlIGNvbXBsZXgsIGJ1dCBmYXN0ZXIgdGhhbiBhbHdheXMgY2FsbGluZyB0b1N0cmluZyxcblx0XHRcdC8vIGh0dHA6Ly9qc3BlcmYuY29tL3Rvc3RyaW5nLXYtY2hlY2tcblx0XHRcdHJldHVybiBfZW1wdHkoYSkgJiYgdHlwZW9mIGEgIT09ICdib29sZWFuJyA/XG5cdFx0XHRcdCcnIDpcblx0XHRcdFx0dHlwZW9mIGEgPT09ICdzdHJpbmcnID9cblx0XHRcdFx0XHRhLnRvTG93ZXJDYXNlKCkgOlxuXHRcdFx0XHRcdCEgYS50b1N0cmluZyA/XG5cdFx0XHRcdFx0XHQnJyA6XG5cdFx0XHRcdFx0XHRhLnRvU3RyaW5nKCk7XG5cdFx0fVxuXHR9LFxuXHRzZWFyY2g6IF9maWx0ZXJTdHJpbmcoZmFsc2UsIHRydWUpXG59KTtcblxuRGF0YVRhYmxlLnR5cGUoJ3N0cmluZy11dGY4Jywge1xuXHRkZXRlY3Q6IHtcblx0XHRhbGxPZjogZnVuY3Rpb24gKCBkICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblx0XHRvbmVPZjogZnVuY3Rpb24gKCBkICkge1xuXHRcdFx0Ly8gQXQgbGVhc3Qgb25lIGRhdGEgcG9pbnQgbXVzdCBjb250YWluIGEgbm9uLUFTQ0lJIGNoYXJhY3RlclxuXHRcdFx0Ly8gVGhpcyBsaW5lIHdpbGwgYWxzbyBjaGVjayBpZiBuYXZpZ2F0b3IubGFuZ3VhZ2VzIGlzIHN1cHBvcnRlZCBvciBub3QuIElmIG5vdCAoU2FmYXJpIDEwLjAtKVxuXHRcdFx0Ly8gdGhpcyBkYXRhIHR5cGUgd29uJ3QgYmUgc3VwcG9ydGVkLlxuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBhdC9jb21wYXRcblx0XHRcdHJldHVybiAhIF9lbXB0eSggZCApICYmIG5hdmlnYXRvci5sYW5ndWFnZXMgJiYgdHlwZW9mIGQgPT09ICdzdHJpbmcnICYmIGQubWF0Y2goL1teXFx4MDAtXFx4N0ZdLyk7XG5cdFx0fVxuXHR9LFxuXHRvcmRlcjoge1xuXHRcdGFzYzogX19kaWFjcml0aWNTb3J0LFxuXHRcdGRlc2M6IGZ1bmN0aW9uIChhLCBiKSB7XG5cdFx0XHRyZXR1cm4gX19kaWFjcml0aWNTb3J0KGEsIGIpICogLTE7XG5cdFx0fVxuXHR9LFxuXHRzZWFyY2g6IF9maWx0ZXJTdHJpbmcoZmFsc2UsIHRydWUpXG59KTtcblxuXG5EYXRhVGFibGUudHlwZSgnaHRtbCcsIHtcblx0ZGV0ZWN0OiB7XG5cdFx0YWxsT2Y6IGZ1bmN0aW9uICggZCApIHtcblx0XHRcdHJldHVybiBfZW1wdHkoIGQgKSB8fCAodHlwZW9mIGQgPT09ICdzdHJpbmcnICYmIGQuaW5kZXhPZignPCcpICE9PSAtMSk7XG5cdFx0fSxcblx0XHRvbmVPZjogZnVuY3Rpb24gKCBkICkge1xuXHRcdFx0Ly8gQXQgbGVhc3Qgb25lIGRhdGEgcG9pbnQgbXVzdCBjb250YWluIGEgYDxgXG5cdFx0XHRyZXR1cm4gISBfZW1wdHkoIGQgKSAmJiB0eXBlb2YgZCA9PT0gJ3N0cmluZycgJiYgZC5pbmRleE9mKCc8JykgIT09IC0xO1xuXHRcdH1cblx0fSxcblx0b3JkZXI6IHtcblx0XHRwcmU6IGZ1bmN0aW9uICggYSApIHtcblx0XHRcdHJldHVybiBfZW1wdHkoYSkgP1xuXHRcdFx0XHQnJyA6XG5cdFx0XHRcdGEucmVwbGFjZSA/XG5cdFx0XHRcdFx0X3N0cmlwSHRtbChhKS50cmltKCkudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdFx0YSsnJztcblx0XHR9XG5cdH0sXG5cdHNlYXJjaDogX2ZpbHRlclN0cmluZyh0cnVlLCB0cnVlKVxufSk7XG5cblxuRGF0YVRhYmxlLnR5cGUoJ2h0bWwtdXRmOCcsIHtcblx0ZGV0ZWN0OiB7XG5cdFx0YWxsT2Y6IGZ1bmN0aW9uICggZCApIHtcblx0XHRcdHJldHVybiBfZW1wdHkoIGQgKSB8fCAodHlwZW9mIGQgPT09ICdzdHJpbmcnICYmIGQuaW5kZXhPZignPCcpICE9PSAtMSk7XG5cdFx0fSxcblx0XHRvbmVPZjogZnVuY3Rpb24gKCBkICkge1xuXHRcdFx0Ly8gQXQgbGVhc3Qgb25lIGRhdGEgcG9pbnQgbXVzdCBjb250YWluIGEgYDxgIGFuZCBhIG5vbi1BU0NJSSBjaGFyYWN0ZXJcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wYXQvY29tcGF0XG5cdFx0XHRyZXR1cm4gbmF2aWdhdG9yLmxhbmd1YWdlcyAmJlxuXHRcdFx0XHQhIF9lbXB0eSggZCApICYmXG5cdFx0XHRcdHR5cGVvZiBkID09PSAnc3RyaW5nJyAmJlxuXHRcdFx0XHRkLmluZGV4T2YoJzwnKSAhPT0gLTEgJiZcblx0XHRcdFx0dHlwZW9mIGQgPT09ICdzdHJpbmcnICYmIGQubWF0Y2goL1teXFx4MDAtXFx4N0ZdLyk7XG5cdFx0fVxuXHR9LFxuXHRvcmRlcjoge1xuXHRcdGFzYzogX19kaWFjcml0aWNIdG1sU29ydCxcblx0XHRkZXNjOiBmdW5jdGlvbiAoYSwgYikge1xuXHRcdFx0cmV0dXJuIF9fZGlhY3JpdGljSHRtbFNvcnQoYSwgYikgKiAtMTtcblx0XHR9XG5cdH0sXG5cdHNlYXJjaDogX2ZpbHRlclN0cmluZyh0cnVlLCB0cnVlKVxufSk7XG5cblxuRGF0YVRhYmxlLnR5cGUoJ2RhdGUnLCB7XG5cdGNsYXNzTmFtZTogJ2R0LXR5cGUtZGF0ZScsXG5cdGRldGVjdDoge1xuXHRcdGFsbE9mOiBmdW5jdGlvbiAoIGQgKSB7XG5cdFx0XHQvLyBWOCB0cmllcyBfdmVyeV8gaGFyZCB0byBtYWtlIGEgc3RyaW5nIHBhc3NlZCBpbnRvIGBEYXRlLnBhcnNlKClgXG5cdFx0XHQvLyB2YWxpZCwgc28gd2UgbmVlZCB0byB1c2UgYSByZWdleCB0byByZXN0cmljdCBkYXRlIGZvcm1hdHMuIFVzZSBhXG5cdFx0XHQvLyBwbHVnLWluIGZvciBhbnl0aGluZyBvdGhlciB0aGFuIElTTzg2MDEgc3R5bGUgc3RyaW5nc1xuXHRcdFx0aWYgKCBkICYmICEoZCBpbnN0YW5jZW9mIERhdGUpICYmICEgX3JlX2RhdGUudGVzdChkKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHR2YXIgcGFyc2VkID0gRGF0ZS5wYXJzZShkKTtcblx0XHRcdHJldHVybiAocGFyc2VkICE9PSBudWxsICYmICFpc05hTihwYXJzZWQpKSB8fCBfZW1wdHkoZCk7XG5cdFx0fSxcblx0XHRvbmVPZjogZnVuY3Rpb24gKCBkICkge1xuXHRcdFx0Ly8gQXQgbGVhc3Qgb25lIGVudHJ5IG11c3QgYmUgYSBkYXRlIG9yIGEgc3RyaW5nIHdpdGggYSBkYXRlXG5cdFx0XHRyZXR1cm4gKGQgaW5zdGFuY2VvZiBEYXRlKSB8fCAodHlwZW9mIGQgPT09ICdzdHJpbmcnICYmIF9yZV9kYXRlLnRlc3QoZCkpO1xuXHRcdH1cblx0fSxcblx0b3JkZXI6IHtcblx0XHRwcmU6IGZ1bmN0aW9uICggZCApIHtcblx0XHRcdHZhciB0cyA9IERhdGUucGFyc2UoIGQgKTtcblx0XHRcdHJldHVybiBpc05hTih0cykgPyAtSW5maW5pdHkgOiB0cztcblx0XHR9XG5cdH1cbn0pO1xuXG5cbkRhdGFUYWJsZS50eXBlKCdodG1sLW51bS1mbXQnLCB7XG5cdGNsYXNzTmFtZTogJ2R0LXR5cGUtbnVtZXJpYycsXG5cdGRldGVjdDoge1xuXHRcdGFsbE9mOiBmdW5jdGlvbiAoIGQsIHNldHRpbmdzICkge1xuXHRcdFx0dmFyIGRlY2ltYWwgPSBzZXR0aW5ncy5vTGFuZ3VhZ2Uuc0RlY2ltYWw7XG5cdFx0XHRyZXR1cm4gX2h0bWxOdW1lcmljKCBkLCBkZWNpbWFsLCB0cnVlLCBmYWxzZSApO1xuXHRcdH0sXG5cdFx0b25lT2Y6IGZ1bmN0aW9uIChkLCBzZXR0aW5ncykge1xuXHRcdFx0Ly8gQXQgbGVhc3Qgb25lIGRhdGEgcG9pbnQgbXVzdCBjb250YWluIGEgbnVtZXJpYyB2YWx1ZVxuXHRcdFx0dmFyIGRlY2ltYWwgPSBzZXR0aW5ncy5vTGFuZ3VhZ2Uuc0RlY2ltYWw7XG5cdFx0XHRyZXR1cm4gX2h0bWxOdW1lcmljKCBkLCBkZWNpbWFsLCB0cnVlLCBmYWxzZSApO1xuXHRcdH1cblx0fSxcblx0b3JkZXI6IHtcblx0XHRwcmU6IGZ1bmN0aW9uICggZCwgcyApIHtcblx0XHRcdHZhciBkcCA9IHMub0xhbmd1YWdlLnNEZWNpbWFsO1xuXHRcdFx0cmV0dXJuIF9fbnVtZXJpY1JlcGxhY2UoIGQsIGRwLCBfcmVfaHRtbCwgX3JlX2Zvcm1hdHRlZF9udW1lcmljICk7XG5cdFx0fVxuXHR9LFxuXHRzZWFyY2g6IF9maWx0ZXJTdHJpbmcodHJ1ZSwgdHJ1ZSlcbn0pO1xuXG5cbkRhdGFUYWJsZS50eXBlKCdodG1sLW51bScsIHtcblx0Y2xhc3NOYW1lOiAnZHQtdHlwZS1udW1lcmljJyxcblx0ZGV0ZWN0OiB7XG5cdFx0YWxsT2Y6IGZ1bmN0aW9uICggZCwgc2V0dGluZ3MgKSB7XG5cdFx0XHR2YXIgZGVjaW1hbCA9IHNldHRpbmdzLm9MYW5ndWFnZS5zRGVjaW1hbDtcblx0XHRcdHJldHVybiBfaHRtbE51bWVyaWMoIGQsIGRlY2ltYWwsIGZhbHNlLCB0cnVlICk7XG5cdFx0fSxcblx0XHRvbmVPZjogZnVuY3Rpb24gKGQsIHNldHRpbmdzKSB7XG5cdFx0XHQvLyBBdCBsZWFzdCBvbmUgZGF0YSBwb2ludCBtdXN0IGNvbnRhaW4gYSBudW1lcmljIHZhbHVlXG5cdFx0XHR2YXIgZGVjaW1hbCA9IHNldHRpbmdzLm9MYW5ndWFnZS5zRGVjaW1hbDtcblx0XHRcdHJldHVybiBfaHRtbE51bWVyaWMoIGQsIGRlY2ltYWwsIGZhbHNlLCBmYWxzZSApO1xuXHRcdH1cblx0fSxcblx0b3JkZXI6IHtcblx0XHRwcmU6IGZ1bmN0aW9uICggZCwgcyApIHtcblx0XHRcdHZhciBkcCA9IHMub0xhbmd1YWdlLnNEZWNpbWFsO1xuXHRcdFx0cmV0dXJuIF9fbnVtZXJpY1JlcGxhY2UoIGQsIGRwLCBfcmVfaHRtbCApO1xuXHRcdH1cblx0fSxcblx0c2VhcmNoOiBfZmlsdGVyU3RyaW5nKHRydWUsIHRydWUpXG59KTtcblxuXG5EYXRhVGFibGUudHlwZSgnbnVtLWZtdCcsIHtcblx0Y2xhc3NOYW1lOiAnZHQtdHlwZS1udW1lcmljJyxcblx0ZGV0ZWN0OiB7XG5cdFx0YWxsT2Y6IGZ1bmN0aW9uICggZCwgc2V0dGluZ3MgKSB7XG5cdFx0XHR2YXIgZGVjaW1hbCA9IHNldHRpbmdzLm9MYW5ndWFnZS5zRGVjaW1hbDtcblx0XHRcdHJldHVybiBfaXNOdW1iZXIoIGQsIGRlY2ltYWwsIHRydWUsIHRydWUgKTtcblx0XHR9LFxuXHRcdG9uZU9mOiBmdW5jdGlvbiAoZCwgc2V0dGluZ3MpIHtcblx0XHRcdC8vIEF0IGxlYXN0IG9uZSBkYXRhIHBvaW50IG11c3QgY29udGFpbiBhIG51bWVyaWMgdmFsdWVcblx0XHRcdHZhciBkZWNpbWFsID0gc2V0dGluZ3Mub0xhbmd1YWdlLnNEZWNpbWFsO1xuXHRcdFx0cmV0dXJuIF9pc051bWJlciggZCwgZGVjaW1hbCwgdHJ1ZSwgZmFsc2UgKTtcblx0XHR9XG5cdH0sXG5cdG9yZGVyOiB7XG5cdFx0cHJlOiBmdW5jdGlvbiAoIGQsIHMgKSB7XG5cdFx0XHR2YXIgZHAgPSBzLm9MYW5ndWFnZS5zRGVjaW1hbDtcblx0XHRcdHJldHVybiBfX251bWVyaWNSZXBsYWNlKCBkLCBkcCwgX3JlX2Zvcm1hdHRlZF9udW1lcmljICk7XG5cdFx0fVxuXHR9XG59KTtcblxuXG5EYXRhVGFibGUudHlwZSgnbnVtJywge1xuXHRjbGFzc05hbWU6ICdkdC10eXBlLW51bWVyaWMnLFxuXHRkZXRlY3Q6IHtcblx0XHRhbGxPZjogZnVuY3Rpb24gKCBkLCBzZXR0aW5ncyApIHtcblx0XHRcdHZhciBkZWNpbWFsID0gc2V0dGluZ3Mub0xhbmd1YWdlLnNEZWNpbWFsO1xuXHRcdFx0cmV0dXJuIF9pc051bWJlciggZCwgZGVjaW1hbCwgZmFsc2UsIHRydWUgKTtcblx0XHR9LFxuXHRcdG9uZU9mOiBmdW5jdGlvbiAoZCwgc2V0dGluZ3MpIHtcblx0XHRcdC8vIEF0IGxlYXN0IG9uZSBkYXRhIHBvaW50IG11c3QgY29udGFpbiBhIG51bWVyaWMgdmFsdWVcblx0XHRcdHZhciBkZWNpbWFsID0gc2V0dGluZ3Mub0xhbmd1YWdlLnNEZWNpbWFsO1xuXHRcdFx0cmV0dXJuIF9pc051bWJlciggZCwgZGVjaW1hbCwgZmFsc2UsIGZhbHNlICk7XG5cdFx0fVxuXHR9LFxuXHRvcmRlcjoge1xuXHRcdHByZTogZnVuY3Rpb24gKGQsIHMpIHtcblx0XHRcdHZhciBkcCA9IHMub0xhbmd1YWdlLnNEZWNpbWFsO1xuXHRcdFx0cmV0dXJuIF9fbnVtZXJpY1JlcGxhY2UoIGQsIGRwICk7XG5cdFx0fVxuXHR9XG59KTtcblxuXG5cblxudmFyIF9fbnVtZXJpY1JlcGxhY2UgPSBmdW5jdGlvbiAoIGQsIGRlY2ltYWxQbGFjZSwgcmUxLCByZTIgKSB7XG5cdGlmICggZCAhPT0gMCAmJiAoIWQgfHwgZCA9PT0gJy0nKSApIHtcblx0XHRyZXR1cm4gLUluZmluaXR5O1xuXHR9XG5cdFxuXHR2YXIgdHlwZSA9IHR5cGVvZiBkO1xuXG5cdGlmICh0eXBlID09PSAnbnVtYmVyJyB8fCB0eXBlID09PSAnYmlnaW50Jykge1xuXHRcdHJldHVybiBkO1xuXHR9XG5cblx0Ly8gSWYgYSBkZWNpbWFsIHBsYWNlIG90aGVyIHRoYW4gYC5gIGlzIHVzZWQsIGl0IG5lZWRzIHRvIGJlIGdpdmVuIHRvIHRoZVxuXHQvLyBmdW5jdGlvbiBzbyB3ZSBjYW4gZGV0ZWN0IGl0IGFuZCByZXBsYWNlIHdpdGggYSBgLmAgd2hpY2ggaXMgdGhlIG9ubHlcblx0Ly8gZGVjaW1hbCBwbGFjZSBKYXZhc2NyaXB0IHJlY29nbmlzZXMgLSBpdCBpcyBub3QgbG9jYWxlIGF3YXJlLlxuXHRpZiAoIGRlY2ltYWxQbGFjZSApIHtcblx0XHRkID0gX251bVRvRGVjaW1hbCggZCwgZGVjaW1hbFBsYWNlICk7XG5cdH1cblxuXHRpZiAoIGQucmVwbGFjZSApIHtcblx0XHRpZiAoIHJlMSApIHtcblx0XHRcdGQgPSBkLnJlcGxhY2UoIHJlMSwgJycgKTtcblx0XHR9XG5cblx0XHRpZiAoIHJlMiApIHtcblx0XHRcdGQgPSBkLnJlcGxhY2UoIHJlMiwgJycgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZCAqIDE7XG59O1xuXG5cbiQuZXh0ZW5kKCB0cnVlLCBEYXRhVGFibGUuZXh0LnJlbmRlcmVyLCB7XG5cdGZvb3Rlcjoge1xuXHRcdF86IGZ1bmN0aW9uICggc2V0dGluZ3MsIGNlbGwsIGNsYXNzZXMgKSB7XG5cdFx0XHRjZWxsLmFkZENsYXNzKGNsYXNzZXMudGZvb3QuY2VsbCk7XG5cdFx0fVxuXHR9LFxuXG5cdGhlYWRlcjoge1xuXHRcdF86IGZ1bmN0aW9uICggc2V0dGluZ3MsIGNlbGwsIGNsYXNzZXMgKSB7XG5cdFx0XHRjZWxsLmFkZENsYXNzKGNsYXNzZXMudGhlYWQuY2VsbCk7XG5cblx0XHRcdGlmICghIHNldHRpbmdzLm9GZWF0dXJlcy5iU29ydCkge1xuXHRcdFx0XHRjZWxsLmFkZENsYXNzKGNsYXNzZXMub3JkZXIubm9uZSk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciB0aXRsZVJvdyA9IHNldHRpbmdzLnRpdGxlUm93O1xuXHRcdFx0dmFyIGhlYWRlclJvd3MgPSBjZWxsLmNsb3Nlc3QoJ3RoZWFkJykuZmluZCgndHInKTtcblx0XHRcdHZhciByb3dJZHggPSBjZWxsLnBhcmVudCgpLmluZGV4KCk7XG5cblx0XHRcdC8vIENvbmRpdGlvbnMgdG8gbm90IGFwcGx5IHRoZSBvcmRlcmluZyBpY29uc1xuXHRcdFx0aWYgKFxuXHRcdFx0XHQvLyBDZWxscyBhbmQgcm93cyB3aGljaCBoYXZlIHRoZSBhdHRyaWJ1dGUgdG8gZGlzYWJsZSB0aGUgaWNvbnNcblx0XHRcdFx0Y2VsbC5hdHRyKCdkYXRhLWR0LW9yZGVyJykgPT09ICdkaXNhYmxlJyB8fFxuXHRcdFx0XHRjZWxsLnBhcmVudCgpLmF0dHIoJ2RhdGEtZHQtb3JkZXInKSA9PT0gJ2Rpc2FibGUnIHx8XG5cblx0XHRcdFx0Ly8gdGl0bGVSb3cgc3VwcG9ydCwgZm9yIGRlZmluaW5nIGEgc3BlY2lmaWMgcm93IGluIHRoZSBoZWFkZXJcblx0XHRcdFx0KHRpdGxlUm93ID09PSB0cnVlICYmIHJvd0lkeCAhPT0gMCkgfHxcblx0XHRcdFx0KHRpdGxlUm93ID09PSBmYWxzZSAmJiByb3dJZHggIT09IGhlYWRlclJvd3MubGVuZ3RoIC0gMSkgfHxcblx0XHRcdFx0KHR5cGVvZiB0aXRsZVJvdyA9PT0gJ251bWJlcicgJiYgcm93SWR4ICE9PSB0aXRsZVJvdylcblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIE5vIGFkZGl0aW9uYWwgbWFyay11cCByZXF1aXJlZFxuXHRcdFx0Ly8gQXR0YWNoIGEgc29ydCBsaXN0ZW5lciB0byB1cGRhdGUgb24gc29ydCAtIG5vdGUgdGhhdCB1c2luZyB0aGVcblx0XHRcdC8vIGBEVGAgbmFtZXNwYWNlIHdpbGwgYWxsb3cgdGhlIGV2ZW50IHRvIGJlIHJlbW92ZWQgYXV0b21hdGljYWxseVxuXHRcdFx0Ly8gb24gZGVzdHJveSwgd2hpbGUgdGhlIGBkdGAgbmFtZXNwYWNlZCBldmVudCBpcyB0aGUgb25lIHdlIGFyZVxuXHRcdFx0Ly8gbGlzdGVuaW5nIGZvclxuXHRcdFx0JChzZXR0aW5ncy5uVGFibGUpLm9uKCAnb3JkZXIuZHQuRFQgY29sdW1uLXZpc2liaWxpdHkuZHQuRFQnLCBmdW5jdGlvbiAoIGUsIGN0eCwgY29sdW1uICkge1xuXHRcdFx0XHRpZiAoIHNldHRpbmdzICE9PSBjdHggKSB7IC8vIG5lZWQgdG8gY2hlY2sgdGhpcyB0aGlzIGlzIHRoZSBob3N0XG5cdFx0XHRcdFx0cmV0dXJuOyAgICAgICAgICAgICAgIC8vIHRhYmxlLCBub3QgYSBuZXN0ZWQgb25lXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgc29ydGluZyA9IGN0eC5zb3J0RGV0YWlscztcblxuXHRcdFx0XHRpZiAoISBzb3J0aW5nKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIG9yZGVyZWRDb2x1bW5zID0gX3BsdWNrKHNvcnRpbmcsICdjb2wnKTtcblxuXHRcdFx0XHQvLyBUaGlzIGhhbmRsZXIgaXMgb25seSBuZWVkZWQgb24gY29sdW1uIHZpc2liaWxpdHkgaWYgdGhlIGNvbHVtbiBpcyBwYXJ0IG9mIHRoZVxuXHRcdFx0XHQvLyBvcmRlcmluZy4gSWYgaXQgaXNuJ3QsIHRoZW4gd2UgY2FuIGJhaWwgb3V0IHRvIHNhdmUgcGVyZm9ybWFuY2UuIEl0IGNvdWxkIGJlIGFcblx0XHRcdFx0Ly8gc2VwYXJhdGUgZXZlbnQgaGFuZGxlciwgYnV0IHRoaXMgaXMgYSBiYWxhbmNlIGJldHdlZW4gY29kZSByZXVzZSAvIHNpemUgYW5kIHBlcmZvcm1hbmNlXG5cdFx0XHRcdC8vIGNvbnNvbGUubG9nKGUsIGUubmFtZSwgY29sdW1uLCBvcmRlcmVkQ29sdW1ucywgb3JkZXJlZENvbHVtbnMuaW5jbHVkZXMoY29sdW1uKSlcblx0XHRcdFx0aWYgKGUudHlwZSA9PT0gJ2NvbHVtbi12aXNpYmlsaXR5JyAmJiAhIG9yZGVyZWRDb2x1bW5zLmluY2x1ZGVzKGNvbHVtbikpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgaTtcblx0XHRcdFx0dmFyIG9yZGVyQ2xhc3NlcyA9IGNsYXNzZXMub3JkZXI7XG5cdFx0XHRcdHZhciBjb2x1bW5zID0gY3R4LmFwaS5jb2x1bW5zKCBjZWxsICk7XG5cdFx0XHRcdHZhciBjb2wgPSBzZXR0aW5ncy5hb0NvbHVtbnNbY29sdW1ucy5mbGF0dGVuKClbMF1dO1xuXHRcdFx0XHR2YXIgb3JkZXJhYmxlID0gY29sdW1ucy5vcmRlcmFibGUoKS5pbmNsdWRlcyh0cnVlKTtcblx0XHRcdFx0dmFyIGFyaWFUeXBlID0gJyc7XG5cdFx0XHRcdHZhciBpbmRleGVzID0gY29sdW1ucy5pbmRleGVzKCk7XG5cdFx0XHRcdHZhciBzb3J0RGlycyA9IGNvbHVtbnMub3JkZXJhYmxlKHRydWUpLmZsYXR0ZW4oKTtcblx0XHRcdFx0dmFyIHRhYkluZGV4ID0gc2V0dGluZ3MuaVRhYkluZGV4O1xuXHRcdFx0XHR2YXIgY2FuT3JkZXIgPSBjdHgub3JkZXJIYW5kbGVyICYmIG9yZGVyYWJsZTtcblxuXHRcdFx0XHRjZWxsXG5cdFx0XHRcdFx0LnJlbW92ZUNsYXNzKFxuXHRcdFx0XHRcdFx0b3JkZXJDbGFzc2VzLmlzQXNjICsnICcrXG5cdFx0XHRcdFx0XHRvcmRlckNsYXNzZXMuaXNEZXNjXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHRcdC50b2dnbGVDbGFzcyggb3JkZXJDbGFzc2VzLm5vbmUsICEgb3JkZXJhYmxlIClcblx0XHRcdFx0XHQudG9nZ2xlQ2xhc3MoIG9yZGVyQ2xhc3Nlcy5jYW5Bc2MsIGNhbk9yZGVyICYmIHNvcnREaXJzLmluY2x1ZGVzKCdhc2MnKSApXG5cdFx0XHRcdFx0LnRvZ2dsZUNsYXNzKCBvcmRlckNsYXNzZXMuY2FuRGVzYywgY2FuT3JkZXIgJiYgc29ydERpcnMuaW5jbHVkZXMoJ2Rlc2MnKSApO1xuXG5cdFx0XHRcdC8vIERldGVybWluZSBpZiBhbGwgb2YgdGhlIGNvbHVtbnMgdGhhdCB0aGlzIGNlbGwgY292ZXJzIGFyZSBpbmNsdWRlZCBpbiB0aGVcblx0XHRcdFx0Ly8gY3VycmVudCBvcmRlcmluZ1xuXHRcdFx0XHR2YXIgaXNPcmRlcmluZyA9IHRydWU7XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKGk9MDsgaTxpbmRleGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKCEgb3JkZXJlZENvbHVtbnMuaW5jbHVkZXMoaW5kZXhlc1tpXSkpIHtcblx0XHRcdFx0XHRcdGlzT3JkZXJpbmcgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGlzT3JkZXJpbmcgKSB7XG5cdFx0XHRcdFx0Ly8gR2V0IHRoZSBvcmRlcmluZyBkaXJlY3Rpb24gZm9yIHRoZSBjb2x1bW5zIHVuZGVyIHRoaXMgY2VsbFxuXHRcdFx0XHRcdC8vIE5vdGUgdGhhdCBpdCBpcyBwb3NzaWJsZSBmb3IgYSBjZWxsIHRvIGJlIGFzYyBhbmQgZGVzYyBzb3J0aW5nXG5cdFx0XHRcdFx0Ly8gKGNvbHVtbiBzcGFubmluZyBjZWxscylcblx0XHRcdFx0XHR2YXIgb3JkZXJEaXJzID0gY29sdW1ucy5vcmRlcigpO1xuXG5cdFx0XHRcdFx0Y2VsbC5hZGRDbGFzcyhcblx0XHRcdFx0XHRcdG9yZGVyRGlycy5pbmNsdWRlcygnYXNjJykgPyBvcmRlckNsYXNzZXMuaXNBc2MgOiAnJyArXG5cdFx0XHRcdFx0XHRvcmRlckRpcnMuaW5jbHVkZXMoJ2Rlc2MnKSA/IG9yZGVyQ2xhc3Nlcy5pc0Rlc2MgOiAnJ1xuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBGaW5kIHRoZSBmaXJzdCB2aXNpYmxlIGNvbHVtbiB0aGF0IGhhcyBvcmRlcmluZyBhcHBsaWVkIHRvIGl0IC0gaXQgZ2V0J3Ncblx0XHRcdFx0Ly8gdGhlIGFyaWEgaW5mb3JtYXRpb24sIGFzIHRoZSBBUklBIHNwZWMgc2F5cyB0aGF0IG9ubHkgb25lIGNvbHVtbiBzaG91bGRcblx0XHRcdFx0Ly8gYmUgbWFya2VkIHdpdGggYXJpYS1zb3J0XG5cdFx0XHRcdHZhciBmaXJzdFZpcyA9IC0xOyAvLyBjb2x1bW4gaW5kZXhcblxuXHRcdFx0XHRmb3IgKGk9MDsgaTxvcmRlcmVkQ29sdW1ucy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGlmIChzZXR0aW5ncy5hb0NvbHVtbnNbb3JkZXJlZENvbHVtbnNbaV1dLmJWaXNpYmxlKSB7XG5cdFx0XHRcdFx0XHRmaXJzdFZpcyA9IG9yZGVyZWRDb2x1bW5zW2ldO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGluZGV4ZXNbMF0gPT0gZmlyc3RWaXMpIHtcblx0XHRcdFx0XHR2YXIgZmlyc3RTb3J0ID0gc29ydGluZ1swXTtcblx0XHRcdFx0XHR2YXIgc29ydE9yZGVyID0gY29sLmFzU29ydGluZztcblxuXHRcdFx0XHRcdGNlbGwuYXR0cignYXJpYS1zb3J0JywgZmlyc3RTb3J0LmRpciA9PT0gJ2FzYycgPyAnYXNjZW5kaW5nJyA6ICdkZXNjZW5kaW5nJyk7XG5cblx0XHRcdFx0XHQvLyBEZXRlcm1pbmUgaWYgdGhlIG5leHQgY2xpY2sgd2lsbCByZW1vdmUgc29ydGluZyBvciBjaGFuZ2UgdGhlIHNvcnRcblx0XHRcdFx0XHRhcmlhVHlwZSA9ICEgc29ydE9yZGVyW2ZpcnN0U29ydC5pbmRleCArIDFdID8gJ1JlbW92ZScgOiAnUmV2ZXJzZSc7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Y2VsbC5yZW1vdmVBdHRyKCdhcmlhLXNvcnQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE1ha2UgdGhlIGhlYWRlcnMgdGFiLWFibGUgZm9yIGtleWJvYXJkIG5hdmlnYXRpb25cblx0XHRcdFx0aWYgKG9yZGVyYWJsZSkge1xuXHRcdFx0XHRcdHZhciBvcmRlclNwYW4gPSBjZWxsLmZpbmQoJy5kdC1jb2x1bW4tb3JkZXInKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRvcmRlclNwYW5cblx0XHRcdFx0XHRcdC5hdHRyKCdyb2xlJywgJ2J1dHRvbicpXG5cdFx0XHRcdFx0XHQuYXR0cignYXJpYS1sYWJlbCcsIG9yZGVyYWJsZVxuXHRcdFx0XHRcdFx0XHQ/IGNvbC5hcmlhVGl0bGUgKyBjdHguYXBpLmkxOG4oJ29BcmlhLm9yZGVyYWJsZScgKyBhcmlhVHlwZSlcblx0XHRcdFx0XHRcdFx0OiBjb2wuYXJpYVRpdGxlXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0aWYgKHRhYkluZGV4ICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0b3JkZXJTcGFuLmF0dHIoJ3RhYmluZGV4JywgdGFiSW5kZXgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblx0fSxcblxuXHRsYXlvdXQ6IHtcblx0XHRfOiBmdW5jdGlvbiAoIHNldHRpbmdzLCBjb250YWluZXIsIGl0ZW1zICkge1xuXHRcdFx0dmFyIGNsYXNzZXMgPSBzZXR0aW5ncy5vQ2xhc3Nlcy5sYXlvdXQ7XG5cdFx0XHR2YXIgcm93ID0gJCgnPGRpdi8+Jylcblx0XHRcdFx0LmF0dHIoJ2lkJywgaXRlbXMuaWQgfHwgbnVsbClcblx0XHRcdFx0LmFkZENsYXNzKGl0ZW1zLmNsYXNzTmFtZSB8fCBjbGFzc2VzLnJvdylcblx0XHRcdFx0LmFwcGVuZFRvKCBjb250YWluZXIgKTtcblxuXHRcdFx0RGF0YVRhYmxlLmV4dC5yZW5kZXJlci5sYXlvdXQuX2ZvckxheW91dFJvdyhpdGVtcywgZnVuY3Rpb24gKGtleSwgdmFsKSB7XG5cdFx0XHRcdGlmIChrZXkgPT09ICdpZCcgfHwga2V5ID09PSAnY2xhc3NOYW1lJykge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBrbGFzcyA9ICcnO1xuXG5cdFx0XHRcdGlmICh2YWwudGFibGUpIHtcblx0XHRcdFx0XHRyb3cuYWRkQ2xhc3MoY2xhc3Nlcy50YWJsZVJvdyk7XG5cdFx0XHRcdFx0a2xhc3MgKz0gY2xhc3Nlcy50YWJsZUNlbGwgKyAnICc7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoa2V5ID09PSAnc3RhcnQnKSB7XG5cdFx0XHRcdFx0a2xhc3MgKz0gY2xhc3Nlcy5zdGFydDtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmIChrZXkgPT09ICdlbmQnKSB7XG5cdFx0XHRcdFx0a2xhc3MgKz0gY2xhc3Nlcy5lbmQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0a2xhc3MgKz0gY2xhc3Nlcy5mdWxsO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0JCgnPGRpdi8+Jylcblx0XHRcdFx0XHQuYXR0cih7XG5cdFx0XHRcdFx0XHRpZDogdmFsLmlkIHx8IG51bGwsXG5cdFx0XHRcdFx0XHRcImNsYXNzXCI6IHZhbC5jbGFzc05hbWVcblx0XHRcdFx0XHRcdFx0PyB2YWwuY2xhc3NOYW1lXG5cdFx0XHRcdFx0XHRcdDogY2xhc3Nlcy5jZWxsICsgJyAnICsga2xhc3Ncblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdC5hcHBlbmQoIHZhbC5jb250ZW50cyApXG5cdFx0XHRcdFx0LmFwcGVuZFRvKCByb3cgKTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHQvLyBTaGFyZWQgZm9yIHVzZSBieSB0aGUgc3R5bGluZyBmcmFtZXdvcmtzXG5cdFx0X2ZvckxheW91dFJvdzogZnVuY3Rpb24gKGl0ZW1zLCBmbikge1xuXHRcdFx0Ly8gQXMgd2UgYXJlIGluc2VydGluZyBkb20gZWxlbWVudHMsIHdlIG5lZWQgc3RhcnQgLyBlbmQgaW4gYVxuXHRcdFx0Ly8gc3BlY2lmaWMgb3JkZXIsIHRoaXMgZnVuY3Rpb24gaXMgdXNlZCBmb3Igc29ydGluZyB0aGUgbGF5b3V0XG5cdFx0XHQvLyBrZXlzLlxuXHRcdFx0dmFyIGxheW91dEVudW0gPSBmdW5jdGlvbiAoeCkge1xuXHRcdFx0XHRzd2l0Y2ggKHgpIHtcblx0XHRcdFx0XHRjYXNlICcnOiByZXR1cm4gMDtcblx0XHRcdFx0XHRjYXNlICdzdGFydCc6IHJldHVybiAxO1xuXHRcdFx0XHRcdGNhc2UgJ2VuZCc6IHJldHVybiAyO1xuXHRcdFx0XHRcdGRlZmF1bHQ6IHJldHVybiAzO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHRPYmplY3Rcblx0XHRcdFx0LmtleXMoaXRlbXMpXG5cdFx0XHRcdC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGxheW91dEVudW0oYSkgLSBsYXlvdXRFbnVtKGIpO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHRcdFx0Zm4oa2V5LCBpdGVtc1trZXldKTtcblx0XHRcdFx0fSk7XG5cdFx0fVxuXHR9XG59ICk7XG5cblxuRGF0YVRhYmxlLmZlYXR1cmUgPSB7fTtcblxuLy8gVGhpcmQgcGFyYW1ldGVyIGlzIGludGVybmFsIG9ubHkhXG5EYXRhVGFibGUuZmVhdHVyZS5yZWdpc3RlciA9IGZ1bmN0aW9uICggbmFtZSwgY2IsIGxlZ2FjeSApIHtcblx0RGF0YVRhYmxlLmV4dC5mZWF0dXJlc1sgbmFtZSBdID0gY2I7XG5cblx0aWYgKGxlZ2FjeSkge1xuXHRcdF9leHQuZmVhdHVyZS5wdXNoKHtcblx0XHRcdGNGZWF0dXJlOiBsZWdhY3ksXG5cdFx0XHRmbkluaXQ6IGNiXG5cdFx0fSk7XG5cdH1cbn07XG5cbmZ1bmN0aW9uIF9kaXZQcm9wKGVsLCBwcm9wLCB2YWwpIHtcblx0aWYgKHZhbCkge1xuXHRcdGVsW3Byb3BdID0gdmFsO1xuXHR9XG59XG5cbkRhdGFUYWJsZS5mZWF0dXJlLnJlZ2lzdGVyKCAnZGl2JywgZnVuY3Rpb24gKCBzZXR0aW5ncywgb3B0cyApIHtcblx0dmFyIG4gPSAkKCc8ZGl2PicpWzBdO1xuXG5cdGlmIChvcHRzKSB7XG5cdFx0X2RpdlByb3AobiwgJ2NsYXNzTmFtZScsIG9wdHMuY2xhc3NOYW1lKTtcblx0XHRfZGl2UHJvcChuLCAnaWQnLCBvcHRzLmlkKTtcblx0XHRfZGl2UHJvcChuLCAnaW5uZXJIVE1MJywgb3B0cy5odG1sKTtcblx0XHRfZGl2UHJvcChuLCAndGV4dENvbnRlbnQnLCBvcHRzLnRleHQpO1xuXHR9XG5cblx0cmV0dXJuIG47XG59ICk7XG5cbkRhdGFUYWJsZS5mZWF0dXJlLnJlZ2lzdGVyKCAnaW5mbycsIGZ1bmN0aW9uICggc2V0dGluZ3MsIG9wdHMgKSB7XG5cdC8vIEZvciBjb21wYXRpYmlsaXR5IHdpdGggdGhlIGxlZ2FjeSBgaW5mb2AgdG9wIGxldmVsIG9wdGlvblxuXHRpZiAoISBzZXR0aW5ncy5vRmVhdHVyZXMuYkluZm8pIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdHZhclxuXHRcdGxhbmcgID0gc2V0dGluZ3Mub0xhbmd1YWdlLFxuXHRcdHRpZCA9IHNldHRpbmdzLnNUYWJsZUlkLFxuXHRcdG4gPSAkKCc8ZGl2Lz4nLCB7XG5cdFx0XHQnY2xhc3MnOiBzZXR0aW5ncy5vQ2xhc3Nlcy5pbmZvLmNvbnRhaW5lcixcblx0XHR9ICk7XG5cblx0b3B0cyA9ICQuZXh0ZW5kKHtcblx0XHRjYWxsYmFjazogbGFuZy5mbkluZm9DYWxsYmFjayxcblx0XHRlbXB0eTogbGFuZy5zSW5mb0VtcHR5LFxuXHRcdHBvc3RmaXg6IGxhbmcuc0luZm9Qb3N0Rml4LFxuXHRcdHNlYXJjaDogbGFuZy5zSW5mb0ZpbHRlcmVkLFxuXHRcdHRleHQ6IGxhbmcuc0luZm8sXG5cdH0sIG9wdHMpO1xuXG5cblx0Ly8gVXBkYXRlIGRpc3BsYXkgb24gZWFjaCBkcmF3XG5cdHNldHRpbmdzLmFvRHJhd0NhbGxiYWNrLnB1c2goZnVuY3Rpb24gKHMpIHtcblx0XHRfZm5VcGRhdGVJbmZvKHMsIG9wdHMsIG4pO1xuXHR9KTtcblxuXHQvLyBGb3IgdGhlIGZpcnN0IGluZm8gZGlzcGxheSBpbiB0aGUgdGFibGUsIHdlIGFkZCBhIGNhbGxiYWNrIGFuZCBhcmlhIGluZm9ybWF0aW9uLlxuXHRpZiAoISBzZXR0aW5ncy5faW5mb0VsKSB7XG5cdFx0bi5hdHRyKHtcblx0XHRcdCdhcmlhLWxpdmUnOiAncG9saXRlJyxcblx0XHRcdGlkOiB0aWQrJ19pbmZvJyxcblx0XHRcdHJvbGU6ICdzdGF0dXMnXG5cdFx0fSk7XG5cblx0XHQvLyBUYWJsZSBpcyBkZXNjcmliZWQgYnkgb3VyIGluZm8gZGl2XG5cdFx0JChzZXR0aW5ncy5uVGFibGUpLmF0dHIoICdhcmlhLWRlc2NyaWJlZGJ5JywgdGlkKydfaW5mbycgKTtcblxuXHRcdHNldHRpbmdzLl9pbmZvRWwgPSBuO1xuXHR9XG5cblx0cmV0dXJuIG47XG59LCAnaScgKTtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIGluZm9ybWF0aW9uIGVsZW1lbnRzIGluIHRoZSBkaXNwbGF5XG4gKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gKi9cbmZ1bmN0aW9uIF9mblVwZGF0ZUluZm8gKCBzZXR0aW5ncywgb3B0cywgbm9kZSApXG57XG5cdHZhclxuXHRcdHN0YXJ0ID0gc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQrMSxcblx0XHRlbmQgICA9IHNldHRpbmdzLmZuRGlzcGxheUVuZCgpLFxuXHRcdG1heCAgID0gc2V0dGluZ3MuZm5SZWNvcmRzVG90YWwoKSxcblx0XHR0b3RhbCA9IHNldHRpbmdzLmZuUmVjb3Jkc0Rpc3BsYXkoKSxcblx0XHRvdXQgICA9IHRvdGFsXG5cdFx0XHQ/IG9wdHMudGV4dFxuXHRcdFx0OiBvcHRzLmVtcHR5O1xuXG5cdGlmICggdG90YWwgIT09IG1heCApIHtcblx0XHQvLyBSZWNvcmQgc2V0IGFmdGVyIGZpbHRlcmluZ1xuXHRcdG91dCArPSAnICcgKyBvcHRzLnNlYXJjaDtcblx0fVxuXG5cdC8vIENvbnZlcnQgdGhlIG1hY3Jvc1xuXHRvdXQgKz0gb3B0cy5wb3N0Zml4O1xuXHRvdXQgPSBfZm5NYWNyb3MoIHNldHRpbmdzLCBvdXQgKTtcblxuXHRpZiAoIG9wdHMuY2FsbGJhY2sgKSB7XG5cdFx0b3V0ID0gb3B0cy5jYWxsYmFjay5jYWxsKCBzZXR0aW5ncy5vSW5zdGFuY2UsXG5cdFx0XHRzZXR0aW5ncywgc3RhcnQsIGVuZCwgbWF4LCB0b3RhbCwgb3V0XG5cdFx0KTtcblx0fVxuXG5cdG5vZGUuaHRtbCggb3V0ICk7XG5cblx0X2ZuQ2FsbGJhY2tGaXJlKHNldHRpbmdzLCBudWxsLCAnaW5mbycsIFtzZXR0aW5ncywgbm9kZVswXSwgb3V0XSk7XG59XG5cbnZhciBfX3NlYXJjaENvdW50ZXIgPSAwO1xuXG4vLyBvcHRzXG4vLyAtIHRleHRcbi8vIC0gcGxhY2Vob2xkZXJcbkRhdGFUYWJsZS5mZWF0dXJlLnJlZ2lzdGVyKCAnc2VhcmNoJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgb3B0cyApIHtcblx0Ly8gRG9uJ3Qgc2hvdyB0aGUgaW5wdXQgaWYgZmlsdGVyaW5nIGlzbid0IGF2YWlsYWJsZSBvbiB0aGUgdGFibGVcblx0aWYgKCEgc2V0dGluZ3Mub0ZlYXR1cmVzLmJGaWx0ZXIpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdHZhciBjbGFzc2VzID0gc2V0dGluZ3Mub0NsYXNzZXMuc2VhcmNoO1xuXHR2YXIgdGFibGVJZCA9IHNldHRpbmdzLnNUYWJsZUlkO1xuXHR2YXIgbGFuZ3VhZ2UgPSBzZXR0aW5ncy5vTGFuZ3VhZ2U7XG5cdHZhciBwcmV2aW91c1NlYXJjaCA9IHNldHRpbmdzLm9QcmV2aW91c1NlYXJjaDtcblx0dmFyIGlucHV0ID0gJzxpbnB1dCB0eXBlPVwic2VhcmNoXCIgY2xhc3M9XCInK2NsYXNzZXMuaW5wdXQrJ1wiLz4nO1xuXG5cdG9wdHMgPSAkLmV4dGVuZCh7XG5cdFx0cGxhY2Vob2xkZXI6IGxhbmd1YWdlLnNTZWFyY2hQbGFjZWhvbGRlcixcblx0XHRwcm9jZXNzaW5nOiBmYWxzZSxcblx0XHR0ZXh0OiBsYW5ndWFnZS5zU2VhcmNoXG5cdH0sIG9wdHMpO1xuXG5cdC8vIFRoZSBfSU5QVVRfIGlzIG9wdGlvbmFsIC0gaXMgYXBwZW5kZWQgaWYgbm90IHByZXNlbnRcblx0aWYgKG9wdHMudGV4dC5pbmRleE9mKCdfSU5QVVRfJykgPT09IC0xKSB7XG5cdFx0b3B0cy50ZXh0ICs9ICdfSU5QVVRfJztcblx0fVxuXG5cdG9wdHMudGV4dCA9IF9mbk1hY3JvcyhzZXR0aW5ncywgb3B0cy50ZXh0KTtcblxuXHQvLyBXZSBjYW4gcHV0IHRoZSA8aW5wdXQ+IG91dHNpZGUgb2YgdGhlIGxhYmVsIGlmIGl0IGlzIGF0IHRoZSBzdGFydCBvciBlbmRcblx0Ly8gd2hpY2ggaGVscHMgaW1wcm92ZSBhY2Nlc3NhYmlsaXR5IChub3QgYWxsIHNjcmVlbiByZWFkZXJzIGxpa2UgaW1wbGljaXRcblx0Ly8gZm9yIGVsZW1lbnRzKS5cblx0dmFyIGVuZCA9IG9wdHMudGV4dC5tYXRjaCgvX0lOUFVUXyQvKTtcblx0dmFyIHN0YXJ0ID0gb3B0cy50ZXh0Lm1hdGNoKC9eX0lOUFVUXy8pO1xuXHR2YXIgcmVtb3ZlZCA9IG9wdHMudGV4dC5yZXBsYWNlKC9fSU5QVVRfLywgJycpO1xuXHR2YXIgc3RyID0gJzxsYWJlbD4nICsgb3B0cy50ZXh0ICsgJzwvbGFiZWw+JztcblxuXHRpZiAoc3RhcnQpIHtcblx0XHRzdHIgPSAnX0lOUFVUXzxsYWJlbD4nICsgcmVtb3ZlZCArICc8L2xhYmVsPic7XG5cdH1cblx0ZWxzZSBpZiAoZW5kKSB7XG5cdFx0c3RyID0gJzxsYWJlbD4nICsgcmVtb3ZlZCArICc8L2xhYmVsPl9JTlBVVF8nO1xuXHR9XG5cblx0dmFyIGZpbHRlciA9ICQoJzxkaXY+Jylcblx0XHQuYWRkQ2xhc3MoY2xhc3Nlcy5jb250YWluZXIpXG5cdFx0LmFwcGVuZChzdHIucmVwbGFjZSgvX0lOUFVUXy8sIGlucHV0KSk7XG5cblx0Ly8gYWRkIGZvciBhbmQgaWQgdG8gbGFiZWwgYW5kIGlucHV0XG5cdGZpbHRlci5maW5kKCdsYWJlbCcpLmF0dHIoJ2ZvcicsICdkdC1zZWFyY2gtJyArIF9fc2VhcmNoQ291bnRlcik7XG5cdGZpbHRlci5maW5kKCdpbnB1dCcpLmF0dHIoJ2lkJywgJ2R0LXNlYXJjaC0nICsgX19zZWFyY2hDb3VudGVyKTtcblx0X19zZWFyY2hDb3VudGVyKys7XG5cblx0dmFyIHNlYXJjaEZuID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgdmFsID0gdGhpcy52YWx1ZTtcblxuXHRcdGlmKHByZXZpb3VzU2VhcmNoLnJldHVybiAmJiBldmVudC5rZXkgIT09IFwiRW50ZXJcIikge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8qIE5vdyBkbyB0aGUgZmlsdGVyICovXG5cdFx0aWYgKCB2YWwgIT0gcHJldmlvdXNTZWFyY2guc2VhcmNoICkge1xuXHRcdFx0X2ZuUHJvY2Vzc2luZ1J1bihzZXR0aW5ncywgb3B0cy5wcm9jZXNzaW5nLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHByZXZpb3VzU2VhcmNoLnNlYXJjaCA9IHZhbDtcblx0XHRcblx0XHRcdFx0X2ZuRmlsdGVyQ29tcGxldGUoIHNldHRpbmdzLCBwcmV2aW91c1NlYXJjaCApO1xuXHRcdFxuXHRcdFx0XHQvLyBOZWVkIHRvIHJlZHJhdywgd2l0aG91dCByZXNvcnRpbmdcblx0XHRcdFx0c2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQgPSAwO1xuXHRcdFx0XHRfZm5EcmF3KCBzZXR0aW5ncyApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9O1xuXG5cdHZhciBzZWFyY2hEZWxheSA9IHNldHRpbmdzLnNlYXJjaERlbGF5ICE9PSBudWxsID9cblx0XHRzZXR0aW5ncy5zZWFyY2hEZWxheSA6XG5cdFx0MDtcblxuXHR2YXIganFGaWx0ZXIgPSAkKCdpbnB1dCcsIGZpbHRlcilcblx0XHQudmFsKCBwcmV2aW91c1NlYXJjaC5zZWFyY2ggKVxuXHRcdC5hdHRyKCAncGxhY2Vob2xkZXInLCBvcHRzLnBsYWNlaG9sZGVyIClcblx0XHQub24oXG5cdFx0XHQna2V5dXAuRFQgc2VhcmNoLkRUIGlucHV0LkRUIHBhc3RlLkRUIGN1dC5EVCcsXG5cdFx0XHRzZWFyY2hEZWxheSA/XG5cdFx0XHRcdERhdGFUYWJsZS51dGlsLmRlYm91bmNlKCBzZWFyY2hGbiwgc2VhcmNoRGVsYXkgKSA6XG5cdFx0XHRcdHNlYXJjaEZuXG5cdFx0KVxuXHRcdC5vbiggJ21vdXNldXAuRFQnLCBmdW5jdGlvbihlKSB7XG5cdFx0XHQvLyBFZGdlIGZpeCEgRWRnZSAxNyBkb2VzIG5vdCB0cmlnZ2VyIGFueXRoaW5nIG90aGVyIHRoYW4gbW91c2UgZXZlbnRzIHdoZW4gY2xpY2tpbmdcblx0XHRcdC8vIG9uIHRoZSBjbGVhciBpY29uIChFZGdlIGJ1ZyAxNzU4NDUxNSkuIFRoaXMgaXMgc2FmZSBpbiBvdGhlciBicm93c2VycyBhcyBgc2VhcmNoRm5gXG5cdFx0XHQvLyBjaGVja3MgdGhlIHZhbHVlIHRvIHNlZSBpZiBpdCBoYXMgY2hhbmdlZC4gSW4gb3RoZXIgYnJvd3NlcnMgaXQgd29uJ3QgaGF2ZS5cblx0XHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0c2VhcmNoRm4uY2FsbChqcUZpbHRlclswXSwgZSk7XG5cdFx0XHR9LCAxMCk7XG5cdFx0fSApXG5cdFx0Lm9uKCAna2V5cHJlc3MuRFQnLCBmdW5jdGlvbihlKSB7XG5cdFx0XHQvKiBQcmV2ZW50IGZvcm0gc3VibWlzc2lvbiAqL1xuXHRcdFx0aWYgKCBlLmtleUNvZGUgPT0gMTMgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9IClcblx0XHQuYXR0cignYXJpYS1jb250cm9scycsIHRhYmxlSWQpO1xuXG5cdC8vIFVwZGF0ZSB0aGUgaW5wdXQgZWxlbWVudHMgd2hlbmV2ZXIgdGhlIHRhYmxlIGlzIGZpbHRlcmVkXG5cdCQoc2V0dGluZ3MublRhYmxlKS5vbiggJ3NlYXJjaC5kdC5EVCcsIGZ1bmN0aW9uICggZXYsIHMgKSB7XG5cdFx0aWYgKCBzZXR0aW5ncyA9PT0gcyAmJiBqcUZpbHRlclswXSAhPT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCApIHtcblx0XHRcdGpxRmlsdGVyLnZhbCggdHlwZW9mIHByZXZpb3VzU2VhcmNoLnNlYXJjaCAhPT0gJ2Z1bmN0aW9uJ1xuXHRcdFx0XHQ/IHByZXZpb3VzU2VhcmNoLnNlYXJjaFxuXHRcdFx0XHQ6ICcnXG5cdFx0XHQpO1xuXHRcdH1cblx0fSApO1xuXG5cdHJldHVybiBmaWx0ZXI7XG59LCAnZicgKTtcblxuLy8gb3B0c1xuLy8gLSB0eXBlIC0gYnV0dG9uIGNvbmZpZ3VyYXRpb25cbi8vIC0gYnV0dG9ucyAtIG51bWJlciBvZiBidXR0b25zIHRvIHNob3cgLSBtdXN0IGJlIG9kZFxuRGF0YVRhYmxlLmZlYXR1cmUucmVnaXN0ZXIoICdwYWdpbmcnLCBmdW5jdGlvbiAoIHNldHRpbmdzLCBvcHRzICkge1xuXHQvLyBEb24ndCBzaG93IHRoZSBwYWdpbmcgaW5wdXQgaWYgdGhlIHRhYmxlIGRvZXNuJ3QgaGF2ZSBwYWdpbmcgZW5hYmxlZFxuXHRpZiAoISBzZXR0aW5ncy5vRmVhdHVyZXMuYlBhZ2luYXRlKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRvcHRzID0gJC5leHRlbmQoe1xuXHRcdGJ1dHRvbnM6IERhdGFUYWJsZS5leHQucGFnZXIubnVtYmVyc19sZW5ndGgsXG5cdFx0dHlwZTogc2V0dGluZ3Muc1BhZ2luYXRpb25UeXBlLFxuXHRcdGJvdW5kYXJ5TnVtYmVyczogdHJ1ZSxcblx0XHRmaXJzdExhc3Q6IHRydWUsXG5cdFx0cHJldmlvdXNOZXh0OiB0cnVlLFxuXHRcdG51bWJlcnM6IHRydWVcblx0fSwgb3B0cyk7XG5cblx0dmFyIGhvc3QgPSAkKCc8ZGl2Lz4nKVxuXHRcdC5hZGRDbGFzcyhzZXR0aW5ncy5vQ2xhc3Nlcy5wYWdpbmcuY29udGFpbmVyICsgKG9wdHMudHlwZSA/ICcgcGFnaW5nXycgKyBvcHRzLnR5cGUgOiAnJykpXG5cdFx0LmFwcGVuZChcblx0XHRcdCQoJzxuYXY+Jylcblx0XHRcdFx0LmF0dHIoJ2FyaWEtbGFiZWwnLCAncGFnaW5hdGlvbicpXG5cdFx0XHRcdC5hZGRDbGFzcyhzZXR0aW5ncy5vQ2xhc3Nlcy5wYWdpbmcubmF2KVxuXHRcdCk7XG5cdHZhciBkcmF3ID0gZnVuY3Rpb24gKCkge1xuXHRcdF9wYWdpbmdEcmF3KHNldHRpbmdzLCBob3N0LmNoaWxkcmVuKCksIG9wdHMpO1xuXHR9O1xuXG5cdHNldHRpbmdzLmFvRHJhd0NhbGxiYWNrLnB1c2goZHJhdyk7XG5cblx0Ly8gUmVzcG9uc2l2ZSByZWRyYXcgb2YgcGFnaW5nIGNvbnRyb2xcblx0JChzZXR0aW5ncy5uVGFibGUpLm9uKCdjb2x1bW4tc2l6aW5nLmR0LkRUJywgZHJhdyk7XG5cblx0cmV0dXJuIGhvc3Q7XG59LCAncCcgKTtcblxuLyoqXG4gKiBEeW5hbWljYWxseSBjcmVhdGUgdGhlIGJ1dHRvbiB0eXBlIGFycmF5IGJhc2VkIG9uIHRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gKiBUaGlzIHdpbGwgb25seSBoYXBwZW4gaWYgdGhlIHBhZ2luZyB0eXBlIGlzIG5vdCBkZWZpbmVkLlxuICovXG5mdW5jdGlvbiBfcGFnaW5nRHluYW1pYyhvcHRzKSB7XG5cdHZhciBvdXQgPSBbXTtcblxuXHRpZiAob3B0cy5udW1iZXJzKSB7XG5cdFx0b3V0LnB1c2goJ251bWJlcnMnKTtcblx0fVxuXG5cdGlmIChvcHRzLnByZXZpb3VzTmV4dCkge1xuXHRcdG91dC51bnNoaWZ0KCdwcmV2aW91cycpO1xuXHRcdG91dC5wdXNoKCduZXh0Jyk7XG5cdH1cblxuXHRpZiAob3B0cy5maXJzdExhc3QpIHtcblx0XHRvdXQudW5zaGlmdCgnZmlyc3QnKTtcblx0XHRvdXQucHVzaCgnbGFzdCcpO1xuXHR9XG5cblx0cmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gX3BhZ2luZ0RyYXcoc2V0dGluZ3MsIGhvc3QsIG9wdHMpIHtcblx0aWYgKCEgc2V0dGluZ3MuX2JJbml0Q29tcGxldGUpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHR2YXJcblx0XHRwbHVnaW4gPSBvcHRzLnR5cGVcblx0XHRcdD8gRGF0YVRhYmxlLmV4dC5wYWdlclsgb3B0cy50eXBlIF1cblx0XHRcdDogX3BhZ2luZ0R5bmFtaWMsXG5cdFx0YXJpYSA9IHNldHRpbmdzLm9MYW5ndWFnZS5vQXJpYS5wYWdpbmF0ZSB8fCB7fSxcblx0XHRzdGFydCAgICAgID0gc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQsXG5cdFx0bGVuICAgICAgICA9IHNldHRpbmdzLl9pRGlzcGxheUxlbmd0aCxcblx0XHR2aXNSZWNvcmRzID0gc2V0dGluZ3MuZm5SZWNvcmRzRGlzcGxheSgpLFxuXHRcdGFsbCAgICAgICAgPSBsZW4gPT09IC0xLFxuXHRcdHBhZ2UgPSBhbGwgPyAwIDogTWF0aC5jZWlsKCBzdGFydCAvIGxlbiApLFxuXHRcdHBhZ2VzID0gYWxsID8gMSA6IE1hdGguY2VpbCggdmlzUmVjb3JkcyAvIGxlbiApLFxuXHRcdGJ1dHRvbnMgPSBbXSxcblx0XHRidXR0b25FbHMgPSBbXSxcblx0XHRidXR0b25zTmVzdGVkID0gcGx1Z2luKG9wdHMpXG5cdFx0XHQubWFwKGZ1bmN0aW9uICh2YWwpIHtcblx0XHRcdFx0cmV0dXJuIHZhbCA9PT0gJ251bWJlcnMnXG5cdFx0XHRcdFx0PyBfcGFnaW5nTnVtYmVycyhwYWdlLCBwYWdlcywgb3B0cy5idXR0b25zLCBvcHRzLmJvdW5kYXJ5TnVtYmVycylcblx0XHRcdFx0XHQ6IHZhbDtcblx0XHRcdH0pO1xuXG5cdC8vIC5mbGF0KCkgd291bGQgYmUgYmV0dGVyLCBidXQgbm90IHN1cHBvcnRlZCBpbiBvbGQgU2FmYXJpXG5cdGJ1dHRvbnMgPSBidXR0b25zLmNvbmNhdC5hcHBseShidXR0b25zLCBidXR0b25zTmVzdGVkKTtcblxuXHRmb3IgKHZhciBpPTAgOyBpPGJ1dHRvbnMubGVuZ3RoIDsgaSsrKSB7XG5cdFx0dmFyIGJ1dHRvbiA9IGJ1dHRvbnNbaV07XG5cblx0XHR2YXIgYnRuSW5mbyA9IF9wYWdpbmdCdXR0b25JbmZvKHNldHRpbmdzLCBidXR0b24sIHBhZ2UsIHBhZ2VzKTtcblx0XHR2YXIgYnRuID0gX2ZuUmVuZGVyZXIoIHNldHRpbmdzLCAncGFnaW5nQnV0dG9uJyApKFxuXHRcdFx0c2V0dGluZ3MsXG5cdFx0XHRidXR0b24sXG5cdFx0XHRidG5JbmZvLmRpc3BsYXksXG5cdFx0XHRidG5JbmZvLmFjdGl2ZSxcblx0XHRcdGJ0bkluZm8uZGlzYWJsZWRcblx0XHQpO1xuXG5cdFx0dmFyIGFyaWFMYWJlbCA9IHR5cGVvZiBidXR0b24gPT09ICdzdHJpbmcnXG5cdFx0XHQ/IGFyaWFbIGJ1dHRvbiBdXG5cdFx0XHQ6IGFyaWEubnVtYmVyXG5cdFx0XHRcdD8gYXJpYS5udW1iZXIgKyAoYnV0dG9uKzEpXG5cdFx0XHRcdDogbnVsbDtcblxuXHRcdC8vIENvbW1vbiBhdHRyaWJ1dGVzXG5cdFx0JChidG4uY2xpY2tlcikuYXR0cih7XG5cdFx0XHQnYXJpYS1jb250cm9scyc6IHNldHRpbmdzLnNUYWJsZUlkLFxuXHRcdFx0J2FyaWEtZGlzYWJsZWQnOiBidG5JbmZvLmRpc2FibGVkID8gJ3RydWUnIDogbnVsbCxcblx0XHRcdCdhcmlhLWN1cnJlbnQnOiBidG5JbmZvLmFjdGl2ZSA/ICdwYWdlJyA6IG51bGwsXG5cdFx0XHQnYXJpYS1sYWJlbCc6IGFyaWFMYWJlbCxcblx0XHRcdCdkYXRhLWR0LWlkeCc6IGJ1dHRvbixcblx0XHRcdCd0YWJJbmRleCc6IGJ0bkluZm8uZGlzYWJsZWRcblx0XHRcdFx0PyAtMVxuXHRcdFx0XHQ6IHNldHRpbmdzLmlUYWJJbmRleCAmJiBidG4uY2xpY2tlclswXS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSAnc3Bhbidcblx0XHRcdFx0XHQ/IHNldHRpbmdzLmlUYWJJbmRleFxuXHRcdFx0XHRcdDogbnVsbCwgLy8gYDBgIGRvZXNuJ3QgbmVlZCBhIHRhYkluZGV4IHNpbmNlIGl0IGlzIHRoZSBkZWZhdWx0XG5cdFx0fSk7XG5cblx0XHRpZiAodHlwZW9mIGJ1dHRvbiAhPT0gJ251bWJlcicpIHtcblx0XHRcdCQoYnRuLmNsaWNrZXIpLmFkZENsYXNzKGJ1dHRvbik7XG5cdFx0fVxuXG5cdFx0X2ZuQmluZEFjdGlvbihcblx0XHRcdGJ0bi5jbGlja2VyLCB7YWN0aW9uOiBidXR0b259LCBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblxuXHRcdFx0XHRfZm5QYWdlQ2hhbmdlKCBzZXR0aW5ncywgZS5kYXRhLmFjdGlvbiwgdHJ1ZSApO1xuXHRcdFx0fVxuXHRcdCk7XG5cblx0XHRidXR0b25FbHMucHVzaChidG4uZGlzcGxheSk7XG5cdH1cblxuXHR2YXIgd3JhcHBlZCA9IF9mblJlbmRlcmVyKHNldHRpbmdzLCAncGFnaW5nQ29udGFpbmVyJykoXG5cdFx0c2V0dGluZ3MsIGJ1dHRvbkVsc1xuXHQpO1xuXG5cdHZhciBhY3RpdmVFbCA9IGhvc3QuZmluZChkb2N1bWVudC5hY3RpdmVFbGVtZW50KS5kYXRhKCdkdC1pZHgnKTtcblxuXHRob3N0LmVtcHR5KCkuYXBwZW5kKHdyYXBwZWQpO1xuXG5cdGlmICggYWN0aXZlRWwgIT09IHVuZGVmaW5lZCApIHtcblx0XHRob3N0LmZpbmQoICdbZGF0YS1kdC1pZHg9JythY3RpdmVFbCsnXScgKS50cmlnZ2VyKCdmb2N1cycpO1xuXHR9XG5cblx0Ly8gUmVzcG9uc2l2ZSAtIGNoZWNrIGlmIHRoZSBidXR0b25zIGFyZSBvdmVyIHR3byBsaW5lcyBiYXNlZCBvbiB0aGVcblx0Ly8gaGVpZ2h0IG9mIHRoZSBidXR0b25zIGFuZCB0aGUgY29udGFpbmVyLlxuXHRpZiAoYnV0dG9uRWxzLmxlbmd0aCkge1xuXHRcdHZhciBvdXRlckhlaWdodCA9ICQoYnV0dG9uRWxzWzBdKS5vdXRlckhlaWdodCgpO1xuXHRcblx0XHRpZiAoXG5cdFx0XHRvcHRzLmJ1dHRvbnMgPiAxICYmIC8vIHByZXZlbnQgaW5maW5pdGVcblx0XHRcdG91dGVySGVpZ2h0ID4gMCAmJiAvLyB3aWxsIGJlIDAgaWYgaGlkZGVuXG5cdFx0XHQkKGhvc3QpLmhlaWdodCgpID49IChvdXRlckhlaWdodCAqIDIpIC0gMTBcblx0XHQpIHtcblx0XHRcdF9wYWdpbmdEcmF3KHNldHRpbmdzLCBob3N0LCAkLmV4dGVuZCh7fSwgb3B0cywgeyBidXR0b25zOiBvcHRzLmJ1dHRvbnMgLSAyIH0pKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBHZXQgcHJvcGVydGllcyBmb3IgYSBidXR0b24gYmFzZWQgb24gdGhlIGN1cnJlbnQgcGFnaW5nIHN0YXRlIG9mIHRoZSB0YWJsZVxuICpcbiAqIEBwYXJhbSB7Kn0gc2V0dGluZ3MgRFQgc2V0dGluZ3Mgb2JqZWN0XG4gKiBAcGFyYW0geyp9IGJ1dHRvbiBUaGUgYnV0dG9uIHR5cGUgaW4gcXVlc3Rpb25cbiAqIEBwYXJhbSB7Kn0gcGFnZSBUYWJsZSdzIGN1cnJlbnQgcGFnZVxuICogQHBhcmFtIHsqfSBwYWdlcyBOdW1iZXIgb2YgcGFnZXNcbiAqIEByZXR1cm5zIEluZm8gb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIF9wYWdpbmdCdXR0b25JbmZvKHNldHRpbmdzLCBidXR0b24sIHBhZ2UsIHBhZ2VzKSB7XG5cdHZhciBsYW5nID0gc2V0dGluZ3Mub0xhbmd1YWdlLm9QYWdpbmF0ZTtcblx0dmFyIG8gPSB7XG5cdFx0ZGlzcGxheTogJycsXG5cdFx0YWN0aXZlOiBmYWxzZSxcblx0XHRkaXNhYmxlZDogZmFsc2Vcblx0fTtcblxuXHRzd2l0Y2ggKCBidXR0b24gKSB7XG5cdFx0Y2FzZSAnZWxsaXBzaXMnOlxuXHRcdFx0by5kaXNwbGF5ID0gJyYjeDIwMjY7Jztcblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSAnZmlyc3QnOlxuXHRcdFx0by5kaXNwbGF5ID0gbGFuZy5zRmlyc3Q7XG5cblx0XHRcdGlmIChwYWdlID09PSAwKSB7XG5cdFx0XHRcdG8uZGlzYWJsZWQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlICdwcmV2aW91cyc6XG5cdFx0XHRvLmRpc3BsYXkgPSBsYW5nLnNQcmV2aW91cztcblxuXHRcdFx0aWYgKCBwYWdlID09PSAwICkge1xuXHRcdFx0XHRvLmRpc2FibGVkID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSAnbmV4dCc6XG5cdFx0XHRvLmRpc3BsYXkgPSBsYW5nLnNOZXh0O1xuXG5cdFx0XHRpZiAoIHBhZ2VzID09PSAwIHx8IHBhZ2UgPT09IHBhZ2VzLTEgKSB7XG5cdFx0XHRcdG8uZGlzYWJsZWQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlICdsYXN0Jzpcblx0XHRcdG8uZGlzcGxheSA9IGxhbmcuc0xhc3Q7XG5cblx0XHRcdGlmICggcGFnZXMgPT09IDAgfHwgcGFnZSA9PT0gcGFnZXMtMSApIHtcblx0XHRcdFx0by5kaXNhYmxlZCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRicmVhaztcblxuXHRcdGRlZmF1bHQ6XG5cdFx0XHRpZiAoIHR5cGVvZiBidXR0b24gPT09ICdudW1iZXInICkge1xuXHRcdFx0XHRvLmRpc3BsYXkgPSBzZXR0aW5ncy5mbkZvcm1hdE51bWJlciggYnV0dG9uICsgMSApO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHBhZ2UgPT09IGJ1dHRvbikge1xuXHRcdFx0XHRcdG8uYWN0aXZlID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0YnJlYWs7XG5cdH1cblxuXHRyZXR1cm4gbztcbn1cblxuLyoqXG4gKiBDb21wdXRlIHdoYXQgbnVtYmVyIGJ1dHRvbnMgdG8gc2hvdyBpbiB0aGUgcGFnaW5nIGNvbnRyb2xcbiAqXG4gKiBAcGFyYW0geyp9IHBhZ2UgQ3VycmVudCBwYWdlXG4gKiBAcGFyYW0geyp9IHBhZ2VzIFRvdGFsIG51bWJlciBvZiBwYWdlc1xuICogQHBhcmFtIHsqfSBidXR0b25zIFRhcmdldCBudW1iZXIgb2YgbnVtYmVyIGJ1dHRvbnNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYWRkRmlyc3RMYXN0IEluZGljYXRlIGlmIHBhZ2UgMSBhbmQgZW5kIHNob3VsZCBiZSBpbmNsdWRlZFxuICogQHJldHVybnMgQnV0dG9ucyB0byBzaG93XG4gKi9cbmZ1bmN0aW9uIF9wYWdpbmdOdW1iZXJzICggcGFnZSwgcGFnZXMsIGJ1dHRvbnMsIGFkZEZpcnN0TGFzdCApIHtcblx0dmFyXG5cdFx0bnVtYmVycyA9IFtdLFxuXHRcdGhhbGYgPSBNYXRoLmZsb29yKGJ1dHRvbnMgLyAyKSxcblx0XHRiZWZvcmUgPSBhZGRGaXJzdExhc3QgPyAyIDogMSxcblx0XHRhZnRlciA9IGFkZEZpcnN0TGFzdCA/IDEgOiAwO1xuXG5cdGlmICggcGFnZXMgPD0gYnV0dG9ucyApIHtcblx0XHRudW1iZXJzID0gX3JhbmdlKDAsIHBhZ2VzKTtcblx0fVxuXHRlbHNlIGlmIChidXR0b25zID09PSAxKSB7XG5cdFx0Ly8gU2luZ2xlIGJ1dHRvbiAtIGN1cnJlbnQgcGFnZSBvbmx5XG5cdFx0bnVtYmVycyA9IFtwYWdlXTtcblx0fVxuXHRlbHNlIGlmIChidXR0b25zID09PSAzKSB7XG5cdFx0Ly8gU3BlY2lhbCBsb2dpYyBmb3IganVzdCB0aHJlZSBidXR0b25zXG5cdFx0aWYgKHBhZ2UgPD0gMSkge1xuXHRcdFx0bnVtYmVycyA9IFswLCAxLCAnZWxsaXBzaXMnXTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAocGFnZSA+PSBwYWdlcyAtIDIpIHtcblx0XHRcdG51bWJlcnMgPSBfcmFuZ2UocGFnZXMtMiwgcGFnZXMpO1xuXHRcdFx0bnVtYmVycy51bnNoaWZ0KCdlbGxpcHNpcycpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdG51bWJlcnMgPSBbJ2VsbGlwc2lzJywgcGFnZSwgJ2VsbGlwc2lzJ107XG5cdFx0fVxuXHR9XG5cdGVsc2UgaWYgKCBwYWdlIDw9IGhhbGYgKSB7XG5cdFx0bnVtYmVycyA9IF9yYW5nZSgwLCBidXR0b25zLWJlZm9yZSk7XG5cdFx0bnVtYmVycy5wdXNoKCdlbGxpcHNpcycpO1xuXG5cdFx0aWYgKGFkZEZpcnN0TGFzdCkge1xuXHRcdFx0bnVtYmVycy5wdXNoKHBhZ2VzLTEpO1xuXHRcdH1cblx0fVxuXHRlbHNlIGlmICggcGFnZSA+PSBwYWdlcyAtIDEgLSBoYWxmICkge1xuXHRcdG51bWJlcnMgPSBfcmFuZ2UocGFnZXMtKGJ1dHRvbnMtYmVmb3JlKSwgcGFnZXMpO1xuXHRcdG51bWJlcnMudW5zaGlmdCgnZWxsaXBzaXMnKTtcblxuXHRcdGlmIChhZGRGaXJzdExhc3QpIHtcblx0XHRcdG51bWJlcnMudW5zaGlmdCgwKTtcblx0XHR9XG5cdH1cblx0ZWxzZSB7XG5cdFx0bnVtYmVycyA9IF9yYW5nZShwYWdlLWhhbGYrYmVmb3JlLCBwYWdlK2hhbGYtYWZ0ZXIpO1xuXHRcdG51bWJlcnMucHVzaCgnZWxsaXBzaXMnKTtcblx0XHRudW1iZXJzLnVuc2hpZnQoJ2VsbGlwc2lzJyk7XG5cblx0XHRpZiAoYWRkRmlyc3RMYXN0KSB7XG5cdFx0XHRudW1iZXJzLnB1c2gocGFnZXMtMSk7XG5cdFx0XHRudW1iZXJzLnVuc2hpZnQoMCk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG51bWJlcnM7XG59XG5cbnZhciBfX2xlbmd0aENvdW50ZXIgPSAwO1xuXG4vLyBvcHRzXG4vLyAtIG1lbnVcbi8vIC0gdGV4dFxuRGF0YVRhYmxlLmZlYXR1cmUucmVnaXN0ZXIoICdwYWdlTGVuZ3RoJywgZnVuY3Rpb24gKCBzZXR0aW5ncywgb3B0cyApIHtcblx0dmFyIGZlYXR1cmVzID0gc2V0dGluZ3Mub0ZlYXR1cmVzO1xuXG5cdC8vIEZvciBjb21wYXRpYmlsaXR5IHdpdGggdGhlIGxlZ2FjeSBgcGFnZUxlbmd0aGAgdG9wIGxldmVsIG9wdGlvblxuXHRpZiAoISBmZWF0dXJlcy5iUGFnaW5hdGUgfHwgISBmZWF0dXJlcy5iTGVuZ3RoQ2hhbmdlKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRvcHRzID0gJC5leHRlbmQoe1xuXHRcdG1lbnU6IHNldHRpbmdzLmFMZW5ndGhNZW51LFxuXHRcdHRleHQ6IHNldHRpbmdzLm9MYW5ndWFnZS5zTGVuZ3RoTWVudVxuXHR9LCBvcHRzKTtcblxuXHR2YXJcblx0XHRjbGFzc2VzICA9IHNldHRpbmdzLm9DbGFzc2VzLmxlbmd0aCxcblx0XHR0YWJsZUlkICA9IHNldHRpbmdzLnNUYWJsZUlkLFxuXHRcdG1lbnUgICAgID0gb3B0cy5tZW51LFxuXHRcdGxlbmd0aHMgID0gW10sXG5cdFx0bGFuZ3VhZ2UgPSBbXSxcblx0XHRpO1xuXG5cdC8vIE9wdGlvbnMgY2FuIGJlIGdpdmVuIGluIGEgbnVtYmVyIG9mIHdheXNcblx0aWYgKEFycmF5LmlzQXJyYXkoIG1lbnVbMF0gKSkge1xuXHRcdC8vIE9sZCAxLnggc3R5bGUgLSAyRCBhcnJheVxuXHRcdGxlbmd0aHMgPSBtZW51WzBdO1xuXHRcdGxhbmd1YWdlID0gbWVudVsxXTtcblx0fVxuXHRlbHNlIHtcblx0XHRmb3IgKCBpPTAgOyBpPG1lbnUubGVuZ3RoIDsgaSsrICkge1xuXHRcdFx0Ly8gQW4gb2JqZWN0IHdpdGggZGlmZmVyZW50IGxhYmVsIGFuZCB2YWx1ZVxuXHRcdFx0aWYgKCQuaXNQbGFpbk9iamVjdChtZW51W2ldKSkge1xuXHRcdFx0XHRsZW5ndGhzLnB1c2gobWVudVtpXS52YWx1ZSk7XG5cdFx0XHRcdGxhbmd1YWdlLnB1c2gobWVudVtpXS5sYWJlbCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Ly8gT3IganVzdCBhIG51bWJlciB0byBkaXNwbGF5IGFuZCB1c2Vcblx0XHRcdFx0bGVuZ3Rocy5wdXNoKG1lbnVbaV0pO1xuXHRcdFx0XHRsYW5ndWFnZS5wdXNoKG1lbnVbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFdlIGNhbiBwdXQgdGhlIDxzZWxlY3Q+IG91dHNpZGUgb2YgdGhlIGxhYmVsIGlmIGl0IGlzIGF0IHRoZSBzdGFydCBvclxuXHQvLyBlbmQgd2hpY2ggaGVscHMgaW1wcm92ZSBhY2Nlc3NhYmlsaXR5IChub3QgYWxsIHNjcmVlbiByZWFkZXJzIGxpa2Vcblx0Ly8gaW1wbGljaXQgZm9yIGVsZW1lbnRzKS5cblx0dmFyIGVuZCA9IG9wdHMudGV4dC5tYXRjaCgvX01FTlVfJC8pO1xuXHR2YXIgc3RhcnQgPSBvcHRzLnRleHQubWF0Y2goL15fTUVOVV8vKTtcblx0dmFyIHJlbW92ZWQgPSBvcHRzLnRleHQucmVwbGFjZSgvX01FTlVfLywgJycpO1xuXHR2YXIgc3RyID0gJzxsYWJlbD4nICsgb3B0cy50ZXh0ICsgJzwvbGFiZWw+JztcblxuXHRpZiAoc3RhcnQpIHtcblx0XHRzdHIgPSAnX01FTlVfPGxhYmVsPicgKyByZW1vdmVkICsgJzwvbGFiZWw+Jztcblx0fVxuXHRlbHNlIGlmIChlbmQpIHtcblx0XHRzdHIgPSAnPGxhYmVsPicgKyByZW1vdmVkICsgJzwvbGFiZWw+X01FTlVfJztcblx0fVxuXG5cdC8vIFdyYXBwZXIgZWxlbWVudCAtIHVzZSBhIHNwYW4gYXMgYSBob2xkZXIgZm9yIHdoZXJlIHRoZSBzZWxlY3Qgd2lsbCBnb1xuXHR2YXIgdG1wSWQgPSAndG1wLScgKyAoK25ldyBEYXRlKCkpXG5cdHZhciBkaXYgPSAkKCc8ZGl2Lz4nKVxuXHRcdC5hZGRDbGFzcyggY2xhc3Nlcy5jb250YWluZXIgKVxuXHRcdC5hcHBlbmQoXG5cdFx0XHRzdHIucmVwbGFjZSggJ19NRU5VXycsICc8c3BhbiBpZD1cIicrdG1wSWQrJ1wiPjwvc3Bhbj4nIClcblx0XHQpO1xuXG5cdC8vIFNhdmUgdGV4dCBub2RlIGNvbnRlbnQgZm9yIG1hY3JvIHVwZGF0aW5nXG5cdHZhciB0ZXh0Tm9kZXMgPSBbXTtcblx0QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZGl2LmZpbmQoJ2xhYmVsJylbMF0uY2hpbGROb2RlcykuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcblx0XHRpZiAoZWwubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG5cdFx0XHR0ZXh0Tm9kZXMucHVzaCh7XG5cdFx0XHRcdGVsOiBlbCxcblx0XHRcdFx0dGV4dDogZWwudGV4dENvbnRlbnRcblx0XHRcdH0pO1xuXHRcdH1cblx0fSk7XG5cblx0Ly8gVXBkYXRlIHRoZSBsYWJlbCB0ZXh0IGluIGNhc2UgaXQgaGFzIGFuIGVudHJpZXMgdmFsdWVcblx0dmFyIHVwZGF0ZUVudHJpZXMgPSBmdW5jdGlvbiAobGVuKSB7XG5cdFx0dGV4dE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcblx0XHRcdG5vZGUuZWwudGV4dENvbnRlbnQgPSBfZm5NYWNyb3Moc2V0dGluZ3MsIG5vZGUudGV4dCwgbGVuKTtcblx0XHR9KTtcblx0fVxuXG5cdC8vIE5leHQsIHRoZSBzZWxlY3QgaXRzZWxmLCBhbG9uZyB3aXRoIHRoZSBvcHRpb25zXG5cdHZhciBzZWxlY3QgPSAkKCc8c2VsZWN0Lz4nLCB7XG5cdFx0J2FyaWEtY29udHJvbHMnOiB0YWJsZUlkLFxuXHRcdCdjbGFzcyc6ICAgICAgICAgY2xhc3Nlcy5zZWxlY3Rcblx0fSApO1xuXG5cdGZvciAoIGk9MCA7IGk8bGVuZ3Rocy5sZW5ndGggOyBpKysgKSB7XG5cdFx0Ly8gQXR0ZW1wdCB0byBsb29rIHVwIHRoZSBsZW5ndGggZnJvbSB0aGUgaTE4biBvcHRpb25zXG5cdFx0dmFyIGxhYmVsID0gc2V0dGluZ3MuYXBpLmkxOG4oJ2xlbmd0aExhYmVscy4nICsgbGVuZ3Roc1tpXSwgbnVsbCk7XG5cblx0XHRpZiAobGFiZWwgPT09IG51bGwpIHtcblx0XHRcdC8vIElmIG5vdCBwcmVzZW50LCBmYWxsYmFjayB0byBvbGQgc3R5bGVcblx0XHRcdGxhYmVsID0gdHlwZW9mIGxhbmd1YWdlW2ldID09PSAnbnVtYmVyJyA/XG5cdFx0XHRcdHNldHRpbmdzLmZuRm9ybWF0TnVtYmVyKCBsYW5ndWFnZVtpXSApIDpcblx0XHRcdFx0bGFuZ3VhZ2VbaV07XG5cdFx0fVxuXG5cdFx0c2VsZWN0WzBdWyBpIF0gPSBuZXcgT3B0aW9uKGxhYmVsLCBsZW5ndGhzW2ldKTtcblx0fVxuXG5cdC8vIGFkZCBmb3IgYW5kIGlkIHRvIGxhYmVsIGFuZCBpbnB1dFxuXHRkaXYuZmluZCgnbGFiZWwnKS5hdHRyKCdmb3InLCAnZHQtbGVuZ3RoLScgKyBfX2xlbmd0aENvdW50ZXIpO1xuXHRzZWxlY3QuYXR0cignaWQnLCAnZHQtbGVuZ3RoLScgKyBfX2xlbmd0aENvdW50ZXIpO1xuXHRfX2xlbmd0aENvdW50ZXIrKztcblxuXHQvLyBTd2FwIGluIHRoZSBzZWxlY3QgbGlzdFxuXHRkaXYuZmluZCgnIycgKyB0bXBJZCkucmVwbGFjZVdpdGgoc2VsZWN0KTtcblxuXHQvLyBDYW4ndCB1c2UgYHNlbGVjdGAgdmFyaWFibGUgYXMgdXNlciBtaWdodCBwcm92aWRlIHRoZWlyIG93biBhbmQgdGhlXG5cdC8vIHJlZmVyZW5jZSBpcyBicm9rZW4gYnkgdGhlIHVzZSBvZiBvdXRlckhUTUxcblx0JCgnc2VsZWN0JywgZGl2KVxuXHRcdC52YWwoIHNldHRpbmdzLl9pRGlzcGxheUxlbmd0aCApXG5cdFx0Lm9uKCAnY2hhbmdlLkRUJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRfZm5MZW5ndGhDaGFuZ2UoIHNldHRpbmdzLCAkKHRoaXMpLnZhbCgpICk7XG5cdFx0XHRfZm5EcmF3KCBzZXR0aW5ncyApO1xuXHRcdH0gKTtcblxuXHQvLyBVcGRhdGUgbm9kZSB2YWx1ZSB3aGVuZXZlciBhbnl0aGluZyBjaGFuZ2VzIHRoZSB0YWJsZSdzIGxlbmd0aFxuXHQkKHNldHRpbmdzLm5UYWJsZSkub24oICdsZW5ndGguZHQuRFQnLCBmdW5jdGlvbiAoZSwgcywgbGVuKSB7XG5cdFx0aWYgKCBzZXR0aW5ncyA9PT0gcyApIHtcblx0XHRcdCQoJ3NlbGVjdCcsIGRpdikudmFsKCBsZW4gKTtcblxuXHRcdFx0Ly8gUmVzb2x2ZSBwbHVyYWxzIGluIHRoZSB0ZXh0IGZvciB0aGUgbmV3IGxlbmd0aFxuXHRcdFx0dXBkYXRlRW50cmllcyhsZW4pO1xuXHRcdH1cblx0fSApO1xuXG5cdHVwZGF0ZUVudHJpZXMoc2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoKTtcblxuXHRyZXR1cm4gZGl2O1xufSwgJ2wnICk7XG5cbi8vIGpRdWVyeSBhY2Nlc3NcbiQuZm4uZGF0YVRhYmxlID0gRGF0YVRhYmxlO1xuXG4vLyBQcm92aWRlIGFjY2VzcyB0byB0aGUgaG9zdCBqUXVlcnkgb2JqZWN0IChjaXJjdWxhciByZWZlcmVuY2UpXG5EYXRhVGFibGUuJCA9ICQ7XG5cbi8vIExlZ2FjeSBhbGlhc2VzXG4kLmZuLmRhdGFUYWJsZVNldHRpbmdzID0gRGF0YVRhYmxlLnNldHRpbmdzO1xuJC5mbi5kYXRhVGFibGVFeHQgPSBEYXRhVGFibGUuZXh0O1xuXG4vLyBXaXRoIGEgY2FwaXRhbCBgRGAgd2UgcmV0dXJuIGEgRGF0YVRhYmxlcyBBUEkgaW5zdGFuY2UgcmF0aGVyIHRoYW4gYVxuLy8galF1ZXJ5IG9iamVjdFxuJC5mbi5EYXRhVGFibGUgPSBmdW5jdGlvbiAoIG9wdHMgKSB7XG5cdHJldHVybiAkKHRoaXMpLmRhdGFUYWJsZSggb3B0cyApLmFwaSgpO1xufTtcblxuLy8gQWxsIHByb3BlcnRpZXMgdGhhdCBhcmUgYXZhaWxhYmxlIHRvICQuZm4uZGF0YVRhYmxlIHNob3VsZCBhbHNvIGJlXG4vLyBhdmFpbGFibGUgb24gJC5mbi5EYXRhVGFibGVcbiQuZWFjaCggRGF0YVRhYmxlLCBmdW5jdGlvbiAoIHByb3AsIHZhbCApIHtcblx0JC5mbi5EYXRhVGFibGVbIHByb3AgXSA9IHZhbDtcbn0gKTtcblxuZXhwb3J0IGRlZmF1bHQgRGF0YVRhYmxlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9